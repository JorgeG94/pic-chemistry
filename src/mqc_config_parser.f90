!! Parser for MQC section-based input files (.mqc format)
module mqc_config_parser
   !! Parses section-based input files with %section...end blocks
   !! This is the new format generated by mqc_prep.py
   use pic_types, only: dp, int32, int64
   use mqc_method_types, only: method_type_from_string, METHOD_TYPE_GFN2, METHOD_TYPE_UNKNOWN
   use mqc_calc_types, only: calc_type_from_string, CALC_TYPE_ENERGY, CALC_TYPE_UNKNOWN
   use mqc_geometry, only: geometry_type
   implicit none
   private

   public :: mqc_config_t, read_mqc_file
   public :: input_fragment_t, bond_t

   ! Maximum line length for reading
   integer, parameter :: MAX_LINE_LEN = 1024

   type :: input_fragment_t
      !! Input fragment definition with charge, multiplicity, and atom indices
      !! This is the parsed representation from the input file, not the computational fragment
      integer :: charge = 0
      integer :: multiplicity = 1
      integer, allocatable :: indices(:)  !! Atom indices in this fragment
   contains
      procedure :: destroy => input_fragment_destroy
   end type input_fragment_t

   type :: bond_t
      !! Bond definition with atom indices, order, and broken status
      integer :: atom_i = 0
      integer :: atom_j = 0
      integer :: order = 1
      logical :: is_broken = .false.
   end type bond_t

   type :: mqc_config_t
      !! Complete configuration from .mqc file

      ! Schema information
      character(len=:), allocatable :: schema_name
      character(len=:), allocatable :: schema_version
      integer :: index_base = 0  !! 0-based or 1-based indexing
      character(len=:), allocatable :: units  !! angstrom or bohr

      ! Model information
      integer(int32) :: method = METHOD_TYPE_GFN2
      character(len=:), allocatable :: basis
      character(len=:), allocatable :: aux_basis

      ! Driver information
      integer(int32) :: calc_type = CALC_TYPE_ENERGY

      ! Structure information
      integer :: charge = 0
      integer :: multiplicity = 1

      ! Geometry
      type(geometry_type) :: geometry

      ! Fragments
      integer :: nfrag = 0
      type(input_fragment_t), allocatable :: fragments(:)

      ! Connectivity
      integer :: nbonds = 0
      integer :: nbroken = 0
      type(bond_t), allocatable :: bonds(:)

      ! SCF settings
      integer :: scf_maxiter = 300
      real(dp) :: scf_tolerance = 1.0e-6_dp

      ! Fragmentation settings
      character(len=:), allocatable :: frag_method  !! MBE, etc.
      integer :: frag_level = 1
      logical :: allow_overlapping_fragments = .false.
      character(len=:), allocatable :: embedding
      character(len=:), allocatable :: cutoff_method
      character(len=:), allocatable :: distance_metric
      real(dp) :: dimer_cutoff = 0.0_dp
      real(dp) :: trimer_cutoff = 0.0_dp

      ! Logger settings (kept for compatibility)
      character(len=:), allocatable :: log_level

   contains
      procedure :: destroy => config_destroy
   end type mqc_config_t

contains

   subroutine read_mqc_file(filename, config, stat, errmsg)
      !! Read and parse a .mqc format input file
      character(len=*), intent(in) :: filename
      type(mqc_config_t), intent(out) :: config
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      integer :: unit, io_stat
      character(len=MAX_LINE_LEN) :: line
      logical :: file_exists

      stat = 0

      inquire (file=filename, exist=file_exists)
      if (.not. file_exists) then
         stat = 1
         errmsg = "Input file not found: "//trim(filename)
         return
      end if

      open (newunit=unit, file=filename, status='old', action='read', iostat=io_stat)
      if (io_stat /= 0) then
         stat = io_stat
         errmsg = "Error opening input file: "//trim(filename)
         return
      end if

      ! Set defaults
      config%log_level = "info"

      ! Read file line by line and dispatch to section parsers
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) exit

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         ! Check for section start
         if (line(1:1) == '%') then
            select case (trim(line))
            case ('%schema')
               call parse_schema_section(unit, config, stat, errmsg)
            case ('%model')
               call parse_model_section(unit, config, stat, errmsg)
            case ('%driver')
               call parse_driver_section(unit, config, stat, errmsg)
            case ('%structure')
               call parse_structure_section(unit, config, stat, errmsg)
            case ('%geometry')
               call parse_geometry_section(unit, config, stat, errmsg)
            case ('%fragments')
               call parse_fragments_section(unit, config, stat, errmsg)
            case ('%connectivity')
               call parse_connectivity_section(unit, config, stat, errmsg)
            case ('%scf')
               call parse_scf_section(unit, config, stat, errmsg)
            case ('%fragmentation')
               call parse_fragmentation_section(unit, config, stat, errmsg)
            case ('%system')
               call parse_system_section(unit, config, stat, errmsg)
            case default
               ! Skip unknown sections
               call skip_to_end(unit, stat, errmsg)
            end select

            if (stat /= 0) then
               close (unit)
               return
            end if
         end if
      end do

      close (unit)

      ! Validate required fields
      if (.not. allocated(config%schema_name)) then
         stat = 1
         errmsg = "Missing required section: %schema"
         return
      end if

      if (.not. allocated(config%geometry%coords) .or. config%geometry%natoms == 0) then
         stat = 1
         errmsg = "Missing required section: %geometry"
         return
      end if

   end subroutine read_mqc_file

   subroutine parse_schema_section(unit, config, stat, errmsg)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos

      stat = 0

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Unexpected end of file in %schema section"
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(line) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('name')
            config%schema_name = trim(value)
         case ('version')
            config%schema_version = trim(value)
         case ('index_base')
            read (value, *, iostat=io_stat) config%index_base
         case ('units')
            config%units = trim(value)
         end select
      end do

   end subroutine parse_schema_section

   subroutine parse_model_section(unit, config, stat, errmsg)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos

      stat = 0

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Unexpected end of file in %model section"
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(line) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('method')
            ! Parse method string (e.g., "XTB-GFN1" -> "gfn1")
            config%method = parse_method_string(trim(value))
            if (config%method == METHOD_TYPE_UNKNOWN) then
               stat = 1
               errmsg = "Invalid method: "//trim(value)
               return
            end if
         case ('basis')
            config%basis = trim(value)
         case ('aux_basis')
            config%aux_basis = trim(value)
         end select
      end do

   end subroutine parse_model_section

   subroutine parse_driver_section(unit, config, stat, errmsg)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos

      stat = 0

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Unexpected end of file in %driver section"
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(line) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('type')
            config%calc_type = calc_type_from_string(trim(value))
            if (config%calc_type == CALC_TYPE_UNKNOWN) then
               stat = 1
               errmsg = "Invalid calc_type: "//trim(value)
               return
            end if
         end select
      end do

   end subroutine parse_driver_section

   subroutine parse_structure_section(unit, config, stat, errmsg)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos

      stat = 0

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Unexpected end of file in %structure section"
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(line) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('charge')
            read (value, *, iostat=io_stat) config%charge
         case ('multiplicity')
            read (value, *, iostat=io_stat) config%multiplicity
         end select
      end do

   end subroutine parse_structure_section

   subroutine parse_geometry_section(unit, config, stat, errmsg)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line, elem
      integer :: io_stat, natoms, i
      real(dp) :: x, y, z

      stat = 0

      ! Read number of atoms
      read (unit, '(A)', iostat=io_stat) line
      if (io_stat /= 0) then
         stat = 1
         errmsg = "Error reading natoms in %geometry section"
         return
      end if

      read (line, *, iostat=io_stat) natoms
      if (io_stat /= 0) then
         stat = 1
         errmsg = "Invalid natoms in %geometry section"
         return
      end if

      config%geometry%natoms = natoms

      ! Read blank line (comment line in XYZ format)
      read (unit, '(A)', iostat=io_stat) line
      if (io_stat /= 0) then
         stat = 1
         errmsg = "Error reading comment line in %geometry section"
         return
      end if

      config%geometry%comment = trim(line)

      ! Allocate arrays
      allocate (character(len=4) :: config%geometry%elements(natoms))
      allocate (config%geometry%coords(3, natoms))

      ! Read coordinates
      do i = 1, natoms
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Error reading geometry coordinates"
            return
         end if

         line = adjustl(line)
         if (trim(line) == 'end') then
            stat = 1
            errmsg = "Unexpected 'end' while reading geometry"
            return
         end if

         read (line, *, iostat=io_stat) elem, x, y, z
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Invalid coordinate format in %geometry section"
            return
         end if

         config%geometry%elements(i) = trim(elem)
         config%geometry%coords(1, i) = x
         config%geometry%coords(2, i) = y
         config%geometry%coords(3, i) = z
      end do

      ! Read 'end' marker
      read (unit, '(A)', iostat=io_stat) line
      if (io_stat /= 0) then
         stat = 1
         errmsg = "Missing 'end' in %geometry section"
         return
      end if

      line = adjustl(line)
      if (trim(line) /= 'end') then
         stat = 1
         errmsg = "Expected 'end' after geometry coordinates"
         return
      end if

   end subroutine parse_geometry_section

   subroutine parse_fragments_section(unit, config, stat, errmsg)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos, nfrag, ifrag

      stat = 0
      nfrag = 0

      ! First pass: read nfrag
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Unexpected end of file in %fragments section"
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(line) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos > 0) then
            key = adjustl(line(1:eq_pos - 1))
            value = adjustl(line(eq_pos + 1:))

            if (trim(key) == 'nfrag') then
               read (value, *, iostat=io_stat) nfrag
               if (io_stat /= 0) then
                  stat = 1
                  errmsg = "Invalid nfrag value"
                  return
               end if
               exit
            end if
         end if
      end do

      if (nfrag == 0) then
         ! No fragments, just skip to end
         call skip_to_end(unit, stat, errmsg)
         return
      end if

      config%nfrag = nfrag
      allocate (config%fragments(nfrag))

      ! Parse individual fragments
      ifrag = 0
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) exit

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(line) == 'end') exit

         if (trim(line) == '%fragment') then
            ifrag = ifrag + 1
            if (ifrag > nfrag) then
               stat = 1
               errmsg = "More fragments than declared nfrag"
               return
            end if
            call parse_fragment(unit, config%fragments(ifrag), stat, errmsg)
            if (stat /= 0) return
         end if
      end do

      if (ifrag /= nfrag) then
         stat = 1
         write (errmsg, '(A,I0,A,I0)') "Expected ", nfrag, " fragments, found ", ifrag
         return
      end if

   end subroutine parse_fragments_section

   subroutine parse_fragment(unit, fragment, stat, errmsg)
      integer, intent(in) :: unit
      type(input_fragment_t), intent(inout) :: fragment
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos
      logical :: in_indices

      stat = 0
      in_indices = .false.

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Unexpected end of file in %fragment"
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(line) == 'end') then
            if (in_indices) then
               in_indices = .false.
               cycle
            else
               exit
            end if
         end if

         if (trim(line) == '%indices') then
            in_indices = .true.
            cycle
         end if

         if (in_indices) then
            ! Read indices
            call parse_indices_line(line, fragment, stat, errmsg)
            if (stat /= 0) return
         else
            eq_pos = index(line, '=')
            if (eq_pos > 0) then
               key = adjustl(line(1:eq_pos - 1))
               value = adjustl(line(eq_pos + 1:))

               select case (trim(key))
               case ('charge')
                  read (value, *, iostat=io_stat) fragment%charge
               case ('multiplicity')
                  read (value, *, iostat=io_stat) fragment%multiplicity
               end select
            end if
         end if
      end do

   end subroutine parse_fragment

   subroutine parse_indices_line(line, fragment, stat, errmsg)
      character(len=*), intent(in) :: line
      type(input_fragment_t), intent(inout) :: fragment
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      integer :: io_stat, pos, count, i, idx
      character(len=MAX_LINE_LEN) :: temp_line
      integer, allocatable :: temp_indices(:), new_indices(:)

      stat = 0
      temp_line = line

      ! Count how many integers
      count = 0
      do
         read (temp_line, *, iostat=io_stat) idx
         if (io_stat /= 0) exit
         count = count + 1
         ! Remove the read integer from temp_line
         pos = scan(temp_line, ' ')
         if (pos == 0) exit
         temp_line = adjustl(temp_line(pos:))
      end do

      if (count == 0) return

      ! Allocate temporary array
      allocate (temp_indices(count))

      ! Read the integers
      read (line, *, iostat=io_stat) temp_indices
      if (io_stat /= 0) then
         stat = 1
         errmsg = "Error reading fragment indices"
         deallocate (temp_indices)
         return
      end if

      ! Append to existing indices
      if (allocated(fragment%indices)) then
         allocate (new_indices(size(fragment%indices) + count))
         new_indices(1:size(fragment%indices)) = fragment%indices
         new_indices(size(fragment%indices) + 1:) = temp_indices
         call move_alloc(new_indices, fragment%indices)
      else
         call move_alloc(temp_indices, fragment%indices)
      end if

   end subroutine parse_indices_line

   subroutine parse_connectivity_section(unit, config, stat, errmsg)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line, key, value, status_str
      integer :: io_stat, eq_pos, nbonds, ibond
      integer :: atom_i, atom_j, order

      stat = 0
      nbonds = 0

      ! First pass: read nbonds
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Unexpected end of file in %connectivity section"
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(line) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos > 0) then
            key = adjustl(line(1:eq_pos - 1))
            value = adjustl(line(eq_pos + 1:))

            if (trim(key) == 'nbonds') then
               read (value, *, iostat=io_stat) nbonds
               if (io_stat /= 0) then
                  stat = 1
                  errmsg = "Invalid nbonds value"
                  return
               end if
               exit
            end if
         end if
      end do

      if (nbonds == 0) then
         ! No bonds, just skip to end
         call skip_to_end(unit, stat, errmsg)
         return
      end if

      config%nbonds = nbonds
      allocate (config%bonds(nbonds))

      ! Read bonds
      ibond = 0
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) exit

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         ! Check for key=value pairs (like nbroken=9)
         eq_pos = index(line, '=')
         if (eq_pos > 0) then
            key = adjustl(line(1:eq_pos - 1))
            value = adjustl(line(eq_pos + 1:))
            if (trim(key) == 'nbroken') then
               read (value, *, iostat=io_stat) config%nbroken
            end if
            cycle
         end if

         if (trim(line) == 'end') exit

         ! Parse bond line: atom_i atom_j order broken/preserved
         read (line, *, iostat=io_stat) atom_i, atom_j, order, status_str
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Invalid bond format in %connectivity section"
            return
         end if

         ibond = ibond + 1
         if (ibond > nbonds) then
            stat = 1
            errmsg = "More bonds than declared nbonds"
            return
         end if

         config%bonds(ibond)%atom_i = atom_i
         config%bonds(ibond)%atom_j = atom_j
         config%bonds(ibond)%order = order
         config%bonds(ibond)%is_broken = (trim(status_str) == 'broken')
      end do

   end subroutine parse_connectivity_section

   subroutine parse_scf_section(unit, config, stat, errmsg)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos

      stat = 0

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Unexpected end of file in %scf section"
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(line) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('maxiter')
            read (value, *, iostat=io_stat) config%scf_maxiter
         case ('tolerance')
            read (value, *, iostat=io_stat) config%scf_tolerance
         end select
      end do

   end subroutine parse_scf_section

   subroutine parse_fragmentation_section(unit, config, stat, errmsg)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos
      logical :: in_cutoffs

      stat = 0
      in_cutoffs = .false.

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Unexpected end of file in %fragmentation section"
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(line) == 'end') then
            if (in_cutoffs) then
               in_cutoffs = .false.
               cycle
            else
               exit
            end if
         end if

         if (trim(line) == '%cutoffs') then
            in_cutoffs = .true.
            cycle
         end if

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         if (in_cutoffs) then
            select case (trim(key))
            case ('dimer')
               read (value, *, iostat=io_stat) config%dimer_cutoff
            case ('trimer')
               read (value, *, iostat=io_stat) config%trimer_cutoff
            end select
         else
            select case (trim(key))
            case ('method')
               config%frag_method = trim(value)
            case ('level')
               read (value, *, iostat=io_stat) config%frag_level
            case ('allow_overlapping_fragments')
               config%allow_overlapping_fragments = (trim(value) == 'true')
            case ('embedding')
               config%embedding = trim(value)
            case ('cutoff_method')
               config%cutoff_method = trim(value)
            case ('distance_metric')
               config%distance_metric = trim(value)
            end select
         end if
      end do

   end subroutine parse_fragmentation_section

   subroutine parse_system_section(unit, config, stat, errmsg)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos

      stat = 0

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Unexpected end of file in %system section"
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(line) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('log_level')
            config%log_level = trim(value)
         end select
      end do

   end subroutine parse_system_section

   subroutine skip_to_end(unit, stat, errmsg)
      !! Skip lines until 'end' marker is found
      integer, intent(in) :: unit
      integer, intent(out) :: stat
      character(len=:), allocatable, intent(out) :: errmsg

      character(len=MAX_LINE_LEN) :: line
      integer :: io_stat

      stat = 0

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            stat = 1
            errmsg = "Unexpected end of file while skipping section"
            return
         end if

         line = adjustl(line)
         if (trim(line) == 'end') exit
      end do

   end subroutine skip_to_end

   function parse_method_string(method_str) result(method_type)
      !! Parse method string from input file (e.g., "XTB-GFN1" -> gfn1)
      character(len=*), intent(in) :: method_str
      integer(int32) :: method_type

      character(len=:), allocatable :: lower_str, method_part
      integer :: dash_pos, i

      ! Convert to lowercase
      allocate (character(len=len_trim(method_str)) :: lower_str)
      lower_str = trim(adjustl(method_str))
      do i = 1, len(lower_str)
         if (lower_str(i:i) >= 'A' .and. lower_str(i:i) <= 'Z') then
            lower_str(i:i) = achar(iachar(lower_str(i:i)) + 32)
         end if
      end do

      ! Handle "XTB-GFN1" format -> extract "gfn1"
      if (index(lower_str, 'xtb') > 0) then
         dash_pos = index(lower_str, '-')
         if (dash_pos > 0) then
            method_part = lower_str(dash_pos + 1:)
         else
            method_part = lower_str
         end if
      else
         method_part = lower_str
      end if

      method_type = method_type_from_string(method_part)

   end function parse_method_string

   subroutine config_destroy(this)
      !! Clean up allocated memory in mqc_config_t
      class(mqc_config_t), intent(inout) :: this
      integer :: i

      if (allocated(this%schema_name)) deallocate (this%schema_name)
      if (allocated(this%schema_version)) deallocate (this%schema_version)
      if (allocated(this%units)) deallocate (this%units)
      if (allocated(this%basis)) deallocate (this%basis)
      if (allocated(this%aux_basis)) deallocate (this%aux_basis)
      if (allocated(this%log_level)) deallocate (this%log_level)
      if (allocated(this%frag_method)) deallocate (this%frag_method)
      if (allocated(this%embedding)) deallocate (this%embedding)
      if (allocated(this%cutoff_method)) deallocate (this%cutoff_method)
      if (allocated(this%distance_metric)) deallocate (this%distance_metric)

      call this%geometry%destroy()

      if (allocated(this%fragments)) then
         do i = 1, size(this%fragments)
            call this%fragments(i)%destroy()
         end do
         deallocate (this%fragments)
      end if

      if (allocated(this%bonds)) deallocate (this%bonds)

   end subroutine config_destroy

   subroutine input_fragment_destroy(this)
      !! Clean up allocated memory in input_fragment_t
      class(input_fragment_t), intent(inout) :: this
      if (allocated(this%indices)) deallocate (this%indices)
   end subroutine input_fragment_destroy

end module mqc_config_parser
