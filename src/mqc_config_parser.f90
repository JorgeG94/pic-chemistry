!! Parser for MQC section-based input files (.mqc format)
module mqc_config_parser
   !! Parses section-based input files with %section...end blocks
   !! This is the new format generated by mqc_prep.py
   use pic_types, only: dp, int32, int64
   use mqc_method_types, only: method_type_from_string, METHOD_TYPE_GFN2, METHOD_TYPE_UNKNOWN
   use mqc_calc_types, only: calc_type_from_string, CALC_TYPE_ENERGY, CALC_TYPE_UNKNOWN
   use mqc_geometry, only: geometry_type
   use mqc_error, only: error_t, ERROR_IO, ERROR_PARSE, ERROR_VALIDATION
   implicit none
   private

   public :: mqc_config_t, read_mqc_file
   public :: input_fragment_t, bond_t, molecule_t

   ! Maximum line length for reading
   integer, parameter :: MAX_LINE_LEN = 1024

   type :: input_fragment_t
      !! Input fragment definition with charge, multiplicity, and atom indices
      !! This is the parsed representation from the input file, not the computational fragment
      integer :: charge = 0
      integer :: multiplicity = 1
      integer, allocatable :: indices(:)  !! Atom indices in this fragment
   contains
      procedure :: destroy => input_fragment_destroy
   end type input_fragment_t

   type :: bond_t
      !! Bond definition with atom indices, order, and broken status
      integer :: atom_i = 0
      integer :: atom_j = 0
      integer :: order = 1
      logical :: is_broken = .false.
   end type bond_t

   type :: molecule_t
      !! Single molecule definition with structure, geometry, fragments, and connectivity
      character(len=:), allocatable :: name  !! Optional molecule name

      ! Structure information
      integer :: charge = 0
      integer :: multiplicity = 1

      ! Geometry
      type(geometry_type) :: geometry

      ! Fragments
      integer :: nfrag = 0
      type(input_fragment_t), allocatable :: fragments(:)

      ! Connectivity
      integer :: nbonds = 0
      integer :: nbroken = 0
      type(bond_t), allocatable :: bonds(:)

   contains
      procedure :: destroy => molecule_destroy
   end type molecule_t

   type :: mqc_config_t
      !! Complete configuration from .mqc file

      ! Schema information
      character(len=:), allocatable :: schema_name
      character(len=:), allocatable :: schema_version
      integer :: index_base = 0  !! 0-based or 1-based indexing
      character(len=:), allocatable :: units  !! angstrom or bohr

      ! Model information
      integer(int32) :: method = METHOD_TYPE_GFN2
      character(len=:), allocatable :: basis
      character(len=:), allocatable :: aux_basis

      ! Driver information
      integer(int32) :: calc_type = CALC_TYPE_ENERGY

      ! Multiple molecules support
      integer :: nmol = 0  !! Number of molecules (0 = single molecule mode for backward compatibility)
      type(molecule_t), allocatable :: molecules(:)  !! Array of molecules (if nmol > 0)

      ! Single molecule fields (backward compatibility - used if nmol == 0)
      ! Structure information
      integer :: charge = 0
      integer :: multiplicity = 1

      ! Geometry
      type(geometry_type) :: geometry

      ! Fragments
      integer :: nfrag = 0
      type(input_fragment_t), allocatable :: fragments(:)

      ! Connectivity
      integer :: nbonds = 0
      integer :: nbroken = 0
      type(bond_t), allocatable :: bonds(:)

      ! SCF settings
      integer :: scf_maxiter = 300
      real(dp) :: scf_tolerance = 1.0e-6_dp

      ! Fragmentation settings
      character(len=:), allocatable :: frag_method  !! MBE, etc.
      integer :: frag_level = 1
      logical :: allow_overlapping_fragments = .false.
      character(len=:), allocatable :: embedding
      character(len=:), allocatable :: cutoff_method
      character(len=:), allocatable :: distance_metric
      real(dp) :: dimer_cutoff = 0.0_dp
      real(dp) :: trimer_cutoff = 0.0_dp

      ! Logger settings (kept for compatibility)
      character(len=:), allocatable :: log_level

   contains
      procedure :: destroy => config_destroy
   end type mqc_config_t

contains

   pure function strip_comment(line) result(stripped)
      !! Remove comments (! or #) from a line and trim result
      character(len=*), intent(in) :: line
      character(len=:), allocatable :: stripped
      integer :: comment_pos

      ! Find first occurrence of ! or #
      comment_pos = index(line, '!')
      if (comment_pos == 0) comment_pos = index(line, '#')

      if (comment_pos > 0) then
         ! Comment found - take everything before it
         stripped = trim(adjustl(line(1:comment_pos - 1)))
      else
         ! No comment - use full line
         stripped = trim(adjustl(line))
      end if
   end function strip_comment

   subroutine read_mqc_file(filename, config, error)
      !! Read and parse a .mqc format input file
      character(len=*), intent(in) :: filename
      type(mqc_config_t), intent(out) :: config
      type(error_t), intent(out) :: error

      integer :: unit, io_stat
      character(len=MAX_LINE_LEN) :: line
      logical :: file_exists
      type(error_t) :: parse_error

      inquire (file=filename, exist=file_exists)
      if (.not. file_exists) then
         call error%set(ERROR_IO, "Input file not found: "//trim(filename))
         return
      end if

      open (newunit=unit, file=filename, status='old', action='read', iostat=io_stat)
      if (io_stat /= 0) then
         call error%set(ERROR_IO, "Error opening input file: "//trim(filename))
         return
      end if

      ! Set defaults
      config%log_level = "info"

      ! Read file line by line and dispatch to section parsers
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) exit

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         ! Check for section start
         if (line(1:1) == '%') then
            select case (trim(line))
            case ('%schema')
               call parse_schema_section(unit, config, parse_error)
            case ('%model')
               call parse_model_section(unit, config, parse_error)
            case ('%driver')
               call parse_driver_section(unit, config, parse_error)
            case ('%structure')
               call parse_structure_section(unit, config, parse_error)
            case ('%geometry')
               call parse_geometry_section(unit, config, parse_error)
            case ('%fragments')
               call parse_fragments_section(unit, config, parse_error)
            case ('%connectivity')
               call parse_connectivity_section(unit, config, parse_error)
            case ('%scf')
               call parse_scf_section(unit, config, parse_error)
            case ('%fragmentation')
               call parse_fragmentation_section(unit, config, parse_error)
            case ('%system')
               call parse_system_section(unit, config, parse_error)
            case ('%molecules')
               call parse_molecules_section(unit, config, parse_error)
            case default
               ! Skip unknown sections
               call skip_to_end(unit, parse_error)
            end select

            if (parse_error%has_error()) then
               error = parse_error
               close (unit)
               return
            end if
         end if
      end do

      close (unit)

      ! Validate required fields
      if (.not. allocated(config%schema_name)) then
         call error%set(ERROR_VALIDATION, "Missing required section: %schema")
         return
      end if

      ! Validate geometry: required for single-molecule mode, not for multi-molecule mode
      if (config%nmol == 0) then
         ! Single molecule mode: require top-level geometry
         if (.not. allocated(config%geometry%coords) .or. config%geometry%natoms == 0) then
            call error%set(ERROR_VALIDATION, "Missing required section: %geometry")
            return
         end if
      else
         ! Multi-molecule mode: each molecule must have geometry (validated during parsing)
         ! No additional validation needed here
      end if

   end subroutine read_mqc_file

   subroutine parse_schema_section(unit, config, error)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_PARSE, "Unexpected end of file in %schema section")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('name')
            config%schema_name = trim(value)
         case ('version')
            config%schema_version = trim(value)
         case ('index_base')
            read (value, *, iostat=io_stat) config%index_base
         case ('units')
            config%units = trim(value)
         case default
            call error%set(ERROR_PARSE, "Unknown key in %schema section: "//trim(key))
            return
         end select
      end do

   end subroutine parse_schema_section

   subroutine parse_model_section(unit, config, error)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file in %model section")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('method')
            ! Parse method string (e.g., "XTB-GFN1" -> "gfn1")
            config%method = parse_method_string(trim(value))
            if (config%method == METHOD_TYPE_UNKNOWN) then
               call error%set(ERROR_PARSE, "Invalid method: "//trim(value))
               return
            end if
         case ('basis')
            config%basis = trim(value)
         case ('aux_basis')
            config%aux_basis = trim(value)
         case default
            call error%set(ERROR_PARSE, "Unknown key in %model section: "//trim(key))
            return
         end select
      end do

   end subroutine parse_model_section

   subroutine parse_driver_section(unit, config, error)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file in %driver section")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('type')
            config%calc_type = calc_type_from_string(trim(value))
            if (config%calc_type == CALC_TYPE_UNKNOWN) then
               call error%set(ERROR_PARSE, "Invalid calc_type: "//trim(value))
               return
            end if
         case default
            call error%set(ERROR_PARSE, "Unknown key in %driver section: "//trim(key))
            return
         end select
      end do

   end subroutine parse_driver_section

   subroutine parse_structure_section(unit, config, error)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      type(error_t), intent(out) :: error

      call parse_structure_generic(unit, config%charge, config%multiplicity, error)

   end subroutine parse_structure_section

   subroutine parse_geometry_section(unit, config, error)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      type(error_t), intent(out) :: error

      call parse_geometry_generic(unit, config%geometry, error)

   end subroutine parse_geometry_section

   subroutine parse_fragments_section(unit, config, error)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      type(error_t), intent(out) :: error

      call parse_fragments_generic(unit, config%nfrag, config%fragments, error)

   end subroutine parse_fragments_section

   subroutine parse_fragment(unit, fragment, error)
      integer, intent(in) :: unit
      type(input_fragment_t), intent(inout) :: fragment
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos
      logical :: in_indices
      in_indices = .false.

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file in %fragment")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') then
            if (in_indices) then
               in_indices = .false.
               cycle
            else
               exit
            end if
         end if

         if (trim(line) == '%indices') then
            in_indices = .true.
            cycle
         end if

         if (in_indices) then
            ! Read indices
            call parse_indices_line(line, fragment, error)
            if (error%has_error()) return
         else
            eq_pos = index(line, '=')
            if (eq_pos > 0) then
               key = adjustl(line(1:eq_pos - 1))
               value = adjustl(line(eq_pos + 1:))

               select case (trim(key))
               case ('charge')
                  read (value, *, iostat=io_stat) fragment%charge
               case ('multiplicity')
                  read (value, *, iostat=io_stat) fragment%multiplicity
               case default
                  call error%set(ERROR_PARSE, "Unknown key in fragment properties: "//trim(key))
                  return
               end select
            end if
         end if
      end do

   end subroutine parse_fragment

   subroutine parse_indices_line(line, fragment, error)
      character(len=*), intent(in) :: line
      type(input_fragment_t), intent(inout) :: fragment
      type(error_t), intent(out) :: error

      integer :: io_stat, pos, count, i, idx
      character(len=MAX_LINE_LEN) :: temp_line
      integer, allocatable :: temp_indices(:), new_indices(:)
      temp_line = line

      ! Count how many integers
      count = 0
      do
         read (temp_line, *, iostat=io_stat) idx
         if (io_stat /= 0) exit
         count = count + 1
         ! Remove the read integer from temp_line
         pos = scan(temp_line, ' ')
         if (pos == 0) exit
         temp_line = adjustl(temp_line(pos:))
      end do

      if (count == 0) return

      ! Allocate temporary array
      allocate (temp_indices(count))

      ! Read the integers
      read (line, *, iostat=io_stat) temp_indices
      if (io_stat /= 0) then
         call error%set(ERROR_PARSE, "Error reading fragment indices")
         deallocate (temp_indices)
         return
      end if

      ! Append to existing indices
      if (allocated(fragment%indices)) then
         allocate (new_indices(size(fragment%indices) + count))
         new_indices(1:size(fragment%indices)) = fragment%indices
         new_indices(size(fragment%indices) + 1:) = temp_indices
         call move_alloc(new_indices, fragment%indices)
      else
         call move_alloc(temp_indices, fragment%indices)
      end if

   end subroutine parse_indices_line

   subroutine parse_connectivity_section(unit, config, error)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      type(error_t), intent(out) :: error

      call parse_connectivity_generic(unit, config%nbonds, config%nbroken, config%bonds, error)

   end subroutine parse_connectivity_section

   subroutine parse_scf_section(unit, config, error)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file in %scf section")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('maxiter')
            read (value, *, iostat=io_stat) config%scf_maxiter
         case ('tolerance')
            read (value, *, iostat=io_stat) config%scf_tolerance
         case default
            call error%set(ERROR_PARSE, "Unknown key in %scf section: "//trim(key))
            return
         end select
      end do

   end subroutine parse_scf_section

   subroutine parse_fragmentation_section(unit, config, error)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos
      logical :: in_cutoffs
      in_cutoffs = .false.

      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file in %fragmentation section")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') then
            if (in_cutoffs) then
               in_cutoffs = .false.
               cycle
            else
               exit
            end if
         end if

         if (trim(line) == '%cutoffs') then
            in_cutoffs = .true.
            cycle
         end if

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         if (in_cutoffs) then
            select case (trim(key))
            case ('dimer')
               read (value, *, iostat=io_stat) config%dimer_cutoff
            case ('trimer')
               read (value, *, iostat=io_stat) config%trimer_cutoff
            case default
               call error%set(ERROR_PARSE, "Unknown key in %fragmentation cutoffs subsection: "//trim(key))
               return
            end select
         else
            select case (trim(key))
            case ('method')
               config%frag_method = trim(value)
            case ('level')
               read (value, *, iostat=io_stat) config%frag_level
            case ('allow_overlapping_fragments')
               config%allow_overlapping_fragments = (trim(value) == 'true')
            case ('embedding')
               config%embedding = trim(value)
            case ('cutoff_method')
               config%cutoff_method = trim(value)
            case ('distance_metric')
               config%distance_metric = trim(value)
            case default
               call error%set(ERROR_PARSE, "Unknown key in %fragmentation section: "//trim(key))
               return
            end select
         end if
      end do

   end subroutine parse_fragmentation_section

   subroutine parse_system_section(unit, config, error)
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file in %system section")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('log_level')
            config%log_level = trim(value)
         case default
            call error%set(ERROR_PARSE, "Unknown key in %system section: "//trim(key))
            return
         end select
      end do

   end subroutine parse_system_section

   subroutine parse_molecules_section(unit, config, error)
      !! Parse %molecules section containing multiple %molecule blocks
      integer, intent(in) :: unit
      type(mqc_config_t), intent(inout) :: config
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value
      character(len=256) :: msg
      integer :: io_stat, eq_pos, nmol, imol
      nmol = 0

      ! First pass: read nmol
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file in %molecules section")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos > 0) then
            key = adjustl(line(1:eq_pos - 1))
            value = adjustl(line(eq_pos + 1:))

            if (trim(key) == 'nmol') then
               read (value, *, iostat=io_stat) nmol
               if (io_stat /= 0) then
                  call error%set(ERROR_PARSE, "Invalid nmol value")
                  return
               end if
               exit
            end if
         end if
      end do

      if (nmol == 0) then
         ! No molecules, just skip to end
         call skip_to_end(unit, error)
         return
      end if

      config%nmol = nmol
      allocate (config%molecules(nmol))

      ! Parse individual molecules
      imol = 0
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) exit

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         if (trim(line) == '%molecule') then
            imol = imol + 1
            if (imol > nmol) then
               call error%set(ERROR_PARSE, "More molecules than declared nmol")
               return
            end if
            call parse_single_molecule(unit, config%molecules(imol), error)
            if (error%has_error()) return
         end if
      end do

      if (imol /= nmol) then
         write (msg, '(A,I0,A,I0)') "Expected ", nmol, " molecules, found ", imol
         call error%set(ERROR_PARSE, trim(msg))
         return
      end if

   end subroutine parse_molecules_section

   subroutine parse_single_molecule(unit, mol, error)
      !! Parse a single %molecule block with its sections
      integer, intent(in) :: unit
      type(molecule_t), intent(inout) :: mol
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file in %molecule")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         ! Check for key=value pairs (like name)
         eq_pos = index(line, '=')
         if (eq_pos > 0) then
            key = adjustl(line(1:eq_pos - 1))
            value = adjustl(line(eq_pos + 1:))
            if (trim(key) == 'name') then
               mol%name = trim(value)
               cycle
            end if
         end if

         ! Check for subsections
         if (line(1:1) == '%') then
            select case (trim(line))
            case ('%structure')
               call parse_molecule_structure(unit, mol, error)
            case ('%geometry')
               call parse_molecule_geometry(unit, mol, error)
            case ('%fragments')
               call parse_molecule_fragments(unit, mol, error)
            case ('%connectivity')
               call parse_molecule_connectivity(unit, mol, error)
            case default
               ! Skip unknown subsections
               call skip_to_end(unit, error)
            end select

            if (error%has_error()) return
         end if
      end do

   end subroutine parse_single_molecule

   subroutine parse_molecule_structure(unit, mol, error)
      !! Parse %structure section for a molecule
      integer, intent(in) :: unit
      type(molecule_t), intent(inout) :: mol
      type(error_t), intent(out) :: error

      call parse_structure_generic(unit, mol%charge, mol%multiplicity, error)

   end subroutine parse_molecule_structure

   subroutine parse_molecule_geometry(unit, mol, error)
      !! Parse %geometry section for a molecule
      integer, intent(in) :: unit
      type(molecule_t), intent(inout) :: mol
      type(error_t), intent(out) :: error

      call parse_geometry_generic(unit, mol%geometry, error)

   end subroutine parse_molecule_geometry

   subroutine parse_molecule_fragments(unit, mol, error)
      !! Parse %fragments section for a molecule
      integer, intent(in) :: unit
      type(molecule_t), intent(inout) :: mol
      type(error_t), intent(out) :: error

      call parse_fragments_generic(unit, mol%nfrag, mol%fragments, error)

   end subroutine parse_molecule_fragments

   subroutine parse_molecule_connectivity(unit, mol, error)
      !! Parse %connectivity section for a molecule
      integer, intent(in) :: unit
      type(molecule_t), intent(inout) :: mol
      type(error_t), intent(out) :: error

      call parse_connectivity_generic(unit, mol%nbonds, mol%nbroken, mol%bonds, error)

   end subroutine parse_molecule_connectivity

   subroutine skip_to_end(unit, error)
      !! Skip lines until 'end' marker is found
      integer, intent(in) :: unit
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line
      integer :: io_stat
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file while skipping section")
            return
         end if

         line = adjustl(line)
         if (trim(strip_comment(line)) == 'end') exit
      end do

   end subroutine skip_to_end

   function parse_method_string(method_str) result(method_type)
      !! Parse method string from input file (e.g., "XTB-GFN1" -> gfn1)
      character(len=*), intent(in) :: method_str
      integer(int32) :: method_type

      character(len=:), allocatable :: lower_str, method_part
      integer :: dash_pos, i

      ! Convert to lowercase
      allocate (character(len=len_trim(method_str)) :: lower_str)
      lower_str = trim(adjustl(method_str))
      do i = 1, len(lower_str)
         if (lower_str(i:i) >= 'A' .and. lower_str(i:i) <= 'Z') then
            lower_str(i:i) = achar(iachar(lower_str(i:i)) + 32)
         end if
      end do

      ! Handle "XTB-GFN1" format -> extract "gfn1"
      if (index(lower_str, 'xtb') > 0) then
         dash_pos = index(lower_str, '-')
         if (dash_pos > 0) then
            method_part = lower_str(dash_pos + 1:)
         else
            method_part = lower_str
         end if
      else
         method_part = lower_str
      end if

      method_type = method_type_from_string(method_part)

   end function parse_method_string

   subroutine molecule_destroy(this)
      !! Clean up allocated memory in molecule_t
      class(molecule_t), intent(inout) :: this
      integer :: i

      if (allocated(this%name)) deallocate (this%name)

      call this%geometry%destroy()

      if (allocated(this%fragments)) then
         do i = 1, size(this%fragments)
            call this%fragments(i)%destroy()
         end do
         deallocate (this%fragments)
      end if

      if (allocated(this%bonds)) deallocate (this%bonds)

   end subroutine molecule_destroy

   subroutine config_destroy(this)
      !! Clean up allocated memory in mqc_config_t
      class(mqc_config_t), intent(inout) :: this
      integer :: i

      if (allocated(this%schema_name)) deallocate (this%schema_name)
      if (allocated(this%schema_version)) deallocate (this%schema_version)
      if (allocated(this%units)) deallocate (this%units)
      if (allocated(this%basis)) deallocate (this%basis)
      if (allocated(this%aux_basis)) deallocate (this%aux_basis)
      if (allocated(this%log_level)) deallocate (this%log_level)
      if (allocated(this%frag_method)) deallocate (this%frag_method)
      if (allocated(this%embedding)) deallocate (this%embedding)
      if (allocated(this%cutoff_method)) deallocate (this%cutoff_method)
      if (allocated(this%distance_metric)) deallocate (this%distance_metric)

      call this%geometry%destroy()

      if (allocated(this%fragments)) then
         do i = 1, size(this%fragments)
            call this%fragments(i)%destroy()
         end do
         deallocate (this%fragments)
      end if

      if (allocated(this%bonds)) deallocate (this%bonds)

      ! Clean up molecules array (multi-molecule mode)
      if (allocated(this%molecules)) then
         do i = 1, size(this%molecules)
            call this%molecules(i)%destroy()
         end do
         deallocate (this%molecules)
      end if

   end subroutine config_destroy

   subroutine input_fragment_destroy(this)
      !! Clean up allocated memory in input_fragment_t
      class(input_fragment_t), intent(inout) :: this
      if (allocated(this%indices)) deallocate (this%indices)
   end subroutine input_fragment_destroy

   !! ========================================================================
   !! Generic parsing helpers to eliminate redundancy
   !! ========================================================================

   subroutine parse_structure_generic(unit, charge, multiplicity, error)
      !! Generic parser for %structure section (works for both config and molecule)
      integer, intent(in) :: unit
      integer, intent(inout) :: charge, multiplicity
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value
      integer :: io_stat, eq_pos
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file in %structure section")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos == 0) cycle

         key = adjustl(line(1:eq_pos - 1))
         value = adjustl(line(eq_pos + 1:))

         select case (trim(key))
         case ('charge')
            read (value, *, iostat=io_stat) charge
         case ('multiplicity')
            read (value, *, iostat=io_stat) multiplicity
         case default
            call error%set(ERROR_PARSE, "Unknown key in %structure section: "//trim(key))
            return
         end select
      end do

   end subroutine parse_structure_generic

   subroutine parse_geometry_generic(unit, geom, error)
      !! Generic parser for %geometry section (works for both config and molecule)
      integer, intent(in) :: unit
      type(geometry_type), intent(inout) :: geom
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, elem
      integer :: io_stat, natoms, i
      real(dp) :: x, y, z
      ! Read number of atoms
      read (unit, '(A)', iostat=io_stat) line
      if (io_stat /= 0) then
         call error%set(ERROR_PARSE, "Error reading natoms in %geometry section")
         return
      end if

      read (line, *, iostat=io_stat) natoms
      if (io_stat /= 0) then
         call error%set(ERROR_PARSE, "Invalid natoms in %geometry section")
         return
      end if

      geom%natoms = natoms

      ! Read blank line (comment line in XYZ format)
      read (unit, '(A)', iostat=io_stat) line
      if (io_stat /= 0) then
         call error%set(ERROR_PARSE, "Error reading comment line in %geometry section")
         return
      end if

      geom%comment = trim(line)

      ! Allocate arrays
      allocate (character(len=4) :: geom%elements(natoms))
      allocate (geom%coords(3, natoms))

      ! Read coordinates
      do i = 1, natoms
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_PARSE, "Error reading geometry coordinates")
            return
         end if

         line = adjustl(line)
         if (trim(strip_comment(line)) == 'end') then
            call error%set(ERROR_PARSE, "Unexpected 'end' while reading geometry")
            return
         end if

         read (line, *, iostat=io_stat) elem, x, y, z
         if (io_stat /= 0) then
            call error%set(ERROR_PARSE, "Invalid coordinate format in %geometry section")
            return
         end if

         geom%elements(i) = trim(elem)
         geom%coords(1, i) = x
         geom%coords(2, i) = y
         geom%coords(3, i) = z
      end do

      ! Read 'end' marker
      read (unit, '(A)', iostat=io_stat) line
      if (io_stat /= 0) then
         call error%set(ERROR_VALIDATION, "Missing 'end' in %geometry section")
         return
      end if

      line = adjustl(line)
      if (trim(strip_comment(line)) /= 'end') then
         call error%set(ERROR_PARSE, "Expected 'end' after geometry coordinates")
         return
      end if

   end subroutine parse_geometry_generic

   subroutine parse_fragments_generic(unit, nfrag, fragments, error)
      !! Generic parser for %fragments section (works for both config and molecule)
      integer, intent(in) :: unit
      integer, intent(inout) :: nfrag
      type(input_fragment_t), allocatable, intent(inout) :: fragments(:)
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value
      character(len=256) :: msg
      integer :: io_stat, eq_pos, nfrag_local, ifrag
      nfrag_local = 0

      ! First pass: read nfrag
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file in %fragments section")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos > 0) then
            key = adjustl(line(1:eq_pos - 1))
            value = adjustl(line(eq_pos + 1:))

            if (trim(key) == 'nfrag') then
               read (value, *, iostat=io_stat) nfrag_local
               if (io_stat /= 0) then
                  call error%set(ERROR_PARSE, "Invalid nfrag value")
                  return
               end if
               exit
            end if
         end if
      end do

      if (nfrag_local == 0) then
         ! No fragments, just skip to end
         call skip_to_end(unit, error)
         return
      end if

      nfrag = nfrag_local
      allocate (fragments(nfrag))

      ! Parse individual fragments
      ifrag = 0
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) exit

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         if (trim(line) == '%fragment') then
            ifrag = ifrag + 1
            if (ifrag > nfrag) then
               call error%set(ERROR_PARSE, "More fragments than declared nfrag")
               return
            end if
            call parse_fragment(unit, fragments(ifrag), error)
            if (error%has_error()) return
         end if
      end do

      if (ifrag /= nfrag) then
         write (msg, '(A,I0,A,I0)') "Expected ", nfrag, " fragments, found ", ifrag
         call error%set(ERROR_PARSE, trim(msg))
         return
      end if

   end subroutine parse_fragments_generic

   subroutine parse_connectivity_generic(unit, nbonds, nbroken, bonds, error)
      !! Generic parser for %connectivity section (works for both config and molecule)
      integer, intent(in) :: unit
      integer, intent(inout) :: nbonds, nbroken
      type(bond_t), allocatable, intent(inout) :: bonds(:)
      type(error_t), intent(out) :: error

      character(len=MAX_LINE_LEN) :: line, key, value, status_str
      integer :: io_stat, eq_pos, nbonds_local, ibond
      integer :: atom_i, atom_j, order
      nbonds_local = 0

      ! First pass: read nbonds
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) then
            call error%set(ERROR_IO, "Unexpected end of file in %connectivity section")
            return
         end if

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         if (trim(strip_comment(line)) == 'end') exit

         eq_pos = index(line, '=')
         if (eq_pos > 0) then
            key = adjustl(line(1:eq_pos - 1))
            value = adjustl(line(eq_pos + 1:))

            if (trim(key) == 'nbonds') then
               read (value, *, iostat=io_stat) nbonds_local
               if (io_stat /= 0) then
                  call error%set(ERROR_PARSE, "Invalid nbonds value")
                  return
               end if
               exit
            end if
         end if
      end do

      if (nbonds_local == 0) then
         ! No bonds, just skip to end
         call skip_to_end(unit, error)
         return
      end if

      nbonds = nbonds_local
      allocate (bonds(nbonds))

      ! Read bonds
      ibond = 0
      do
         read (unit, '(A)', iostat=io_stat) line
         if (io_stat /= 0) exit

         line = adjustl(line)
         if (len_trim(line) == 0) cycle
         if (line(1:1) == '#' .or. line(1:1) == '!') cycle

         ! Check for key=value pairs (like nbroken=9)
         eq_pos = index(line, '=')
         if (eq_pos > 0) then
            key = adjustl(line(1:eq_pos - 1))
            value = adjustl(line(eq_pos + 1:))
            if (trim(key) == 'nbroken') then
               read (value, *, iostat=io_stat) nbroken
            end if
            cycle
         end if

         if (trim(strip_comment(line)) == 'end') exit

         ! Parse bond line: atom_i atom_j order broken/preserved
         read (line, *, iostat=io_stat) atom_i, atom_j, order, status_str
         if (io_stat /= 0) then
            call error%set(ERROR_PARSE, "Invalid bond format in %connectivity section")
            return
         end if

         ibond = ibond + 1
         if (ibond > nbonds) then
            call error%set(ERROR_PARSE, "More bonds than declared nbonds")
            return
         end if

         bonds(ibond)%atom_i = atom_i
         bonds(ibond)%atom_j = atom_j
         bonds(ibond)%order = order
         bonds(ibond)%is_broken = (trim(status_str) == 'broken')
      end do

   end subroutine parse_connectivity_generic

end module mqc_config_parser
