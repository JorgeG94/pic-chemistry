var tipuesearch = {"pages":[{"title":" metalquicha ","text":"metalquicha Metalquicha API Documentation Met’al q’uicha (metalquicha) AI Disclaimer Building Notes on Fortran compiler compatibility Building with the Fortran Package Manager (FPM) Obtaining the FPM Running a calculation Warning This API documentation is a work in progress. Metalquicha API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . Met’al q’uicha (metalquicha) Yes, this is AI generated (the image) if you know an artist, please let me know. Met’al q’uicha (the Huastec (tenek) word for sunflower), which I’ll just write as metalquicha, is a sample quantum chemistry backend\nwith focus on using the pic library and its derivatives: pic-mpi and pic-blas which are Fortran based implementations of commonly used routines such as sorting algorithms,\narray handling, strings, loggers, timers, etc. The documentation is hosted at readthedocs, here . Additionally, users can opt to try the vapaa backend for the mpi_f08 module\nto ensure cross compiler portability. Please report any issues associated here and in vapaa. Metalquicha implements a naive backend for unfragmented and fragmented quantum chemistry\ncalculations. Currently, metalquicha uses tblite as\nits chemistry engine which performs energy calculations. If you are interested in contributing, please see here . Pic is the main project here and all the contributions fall downstream. You can see Project for some information on development priorities and things being done! AI Disclaimer The development of Metalquicha has been assisted by LLMs, such as ChatGPT, and Claude. The philosophy of “vibe coding” applied to this project is as follows: The programmer (Jorge), describes the overall architecture of a subroutine to be implemented and provides pseudocode The LLM produces an implementation that compiles The programmer writes a unit test for the function and validates the subroutine The LLM is asked to optimize the code while keeping the tests passing The programmer evaluates the code and evaluates if the routine needs to be redone or just upgraded by hand Either the programmer changes the code themselves or if they are lazy or cooking dinner while developing, they ask the LLM to try again This was applied for routines such as the mqc_finite_difference module, which is pretty trivial to implement. LLMs were also extensively used to add comments and basic documentation for the code. The idea is that\nMetalquicha is a platform for development of fragmentation methods aimed to be suitable for everyone -\nfrom students with no experience in Fortran and/or Quantum Chemistry to experienced researchers with\nextensive expertise in both. Justification for LLM use I wanted to see to what extent LLMs can be used for Fortran code development. I can conclude that they are actually quite good. Building You will need an internet connection to download the dependencies. The main dependencies are: CMake A Fortran compiler An MPI installation A BLAS/LAPACK install TBLITE (will be downloaded automatically) You can then simply: mkdir build\ncd build\ncmake ../\nmake -j Notes on Fortran compiler compatibility If you enable tblite (enabled by default at the moment) you are going to be blocked by which compilers does tblite\nsupport. If you decide to not build tblite and just build the framework the code will work with most modern compilers. Supported compilers: Using TBlite: gcc, ifx, ifort Without tblite, i.e. no quantum chemistry: gcc, nvfortran, flang(new), ifx, ifort Building with the Fortran Package Manager (FPM) FPM will only work if you are building with openblas, since the linking step is hardcoded. Simply then just do: fpm install --prefix . --compiler mpifort --profile release Obtaining the FPM Install the FPM following the instructions and then simply: fpm install Running a calculation To run a calculation you need to process the JSON input into our mqc format. To do this, you can simply do: python mqc_prep.py validation/inputs/prism.json And this will generate a prism.mqc . Which can be simply run as ./build/mqc validation/inputs/prism.mqc to be run\nin serial mode. Or mpirun -np 4 ./build/mqc validation/inputs/prism.mqc . A sample mqc file is shown below: %schema name = mqc - frag version = 1.0 index_base = 0 units = angstrom end ! schema %model method = XTB - GFN1 basis = cc - pVDZ aux_basis = cc - pVDZ - RIFIT end ! model %driver type = Energy end ! driver %structure charge = 0 multiplicity = 1 end ! structure %geometry 3 O 0 0 0.119262 H 0 0.763239 -0.477047 H 0 -0.763239 -0.477047 end ! geometry %scf maxiter = 300 tolerance = 1e-06 end ! scf If you don’t want to use the python script, you can modify this file by adding an xyz formatted geometry. Supported calculations are Energy , Gradient , and Hessian . Developer Info Jorge Luis Galvez Vallejo","tags":"home","url":"index.html"},{"title":"displaced_geometry_t – metalquicha ","text":"type, public :: displaced_geometry_t Container for a single displaced geometry Inherits type~~displaced_geometry_t~~InheritsGraph type~displaced_geometry_t displaced_geometry_t type~physical_fragment_t physical_fragment_t type~displaced_geometry_t->type~physical_fragment_t geometry type~molecular_basis_type molecular_basis_type type~physical_fragment_t->type~molecular_basis_type basis type~atomic_basis_type atomic_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: atom_index Which atom was displaced (1-based) integer, public :: coordinate Which coordinate was displaced (1=x, 2=y, 3=z) integer, public :: direction +1 for forward, -1 for backward real(kind=dp), public :: displacement Displacement magnitude in Bohr type( physical_fragment_t ), public :: geometry The displaced geometry Type-Bound Procedures procedure, public :: destroy => displaced_geometry_destroy private  subroutine displaced_geometry_destroy (this) Clean up memory for displaced geometry Arguments Type Intent Optional Attributes Name class( displaced_geometry_t ), intent(inout) :: this Source Code type :: displaced_geometry_t !! Container for a single displaced geometry integer :: atom_index !! Which atom was displaced (1-based) integer :: coordinate !! Which coordinate was displaced (1=x, 2=y, 3=z) integer :: direction !! +1 for forward, -1 for backward real ( dp ) :: displacement !! Displacement magnitude in Bohr type ( physical_fragment_t ) :: geometry !! The displaced geometry contains procedure :: destroy => displaced_geometry_destroy end type displaced_geometry_t","tags":"","url":"type/displaced_geometry_t.html"},{"title":"aimd_keywords_t – metalquicha ","text":"type, public :: aimd_keywords_t Ab initio molecular dynamics keywords Inherited by type~~aimd_keywords_t~~InheritedByGraph type~aimd_keywords_t aimd_keywords_t type~driver_config_t driver_config_t type~driver_config_t->type~aimd_keywords_t aimd Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: dt = 1.0_dp Timestep (femtoseconds) real(kind=dp), public :: initial_temperature = 300.0_dp Initial temperature for velocity init (K) integer, public :: nsteps = 0 Number of MD steps (0 = no AIMD) integer, public :: output_frequency = 1 Write output every N steps Source Code type :: aimd_keywords_t !! Ab initio molecular dynamics keywords real ( dp ) :: dt = 1.0_dp !! Timestep (femtoseconds) integer :: nsteps = 0 !! Number of MD steps (0 = no AIMD) real ( dp ) :: initial_temperature = 30 0.0_dp !! Initial temperature for velocity init (K) integer :: output_frequency = 1 !! Write output every N steps end type aimd_keywords_t","tags":"","url":"type/aimd_keywords_t.html"},{"title":"hessian_keywords_t – metalquicha ","text":"type, public :: hessian_keywords_t Hessian calculation keywords Inherited by type~~hessian_keywords_t~~InheritedByGraph type~hessian_keywords_t hessian_keywords_t type~driver_config_t driver_config_t type~driver_config_t->type~hessian_keywords_t hessian Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: displacement = 0.001_dp Finite difference displacement (Bohr) Source Code type :: hessian_keywords_t !! Hessian calculation keywords real ( dp ) :: displacement = 0.001_dp !! Finite difference displacement (Bohr) end type hessian_keywords_t","tags":"","url":"type/hessian_keywords_t.html"},{"title":"scf_keywords_t – metalquicha ","text":"type, public :: scf_keywords_t SCF calculation keywords (placeholder for future use) Inherited by type~~scf_keywords_t~~InheritedByGraph type~scf_keywords_t scf_keywords_t type~driver_config_t driver_config_t type~driver_config_t->type~scf_keywords_t scf Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: convergence_threshold = 1.0e-6_dp Convergence threshold for SCF integer, public :: max_iterations = 100 Maximum SCF iterations logical, public :: use_diis = .true. Use DIIS acceleration Source Code type :: scf_keywords_t !! SCF calculation keywords (placeholder for future use) logical :: use_diis = . true . !! Use DIIS acceleration integer :: max_iterations = 100 !! Maximum SCF iterations real ( dp ) :: convergence_threshold = 1.0e-6_dp !! Convergence threshold for SCF end type scf_keywords_t","tags":"","url":"type/scf_keywords_t.html"},{"title":"calculation_result_t – metalquicha ","text":"type, public :: calculation_result_t Container for quantum chemistry calculation results Stores computed quantities from QC calculations with flags\nindicating which properties have been computed. Inherits type~~calculation_result_t~~InheritsGraph type~calculation_result_t calculation_result_t type~energy_t energy_t type~calculation_result_t->type~energy_t energy type~cc_energy_t cc_energy_t type~energy_t->type~cc_energy_t cc type~mp2_energy_t mp2_energy_t type~energy_t->type~mp2_energy_t mp2 Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dipole (:) Dipole moment vector (3) (Debye) real(kind=dp), public :: distance = 0.0_dp Minimal atomic distance between monomers (Angstrom, 0 for monomers) type( energy_t ), public :: energy Energy components (Hartree) real(kind=dp), public, allocatable :: gradient (:,:) Energy gradient (3, natoms) (Hartree/Bohr) logical, public :: has_dipole = .false. Dipole moment has been computed logical, public :: has_energy = .false. Energy has been computed logical, public :: has_gradient = .false. Gradient has been computed logical, public :: has_hessian = .false. Hessian has been computed logical, public :: has_sigma = .false. Stress tensor has been computed real(kind=dp), public, allocatable :: hessian (:,:) Energy hessian (future implementation) real(kind=dp), public, allocatable :: sigma (:,:) Stress tensor (3,3) (Hartree/Bohr&#94;3) Type-Bound Procedures procedure, public :: destroy => result_destroy Clean up allocated memory private  subroutine result_destroy (this) Clean up allocated memory in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this procedure, public :: reset => result_reset Reset all values and flags private  subroutine result_reset (this) Reset all values and flags in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Source Code type :: calculation_result_t !! Container for quantum chemistry calculation results !! !! Stores computed quantities from QC calculations with flags !! indicating which properties have been computed. type ( energy_t ) :: energy !! Energy components (Hartree) real ( dp ), allocatable :: gradient (:, :) !! Energy gradient (3, natoms) (Hartree/Bohr) real ( dp ), allocatable :: sigma (:, :) !! Stress tensor (3,3) (Hartree/Bohr&#94;3) real ( dp ), allocatable :: hessian (:, :) !! Energy hessian (future implementation) real ( dp ), allocatable :: dipole (:) !! Dipole moment vector (3) (Debye) ! Fragment metadata real ( dp ) :: distance = 0.0_dp !! Minimal atomic distance between monomers (Angstrom, 0 for monomers) ! Computation status flags logical :: has_energy = . false . !! Energy has been computed logical :: has_gradient = . false . !! Gradient has been computed logical :: has_sigma = . false . !! Stress tensor has been computed logical :: has_hessian = . false . !! Hessian has been computed logical :: has_dipole = . false . !! Dipole moment has been computed contains procedure :: destroy => result_destroy !! Clean up allocated memory procedure :: reset => result_reset !! Reset all values and flags end type calculation_result_t","tags":"","url":"type/calculation_result_t.html"},{"title":"cc_energy_t – metalquicha ","text":"type, public :: cc_energy_t Container for coupled cluster energy components Inherited by type~~cc_energy_t~~InheritedByGraph type~cc_energy_t cc_energy_t type~energy_t energy_t type~energy_t->type~cc_energy_t cc type~calculation_result_t calculation_result_t type~calculation_result_t->type~energy_t energy Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: doubles = 0.0_dp Doubles contribution (Hartree) real(kind=dp), public :: singles = 0.0_dp Singles contribution (Hartree) real(kind=dp), public :: triples = 0.0_dp Triples contribution (Hartree) Type-Bound Procedures procedure, public :: check_stability => cc_check_stability Check for positive energies (instability) private  subroutine cc_check_stability (this) Check for positive CC correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this procedure, public :: reset => cc_reset Reset all components to zero private  subroutine cc_reset (this) Reset all CC components to zero Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(inout) :: this procedure, public :: total => cc_total Compute total CC correlation private pure function cc_total (this) result(total) Compute total CC correlation energy Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code type :: cc_energy_t !! Container for coupled cluster energy components real ( dp ) :: singles = 0.0_dp !! Singles contribution (Hartree) real ( dp ) :: doubles = 0.0_dp !! Doubles contribution (Hartree) real ( dp ) :: triples = 0.0_dp !! Triples contribution (Hartree) contains procedure :: total => cc_total !! Compute total CC correlation procedure :: reset => cc_reset !! Reset all components to zero procedure :: check_stability => cc_check_stability !! Check for positive energies (instability) end type cc_energy_t","tags":"","url":"type/cc_energy_t.html"},{"title":"energy_t – metalquicha ","text":"type, public :: energy_t Container for quantum chemistry energy components Stores energy contributions from different levels of theory.\nTotal energy is computed as: scf + mp2%total() + cc%total() Inherits type~~energy_t~~InheritsGraph type~energy_t energy_t type~cc_energy_t cc_energy_t type~energy_t->type~cc_energy_t cc type~mp2_energy_t mp2_energy_t type~energy_t->type~mp2_energy_t mp2 Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~energy_t~~InheritedByGraph type~energy_t energy_t type~calculation_result_t calculation_result_t type~calculation_result_t->type~energy_t energy Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( cc_energy_t ), public :: cc Coupled cluster correlation components type( mp2_energy_t ), public :: mp2 MP2 correlation components real(kind=dp), public :: scf = 0.0_dp SCF/HF reference energy (Hartree) Type-Bound Procedures procedure, public :: reset => energy_reset Reset all components to zero private  subroutine energy_reset (this) Reset all energy components to zero Arguments Type Intent Optional Attributes Name class( energy_t ), intent(inout) :: this procedure, public :: total => energy_total Compute total energy from components private pure function energy_total (this) result(total) Compute total energy from all components Arguments Type Intent Optional Attributes Name class( energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code type :: energy_t !! Container for quantum chemistry energy components !! !! Stores energy contributions from different levels of theory. !! Total energy is computed as: scf + mp2%total() + cc%total() real ( dp ) :: scf = 0.0_dp !! SCF/HF reference energy (Hartree) type ( mp2_energy_t ) :: mp2 !! MP2 correlation components type ( cc_energy_t ) :: cc !! Coupled cluster correlation components ! add more as needed, also need to modify the total energy function contains procedure :: total => energy_total !! Compute total energy from components procedure :: reset => energy_reset !! Reset all components to zero end type energy_t","tags":"","url":"type/energy_t.html"},{"title":"mp2_energy_t – metalquicha ","text":"type, public :: mp2_energy_t Container for MP2 energy components (SS/OS) Inherited by type~~mp2_energy_t~~InheritedByGraph type~mp2_energy_t mp2_energy_t type~energy_t energy_t type~energy_t->type~mp2_energy_t mp2 type~calculation_result_t calculation_result_t type~calculation_result_t->type~energy_t energy Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: os = 0.0_dp Opposite-spin correlation energy (Hartree) real(kind=dp), public :: ss = 0.0_dp Same-spin correlation energy (Hartree) Type-Bound Procedures procedure, public :: check_stability => mp2_check_stability Check for positive energies (instability) private  subroutine mp2_check_stability (this) Check for positive MP2 correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this procedure, public :: reset => mp2_reset Reset both components to zero private  subroutine mp2_reset (this) Reset both MP2 components to zero Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(inout) :: this procedure, public :: scs => mp2_scs Compute SCS-MP2 correlation private pure function mp2_scs (this) result(scs_energy) Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy\nSCS-MP2 uses: E_SCS = (1/3) E_SS + 1.2 E_OS Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) procedure, public :: total => mp2_total Compute total MP2 correlation private pure function mp2_total (this) result(total) Compute total MP2 correlation energy Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code type :: mp2_energy_t !! Container for MP2 energy components (SS/OS) real ( dp ) :: ss = 0.0_dp !! Same-spin correlation energy (Hartree) real ( dp ) :: os = 0.0_dp !! Opposite-spin correlation energy (Hartree) contains procedure :: total => mp2_total !! Compute total MP2 correlation procedure :: scs => mp2_scs !! Compute SCS-MP2 correlation procedure :: reset => mp2_reset !! Reset both components to zero procedure :: check_stability => mp2_check_stability !! Check for positive energies (instability) end type mp2_energy_t","tags":"","url":"type/mp2_energy_t.html"},{"title":"driver_config_t – metalquicha ","text":"type, public :: driver_config_t Inherits type~~driver_config_t~~InheritsGraph type~driver_config_t driver_config_t type~aimd_keywords_t aimd_keywords_t type~driver_config_t->type~aimd_keywords_t aimd type~hessian_keywords_t hessian_keywords_t type~driver_config_t->type~hessian_keywords_t hessian type~scf_keywords_t scf_keywords_t type~driver_config_t->type~scf_keywords_t scf Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( aimd_keywords_t ), public :: aimd AIMD calculation keywords logical, public :: allow_overlapping_fragments = .false. Enable GMBE for overlapping fragments integer(kind=int32), public :: calc_type Calculation type constant real(kind=dp), public, allocatable :: fragment_cutoffs (:) Distance cutoffs for n-mer screening (Angstrom) type( hessian_keywords_t ), public :: hessian Hessian calculation keywords integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method QC method constant integer, public :: nlevel = 0 Fragmentation level (0 = unfragmented) type( scf_keywords_t ), public :: scf SCF calculation keywords Source Code type :: driver_config_t ! Core calculation settings integer ( int32 ) :: method !! QC method constant integer ( int32 ) :: calc_type !! Calculation type constant ! Fragmentation settings integer :: nlevel = 0 !! Fragmentation level (0 = unfragmented) logical :: allow_overlapping_fragments = . false . !! Enable GMBE for overlapping fragments integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) real ( dp ), allocatable :: fragment_cutoffs (:) !! Distance cutoffs for n-mer screening (Angstrom) ! Calculation-specific keywords (structured) type ( hessian_keywords_t ) :: hessian !! Hessian calculation keywords type ( aimd_keywords_t ) :: aimd !! AIMD calculation keywords type ( scf_keywords_t ) :: scf !! SCF calculation keywords end type driver_config_t","tags":"","url":"type/driver_config_t.html"},{"title":"error_t – metalquicha ","text":"type, public :: error_t Components Type Visibility Attributes Name Initial character(len=MAX_LOCATION_LEN), public :: call_stack (MAX_STACK_DEPTH) Call locations integer, public :: code = SUCCESS Error code (0 = no error) character(len=:), public, allocatable :: message Error message Stack trace support integer, public :: stack_depth = 0 Current stack depth Type-Bound Procedures procedure, public :: add_context => error_add_context private pure subroutine error_add_context (this, location) Add a call location to the stack trace\nTypically called when propagating errors upward Read more… Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this character(len=*), intent(in) :: location procedure, public :: clear => error_clear private pure subroutine error_clear (this) Clear the error state and stack trace Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this procedure, public :: get_code => error_get_code private pure function error_get_code (this) result(code) Get the error code Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value integer procedure, public :: get_full_trace => error_get_full_trace private  function error_get_full_trace (this) result(trace) Get complete error message with stack trace\nReturns a multi-line string with error and call stack Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable procedure, public :: get_message => error_get_message private pure function error_get_message (this) result(message) Get the error message (without stack trace) Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable procedure, public :: has_error => error_has_error private pure function error_has_error (this) result(has_err) Check if an error is set Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value logical procedure, public :: print_trace => error_print_trace private  subroutine error_print_trace (this, unit) Print error with stack trace to specified unit\nIf unit not specified, prints to stdout (unit 6) Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this integer, intent(in), optional :: unit procedure, public :: set => error_set private pure subroutine error_set (this, code, message) Set an error with code and message\nResets the stack trace Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this integer, intent(in) :: code character(len=*), intent(in) :: message Source Code type :: error_t integer :: code = SUCCESS !! Error code (0 = no error) character ( len = :), allocatable :: message !! Error message !! Stack trace support integer :: stack_depth = 0 !! Current stack depth character ( len = MAX_LOCATION_LEN ) :: call_stack ( MAX_STACK_DEPTH ) !! Call locations contains procedure :: has_error => error_has_error procedure :: set => error_set procedure :: clear => error_clear procedure :: get_code => error_get_code procedure :: get_message => error_get_message procedure :: add_context => error_add_context procedure :: get_full_trace => error_get_full_trace procedure :: print_trace => error_print_trace end type error_t","tags":"","url":"type/error_t.html"},{"title":"xtb_method_t – metalquicha ","text":"type, public, extends( qc_method_t ) :: xtb_method_t Extended Tight-Binding (xTB) method implementation Concrete implementation of the abstract quantum chemistry method\ninterface for GFN1-xTB and GFN2-xTB calculations via tblite. Inherits type~~xtb_method_t~~InheritsGraph type~xtb_method_t xtb_method_t type~qc_method_t qc_method_t type~xtb_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=wp), public :: accuracy = 0.01_wp Numerical accuracy parameter real(kind=wp), public :: kt = 300.0_wp*3.166808578545117e-06_wp Electronic temperature (300 K) character(len=:), public, allocatable :: variant XTB variant: “gfn1” or “gfn2” logical, public :: verbose = .false. Print calculation details Type-Bound Procedures procedure, public :: calc_energy => xtb_calc_energy Energy-only calculation private  subroutine xtb_calc_energy (this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_gradient => xtb_calc_gradient Energy + gradient calculation private  subroutine xtb_calc_gradient (this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_hessian => xtb_calc_hessian Placeholder for Hessian calculation private  subroutine xtb_calc_hessian (this, fragment, result) Calculate Hessian using finite differences of gradients Read more… Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code type , extends ( qc_method_t ) :: xtb_method_t !! Extended Tight-Binding (xTB) method implementation !! !! Concrete implementation of the abstract quantum chemistry method !! interface for GFN1-xTB and GFN2-xTB calculations via tblite. character ( len = :), allocatable :: variant !! XTB variant: \"gfn1\" or \"gfn2\" logical :: verbose = . false . !! Print calculation details real ( wp ) :: accuracy = 0.01_wp !! Numerical accuracy parameter real ( wp ) :: kt = 30 0.0_wp * 3.166808578545117e-06_wp !! Electronic temperature (300 K) contains procedure :: calc_energy => xtb_calc_energy !! Energy-only calculation procedure :: calc_gradient => xtb_calc_gradient !! Energy + gradient calculation procedure :: calc_hessian => xtb_calc_hessian !! Placeholder for Hessian calculation end type xtb_method_t","tags":"","url":"type/xtb_method_t.html"},{"title":"basis_file_t – metalquicha ","text":"type, public :: basis_file_t Container for basis set file contents Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: data_section character(len=:), public, allocatable :: full_content Source Code type :: basis_file_t !! Container for basis set file contents character ( len = :), allocatable :: full_content character ( len = :), allocatable :: data_section end type basis_file_t","tags":"","url":"type/basis_file_t.html"},{"title":"bond_t – metalquicha ","text":"type, public :: bond_t Bond definition with atom indices, order, and broken status Inherited by type~~bond_t~~InheritedByGraph type~bond_t bond_t type~molecule_t molecule_t type~molecule_t->type~bond_t bonds type~mqc_config_t mqc_config_t type~mqc_config_t->type~bond_t bonds type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: atom_i = 0 integer, public :: atom_j = 0 logical, public :: is_broken = .false. integer, public :: order = 1 Source Code type :: bond_t !! Bond definition with atom indices, order, and broken status integer :: atom_i = 0 integer :: atom_j = 0 integer :: order = 1 logical :: is_broken = . false . end type bond_t","tags":"","url":"type/bond_t.html"},{"title":"input_fragment_t – metalquicha ","text":"type, public :: input_fragment_t Input fragment definition with charge, multiplicity, and atom indices\nThis is the parsed representation from the input file, not the computational fragment Inherited by type~~input_fragment_t~~InheritedByGraph type~input_fragment_t input_fragment_t type~molecule_t molecule_t type~molecule_t->type~input_fragment_t fragments type~mqc_config_t mqc_config_t type~mqc_config_t->type~input_fragment_t fragments type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: charge = 0 integer, public, allocatable :: indices (:) Atom indices in this fragment integer, public :: multiplicity = 1 Type-Bound Procedures procedure, public :: destroy => input_fragment_destroy private  subroutine input_fragment_destroy (this) Clean up allocated memory in input_fragment_t Arguments Type Intent Optional Attributes Name class( input_fragment_t ), intent(inout) :: this Source Code type :: input_fragment_t !! Input fragment definition with charge, multiplicity, and atom indices !! This is the parsed representation from the input file, not the computational fragment integer :: charge = 0 integer :: multiplicity = 1 integer , allocatable :: indices (:) !! Atom indices in this fragment contains procedure :: destroy => input_fragment_destroy end type input_fragment_t","tags":"","url":"type/input_fragment_t.html"},{"title":"molecule_t – metalquicha ","text":"type, public :: molecule_t Single molecule definition with structure, geometry, fragments, and connectivity Inherits type~~molecule_t~~InheritsGraph type~molecule_t molecule_t type~bond_t bond_t type~molecule_t->type~bond_t bonds type~geometry_type geometry_type type~molecule_t->type~geometry_type geometry type~input_fragment_t input_fragment_t type~molecule_t->type~input_fragment_t fragments Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~molecule_t~~InheritedByGraph type~molecule_t molecule_t type~mqc_config_t mqc_config_t type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( bond_t ), public, allocatable :: bonds (:) integer, public :: charge = 0 type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry integer, public :: multiplicity = 1 character(len=:), public, allocatable :: name Optional molecule name integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 Type-Bound Procedures procedure, public :: destroy => molecule_destroy private  subroutine molecule_destroy (this) Clean up allocated memory in molecule_t Arguments Type Intent Optional Attributes Name class( molecule_t ), intent(inout) :: this Source Code type :: molecule_t !! Single molecule definition with structure, geometry, fragments, and connectivity character ( len = :), allocatable :: name !! Optional molecule name ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) contains procedure :: destroy => molecule_destroy end type molecule_t","tags":"","url":"type/molecule_t.html"},{"title":"mqc_config_t – metalquicha ","text":"type, public :: mqc_config_t Complete configuration from .mqc file Inherits type~~mqc_config_t~~InheritsGraph type~mqc_config_t mqc_config_t type~bond_t bond_t type~mqc_config_t->type~bond_t bonds type~geometry_type geometry_type type~mqc_config_t->type~geometry_type geometry type~input_fragment_t input_fragment_t type~mqc_config_t->type~input_fragment_t fragments type~molecule_t molecule_t type~mqc_config_t->type~molecule_t molecules type~molecule_t->type~bond_t bonds type~molecule_t->type~geometry_type geometry type~molecule_t->type~input_fragment_t fragments Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: aimd_dt = 1.0_dp Timestep (femtoseconds) real(kind=dp), public :: aimd_initial_temperature = 300.0_dp Initial temperature for velocity init (K) integer, public :: aimd_nsteps = 0 Number of MD steps (0 = no AIMD) integer, public :: aimd_output_frequency = 1 Write output every N steps logical, public :: allow_overlapping_fragments = .false. character(len=:), public, allocatable :: aux_basis character(len=:), public, allocatable :: basis type( bond_t ), public, allocatable :: bonds (:) integer(kind=int32), public :: calc_type = CALC_TYPE_ENERGY integer, public :: charge = 0 character(len=:), public, allocatable :: cutoff_method character(len=:), public, allocatable :: distance_metric character(len=:), public, allocatable :: embedding integer, public :: frag_level = 1 character(len=:), public, allocatable :: frag_method MBE, etc. real(kind=dp), public, allocatable :: fragment_cutoffs (:) Distance cutoffs indexed by n-mer level (2=dimer, 3=trimer, etc.) type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry real(kind=dp), public :: hessian_displacement = 0.001_dp Finite difference displacement (Bohr) integer, public :: index_base = 0 0-based or 1-based indexing character(len=:), public, allocatable :: log_level integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method = METHOD_TYPE_GFN2 type( molecule_t ), public, allocatable :: molecules (:) Array of molecules (if nmol > 0) integer, public :: multiplicity = 1 integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 integer, public :: nmol = 0 Number of molecules (0 = single molecule mode for backward compatibility) integer, public :: scf_maxiter = 300 real(kind=dp), public :: scf_tolerance = 1.0e-6_dp character(len=:), public, allocatable :: schema_name character(len=:), public, allocatable :: schema_version character(len=:), public, allocatable :: units angstrom or bohr Type-Bound Procedures procedure, public :: destroy => config_destroy private  subroutine config_destroy (this) Clean up allocated memory in mqc_config_t Arguments Type Intent Optional Attributes Name class( mqc_config_t ), intent(inout) :: this Source Code type :: mqc_config_t !! Complete configuration from .mqc file ! Schema information character ( len = :), allocatable :: schema_name character ( len = :), allocatable :: schema_version integer :: index_base = 0 !! 0-based or 1-based indexing character ( len = :), allocatable :: units !! angstrom or bohr ! Model information integer ( int32 ) :: method = METHOD_TYPE_GFN2 character ( len = :), allocatable :: basis character ( len = :), allocatable :: aux_basis ! Driver information integer ( int32 ) :: calc_type = CALC_TYPE_ENERGY ! Multiple molecules support integer :: nmol = 0 !! Number of molecules (0 = single molecule mode for backward compatibility) type ( molecule_t ), allocatable :: molecules (:) !! Array of molecules (if nmol > 0) ! Single molecule fields (backward compatibility - used if nmol == 0) ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) ! SCF settings integer :: scf_maxiter = 300 real ( dp ) :: scf_tolerance = 1.0e-6_dp ! Hessian settings real ( dp ) :: hessian_displacement = 0.001_dp !! Finite difference displacement (Bohr) ! AIMD settings real ( dp ) :: aimd_dt = 1.0_dp !! Timestep (femtoseconds) integer :: aimd_nsteps = 0 !! Number of MD steps (0 = no AIMD) real ( dp ) :: aimd_initial_temperature = 30 0.0_dp !! Initial temperature for velocity init (K) integer :: aimd_output_frequency = 1 !! Write output every N steps ! Fragmentation settings character ( len = :), allocatable :: frag_method !! MBE, etc. integer :: frag_level = 1 logical :: allow_overlapping_fragments = . false . integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) character ( len = :), allocatable :: embedding character ( len = :), allocatable :: cutoff_method character ( len = :), allocatable :: distance_metric real ( dp ), allocatable :: fragment_cutoffs (:) !! Distance cutoffs indexed by n-mer level (2=dimer, 3=trimer, etc.) ! Logger settings (kept for compatibility) character ( len = :), allocatable :: log_level contains procedure :: destroy => config_destroy end type mqc_config_t","tags":"","url":"type/mqc_config_t.html"},{"title":"physical_fragment_t – metalquicha ","text":"type, public :: physical_fragment_t Physical molecular fragment with atomic coordinates and properties Represents a molecular fragment containing atomic positions, element types,\nelectronic structure information, and basis set data for quantum calculations. Inherits type~~physical_fragment_t~~InheritsGraph type~physical_fragment_t physical_fragment_t type~molecular_basis_type molecular_basis_type type~physical_fragment_t->type~molecular_basis_type basis type~atomic_basis_type atomic_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~physical_fragment_t~~InheritedByGraph type~physical_fragment_t physical_fragment_t type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( molecular_basis_type ), public, allocatable :: basis Gaussian basis functions integer, public, allocatable :: cap_replaces_atom (:) Original atom index that each cap replaces (size: n_caps) integer, public :: charge = 0 Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) Cartesian coordinates (3, n_atoms) in Bohr real(kind=dp), public :: distance = 0.0_dp Minimal atomic distance between monomers in fragment (Angstrom, 0 for monomers) integer, public, allocatable :: element_numbers (:) Atomic numbers (Z values) integer, public, allocatable :: local_to_global (:) Map fragment atom index to system atom index (size: n_atoms - n_caps) integer, public :: multiplicity = 1 Spin multiplicity (2S+1) integer, public :: n_atoms Number of atoms in this fragment integer, public :: n_caps = 0 Number of hydrogen caps added (always at end of atom list) integer, public :: nelec = 0 Total number of electrons Type-Bound Procedures procedure, public :: compute_nelec => fragment_compute_nelec Calculate electron count private  subroutine fragment_compute_nelec (this) Compute number of electrons from atomic numbers and charge Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this procedure, public :: destroy => fragment_destroy Memory cleanup private  subroutine fragment_destroy (this) Clean up allocated memory in physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this procedure, public :: set_basis => fragment_set_basis Assign basis set private  subroutine fragment_set_basis (this, basis) Set the basis set for this fragment Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis Source Code type :: physical_fragment_t !! Physical molecular fragment with atomic coordinates and properties !! !! Represents a molecular fragment containing atomic positions, element types, !! electronic structure information, and basis set data for quantum calculations. integer :: n_atoms !! Number of atoms in this fragment integer , allocatable :: element_numbers (:) !! Atomic numbers (Z values) real ( dp ), allocatable :: coordinates (:, :) !! Cartesian coordinates (3, n_atoms) in Bohr ! Electronic structure properties integer :: charge = 0 !! Net molecular charge (electrons) integer :: multiplicity = 1 !! Spin multiplicity (2S+1) integer :: nelec = 0 !! Total number of electrons ! Hydrogen capping for broken bonds integer :: n_caps = 0 !! Number of hydrogen caps added (always at end of atom list) integer , allocatable :: cap_replaces_atom (:) !! Original atom index that each cap replaces (size: n_caps) ! Gradient redistribution support integer , allocatable :: local_to_global (:) !! Map fragment atom index to system atom index (size: n_atoms - n_caps) ! Fragment distance (for screening) real ( dp ) :: distance = 0.0_dp !! Minimal atomic distance between monomers in fragment (Angstrom, 0 for monomers) ! Quantum chemistry basis set type ( molecular_basis_type ), allocatable :: basis !! Gaussian basis functions contains procedure :: destroy => fragment_destroy !! Memory cleanup procedure :: compute_nelec => fragment_compute_nelec !! Calculate electron count procedure :: set_basis => fragment_set_basis !! Assign basis set end type physical_fragment_t","tags":"","url":"type/physical_fragment_t.html"},{"title":"system_geometry_t – metalquicha ","text":"type, public :: system_geometry_t Complete molecular system geometry for fragment-based calculations Contains the full atomic structure of a molecular cluster organized\nby monomers for efficient fragment generation and MBE calculations. Components Type Visibility Attributes Name Initial integer, public :: atoms_per_monomer Atoms in each monomer (0 if variable-sized) integer, public :: charge Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) All coordinates (3, total_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers for all atoms integer, public, allocatable :: fragment_atoms (:,:) Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer, public, allocatable :: fragment_charges (:) Charge for each fragment (n_monomers) integer, public, allocatable :: fragment_multiplicities (:) Multiplicity for each fragment (n_monomers) integer, public, allocatable :: fragment_sizes (:) Number of atoms in each fragment (n_monomers) integer, public :: multiplicity Spin multiplicity (2S+1) integer, public :: n_monomers Number of monomer units in system integer, public :: total_atoms Total number of atoms Type-Bound Procedures procedure, public :: destroy => system_destroy Memory cleanup private  subroutine system_destroy (this) Clean up allocated memory in system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this Source Code type :: system_geometry_t !! Complete molecular system geometry for fragment-based calculations !! !! Contains the full atomic structure of a molecular cluster organized !! by monomers for efficient fragment generation and MBE calculations. integer :: n_monomers !! Number of monomer units in system integer :: atoms_per_monomer !! Atoms in each monomer (0 if variable-sized) integer :: total_atoms !! Total number of atoms integer , allocatable :: element_numbers (:) !! Atomic numbers for all atoms real ( dp ), allocatable :: coordinates (:, :) !! All coordinates (3, total_atoms) in Bohr ! Electronic structure properties integer :: charge !! Net molecular charge (electrons) integer :: multiplicity !! Spin multiplicity (2S+1) ! For variable-sized fragments (explicit fragment definitions) integer , allocatable :: fragment_sizes (:) !! Number of atoms in each fragment (n_monomers) integer , allocatable :: fragment_atoms (:, :) !! Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer , allocatable :: fragment_charges (:) !! Charge for each fragment (n_monomers) integer , allocatable :: fragment_multiplicities (:) !! Multiplicity for each fragment (n_monomers) contains procedure :: destroy => system_destroy !! Memory cleanup end type system_geometry_t","tags":"","url":"type/system_geometry_t.html"},{"title":"geometry_type – metalquicha ","text":"type, public :: geometry_type Molecular geometry data structure Inherited by type~~geometry_type~~InheritedByGraph type~geometry_type geometry_type type~molecule_t molecule_t type~molecule_t->type~geometry_type geometry type~mqc_config_t mqc_config_t type~mqc_config_t->type~geometry_type geometry type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: comment real(kind=dp), public, allocatable :: coords (:,:) character(len=:), public, allocatable :: elements (:) integer, public :: natoms Type-Bound Procedures procedure, public :: destroy => geometry_destroy private  subroutine geometry_destroy (this) Clean up allocated memory in geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this Source Code type :: geometry_type !! Molecular geometry data structure integer :: natoms character ( len = :), allocatable :: elements (:) real ( dp ), allocatable :: coords (:, :) ! coords(3, natoms) character ( len = :), allocatable :: comment contains procedure :: destroy => geometry_destroy end type geometry_type","tags":"","url":"type/geometry_type.html"},{"title":"cli_args_type – metalquicha ","text":"type, public :: cli_args_type Container for parsed command line arguments Stores file paths and options extracted from command line,\nwith automatic memory management for string allocations. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: basis_name Basis set name (e.g., “6-31G”) character(len=:), public, allocatable :: xyz_file Input XYZ geometry file path Type-Bound Procedures procedure, public :: destroy => cli_args_destroy Memory cleanup private  subroutine cli_args_destroy (this) Clean up CLI args Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this Source Code type :: cli_args_type !! Container for parsed command line arguments !! !! Stores file paths and options extracted from command line, !! with automatic memory management for string allocations. character ( len = :), allocatable :: xyz_file !! Input XYZ geometry file path character ( len = :), allocatable :: basis_name !! Basis set name (e.g., \"6-31G\") contains procedure :: destroy => cli_args_destroy !! Memory cleanup end type cli_args_type","tags":"","url":"type/cli_args_type.html"},{"title":"fragment_lookup_t – metalquicha ","text":"type, public :: fragment_lookup_t Hash-based lookup table for O(1) fragment index retrieval Inherits type~~fragment_lookup_t~~InheritsGraph type~fragment_lookup_t fragment_lookup_t type~hash_entry_t hash_entry_t type~fragment_lookup_t->type~hash_entry_t table type~hash_entry_t->type~hash_entry_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: initialized = .false. integer(kind=int64), public :: n_entries = 0 type( hash_entry_t ), public, allocatable :: table (:) integer, public :: table_size = 0 Type-Bound Procedures procedure, public :: destroy => fragment_lookup_destroy private pure subroutine fragment_lookup_destroy (this) Clean up hash table and all chains Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this procedure, public :: find => fragment_lookup_find private  function fragment_lookup_find (this, monomers, n) result(idx) Find fragment index for given monomer combination Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) procedure, public :: init => fragment_lookup_init private pure subroutine fragment_lookup_init (this, estimated_entries) Initialize hash table with estimated size Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries procedure, public :: insert => fragment_lookup_insert private  subroutine fragment_lookup_insert (this, monomers, n, fragment_idx) Insert a monomer combination -> fragment index mapping Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx Source Code type :: fragment_lookup_t !! Hash-based lookup table for O(1) fragment index retrieval integer :: table_size = 0 type ( hash_entry_t ), allocatable :: table (:) integer ( int64 ) :: n_entries = 0 logical :: initialized = . false . contains procedure :: init => fragment_lookup_init procedure :: insert => fragment_lookup_insert procedure :: find => fragment_lookup_find procedure :: destroy => fragment_lookup_destroy end type fragment_lookup_t","tags":"","url":"type/fragment_lookup_t.html"},{"title":"hash_entry_t – metalquicha ","text":"type, private :: hash_entry_t Single entry in hash table (private helper type) Inherited by type~~hash_entry_t~~InheritedByGraph type~hash_entry_t hash_entry_t type~hash_entry_t->type~hash_entry_t next type~fragment_lookup_t fragment_lookup_t type~fragment_lookup_t->type~hash_entry_t table Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, allocatable :: key (:) Sorted monomer indices type( hash_entry_t ), public, pointer :: next => null() Chain for collisions integer(kind=int64), public :: value Fragment index Source Code type :: hash_entry_t !! Single entry in hash table (private helper type) integer , allocatable :: key (:) !! Sorted monomer indices integer ( int64 ) :: value !! Fragment index type ( hash_entry_t ), pointer :: next => null () !! Chain for collisions end type hash_entry_t","tags":"","url":"type/hash_entry_t.html"},{"title":"atomic_basis_type – metalquicha ","text":"type, public :: atomic_basis_type Atomic basis set data structure Inherits type~~atomic_basis_type~~InheritsGraph type~atomic_basis_type atomic_basis_type type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~atomic_basis_type~~InheritedByGraph type~atomic_basis_type atomic_basis_type type~molecular_basis_type molecular_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: element element symbol integer, public :: nshells number of shells in type type( cgto_type ), public, allocatable :: shells (:) array of contracted shells Type-Bound Procedures procedure, public :: allocate_shells => allocate_basis_shells private pure subroutine allocate_basis_shells (self, nshells) Allocate array of shells in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells procedure, public :: destroy => atomic_basis_destroy private pure subroutine atomic_basis_destroy (self) Clean up allocated memory in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self procedure, public :: num_basis_functions => atomic_basis_num_basis_functions private pure function atomic_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for an atom Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer Source Code type :: atomic_basis_type !! Atomic basis set data structure character ( len = :), allocatable :: element !! element symbol type ( cgto_type ), allocatable :: shells (:) !! array of contracted shells integer :: nshells !! number of shells in type contains procedure :: allocate_shells => allocate_basis_shells procedure :: destroy => atomic_basis_destroy procedure :: num_basis_functions => atomic_basis_num_basis_functions end type atomic_basis_type","tags":"","url":"type/atomic_basis_type.html"},{"title":"cgto_type – metalquicha ","text":"type, public :: cgto_type Contracted Gaussian type orbital (CGTO) data structure Inherited by type~~cgto_type~~InheritedByGraph type~cgto_type cgto_type type~atomic_basis_type atomic_basis_type type~atomic_basis_type->type~cgto_type shells type~molecular_basis_type molecular_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: ang_mom Angular momentum quantum number (0=s, 1=p, 2=d, etc.) real(kind=dp), public, allocatable :: coefficients (:) Contraction coefficients real(kind=dp), public, allocatable :: exponents (:) Exponents (alpha values) integer, public :: nfunc Number of primitive Gaussians in the contraction Type-Bound Procedures procedure, public :: allocate_arrays => cgto_allocate_arrays private pure subroutine cgto_allocate_arrays (self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc procedure, public :: destroy => cgto_destroy private pure subroutine cgto_destroy (self) Clean up allocated memory in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self procedure, public :: num_basis_functions => cgto_num_basis_functions private pure function cgto_num_basis_functions (self) result(nbf) Get number of basis functions in a shell (Cartesian) Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer Source Code type :: cgto_type !! Contracted Gaussian type orbital (CGTO) data structure integer :: ang_mom !! Angular momentum quantum number (0=s, 1=p, 2=d, etc.) integer :: nfunc !! Number of primitive Gaussians in the contraction real ( dp ), allocatable :: exponents (:) !! Exponents (alpha values) real ( dp ), allocatable :: coefficients (:) !! Contraction coefficients contains procedure :: allocate_arrays => cgto_allocate_arrays procedure :: destroy => cgto_destroy procedure :: num_basis_functions => cgto_num_basis_functions end type cgto_type","tags":"","url":"type/cgto_type.html"},{"title":"molecular_basis_type – metalquicha ","text":"type, public :: molecular_basis_type Molecular basis set data structure (assembled basis) Inherits type~~molecular_basis_type~~InheritsGraph type~molecular_basis_type molecular_basis_type type~atomic_basis_type atomic_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~molecular_basis_type~~InheritedByGraph type~molecular_basis_type molecular_basis_type type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( atomic_basis_type ), public, allocatable :: elements (:) array of atomic basis types integer, public :: nelements total number of atoms/elements in a molecule Type-Bound Procedures procedure, public :: allocate_elements => basis_set_allocate_elements private pure subroutine basis_set_allocate_elements (self, nelements) Allocate array of atomic basis elements in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements procedure, public :: destroy => basis_set_destroy private pure subroutine basis_set_destroy (self) Clean up allocated memory in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self procedure, public :: num_basis_functions => molecular_basis_num_basis_functions private pure function molecular_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for the molecule Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Source Code type :: molecular_basis_type !! Molecular basis set data structure (assembled basis) type ( atomic_basis_type ), allocatable :: elements (:) !! array of atomic basis types integer :: nelements !! total number of atoms/elements in a molecule contains procedure :: allocate_elements => basis_set_allocate_elements procedure :: destroy => basis_set_destroy procedure :: num_basis_functions => molecular_basis_num_basis_functions end type molecular_basis_type","tags":"","url":"type/molecular_basis_type.html"},{"title":"hf_method_t – metalquicha ","text":"type, public, extends( qc_method_t ) :: hf_method_t Hartree-Fock method implementation Inherits type~~hf_method_t~~InheritsGraph type~hf_method_t hf_method_t type~hf_options_t hf_options_t type~hf_method_t->type~hf_options_t options type~qc_method_t qc_method_t type~hf_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( hf_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => hf_calc_energy private  subroutine hf_calc_energy (this, fragment, result) Calculate electronic energy using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_gradient => hf_calc_gradient private  subroutine hf_calc_gradient (this, fragment, result) Calculate energy gradient using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_hessian => null_hessian Placeholder for Hessian calculation private  subroutine null_hessian (this, fragment, result) Placeholder for Hessian calculation Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code type , extends ( qc_method_t ) :: hf_method_t !! Hartree-Fock method implementation type ( hf_options_t ) :: options contains procedure :: calc_energy => hf_calc_energy procedure :: calc_gradient => hf_calc_gradient procedure :: calc_hessian => null_hessian !! Placeholder for Hessian calculation end type hf_method_t","tags":"","url":"type/hf_method_t.html"},{"title":"hf_options_t – metalquicha ","text":"type, public :: hf_options_t Hartree-Fock calculation options Inherited by type~~hf_options_t~~InheritedByGraph type~hf_options_t hf_options_t type~hf_method_t hf_method_t type~hf_method_t->type~hf_options_t options Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: conv_tol = 1.0e-8_dp Energy convergence threshold integer, public :: max_iter = 100 Maximum SCF iterations logical, public :: spherical = .false. Use spherical (true) or Cartesian (false) basis logical, public :: verbose = .true. Print SCF iterations Source Code type :: hf_options_t !! Hartree-Fock calculation options integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: conv_tol = 1.0e-8_dp !! Energy convergence threshold logical :: spherical = . false . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . true . !! Print SCF iterations end type hf_options_t","tags":"","url":"type/hf_options_t.html"},{"title":"qc_method_t – metalquicha ","text":"type, public, abstract :: qc_method_t Abstract base type for all quantum chemistry methods Defines the required interface for energy and gradient calculations\nthat must be implemented by all concrete method types (XTB, HF, etc.). Inherited by type~~qc_method_t~~InheritedByGraph type~qc_method_t qc_method_t type~hf_method_t hf_method_t type~hf_method_t->type~qc_method_t type~xtb_method_t xtb_method_t type~xtb_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( calc_energy_interface ), public, deferred :: calc_energy Energy calculation interface subroutine calc_energy_interface(this, fragment, result) Prototype Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results procedure( calc_gradient_interface ), public, deferred :: calc_gradient Gradient calculation interface subroutine calc_gradient_interface(this, fragment, result) Prototype Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result procedure( calc_hessian_interface ), public, deferred :: calc_hessian Hessian calculation interface subroutine calc_hessian_interface(this, fragment, result) Prototype Interface for energy, gradient, and Hessian calculations Computes electronic energy, nuclear gradients, and Hessian matrix for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Source Code type , abstract :: qc_method_t !! Abstract base type for all quantum chemistry methods !! !! Defines the required interface for energy and gradient calculations !! that must be implemented by all concrete method types (XTB, HF, etc.). contains procedure ( calc_energy_interface ), deferred :: calc_energy !! Energy calculation interface procedure ( calc_gradient_interface ), deferred :: calc_gradient !! Gradient calculation interface procedure ( calc_hessian_interface ), deferred :: calc_hessian !! Hessian calculation interface end type qc_method_t","tags":"","url":"type/qc_method_t.html"},{"title":"calc_energy_interface – metalquicha","text":"interface private  subroutine calc_energy_interface(this, fragment, result) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results Description Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method.","tags":"","url":"interface/calc_energy_interface.html"},{"title":"calc_gradient_interface – metalquicha","text":"interface private  subroutine calc_gradient_interface(this, fragment, result) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Description Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method.","tags":"","url":"interface/calc_gradient_interface.html"},{"title":"calc_hessian_interface – metalquicha","text":"interface private  subroutine calc_hessian_interface(this, fragment, result) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Description Interface for energy, gradient, and Hessian calculations Computes electronic energy, nuclear gradients, and Hessian matrix for a\nmolecular fragment using the specified quantum chemistry method.","tags":"","url":"interface/calc_hessian_interface.html"},{"title":"apply_distance_screening – metalquicha","text":"public  subroutine apply_distance_screening(polymers, total_fragments, sys_geom, driver_config, max_level) Uses mqc_config_adapter mqc_physical_fragment proc~~apply_distance_screening~~UsesGraph proc~apply_distance_screening apply_distance_screening module~mqc_config_adapter mqc_config_adapter proc~apply_distance_screening->module~mqc_config_adapter module~mqc_physical_fragment mqc_physical_fragment proc~apply_distance_screening->module~mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error pic_logger pic_logger module~mqc_config_adapter->pic_logger pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Apply distance-based screening to filter out fragments that exceed cutoff distances\nModifies polymers array in-place and updates total_fragments count Arguments Type Intent Optional Attributes Name integer, intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: total_fragments type( system_geometry_t ), intent(in) :: sys_geom type( driver_config_t ), intent(in) :: driver_config integer, intent(in) :: max_level Calls proc~~apply_distance_screening~~CallsGraph proc~apply_distance_screening apply_distance_screening info info proc~apply_distance_screening->info proc~calculate_monomer_distance calculate_monomer_distance proc~apply_distance_screening->proc~calculate_monomer_distance to_char to_char proc~apply_distance_screening->to_char proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~apply_distance_screening~~CalledByGraph proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~apply_distance_screening proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: cutoff real(kind=dp), private :: fragment_distance integer, private :: fragment_size integer(kind=int64), private :: fragments_kept integer(kind=int64), private :: fragments_screened integer(kind=int64), private :: i integer, private :: nmer_level Source Code subroutine apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) !! Apply distance-based screening to filter out fragments that exceed cutoff distances !! Modifies polymers array in-place and updates total_fragments count use mqc_physical_fragment , only : calculate_monomer_distance use mqc_config_adapter , only : driver_config_t integer , intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: total_fragments type ( system_geometry_t ), intent ( in ) :: sys_geom type ( driver_config_t ), intent ( in ) :: driver_config integer , intent ( in ) :: max_level integer ( int64 ) :: i , fragments_kept integer :: fragment_size real ( dp ) :: fragment_distance , cutoff integer ( int64 ) :: fragments_screened integer :: nmer_level ! Check if we have cutoffs to apply if (. not . allocated ( driver_config % fragment_cutoffs )) then return ! No screening needed end if fragments_kept = 0_int64 fragments_screened = 0_int64 ! Loop through all fragments and filter based on distance do i = 1_int64 , total_fragments fragment_size = count ( polymers ( i , :) > 0 ) ! Monomers are always kept (distance = 0) if ( fragment_size == 1 ) then fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then ! Compact array - move this fragment to the kept position polymers ( fragments_kept , :) = polymers ( i , :) end if cycle end if ! For n-mers (n >= 2), check if we have a cutoff and apply screening nmer_level = fragment_size if ( nmer_level > size ( driver_config % fragment_cutoffs )) then ! No cutoff defined for this level - keep the fragment fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then polymers ( fragments_kept , :) = polymers ( i , :) end if cycle end if cutoff = driver_config % fragment_cutoffs ( nmer_level ) if ( cutoff <= 0.0_dp ) then ! Negative or zero cutoff means no screening for this level fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then polymers ( fragments_kept , :) = polymers ( i , :) end if cycle end if ! Calculate distance for this fragment fragment_distance = calculate_monomer_distance ( sys_geom , polymers ( i , 1 : fragment_size )) ! Apply cutoff filter if ( fragment_distance <= cutoff ) then ! Keep this fragment fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then polymers ( fragments_kept , :) = polymers ( i , :) end if else ! Screen out this fragment fragments_screened = fragments_screened + 1_int64 end if end do ! Update total fragment count if ( fragments_screened > 0 ) then call logger % info ( \"Distance-based screening applied:\" ) call logger % info ( \"  Fragments before screening: \" // to_char ( total_fragments )) call logger % info ( \"  Fragments screened out: \" // to_char ( fragments_screened )) call logger % info ( \"  Fragments kept: \" // to_char ( fragments_kept )) total_fragments = fragments_kept end if end subroutine apply_distance_screening","tags":"","url":"proc/apply_distance_screening.html"},{"title":"sort_fragments_by_size – metalquicha","text":"public  subroutine sort_fragments_by_size(polymers, total_fragments, max_level) Uses pic_sorting proc~~sort_fragments_by_size~~UsesGraph proc~sort_fragments_by_size sort_fragments_by_size pic_sorting pic_sorting proc~sort_fragments_by_size->pic_sorting Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Sort fragments by size (largest first) for better load balancing\nUses in-place sorting to reorder the polymers array\nLarger fragments (e.g., tetramers) are computed before smaller ones (e.g., dimers) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: polymers (:,:) integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: max_level Calls proc~~sort_fragments_by_size~~CallsGraph proc~sort_fragments_by_size sort_fragments_by_size info info proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sort_fragments_by_size~~CalledByGraph proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~sort_fragments_by_size proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: fragment_size integer(kind=int64), private, allocatable :: fragment_sizes (:) integer(kind=int64), private :: i integer(kind=int64), private :: j integer, private, allocatable :: polymers_copy (:,:) integer(kind=int_index), private, allocatable :: sort_indices (:) integer(kind=int64), private :: sorted_idx Source Code subroutine sort_fragments_by_size ( polymers , total_fragments , max_level ) !! Sort fragments by size (largest first) for better load balancing !! Uses in-place sorting to reorder the polymers array !! Larger fragments (e.g., tetramers) are computed before smaller ones (e.g., dimers) use pic_sorting , only : sort_index integer , intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level integer ( int64 ), allocatable :: fragment_sizes (:) integer ( int_index ), allocatable :: sort_indices (:) integer , allocatable :: polymers_copy (:, :) integer ( int64 ) :: i , j , sorted_idx integer :: fragment_size ! Nothing to sort if we have 1 or fewer fragments if ( total_fragments <= 1 ) return ! Allocate arrays for sorting (0-indexed for PIC library) allocate ( fragment_sizes ( 0 : total_fragments - 1 )) allocate ( sort_indices ( 0 : total_fragments - 1 )) ! Calculate fragment sizes do i = 0 , total_fragments - 1 fragment_size = count ( polymers ( i + 1 , :) > 0 ) fragment_sizes ( i ) = int ( fragment_size , int64 ) end do ! Get sort permutation in descending order (largest first) call sort_index ( fragment_sizes , sort_indices , reverse = . true .) ! Reorder polymers array based on sort permutation allocate ( polymers_copy ( size ( polymers , 1 ), size ( polymers , 2 ))) polymers_copy = polymers ! Reorder: new position j gets data from original position sort_indices(j) ! NOTE: sort_indices already contains 1-indexed values, so don't add 1! do j = 0 , total_fragments - 1 sorted_idx = sort_indices ( j ) ! Already 1-indexed! polymers ( j + 1 , :) = polymers_copy ( sorted_idx , :) end do deallocate ( polymers_copy ) deallocate ( fragment_sizes ) deallocate ( sort_indices ) call logger % info ( \"Fragments queue sorted!\" ) end subroutine sort_fragments_by_size","tags":"","url":"proc/sort_fragments_by_size.html"},{"title":"distributed_unfragmented_hessian – metalquicha","text":"interface Calls interface~~distributed_unfragmented_hessian~~CallsGraph interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian barrier barrier proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker cart_disp cart_disp proc~hessian_coordinator->cart_disp configuration configuration proc~hessian_coordinator->configuration fc_mdyne fc_mdyne proc~hessian_coordinator->fc_mdyne force_constants force_constants proc~hessian_coordinator->force_constants get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time info info proc~hessian_coordinator->info iprobe iprobe proc~hessian_coordinator->iprobe irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~compute_vibrational_analysis compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~energy_total energy_t%energy_total proc~hessian_coordinator->proc~energy_total proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_coordinator->proc~fragment_compute_nelec proc~method_type_to_string method_type_to_string proc~hessian_coordinator->proc~method_type_to_string proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator->proc~print_unfragmented_json proc~print_vibrational_analysis print_vibrational_analysis proc~hessian_coordinator->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~hessian_coordinator->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_coordinator->proc~xtb_calc_gradient recv recv proc~hessian_coordinator->recv reduced_masses reduced_masses proc~hessian_coordinator->reduced_masses start start proc~hessian_coordinator->start to_char to_char proc~hessian_coordinator->to_char vib_freqs vib_freqs proc~hessian_coordinator->vib_freqs abort_comm abort_comm proc~hessian_worker->abort_comm error error proc~hessian_worker->error proc~hessian_worker->irecv proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~hessian_worker->proc~fragment_compute_nelec proc~hessian_worker->proc~method_type_to_string proc~hessian_worker->proc~result_destroy proc~hessian_worker->proc~xtb_calc_gradient send send proc~hessian_worker->send proc~hessian_worker->to_char proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~print_unfragmented_json->error proc~print_unfragmented_json->info proc~print_unfragmented_json->proc~energy_total proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~xtb_calc_gradient->proc~energy_total new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~distributed_unfragmented_hessian~~CalledByGraph interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine distributed_unfragmented_hessian(world_comm, sys_geom, method, driver_config) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method type( driver_config_t ), intent(in), optional :: driver_config Driver configuration","tags":"","url":"interface/distributed_unfragmented_hessian.html"},{"title":"do_fragment_work – metalquicha","text":"interface Calls interface~~do_fragment_work~~CallsGraph interface~do_fragment_work do_fragment_work proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work configuration configuration proc~do_fragment_work->configuration error error proc~do_fragment_work->error proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset info info proc~print_fragment_xyz->info proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom to_char to_char proc~print_fragment_xyz->to_char new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_energy->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~xtb_calc_hessian->info proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~xtb_calc_hessian->to_char proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~result_reset->proc~energy_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~do_fragment_work~~CalledByGraph interface~do_fragment_work do_fragment_work proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine do_fragment_work(fragment_idx, result, method, phys_frag, calc_type) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx type( calculation_result_t ), intent(out) :: result integer(kind=int32), intent(in) :: method type( physical_fragment_t ), intent(in), optional :: phys_frag integer(kind=int32), intent(in) :: calc_type","tags":"","url":"interface/do_fragment_work.html"},{"title":"global_coordinator – metalquicha","text":"interface Calls interface~~global_coordinator~~CallsGraph interface~global_coordinator global_coordinator proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator debug debug proc~global_coordinator->debug error error proc~global_coordinator->error get_elapsed_time get_elapsed_time proc~global_coordinator->get_elapsed_time info info proc~global_coordinator->info iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~result_irecv result_irecv proc~global_coordinator->proc~result_irecv proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker start start proc~global_coordinator->start to_char to_char proc~global_coordinator->to_char verbose verbose proc~global_coordinator->verbose proc~compute_mbe->error proc~compute_mbe->info proc~compute_mbe->to_char cart_disp cart_disp proc~compute_mbe->cart_disp configuration configuration proc~compute_mbe->configuration fc_mdyne fc_mdyne proc~compute_mbe->fc_mdyne force_constants force_constants proc~compute_mbe->force_constants frequencies frequencies proc~compute_mbe->frequencies proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_mbe->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~compute_mbe->proc~energy_total proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe->proc~print_detailed_breakdown_json proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis reduced_masses reduced_masses proc~compute_mbe->reduced_masses proc~result_irecv->irecv recv recv proc~result_irecv->recv proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~build_mbe_lookup_table->debug proc~build_mbe_lookup_table->get_elapsed_time proc~build_mbe_lookup_table->start proc~build_mbe_lookup_table->to_char proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~compute_mbe_delta->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~map_fragment_to_system_gradient->debug proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->configuration proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~map_fragment_to_system_gradient->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->verbose header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->info proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->warning proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal proc~fragment_lookup_insert->fnv_1a_hash proc~fragment_lookup_insert->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~global_coordinator~~CalledByGraph interface~global_coordinator global_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine global_coordinator(world_comm, node_comm, total_fragments, polymers, max_level, node_leader_ranks, num_nodes, sys_geom, calc_type, bonds) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:)","tags":"","url":"interface/global_coordinator.html"},{"title":"node_coordinator – metalquicha","text":"interface Calls interface~~node_coordinator~~CallsGraph interface~node_coordinator node_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator error error proc~node_coordinator->error iprobe iprobe proc~node_coordinator->iprobe irecv irecv proc~node_coordinator->irecv isend isend proc~node_coordinator->isend proc~result_irecv result_irecv proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv to_char to_char proc~node_coordinator->to_char proc~result_irecv->irecv proc~result_irecv->recv proc~result_isend->isend send send proc~result_isend->send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~node_coordinator~~CalledByGraph interface~node_coordinator node_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine node_coordinator(world_comm, node_comm, calc_type) Implementation → Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm integer(kind=int32), intent(in) :: calc_type","tags":"","url":"interface/node_coordinator.html"},{"title":"node_worker – metalquicha","text":"interface Calls interface~~node_worker~~CallsGraph interface~node_worker node_worker proc~node_worker node_worker interface~node_worker->proc~node_worker error error proc~node_worker->error interface~do_fragment_work do_fragment_work proc~node_worker->interface~do_fragment_work irecv irecv proc~node_worker->irecv isend isend proc~node_worker->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_atom_list proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~node_worker->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~node_worker->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~node_worker->proc~fragment_destroy proc~result_isend result_isend proc~node_worker->proc~result_isend recv recv proc~node_worker->recv to_char to_char proc~node_worker->to_char proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~build_fragment_from_indices->proc~error_has_error proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~error_add_context proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~result_isend->isend send send proc~result_isend->send proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~do_fragment_work->error configuration configuration proc~do_fragment_work->configuration proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_fragment_xyz->proc~to_angstrom info info proc~print_fragment_xyz->info new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_energy->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~xtb_calc_hessian->info proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~node_worker~~CalledByGraph interface~node_worker node_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine node_worker(world_comm, node_comm, sys_geom, method, calc_type, bonds) Implementation → Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:)","tags":"","url":"interface/node_worker.html"},{"title":"serial_fragment_processor – metalquicha","text":"interface Calls interface~~serial_fragment_processor~~CallsGraph interface~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor configuration configuration proc~serial_fragment_processor->configuration error error proc~serial_fragment_processor->error get_elapsed_time get_elapsed_time proc~serial_fragment_processor->get_elapsed_time info info proc~serial_fragment_processor->info interface~do_fragment_work do_fragment_work proc~serial_fragment_processor->interface~do_fragment_work omp_get_max_threads omp_get_max_threads proc~serial_fragment_processor->omp_get_max_threads omp_set_num_threads omp_set_num_threads proc~serial_fragment_processor->omp_set_num_threads proc~build_fragment_from_indices build_fragment_from_indices proc~serial_fragment_processor->proc~build_fragment_from_indices proc~calc_type_to_string calc_type_to_string proc~serial_fragment_processor->proc~calc_type_to_string proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~energy_total energy_t%energy_total proc~serial_fragment_processor->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~serial_fragment_processor->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~serial_fragment_processor->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~serial_fragment_processor->proc~fragment_destroy start start proc~serial_fragment_processor->start to_char to_char proc~serial_fragment_processor->to_char verbose verbose proc~serial_fragment_processor->verbose proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~compute_mbe->configuration proc~compute_mbe->error proc~compute_mbe->info proc~compute_mbe->proc~energy_total proc~compute_mbe->to_char cart_disp cart_disp proc~compute_mbe->cart_disp fc_mdyne fc_mdyne proc~compute_mbe->fc_mdyne force_constants force_constants proc~compute_mbe->force_constants frequencies frequencies proc~compute_mbe->frequencies proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_mbe->proc~compute_vibrational_analysis proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe->proc~print_detailed_breakdown_json proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis reduced_masses reduced_masses proc~compute_mbe->reduced_masses proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_mbe_lookup_table->get_elapsed_time proc~build_mbe_lookup_table->start proc~build_mbe_lookup_table->to_char debug debug proc~build_mbe_lookup_table->debug proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~compute_mbe_delta->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~do_fragment_work->configuration proc~do_fragment_work->error proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_has_error proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_gradient->debug proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->verbose header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->info proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->warning proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal proc~fragment_lookup_insert->fnv_1a_hash proc~fragment_lookup_insert->sort proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_fragment_xyz->proc~to_angstrom proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->info proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~serial_fragment_processor~~CalledByGraph interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine serial_fragment_processor(total_fragments, polymers, max_level, sys_geom, method, calc_type, bonds) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:)","tags":"","url":"interface/serial_fragment_processor.html"},{"title":"unfragmented_calculation – metalquicha","text":"interface Calls interface~~unfragmented_calculation~~CallsGraph interface~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation cart_disp cart_disp proc~unfragmented_calculation->cart_disp configuration configuration proc~unfragmented_calculation->configuration eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues error error proc~unfragmented_calculation->error fc_mdyne fc_mdyne proc~unfragmented_calculation->fc_mdyne force_constants force_constants proc~unfragmented_calculation->force_constants frequencies frequencies proc~unfragmented_calculation->frequencies info info proc~unfragmented_calculation->info interface~do_fragment_work do_fragment_work proc~unfragmented_calculation->interface~do_fragment_work proc~check_duplicate_atoms check_duplicate_atoms proc~unfragmented_calculation->proc~check_duplicate_atoms proc~compute_vibrational_analysis compute_vibrational_analysis proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~energy_total energy_t%energy_total proc~unfragmented_calculation->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~unfragmented_calculation->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~unfragmented_calculation->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json proc~print_vibrational_analysis print_vibrational_analysis proc~unfragmented_calculation->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian reduced_masses reduced_masses proc~unfragmented_calculation->reduced_masses to_char to_char proc~unfragmented_calculation->to_char proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~print_unfragmented_json->error proc~print_unfragmented_json->info proc~print_unfragmented_json->proc~energy_total proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~do_fragment_work->configuration proc~do_fragment_work->error proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mass_weight_hessian->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->info proc~xtb_calc_hessian->proc~result_destroy proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~unfragmented_calculation~~CalledByGraph interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine unfragmented_calculation(sys_geom, method, calc_type, bonds, result_out) Implementation → Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( calculation_result_t ), intent(out), optional :: result_out","tags":"","url":"interface/unfragmented_calculation.html"},{"title":"hessian_coordinator – metalquicha","text":"interface Calls interface~~hessian_coordinator~~CallsGraph interface~hessian_coordinator hessian_coordinator proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator cart_disp cart_disp proc~hessian_coordinator->cart_disp configuration configuration proc~hessian_coordinator->configuration fc_mdyne fc_mdyne proc~hessian_coordinator->fc_mdyne force_constants force_constants proc~hessian_coordinator->force_constants get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time info info proc~hessian_coordinator->info iprobe iprobe proc~hessian_coordinator->iprobe irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~compute_vibrational_analysis compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~energy_total energy_t%energy_total proc~hessian_coordinator->proc~energy_total proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_coordinator->proc~fragment_compute_nelec proc~method_type_to_string method_type_to_string proc~hessian_coordinator->proc~method_type_to_string proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator->proc~print_unfragmented_json proc~print_vibrational_analysis print_vibrational_analysis proc~hessian_coordinator->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~hessian_coordinator->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_coordinator->proc~xtb_calc_gradient recv recv proc~hessian_coordinator->recv reduced_masses reduced_masses proc~hessian_coordinator->reduced_masses start start proc~hessian_coordinator->start to_char to_char proc~hessian_coordinator->to_char vib_freqs vib_freqs proc~hessian_coordinator->vib_freqs proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses error error proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~print_unfragmented_json->info proc~print_unfragmented_json->proc~energy_total proc~print_unfragmented_json->error proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~xtb_calc_gradient->proc~energy_total new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~mass_weight_hessian->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~hessian_coordinator~~CalledByGraph interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module subroutine hessian_coordinator(world_comm, sys_geom, method, displacement) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr)","tags":"","url":"interface/hessian_coordinator.html"},{"title":"hessian_worker – metalquicha","text":"interface Calls interface~~hessian_worker~~CallsGraph interface~hessian_worker hessian_worker proc~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker abort_comm abort_comm proc~hessian_worker->abort_comm error error proc~hessian_worker->error irecv irecv proc~hessian_worker->irecv isend isend proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_worker->proc~fragment_compute_nelec proc~method_type_to_string method_type_to_string proc~hessian_worker->proc~method_type_to_string proc~result_destroy calculation_result_t%result_destroy proc~hessian_worker->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_worker->proc~xtb_calc_gradient send send proc~hessian_worker->send to_char to_char proc~hessian_worker->to_char proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_gradient->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~hessian_worker~~CalledByGraph interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_worker interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module subroutine hessian_worker(world_comm, sys_geom, method, displacement) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr)","tags":"","url":"interface/hessian_worker.html"},{"title":"method_type_from_string – metalquicha","text":"public pure function method_type_from_string(method_str) result(method_type) Convert method type string to integer constant Performs case-insensitive comparison and returns appropriate constant.\nReturns METHOD_TYPE_UNKNOWN for unrecognized strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Input string (e.g., “gfn1”, “gfn2”, “hf”) Return Value integer(kind=int32) Output integer constant Called by proc~~method_type_from_string~~CalledByGraph proc~method_type_from_string method_type_from_string proc~parse_method_string parse_method_string proc~parse_method_string->proc~method_type_from_string proc~parse_model_section parse_model_section proc~parse_model_section->proc~parse_method_string proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_model_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=len_trim), private :: lower_str Source Code pure function method_type_from_string ( method_str ) result ( method_type ) !! Convert method type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns METHOD_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: method_str !! Input string (e.g., \"gfn1\", \"gfn2\", \"hf\") integer ( int32 ) :: method_type !! Output integer constant character ( len = len_trim ( method_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) case ( 'gfn1' ) method_type = METHOD_TYPE_GFN1 case ( 'gfn2' ) method_type = METHOD_TYPE_GFN2 case ( 'hf' ) method_type = METHOD_TYPE_HF case default method_type = METHOD_TYPE_UNKNOWN end select end function method_type_from_string","tags":"","url":"proc/method_type_from_string.html"},{"title":"method_type_to_string – metalquicha","text":"public pure function method_type_to_string(method_type) result(method_str) Convert method type integer constant to string Provides human-readable string representation of method type. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: method_type Input integer constant Return Value character(len=:), allocatable Output string representation Called by proc~~method_type_to_string~~CalledByGraph proc~method_type_to_string method_type_to_string proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~method_type_to_string proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~method_type_to_string proc~hessian_worker hessian_worker proc~hessian_worker->proc~method_type_to_string interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function method_type_to_string ( method_type ) result ( method_str ) !! Convert method type integer constant to string !! !! Provides human-readable string representation of method type. integer ( int32 ), intent ( in ) :: method_type !! Input integer constant character ( len = :), allocatable :: method_str !! Output string representation select case ( method_type ) case ( METHOD_TYPE_GFN1 ) method_str = \"gfn1\" case ( METHOD_TYPE_GFN2 ) method_str = \"gfn2\" case ( METHOD_TYPE_HF ) method_str = \"hf\" case default method_str = \"unknown\" end select end function method_type_to_string","tags":"","url":"proc/method_type_to_string.html"},{"title":"copy_and_displace_geometry – metalquicha","text":"public  subroutine copy_and_displace_geometry(reference_geom, atom_idx, coord_idx, displacement, displaced_geom) Create a copy of reference geometry with one coordinate displaced Args:\n  reference_geom: Original geometry to copy\n  atom_idx: Atom to displace (1-based)\n  coord_idx: Coordinate to displace (1=x, 2=y, 3=z)\n  displacement: Amount to displace in Bohr (positive or negative)\n  displaced_geom: Output displaced geometry Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom integer, intent(in) :: atom_idx integer, intent(in) :: coord_idx real(kind=dp), intent(in) :: displacement type( physical_fragment_t ), intent(out) :: displaced_geom Called by proc~~copy_and_displace_geometry~~CalledByGraph proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries generate_perturbed_geometries proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~hessian_worker hessian_worker proc~hessian_worker->proc~copy_and_displace_geometry interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_worker proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_hessian interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine copy_and_displace_geometry ( reference_geom , atom_idx , coord_idx , displacement , displaced_geom ) !! Create a copy of reference geometry with one coordinate displaced !! !! Args: !!   reference_geom: Original geometry to copy !!   atom_idx: Atom to displace (1-based) !!   coord_idx: Coordinate to displace (1=x, 2=y, 3=z) !!   displacement: Amount to displace in Bohr (positive or negative) !!   displaced_geom: Output displaced geometry type ( physical_fragment_t ), intent ( in ) :: reference_geom integer , intent ( in ) :: atom_idx , coord_idx real ( dp ), intent ( in ) :: displacement type ( physical_fragment_t ), intent ( out ) :: displaced_geom ! Copy basic properties displaced_geom % n_atoms = reference_geom % n_atoms displaced_geom % charge = reference_geom % charge displaced_geom % multiplicity = reference_geom % multiplicity displaced_geom % nelec = reference_geom % nelec displaced_geom % n_caps = reference_geom % n_caps ! Allocate and copy arrays allocate ( displaced_geom % element_numbers ( displaced_geom % n_atoms )) allocate ( displaced_geom % coordinates ( 3 , displaced_geom % n_atoms )) displaced_geom % element_numbers = reference_geom % element_numbers displaced_geom % coordinates = reference_geom % coordinates ! Copy hydrogen cap information if present if ( reference_geom % n_caps > 0 ) then allocate ( displaced_geom % cap_replaces_atom ( displaced_geom % n_caps )) displaced_geom % cap_replaces_atom = reference_geom % cap_replaces_atom end if ! Copy gradient redistribution mapping if present if ( allocated ( reference_geom % local_to_global )) then allocate ( displaced_geom % local_to_global ( size ( reference_geom % local_to_global ))) displaced_geom % local_to_global = reference_geom % local_to_global end if ! Apply displacement to specified coordinate displaced_geom % coordinates ( coord_idx , atom_idx ) = & displaced_geom % coordinates ( coord_idx , atom_idx ) + displacement ! Copy basis set if present (same basis, just different geometry) if ( allocated ( reference_geom % basis )) then ! Note: Basis set will need to be rebuilt with new coordinates ! For now, we don't copy it - it should be set up during calculation end if end subroutine copy_and_displace_geometry","tags":"","url":"proc/copy_and_displace_geometry.html"},{"title":"finite_diff_hessian_from_gradients – metalquicha","text":"public  subroutine finite_diff_hessian_from_gradients(reference_geom, forward_gradients, backward_gradients, displacement, hessian) Compute Hessian matrix from finite differences of gradients Uses central finite differences: H_ij = (grad_i(+h) - grad_i(-h)) / (2h) Args:\n  reference_geom: Reference geometry (for dimensioning)\n  forward_gradients: Gradients at forward-displaced geometries (3 n_atoms, 3, n_atoms)\n  backward_gradients: Gradients at backward-displaced geometries (3 n_atoms, 3, n_atoms)\n  displacement: Step size used in Bohr\n  hessian: Output Hessian matrix (3 n_atoms, 3 n_atoms) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: forward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: backward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: displacement real(kind=dp), intent(out), allocatable :: hessian (:,:) (3 n_atoms, 3 n_atoms) Called by proc~~finite_diff_hessian_from_gradients~~CalledByGraph proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_hessian interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: disp_idx integer, private :: i_global integer, private :: iatom integer, private :: icoord integer, private :: j_global integer, private :: jatom integer, private :: jcoord integer, private :: n_atoms integer, private :: n_coords Source Code subroutine finite_diff_hessian_from_gradients ( reference_geom , forward_gradients , backward_gradients , & displacement , hessian ) !! Compute Hessian matrix from finite differences of gradients !! !! Uses central finite differences: H_ij = (grad_i(+h) - grad_i(-h)) / (2h) !! !! Args: !!   reference_geom: Reference geometry (for dimensioning) !!   forward_gradients: Gradients at forward-displaced geometries (3*n_atoms, 3, n_atoms) !!   backward_gradients: Gradients at backward-displaced geometries (3*n_atoms, 3, n_atoms) !!   displacement: Step size used in Bohr !!   hessian: Output Hessian matrix (3*n_atoms, 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: forward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: backward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: displacement real ( dp ), intent ( out ), allocatable :: hessian (:, :) !! (3*n_atoms, 3*n_atoms) integer :: n_atoms , n_coords integer :: iatom , jatom , icoord , jcoord integer :: i_global , j_global integer :: disp_idx n_atoms = reference_geom % n_atoms n_coords = 3 * n_atoms allocate ( hessian ( n_coords , n_coords )) hessian = 0.0_dp ! Build Hessian using central differences ! H[i,j] = d²E/(dx_i dx_j) = (dE/dx_j at x_i+h - dE/dx_j at x_i-h) / (2h) disp_idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 disp_idx = disp_idx + 1 i_global = 3 * ( iatom - 1 ) + icoord ! For each displacement, compute derivatives of all gradient components do jatom = 1 , n_atoms do jcoord = 1 , 3 j_global = 3 * ( jatom - 1 ) + jcoord ! Central difference: (grad_j(+h) - grad_j(-h)) / (2h) hessian ( i_global , j_global ) = & ( forward_gradients ( disp_idx , jcoord , jatom ) - & backward_gradients ( disp_idx , jcoord , jatom )) / ( 2.0_dp * displacement ) end do end do end do end do ! Symmetrize the Hessian: H = (H + H&#94;T) / 2 ! This reduces numerical noise from finite differences do i_global = 1 , n_coords do j_global = i_global + 1 , n_coords hessian ( i_global , j_global ) = 0.5_dp * ( hessian ( i_global , j_global ) + hessian ( j_global , i_global )) hessian ( j_global , i_global ) = hessian ( i_global , j_global ) end do end do end subroutine finite_diff_hessian_from_gradients","tags":"","url":"proc/finite_diff_hessian_from_gradients.html"},{"title":"generate_perturbed_geometries – metalquicha","text":"public  subroutine generate_perturbed_geometries(reference_geom, displacement, forward_geoms, backward_geoms) Generate all forward and backward displaced geometries for finite difference calculations For a system with N atoms, this generates:\n  - 3N forward-displaced geometries (+x, +y, +z for each atom)\n  - 3N backward-displaced geometries (-x, -y, -z for each atom) These can be used to compute:\n  - Gradient: from energies at ±displacement\n  - Hessian: from gradients at ±displacement Args:\n  reference_geom: The reference geometry to perturb\n  displacement: Step size in Bohr (typical: 0.001 Bohr)\n  forward_geoms: Output array of forward-displaced geometries (size: 3 n_atoms)\n  backward_geoms: Output array of backward-displaced geometries (size: 3 n_atoms) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: displacement type( displaced_geometry_t ), intent(out), allocatable :: forward_geoms (:) type( displaced_geometry_t ), intent(out), allocatable :: backward_geoms (:) Calls proc~~generate_perturbed_geometries~~CallsGraph proc~generate_perturbed_geometries generate_perturbed_geometries proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_perturbed_geometries~~CalledByGraph proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_hessian interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: iatom integer, private :: icoord integer, private :: idx integer, private :: n_atoms integer, private :: n_displacements Source Code subroutine generate_perturbed_geometries ( reference_geom , displacement , forward_geoms , backward_geoms ) !! Generate all forward and backward displaced geometries for finite difference calculations !! !! For a system with N atoms, this generates: !!   - 3N forward-displaced geometries (+x, +y, +z for each atom) !!   - 3N backward-displaced geometries (-x, -y, -z for each atom) !! !! These can be used to compute: !!   - Gradient: from energies at ±displacement !!   - Hessian: from gradients at ±displacement !! !! Args: !!   reference_geom: The reference geometry to perturb !!   displacement: Step size in Bohr (typical: 0.001 Bohr) !!   forward_geoms: Output array of forward-displaced geometries (size: 3*n_atoms) !!   backward_geoms: Output array of backward-displaced geometries (size: 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: displacement type ( displaced_geometry_t ), intent ( out ), allocatable :: forward_geoms (:) type ( displaced_geometry_t ), intent ( out ), allocatable :: backward_geoms (:) integer :: n_atoms , n_displacements integer :: iatom , icoord , idx integer :: i n_atoms = reference_geom % n_atoms n_displacements = 3 * n_atoms ! x, y, z for each atom allocate ( forward_geoms ( n_displacements )) allocate ( backward_geoms ( n_displacements )) ! Generate all displaced geometries idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 ! x, y, z idx = idx + 1 ! Forward displacement (+h) forward_geoms ( idx )% atom_index = iatom forward_geoms ( idx )% coordinate = icoord forward_geoms ( idx )% direction = + 1 forward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , + displacement , & forward_geoms ( idx )% geometry ) ! Backward displacement (-h) backward_geoms ( idx )% atom_index = iatom backward_geoms ( idx )% coordinate = icoord backward_geoms ( idx )% direction = - 1 backward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , - displacement , & backward_geoms ( idx )% geometry ) end do end do end subroutine generate_perturbed_geometries","tags":"","url":"proc/generate_perturbed_geometries.html"},{"title":"displaced_geometry_destroy – metalquicha","text":"private  subroutine displaced_geometry_destroy(this) Clean up memory for displaced geometry Type Bound displaced_geometry_t Arguments Type Intent Optional Attributes Name class( displaced_geometry_t ), intent(inout) :: this Calls proc~~displaced_geometry_destroy~~CallsGraph proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine displaced_geometry_destroy ( this ) !! Clean up memory for displaced geometry class ( displaced_geometry_t ), intent ( inout ) :: this call this % geometry % destroy () end subroutine displaced_geometry_destroy","tags":"","url":"proc/displaced_geometry_destroy.html"},{"title":"cc_total – metalquicha","text":"private pure function cc_total(this) result(total) Compute total CC correlation energy Type Bound cc_energy_t Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code pure function cc_total ( this ) result ( total ) !! Compute total CC correlation energy class ( cc_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % singles + this % doubles + this % triples end function cc_total","tags":"","url":"proc/cc_total.html"},{"title":"energy_total – metalquicha","text":"private pure function energy_total(this) result(total) Compute total energy from all components Type Bound energy_t Arguments Type Intent Optional Attributes Name class( energy_t ), intent(in) :: this Return Value real(kind=dp) Calls proc~~energy_total~~CallsGraph proc~energy_total energy_t%energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~energy_total~~CalledByGraph proc~energy_total energy_t%energy_total proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~energy_total proc~run_calculation run_calculation proc~compute_energy_and_forces->proc~run_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~energy_total proc~print_gmbe_intersection_debug print_gmbe_intersection_debug proc~compute_gmbe->proc~print_gmbe_intersection_debug proc~compute_mbe compute_mbe proc~compute_mbe->proc~energy_total proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~energy_total proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~energy_total proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator->proc~print_unfragmented_json proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_coordinator->proc~xtb_calc_gradient proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_energy->proc~energy_total proc~print_gmbe_intersection_debug->proc~energy_total proc~print_gmbe_json print_gmbe_json proc~print_gmbe_json->proc~energy_total proc~print_unfragmented_json->proc~energy_total proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~compute_mbe interface~do_fragment_work do_fragment_work proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~print_unfragmented_json proc~unfragmented_calculation->interface~do_fragment_work proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~xtb_calc_energy->proc~energy_total proc~xtb_calc_gradient->proc~energy_total interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~hessian_worker hessian_worker proc~hessian_worker->proc~xtb_calc_gradient proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_gradient->proc~hf_calc_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~serial_fragment_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator proc~xtb_calc_hessian->proc~xtb_calc_gradient interface~do_fragment_work->proc~do_fragment_work interface~global_coordinator->proc~global_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations interface~node_worker node_worker interface~node_worker->proc~node_worker Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function energy_total ( this ) result ( total ) !! Compute total energy from all components class ( energy_t ), intent ( in ) :: this real ( dp ) :: total ! this line needs to me modified if more components are added total = this % scf + this % mp2 % total () + this % cc % total () end function energy_total","tags":"","url":"proc/energy_total.html"},{"title":"mp2_scs – metalquicha","text":"private pure function mp2_scs(this) result(scs_energy) Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy\nSCS-MP2 uses: E_SCS = (1/3) E_SS + 1.2 E_OS Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code pure function mp2_scs ( this ) result ( scs_energy ) !! Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy !! SCS-MP2 uses: E_SCS = (1/3)*E_SS + 1.2*E_OS class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: scs_energy scs_energy = SCS_SS_SCALE * this % ss + SCS_OS_SCALE * this % os end function mp2_scs","tags":"","url":"proc/mp2_scs.html"},{"title":"mp2_total – metalquicha","text":"private pure function mp2_total(this) result(total) Compute total MP2 correlation energy Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Called by proc~~mp2_total~~CalledByGraph proc~mp2_total mp2_energy_t%mp2_total proc~energy_total energy_t%energy_total proc~energy_total->proc~mp2_total proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~energy_total proc~run_calculation run_calculation proc~compute_energy_and_forces->proc~run_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~energy_total proc~print_gmbe_intersection_debug print_gmbe_intersection_debug proc~compute_gmbe->proc~print_gmbe_intersection_debug proc~compute_mbe compute_mbe proc~compute_mbe->proc~energy_total proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~energy_total proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~energy_total proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator->proc~print_unfragmented_json proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_coordinator->proc~xtb_calc_gradient proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_energy->proc~energy_total proc~print_gmbe_intersection_debug->proc~energy_total proc~print_gmbe_json print_gmbe_json proc~print_gmbe_json->proc~energy_total proc~print_unfragmented_json->proc~energy_total proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~compute_mbe interface~do_fragment_work do_fragment_work proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~print_unfragmented_json proc~unfragmented_calculation->interface~do_fragment_work proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~xtb_calc_energy->proc~energy_total proc~xtb_calc_gradient->proc~energy_total interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~hessian_worker hessian_worker proc~hessian_worker->proc~xtb_calc_gradient proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_gradient->proc~hf_calc_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~serial_fragment_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator proc~xtb_calc_hessian->proc~xtb_calc_gradient interface~do_fragment_work->proc~do_fragment_work interface~global_coordinator->proc~global_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function mp2_total ( this ) result ( total ) !! Compute total MP2 correlation energy class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % ss + this % os end function mp2_total","tags":"","url":"proc/mp2_total.html"},{"title":"result_irecv – metalquicha","text":"public  subroutine result_irecv(result, comm, source, tag, req) Receive calculation result over MPI (non-blocking)\nReceives SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(request_t), intent(out) :: req Calls proc~~result_irecv~~CallsGraph proc~result_irecv result_irecv irecv irecv proc~result_irecv->irecv recv recv proc~result_irecv->recv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_irecv~~CalledByGraph proc~result_irecv result_irecv proc~global_coordinator global_coordinator proc~global_coordinator->proc~result_irecv proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~result_irecv proc~node_coordinator node_coordinator proc~node_coordinator->proc~result_irecv interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~node_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(MPI_Status), private :: status Source Code subroutine result_irecv ( result , comm , source , tag , req ) !! Receive calculation result over MPI (non-blocking) !! Receives SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( request_t ), intent ( out ) :: req type ( MPI_Status ) :: status ! Receive SCF energy (non-blocking) call irecv ( comm , result % energy % scf , source , tag , req ) ! Receive other energy components (blocking to avoid needing multiple request handles) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive fragment metadata call recv ( comm , result % distance , source , tag , status ) ! Receive gradient flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if end subroutine result_irecv","tags":"","url":"proc/result_irecv.html"},{"title":"result_isend – metalquicha","text":"public  subroutine result_isend(result, comm, dest, tag, req) Send calculation result over MPI (non-blocking)\nSends SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag type(request_t), intent(out) :: req Calls proc~~result_isend~~CallsGraph proc~result_isend result_isend isend isend proc~result_isend->isend send send proc~result_isend->send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_isend~~CalledByGraph proc~result_isend result_isend proc~node_coordinator node_coordinator proc~node_coordinator->proc~result_isend proc~node_worker node_worker proc~node_worker->proc~result_isend interface~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator interface~node_worker node_worker interface~node_worker->proc~node_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_coordinator proc~run_fragmented_calculation->interface~node_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_isend ( result , comm , dest , tag , req ) !! Send calculation result over MPI (non-blocking) !! Sends SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag type ( request_t ), intent ( out ) :: req ! Send SCF energy (non-blocking) call isend ( comm , result % energy % scf , dest , tag , req ) ! Send other energy components (blocking to avoid needing multiple request handles) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send fragment metadata call send ( comm , result % distance , dest , tag ) ! Send gradient flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if ! Send Hessian flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_hessian , dest , tag ) if ( result % has_hessian ) then call send ( comm , result % hessian , dest , tag ) end if end subroutine result_isend","tags":"","url":"proc/result_isend.html"},{"title":"result_recv – metalquicha","text":"public  subroutine result_recv(result, comm, source, tag, status) Receive calculation result over MPI (blocking)\nReceives energy components and conditionally receives gradient based on flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(MPI_Status), intent(out) :: status Calls proc~~result_recv~~CallsGraph proc~result_recv result_recv recv recv proc~result_recv->recv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_recv ( result , comm , source , tag , status ) !! Receive calculation result over MPI (blocking) !! Receives energy components and conditionally receives gradient based on flag type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( MPI_Status ), intent ( out ) :: status ! Receive energy components call recv ( comm , result % energy % scf , source , tag , status ) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive fragment metadata call recv ( comm , result % distance , source , tag , status ) ! Receive gradient flag and data if present call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data if present call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if end subroutine result_recv","tags":"","url":"proc/result_recv.html"},{"title":"result_send – metalquicha","text":"public  subroutine result_send(result, comm, dest, tag) Send calculation result over MPI (blocking)\nSends energy components and conditionally sends gradient based on has_gradient flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag Calls proc~~result_send~~CallsGraph proc~result_send result_send send send proc~result_send->send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_send ( result , comm , dest , tag ) !! Send calculation result over MPI (blocking) !! Sends energy components and conditionally sends gradient based on has_gradient flag type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag ! Send energy components call send ( comm , result % energy % scf , dest , tag ) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send fragment metadata call send ( comm , result % distance , dest , tag ) ! Send gradient flag and data if present call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if end subroutine result_send","tags":"","url":"proc/result_send.html"},{"title":"cc_check_stability – metalquicha","text":"private  subroutine cc_check_stability(this) Uses pic_logger proc~~cc_check_stability~~UsesGraph proc~cc_check_stability cc_energy_t%cc_check_stability pic_logger pic_logger proc~cc_check_stability->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Check for positive CC correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Type Bound cc_energy_t Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Calls proc~~cc_check_stability~~CallsGraph proc~cc_check_stability cc_energy_t%cc_check_stability warning warning proc~cc_check_stability->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine cc_check_stability ( this ) !! Check for positive CC correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( cc_energy_t ), intent ( in ) :: this if ( this % singles > 0.0_dp ) then call logger % warning ( \"CC singles correlation energy is positive - possible instability!\" ) end if if ( this % doubles > 0.0_dp ) then call logger % warning ( \"CC doubles correlation energy is positive - possible instability!\" ) end if if ( this % triples > 0.0_dp ) then call logger % warning ( \"CC triples correlation energy is positive - possible instability!\" ) end if end subroutine cc_check_stability","tags":"","url":"proc/cc_check_stability.html"},{"title":"cc_reset – metalquicha","text":"private  subroutine cc_reset(this) Reset all CC components to zero Type Bound cc_energy_t Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(inout) :: this Source Code subroutine cc_reset ( this ) !! Reset all CC components to zero class ( cc_energy_t ), intent ( inout ) :: this this % singles = 0.0_dp this % doubles = 0.0_dp this % triples = 0.0_dp end subroutine cc_reset","tags":"","url":"proc/cc_reset.html"},{"title":"energy_reset – metalquicha","text":"private  subroutine energy_reset(this) Reset all energy components to zero Type Bound energy_t Arguments Type Intent Optional Attributes Name class( energy_t ), intent(inout) :: this Calls proc~~energy_reset~~CallsGraph proc~energy_reset energy_t%energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~energy_reset~~CalledByGraph proc~energy_reset energy_t%energy_reset proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~energy_reset proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~result_reset calculation_result_t%result_reset proc~result_reset->proc~energy_reset interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~result_destroy calculation_result_t%result_destroy proc~result_destroy->proc~result_reset proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~result_destroy proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~result_destroy proc~xtb_calc_hessian->proc~result_destroy interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine energy_reset ( this ) !! Reset all energy components to zero class ( energy_t ), intent ( inout ) :: this this % scf = 0.0_dp call this % mp2 % reset () call this % cc % reset () end subroutine energy_reset","tags":"","url":"proc/energy_reset.html"},{"title":"mp2_check_stability – metalquicha","text":"private  subroutine mp2_check_stability(this) Uses pic_logger proc~~mp2_check_stability~~UsesGraph proc~mp2_check_stability mp2_energy_t%mp2_check_stability pic_logger pic_logger proc~mp2_check_stability->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Check for positive MP2 correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Calls proc~~mp2_check_stability~~CallsGraph proc~mp2_check_stability mp2_energy_t%mp2_check_stability warning warning proc~mp2_check_stability->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mp2_check_stability ( this ) !! Check for positive MP2 correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( mp2_energy_t ), intent ( in ) :: this if ( this % ss > 0.0_dp ) then call logger % warning ( \"MP2 same-spin correlation energy is positive - possible instability!\" ) end if if ( this % os > 0.0_dp ) then call logger % warning ( \"MP2 opposite-spin correlation energy is positive - possible instability!\" ) end if end subroutine mp2_check_stability","tags":"","url":"proc/mp2_check_stability.html"},{"title":"mp2_reset – metalquicha","text":"private  subroutine mp2_reset(this) Reset both MP2 components to zero Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(inout) :: this Called by proc~~mp2_reset~~CalledByGraph proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset energy_t%energy_reset proc~energy_reset->proc~mp2_reset proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~energy_reset proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~result_reset calculation_result_t%result_reset proc~result_reset->proc~energy_reset interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~result_destroy calculation_result_t%result_destroy proc~result_destroy->proc~result_reset proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~result_destroy proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~result_destroy proc~xtb_calc_hessian->proc~result_destroy interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mp2_reset ( this ) !! Reset both MP2 components to zero class ( mp2_energy_t ), intent ( inout ) :: this this % ss = 0.0_dp this % os = 0.0_dp end subroutine mp2_reset","tags":"","url":"proc/mp2_reset.html"},{"title":"result_destroy – metalquicha","text":"private  subroutine result_destroy(this) Clean up allocated memory in calculation_result_t Type Bound calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Calls proc~~result_destroy~~CallsGraph proc~result_destroy calculation_result_t%result_destroy proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_destroy~~CalledByGraph proc~result_destroy calculation_result_t%result_destroy proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~result_destroy proc~run_calculation run_calculation proc~compute_energy_and_forces->proc~run_calculation proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~result_destroy interface~do_fragment_work do_fragment_work proc~unfragmented_calculation->interface~do_fragment_work proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~result_destroy interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_hessian interface~do_fragment_work->proc~do_fragment_work proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~run_calculation->proc~run_unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_destroy ( this ) !! Clean up allocated memory in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % sigma )) deallocate ( this % sigma ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) call this % reset () end subroutine result_destroy","tags":"","url":"proc/result_destroy.html"},{"title":"result_reset – metalquicha","text":"private  subroutine result_reset(this) Reset all values and flags in calculation_result_t Type Bound calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Calls proc~~result_reset~~CallsGraph proc~result_reset calculation_result_t%result_reset proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_reset~~CalledByGraph proc~result_reset calculation_result_t%result_reset proc~result_destroy calculation_result_t%result_destroy proc~result_destroy->proc~result_reset proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~result_destroy proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~result_destroy interface~do_fragment_work do_fragment_work proc~unfragmented_calculation->interface~do_fragment_work proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~result_destroy interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_hessian interface~do_fragment_work->proc~do_fragment_work proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_reset ( this ) !! Reset all values and flags in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this call this % energy % reset () this % has_energy = . false . this % has_gradient = . false . this % has_sigma = . false . this % has_hessian = . false . this % has_dipole = . false . end subroutine result_reset","tags":"","url":"proc/result_reset.html"},{"title":"get_logger_level – metalquicha","text":"public  function get_logger_level(level_string) result(level_int) Uses pic_logger proc~~get_logger_level~~UsesGraph proc~get_logger_level get_logger_level pic_logger pic_logger proc~get_logger_level->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Convert string log level to integer value\nThis function uses the pic_logger constants Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: level_string Return Value integer Calls proc~~get_logger_level~~CallsGraph proc~get_logger_level get_logger_level warning warning proc~get_logger_level->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_logger_level~~CalledByGraph proc~get_logger_level get_logger_level program~main main program~main->proc~get_logger_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_logger_level ( level_string ) result ( level_int ) !! Convert string log level to integer value !! This function uses the pic_logger constants use pic_logger , only : debug_level , verbose_level , info_level , performance_level , & warning_level , error_level , knowledge_level character ( len =* ), intent ( in ) :: level_string integer :: level_int select case ( trim ( adjustl ( level_string ))) case ( 'debug' , 'Debug' , 'DEBUG' ) level_int = debug_level case ( 'verbose' , 'Verbose' , 'VERBOSE' ) level_int = verbose_level case ( 'info' , 'Info' , 'INFO' ) level_int = info_level case ( 'performance' , 'Performance' , 'PERFORMANCE' ) level_int = performance_level case ( 'warning' , 'Warning' , 'WARNING' ) level_int = warning_level case ( 'error' , 'Error' , 'ERROR' ) level_int = error_level case ( 'knowledge' , 'Knowledge' , 'KNOWLEDGE' ) level_int = knowledge_level case default ! Default to info level if unknown call logger % warning ( \"Unknown log level string: \" // level_string // \". Defaulting to INFO level.\" ) level_int = info_level end select end function get_logger_level","tags":"","url":"proc/get_logger_level.html"},{"title":"check_fragment_overlap – metalquicha","text":"public  subroutine check_fragment_overlap(fragments, nfrag, error) Uses pic_io mqc_config_parser proc~~check_fragment_overlap~~UsesGraph proc~check_fragment_overlap check_fragment_overlap module~mqc_config_parser mqc_config_parser proc~check_fragment_overlap->module~mqc_config_parser pic_io pic_io proc~check_fragment_overlap->pic_io module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Check if any atoms appear in multiple fragments\nThis is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes Arguments Type Intent Optional Attributes Name type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: nfrag type( error_t ), intent(out) :: error Calls proc~~check_fragment_overlap~~CallsGraph proc~check_fragment_overlap check_fragment_overlap proc~error_set error_t%error_set proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_fragment_overlap~~CalledByGraph proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~check_fragment_overlap proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_i integer, private :: atom_j integer, private :: i integer, private :: j integer, private :: k integer, private :: l Source Code subroutine check_fragment_overlap ( fragments , nfrag , error ) !! Check if any atoms appear in multiple fragments !! This is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes use mqc_config_parser , only : input_fragment_t use pic_io , only : to_char type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: nfrag type ( error_t ), intent ( out ) :: error integer :: i , j , k , l integer :: atom_i , atom_j ! Compare each pair of fragments do i = 1 , nfrag - 1 do j = i + 1 , nfrag ! Compare atoms in fragment i with atoms in fragment j do k = 1 , size ( fragments ( i )% indices ) atom_i = fragments ( i )% indices ( k ) do l = 1 , size ( fragments ( j )% indices ) atom_j = fragments ( j )% indices ( l ) if ( atom_i == atom_j ) then ! Found overlapping atom call error % set ( ERROR_VALIDATION , \"Overlapping fragments detected: fragments \" // to_char ( i ) // \" and \" // & to_char ( j ) // \" both contain atom \" // to_char ( atom_i ) // & \". Set allow_overlapping_fragments = true to allow this.\" ) return end if end do end do end do end do end subroutine check_fragment_overlap","tags":"","url":"proc/check_fragment_overlap.html"},{"title":"config_to_driver – metalquicha","text":"public  subroutine config_to_driver(mqc_config, driver_config, molecule_index) Convert mqc_config_t to minimal driver_config_t\nExtracts only the fields needed by the driver\nIf molecule_index is provided, uses that molecule’s fragment count Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( driver_config_t ), intent(out) :: driver_config integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) Called by proc~~config_to_driver~~CalledByGraph proc~config_to_driver config_to_driver proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_driver program~main main program~main->proc~config_to_driver program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: nfrag_to_use Source Code subroutine config_to_driver ( mqc_config , driver_config , molecule_index ) !! Convert mqc_config_t to minimal driver_config_t !! Extracts only the fields needed by the driver !! If molecule_index is provided, uses that molecule's fragment count type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ), intent ( out ) :: driver_config integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: nfrag_to_use ! Copy method and calc_type (already integers) driver_config % method = mqc_config % method driver_config % calc_type = mqc_config % calc_type ! Determine fragment count if ( present ( molecule_index )) then ! Multi-molecule mode: use specific molecule's fragment count if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then nfrag_to_use = 0 else nfrag_to_use = mqc_config % molecules ( molecule_index )% nfrag end if else ! Single molecule mode (backward compatible) nfrag_to_use = mqc_config % nfrag end if ! Set fragmentation level ! For unfragmented calculations (nfrag=0), nlevel must be 0 if ( nfrag_to_use == 0 ) then driver_config % nlevel = 0 else driver_config % nlevel = mqc_config % frag_level end if ! Set GMBE overlapping fragments flag driver_config % allow_overlapping_fragments = mqc_config % allow_overlapping_fragments ! Set GMBE maximum intersection level driver_config % max_intersection_level = mqc_config % max_intersection_level ! Copy fragment distance cutoffs if present if ( allocated ( mqc_config % fragment_cutoffs )) then allocate ( driver_config % fragment_cutoffs ( size ( mqc_config % fragment_cutoffs ))) driver_config % fragment_cutoffs = mqc_config % fragment_cutoffs end if ! Set calculation-specific keywords driver_config % hessian % displacement = mqc_config % hessian_displacement driver_config % aimd % dt = mqc_config % aimd_dt driver_config % aimd % nsteps = mqc_config % aimd_nsteps driver_config % aimd % initial_temperature = mqc_config % aimd_initial_temperature driver_config % aimd % output_frequency = mqc_config % aimd_output_frequency driver_config % scf % max_iterations = mqc_config % scf_maxiter driver_config % scf % convergence_threshold = mqc_config % scf_tolerance end subroutine config_to_driver","tags":"","url":"proc/config_to_driver.html"},{"title":"config_to_system_geometry – metalquicha","text":"public  subroutine config_to_system_geometry(mqc_config, sys_geom, error, molecule_index) Convert mqc_config_t geometry to system_geometry_t\nFor unfragmented calculations (nfrag=0), treats entire system as single unit\nFor fragmented calculations, currently assumes monomer-based fragmentation\nIf molecule_index is provided, uses that specific molecule from multi-molecule mode Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) Calls proc~~config_to_system_geometry~~CallsGraph proc~config_to_system_geometry config_to_system_geometry proc~error_add_context error_t%error_add_context proc~config_to_system_geometry->proc~error_add_context proc~error_has_error error_t%error_has_error proc~config_to_system_geometry->proc~error_has_error proc~error_set error_t%error_set proc~config_to_system_geometry->proc~error_set proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~molecule_to_system_geometry->proc~error_set proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~initialize_fragmented_system->proc~error_add_context proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~config_to_system_geometry~~CalledByGraph proc~config_to_system_geometry config_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i logical, private :: use_angstrom Source Code subroutine config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index ) !! Convert mqc_config_t geometry to system_geometry_t !! For unfragmented calculations (nfrag=0), treats entire system as single unit !! For fragmented calculations, currently assumes monomer-based fragmentation !! If molecule_index is provided, uses that specific molecule from multi-molecule mode type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: i logical :: use_angstrom ! Determine units use_angstrom = . true . if ( allocated ( mqc_config % units )) then if ( trim ( mqc_config % units ) == 'bohr' ) then use_angstrom = . false . end if end if ! Handle multi-molecule vs single molecule mode if ( present ( molecule_index )) then ! Multi-molecule mode: extract specific molecule if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then call error % set ( ERROR_VALIDATION , \"Invalid molecule_index in multi-molecule mode\" ) return end if call molecule_to_system_geometry ( mqc_config % molecules ( molecule_index ), & sys_geom , use_angstrom , mqc_config % allow_overlapping_fragments , error ) else ! Single molecule mode (backward compatible) ! Check if geometry is loaded if ( mqc_config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in mqc_config\" ) return end if if ( mqc_config % nfrag == 0 ) then ! Unfragmented calculation: entire system is one \"monomer\" call geometry_to_system_unfragmented ( mqc_config % geometry , sys_geom , use_angstrom ) sys_geom % charge = mqc_config % charge sys_geom % multiplicity = mqc_config % multiplicity else ! Fragmented calculation with explicit fragments call geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_adapter:config_to_system_geometry\" ) return end if end if end if end subroutine config_to_system_geometry","tags":"","url":"proc/config_to_system_geometry.html"},{"title":"geometry_to_system_fragmented – metalquicha","text":"private  subroutine geometry_to_system_fragmented(mqc_config, sys_geom, use_angstrom, error) Convert geometry to system_geometry_t for fragmented calculation\nSupports both identical and variable-sized fragments Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom type( error_t ), intent(out) :: error Calls proc~~geometry_to_system_fragmented~~CallsGraph proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~element_symbol_to_number element_symbol_to_number proc~initialize_fragmented_system->proc~element_symbol_to_number proc~error_add_context error_t%error_add_context proc~initialize_fragmented_system->proc~error_add_context proc~error_has_error error_t%error_has_error proc~initialize_fragmented_system->proc~error_has_error proc~to_bohr to_bohr proc~initialize_fragmented_system->proc~to_bohr proc~error_set error_t%error_set proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~geometry_to_system_fragmented~~CalledByGraph proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) !! Convert geometry to system_geometry_t for fragmented calculation !! Supports both identical and variable-sized fragments type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error call initialize_fragmented_system ( mqc_config % nfrag , mqc_config % geometry , mqc_config % fragments , & mqc_config % charge , mqc_config % multiplicity , & mqc_config % allow_overlapping_fragments , use_angstrom , & sys_geom , error ) end subroutine geometry_to_system_fragmented","tags":"","url":"proc/geometry_to_system_fragmented.html"},{"title":"geometry_to_system_unfragmented – metalquicha","text":"private  subroutine geometry_to_system_unfragmented(geom, sys_geom, use_angstrom) Uses mqc_geometry proc~~geometry_to_system_unfragmented~~UsesGraph proc~geometry_to_system_unfragmented geometry_to_system_unfragmented module~mqc_geometry mqc_geometry proc~geometry_to_system_unfragmented->module~mqc_geometry pic_types pic_types module~mqc_geometry->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Convert geometry to system_geometry_t for unfragmented calculation\nTreats entire system as a single monomer Arguments Type Intent Optional Attributes Name type( geometry_type ), intent(in) :: geom type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom Calls proc~~geometry_to_system_unfragmented~~CallsGraph proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~geometry_to_system_unfragmented~~CalledByGraph proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine geometry_to_system_unfragmented ( geom , sys_geom , use_angstrom ) !! Convert geometry to system_geometry_t for unfragmented calculation !! Treats entire system as a single monomer use mqc_geometry , only : geometry_type type ( geometry_type ), intent ( in ) :: geom type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom integer :: i ! For unfragmented: n_monomers=1, atoms_per_monomer=natoms sys_geom % n_monomers = 1 sys_geom % atoms_per_monomer = geom % natoms sys_geom % total_atoms = geom % natoms allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine geometry_to_system_unfragmented","tags":"","url":"proc/geometry_to_system_unfragmented.html"},{"title":"initialize_fragmented_system – metalquicha","text":"private  subroutine initialize_fragmented_system(nfrag, geom, fragments, charge, multiplicity, allow_overlapping, use_angstrom, sys_geom, error) Uses mqc_geometry mqc_config_parser proc~~initialize_fragmented_system~~UsesGraph proc~initialize_fragmented_system initialize_fragmented_system module~mqc_config_parser mqc_config_parser proc~initialize_fragmented_system->module~mqc_config_parser module~mqc_geometry mqc_geometry proc~initialize_fragmented_system->module~mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_geometry->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Shared helper to initialize system_geometry_t for fragmented calculations\nHandles fragment allocation, size checking, and overlap validation Arguments Type Intent Optional Attributes Name integer, intent(in) :: nfrag type( geometry_type ), intent(in) :: geom type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: charge integer, intent(in) :: multiplicity logical, intent(in) :: allow_overlapping logical, intent(in) :: use_angstrom type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error Calls proc~~initialize_fragmented_system~~CallsGraph proc~initialize_fragmented_system initialize_fragmented_system proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~element_symbol_to_number element_symbol_to_number proc~initialize_fragmented_system->proc~element_symbol_to_number proc~error_add_context error_t%error_add_context proc~initialize_fragmented_system->proc~error_add_context proc~error_has_error error_t%error_has_error proc~initialize_fragmented_system->proc~error_has_error proc~to_bohr to_bohr proc~initialize_fragmented_system->proc~to_bohr proc~error_set error_t%error_set proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initialize_fragmented_system~~CalledByGraph proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: all_same_size integer, private :: atoms_in_first_frag integer, private :: i integer, private :: j integer, private :: max_frag_size Source Code subroutine initialize_fragmented_system ( nfrag , geom , fragments , charge , multiplicity , & allow_overlapping , use_angstrom , sys_geom , error ) !! Shared helper to initialize system_geometry_t for fragmented calculations !! Handles fragment allocation, size checking, and overlap validation use mqc_geometry , only : geometry_type use mqc_config_parser , only : input_fragment_t integer , intent ( in ) :: nfrag type ( geometry_type ), intent ( in ) :: geom type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: charge , multiplicity logical , intent ( in ) :: allow_overlapping logical , intent ( in ) :: use_angstrom type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer :: i , j , atoms_in_first_frag , max_frag_size logical :: all_same_size ! Set up basic system geometry sys_geom % n_monomers = nfrag sys_geom % total_atoms = geom % natoms sys_geom % charge = charge sys_geom % multiplicity = multiplicity ! Allocate fragment info arrays allocate ( sys_geom % fragment_sizes ( nfrag )) allocate ( sys_geom % fragment_charges ( nfrag )) allocate ( sys_geom % fragment_multiplicities ( nfrag )) ! Get fragment sizes max_frag_size = 0 atoms_in_first_frag = size ( fragments ( 1 )% indices ) all_same_size = . true . do i = 1 , nfrag sys_geom % fragment_sizes ( i ) = size ( fragments ( i )% indices ) sys_geom % fragment_charges ( i ) = fragments ( i )% charge sys_geom % fragment_multiplicities ( i ) = fragments ( i )% multiplicity max_frag_size = max ( max_frag_size , sys_geom % fragment_sizes ( i )) if ( sys_geom % fragment_sizes ( i ) /= atoms_in_first_frag ) then all_same_size = . false . end if end do ! Allocate fragment_atoms array allocate ( sys_geom % fragment_atoms ( max_frag_size , nfrag )) sys_geom % fragment_atoms = - 1 ! Initialize with invalid index ! Store fragment atom indices (0-indexed from input file) do i = 1 , nfrag do j = 1 , sys_geom % fragment_sizes ( i ) sys_geom % fragment_atoms ( j , i ) = fragments ( i )% indices ( j ) end do end do ! Check for overlapping fragments if not allowed if (. not . allow_overlapping ) then call check_fragment_overlap ( fragments , nfrag , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_adapter:geometry_to_system_fragmented\" ) return end if end if ! Set atoms_per_monomer: use common size if identical, else 0 if ( all_same_size ) then sys_geom % atoms_per_monomer = atoms_in_first_frag else sys_geom % atoms_per_monomer = 0 ! Signal variable-sized fragments end if allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine initialize_fragmented_system","tags":"","url":"proc/initialize_fragmented_system.html"},{"title":"molecule_to_system_geometry – metalquicha","text":"private  subroutine molecule_to_system_geometry(mol, sys_geom, use_angstrom, allow_overlapping, error) Uses mqc_config_parser proc~~molecule_to_system_geometry~~UsesGraph proc~molecule_to_system_geometry molecule_to_system_geometry module~mqc_config_parser mqc_config_parser proc~molecule_to_system_geometry->module~mqc_config_parser module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Convert a molecule_t to system_geometry_t\nHandles both unfragmented (nfrag=0) and fragmented molecules Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: mol type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom logical, intent(in) :: allow_overlapping type( error_t ), intent(out) :: error Calls proc~~molecule_to_system_geometry~~CallsGraph proc~molecule_to_system_geometry molecule_to_system_geometry proc~error_set error_t%error_set proc~molecule_to_system_geometry->proc~error_set proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~initialize_fragmented_system initialize_fragmented_system proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~initialize_fragmented_system->proc~element_symbol_to_number proc~error_add_context error_t%error_add_context proc~initialize_fragmented_system->proc~error_add_context proc~error_has_error error_t%error_has_error proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~molecule_to_system_geometry~~CalledByGraph proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine molecule_to_system_geometry ( mol , sys_geom , use_angstrom , allow_overlapping , error ) !! Convert a molecule_t to system_geometry_t !! Handles both unfragmented (nfrag=0) and fragmented molecules use mqc_config_parser , only : molecule_t type ( molecule_t ), intent ( in ) :: mol type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error logical , intent ( in ) :: allow_overlapping ! Check if geometry is loaded if ( mol % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in molecule\" ) return end if if ( mol % nfrag == 0 ) then ! Unfragmented molecule call geometry_to_system_unfragmented ( mol % geometry , sys_geom , use_angstrom ) sys_geom % charge = mol % charge sys_geom % multiplicity = mol % multiplicity else ! Fragmented molecule call initialize_fragmented_system ( mol % nfrag , mol % geometry , mol % fragments , & mol % charge , mol % multiplicity , & allow_overlapping , use_angstrom , & sys_geom , error ) end if end subroutine molecule_to_system_geometry","tags":"","url":"proc/molecule_to_system_geometry.html"},{"title":"error_get_code – metalquicha","text":"private pure function error_get_code(this) result(code) Get the error code Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value integer Source Code pure function error_get_code ( this ) result ( code ) !! Get the error code class ( error_t ), intent ( in ) :: this integer :: code code = this % code end function error_get_code","tags":"","url":"proc/error_get_code.html"},{"title":"error_get_full_trace – metalquicha","text":"private  function error_get_full_trace(this) result(trace) Get complete error message with stack trace\nReturns a multi-line string with error and call stack Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable Calls proc~~error_get_full_trace~~CallsGraph proc~error_get_full_trace error_t%error_get_full_trace proc~error_has_error error_t%error_has_error proc~error_get_full_trace->proc~error_has_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~error_get_full_trace~~CalledByGraph proc~error_get_full_trace error_t%error_get_full_trace proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~error_get_full_trace proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~node_worker node_worker proc~node_worker->proc~error_get_full_trace proc~process_intersection_derivatives->proc~error_get_full_trace proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~error_get_full_trace proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~error_get_full_trace proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~error_get_full_trace interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator program~main main program~main->proc~run_multi_molecule_calculations program~main->proc~run_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=2048), private :: buffer integer, private :: i integer, private :: pos Source Code function error_get_full_trace ( this ) result ( trace ) !! Get complete error message with stack trace !! Returns a multi-line string with error and call stack class ( error_t ), intent ( in ) :: this character ( len = :), allocatable :: trace character ( len = 2048 ) :: buffer integer :: i , pos if (. not . this % has_error ()) then trace = \"\" return end if ! Build error message write ( buffer , '(A,I0,A)' ) \"Error \" , this % code , \": \" pos = len_trim ( buffer ) + 1 if ( allocated ( this % message )) then buffer ( pos :) = this % message pos = len_trim ( buffer ) + 1 end if ! Add stack trace if available if ( this % stack_depth > 0 ) then buffer ( pos :) = new_line ( 'a' ) // \"Call stack (most recent first):\" pos = len_trim ( buffer ) + 1 do i = this % stack_depth , 1 , - 1 write ( buffer ( pos :), '(A,I0,A)' ) new_line ( 'a' ) // \"  [\" , i , \"] \" pos = len_trim ( buffer ) + 1 buffer ( pos :) = trim ( this % call_stack ( i )) pos = len_trim ( buffer ) + 1 end do end if trace = trim ( buffer ) end function error_get_full_trace","tags":"","url":"proc/error_get_full_trace.html"},{"title":"error_get_message – metalquicha","text":"private pure function error_get_message(this) result(message) Get the error message (without stack trace) Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable Called by proc~~error_get_message~~CalledByGraph proc~error_get_message error_t%error_get_message proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~error_get_message program~main main program~main->proc~error_get_message Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function error_get_message ( this ) result ( message ) !! Get the error message (without stack trace) class ( error_t ), intent ( in ) :: this character ( len = :), allocatable :: message if ( allocated ( this % message )) then message = this % message else message = \"\" end if end function error_get_message","tags":"","url":"proc/error_get_message.html"},{"title":"error_has_error – metalquicha","text":"private pure function error_has_error(this) result(has_err) Check if an error is set Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value logical Called by proc~~error_has_error~~CalledByGraph proc~error_has_error error_t%error_has_error proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~error_has_error proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~error_has_error proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~error_has_error proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~error_has_error proc~compute_gmbe->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~compute_gmbe->proc~error_get_full_trace proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~error_has_error proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~error_get_full_trace->proc~error_has_error proc~error_print_trace error_t%error_print_trace proc~error_print_trace->proc~error_has_error proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~error_has_error proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~error_has_error proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~error_has_error proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~node_worker node_worker proc~node_worker->proc~error_has_error proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~error_get_full_trace proc~parse_element_basis->proc~error_has_error proc~parse_fragment parse_fragment proc~parse_fragment->proc~error_has_error proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~error_has_error proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~parse_fragment proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~error_has_error proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_single_molecule->proc~error_has_error proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~process_intersection_derivatives->proc~error_has_error proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~process_intersection_derivatives->proc~error_get_full_trace proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~error_has_error proc~read_mqc_file->proc~parse_fragmentation_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~read_xyz_file->proc~error_has_error proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~error_has_error proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~run_multi_molecule_calculations->proc~error_get_full_trace proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~error_get_full_trace proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~error_has_error proc~unfragmented_calculation->proc~error_get_full_trace program~main main program~main->proc~error_has_error program~main->proc~config_to_system_geometry program~main->proc~read_mqc_file program~main->proc~run_multi_molecule_calculations program~main->proc~run_calculation interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_fragmented_calculation->proc~gmbe_pie_coordinator interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function error_has_error ( this ) result ( has_err ) !! Check if an error is set class ( error_t ), intent ( in ) :: this logical :: has_err has_err = ( this % code /= SUCCESS ) end function error_has_error","tags":"","url":"proc/error_has_error.html"},{"title":"error_add_context – metalquicha","text":"private pure subroutine error_add_context(this, location) Add a call location to the stack trace\nTypically called when propagating errors upward Example:\n  call some_routine(…, error)\n  if (error%has_error()) then\n     call error%add_context(“mqc_mbe:compute_energy”)\n     return\n  end if Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this character(len=*), intent(in) :: location Called by proc~~error_add_context~~CalledByGraph proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~error_add_context proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~error_add_context proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~error_add_context proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~error_add_context proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~error_add_context proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~error_add_context proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~parse_element_basis->proc~error_add_context proc~parse_fragment parse_fragment proc~parse_fragment->proc~error_add_context proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~error_add_context proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~error_add_context proc~parse_fragments_generic->proc~parse_fragment proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~error_add_context proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_single_molecule->proc~error_add_context proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~error_add_context proc~read_mqc_file->proc~parse_fragmentation_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~read_xyz_file->proc~error_add_context proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~error_add_context proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list program~main main program~main->proc~config_to_system_geometry program~main->proc~read_mqc_file program~main->proc~run_multi_molecule_calculations program~main->proc~run_calculation interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation->proc~run_fragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine error_add_context ( this , location ) !! Add a call location to the stack trace !! Typically called when propagating errors upward !! !! Example: !!   call some_routine(..., error) !!   if (error%has_error()) then !!      call error%add_context(\"mqc_mbe:compute_energy\") !!      return !!   end if class ( error_t ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: location if ( this % stack_depth < MAX_STACK_DEPTH ) then this % stack_depth = this % stack_depth + 1 this % call_stack ( this % stack_depth ) = location end if ! If stack is full, silently ignore (could print warning in non-pure version) end subroutine error_add_context","tags":"","url":"proc/error_add_context.html"},{"title":"error_clear – metalquicha","text":"private pure subroutine error_clear(this) Clear the error state and stack trace Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this Source Code pure subroutine error_clear ( this ) !! Clear the error state and stack trace class ( error_t ), intent ( inout ) :: this this % code = SUCCESS this % stack_depth = 0 if ( allocated ( this % message )) deallocate ( this % message ) end subroutine error_clear","tags":"","url":"proc/error_clear.html"},{"title":"error_print_trace – metalquicha","text":"private  subroutine error_print_trace(this, unit) Print error with stack trace to specified unit\nIf unit not specified, prints to stdout (unit 6) Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this integer, intent(in), optional :: unit Calls proc~~error_print_trace~~CallsGraph proc~error_print_trace error_t%error_print_trace proc~error_has_error error_t%error_has_error proc~error_print_trace->proc~error_has_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: out_unit Source Code subroutine error_print_trace ( this , unit ) !! Print error with stack trace to specified unit !! If unit not specified, prints to stdout (unit 6) class ( error_t ), intent ( in ) :: this integer , intent ( in ), optional :: unit integer :: out_unit , i out_unit = 6 ! stdout if ( present ( unit )) out_unit = unit if (. not . this % has_error ()) return ! Print error message write ( out_unit , '(A,I0,A)' , advance = 'no' ) \"Error \" , this % code , \": \" if ( allocated ( this % message )) then write ( out_unit , '(A)' ) trim ( this % message ) else write ( out_unit , '(A)' ) \"(no message)\" end if ! Print stack trace if available if ( this % stack_depth > 0 ) then write ( out_unit , '(A)' ) \"Call stack (most recent first):\" do i = this % stack_depth , 1 , - 1 write ( out_unit , '(A,I0,A)' , advance = 'no' ) \"  [\" , i , \"] \" write ( out_unit , '(A)' ) trim ( this % call_stack ( i )) end do end if end subroutine error_print_trace","tags":"","url":"proc/error_print_trace.html"},{"title":"error_set – metalquicha","text":"private pure subroutine error_set(this, code, message) Set an error with code and message\nResets the stack trace Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this integer, intent(in) :: code character(len=*), intent(in) :: message Called by proc~~error_set~~CalledByGraph proc~error_set error_t%error_set proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~error_set proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~check_duplicate_atoms check_duplicate_atoms proc~check_duplicate_atoms->proc~error_set proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->proc~error_set proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~error_set proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~error_set proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~error_set proc~find_basis_file find_basis_file proc~find_basis_file->proc~error_set proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~error_set proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~molecule_to_system_geometry->proc~error_set proc~initialize_fragmented_system initialize_fragmented_system proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~parse_aimd_section parse_aimd_section proc~parse_aimd_section->proc~error_set proc~parse_command_line parse_command_line proc~parse_command_line->proc~error_set proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~parse_driver_section parse_driver_section proc~parse_driver_section->proc~error_set proc~parse_element_basis->proc~error_set proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~parse_fragment parse_fragment proc~parse_fragment->proc~error_set proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~error_set proc~validate_cutoffs validate_cutoffs proc~parse_fragmentation_section->proc~validate_cutoffs proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_generic->proc~skip_to_end proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_generic->proc~error_set proc~parse_hessian_section parse_hessian_section proc~parse_hessian_section->proc~error_set proc~parse_indices_line->proc~error_set proc~parse_model_section parse_model_section proc~parse_model_section->proc~error_set proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~error_set proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~skip_to_end proc~parse_scf_section parse_scf_section proc~parse_scf_section->proc~error_set proc~parse_schema_section parse_schema_section proc~parse_schema_section->proc~error_set proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic parse_structure_generic proc~parse_structure_generic->proc~error_set proc~parse_system_section parse_system_section proc~parse_system_section->proc~error_set proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~error_set proc~read_mqc_file->proc~parse_aimd_section proc~read_mqc_file->proc~parse_driver_section proc~read_mqc_file->proc~parse_fragmentation_section proc~read_mqc_file->proc~parse_hessian_section proc~read_mqc_file->proc~parse_model_section proc~read_mqc_file->proc~parse_molecules_section proc~read_mqc_file->proc~parse_scf_section proc~read_mqc_file->proc~parse_schema_section proc~read_mqc_file->proc~parse_system_section proc~read_mqc_file->proc~skip_to_end proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_geometry_section parse_geometry_section proc~read_mqc_file->proc~parse_geometry_section proc~parse_structure_section parse_structure_section proc~read_mqc_file->proc~parse_structure_section proc~read_xyz_file->proc~error_set proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~read_xyz_string->proc~error_set proc~skip_to_end->proc~error_set proc~validate_cutoffs->proc~error_set proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~initialize_fragmented_system->proc~check_fragment_overlap proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~check_duplicate_atoms program~main main program~main->proc~config_to_system_geometry program~main->proc~read_mqc_file program~main->proc~run_multi_molecule_calculations interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine error_set ( this , code , message ) !! Set an error with code and message !! Resets the stack trace class ( error_t ), intent ( inout ) :: this integer , intent ( in ) :: code character ( len =* ), intent ( in ) :: message this % code = code this % message = trim ( message ) this % stack_depth = 0 ! Reset stack when setting new error end subroutine error_set","tags":"","url":"proc/error_set.html"},{"title":"xtb_calc_energy – metalquicha","text":"private  subroutine xtb_calc_energy(this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Type Bound xtb_method_t Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~xtb_calc_energy~~CallsGraph proc~xtb_calc_energy xtb_method_t%xtb_calc_energy new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_energy->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~xtb_calc_energy~~CalledByGraph proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_energy interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(xtb_calculator), private :: calc type(context_type), private :: ctx real(kind=wp), private :: energy type(error_type), private, allocatable :: error type(structure_type), private :: mol integer, private, allocatable :: num (:) integer, private :: verbosity type(wavefunction_type), private :: wfn real(kind=wp), private, allocatable :: xyz (:,:) Source Code subroutine xtb_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity if ( this % verbose ) then print * , \"XTB: Calculating energy using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure ! charge is real(wp), multiplicity converted to uhf (unpaired electrons) call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default error stop \"Unknown XTB variant: \" // this % variant end select if ( allocated ( error )) then error stop \"Failed to create XTB calculator\" end if ! Create wavefunction and run single point calculation call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt ) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , verbosity = verbosity ) ! Store result (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () end if deallocate ( num , xyz ) end subroutine xtb_calc_energy","tags":"","url":"proc/xtb_calc_energy.html"},{"title":"xtb_calc_gradient – metalquicha","text":"private  subroutine xtb_calc_gradient(this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Type Bound xtb_method_t Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~xtb_calc_gradient~~CallsGraph proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_gradient->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~xtb_calc_gradient~~CalledByGraph proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~xtb_calc_gradient proc~hessian_worker hessian_worker proc~hessian_worker->proc~xtb_calc_gradient proc~xtb_calc_hessian->proc~xtb_calc_gradient interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(xtb_calculator), private :: calc type(context_type), private :: ctx real(kind=wp), private :: energy type(error_type), private, allocatable :: error real(kind=wp), private, allocatable :: gradient (:,:) type(structure_type), private :: mol integer, private, allocatable :: num (:) real(kind=wp), private, allocatable :: sigma (:,:) integer, private :: verbosity type(wavefunction_type), private :: wfn real(kind=wp), private, allocatable :: xyz (:,:) Source Code subroutine xtb_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity real ( wp ), allocatable :: gradient (:, :) real ( wp ), allocatable :: sigma (:, :) if ( this % verbose ) then print * , \"XTB: Calculating gradient using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default error stop \"Unknown XTB variant: \" // this % variant end select if ( allocated ( error )) then error stop \"Failed to create XTB calculator\" end if ! Allocate gradient and sigma arrays (initialize to zero) allocate ( gradient ( 3 , fragment % n_atoms )) allocate ( sigma ( 3 , 3 )) gradient = 0.0_wp sigma = 0.0_wp ! Create wavefunction and run single point calculation with gradient call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt , grad = . true .) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , & gradient = gradient , sigma = sigma , verbosity = verbosity ) ! Store results (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . ! Store gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = real ( gradient , dp ) result % has_gradient = . true . ! Store sigma (stress tensor) allocate ( result % sigma ( 3 , 3 )) result % sigma = real ( sigma , dp ) result % has_sigma = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () print * , \"XTB: Gradient norm =\" , sqrt ( sum ( result % gradient ** 2 )) print * , \"XTB: Gradient calculation complete\" end if deallocate ( num , xyz , gradient , sigma ) end subroutine xtb_calc_gradient","tags":"","url":"proc/xtb_calc_gradient.html"},{"title":"xtb_calc_hessian – metalquicha","text":"private  subroutine xtb_calc_hessian(this, fragment, result) Uses pic_io pic_logger mqc_finite_differences proc~~xtb_calc_hessian~~UsesGraph proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian module~mqc_finite_differences mqc_finite_differences proc~xtb_calc_hessian->module~mqc_finite_differences pic_io pic_io proc~xtb_calc_hessian->pic_io pic_logger pic_logger proc~xtb_calc_hessian->pic_logger module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calculate Hessian using finite differences of gradients Since tblite does not natively support analytic Hessians, this routine\ncomputes the Hessian numerically via central finite differences:\n  H[i,j] = (grad_j(x_i + h) - grad_j(x_i - h)) / (2h) This requires 6N gradient calculations (forward and backward for each coordinate) Type Bound xtb_method_t Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~xtb_calc_hessian~~CallsGraph proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian error error proc~xtb_calc_hessian->error info info proc~xtb_calc_hessian->info proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~xtb_calc_hessian->proc~xtb_calc_gradient to_char to_char proc~xtb_calc_hessian->to_char proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_gradient->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~xtb_calc_hessian~~CalledByGraph proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_hessian interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( displaced_geometry_t ), private, allocatable :: backward_geoms (:) real(kind=dp), private, allocatable :: backward_gradients (:,:,:) type( calculation_result_t ), private :: disp_result real(kind=dp), private :: displacement type( displaced_geometry_t ), private, allocatable :: forward_geoms (:) real(kind=dp), private, allocatable :: forward_gradients (:,:,:) integer, private :: i integer, private :: n_atoms integer, private :: n_displacements Source Code subroutine xtb_calc_hessian ( this , fragment , result ) !! Calculate Hessian using finite differences of gradients !! !! Since tblite does not natively support analytic Hessians, this routine !! computes the Hessian numerically via central finite differences: !!   H[i,j] = (grad_j(x_i + h) - grad_j(x_i - h)) / (2h) !! !! This requires 6N gradient calculations (forward and backward for each coordinate) use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT use pic_logger , only : logger => global_logger use pic_io , only : to_char class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result type ( displaced_geometry_t ), allocatable :: forward_geoms (:), backward_geoms (:) real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) type ( calculation_result_t ) :: disp_result real ( dp ) :: displacement integer :: n_atoms , n_displacements , i n_atoms = fragment % n_atoms n_displacements = 3 * n_atoms displacement = DEFAULT_DISPLACEMENT if ( this % verbose ) then call logger % info ( \"XTB: Computing Hessian via finite differences\" ) call logger % info ( \"  Method: Central differences of gradients\" ) call logger % info ( \"  Atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) call logger % info ( \"  Finite difference step size: \" // to_char ( displacement ) // \" Bohr\" ) end if ! Generate all perturbed geometries call generate_perturbed_geometries ( fragment , displacement , forward_geoms , backward_geoms ) ! Allocate storage for gradients at displaced geometries allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) ! Compute gradients at all forward-displaced geometries if ( this % verbose ) then call logger % info ( \"  Computing forward-displaced gradients...\" ) end if do i = 1 , n_displacements ! Forward call this % calc_gradient ( forward_geoms ( i )% geometry , disp_result ) if (. not . disp_result % has_gradient ) then call logger % error ( \"Failed to compute gradient for forward displacement \" // to_char ( i )) error stop \"Finite difference Hessian: gradient calculation failed\" end if forward_gradients ( i , :, :) = disp_result % gradient call disp_result % destroy () ! Backward call this % calc_gradient ( backward_geoms ( i )% geometry , disp_result ) if (. not . disp_result % has_gradient ) then call logger % error ( \"Failed to compute gradient for backward displacement \" // to_char ( i )) error stop \"Finite difference Hessian: gradient calculation failed\" end if backward_gradients ( i , :, :) = disp_result % gradient call disp_result % destroy () end do if ( this % verbose ) then call logger % info ( \"  Forward and backward gradient calculations complete \" ) end if ! Compute Hessian from finite differences if ( this % verbose ) then call logger % info ( \"  Assembling Hessian matrix...\" ) end if call finite_diff_hessian_from_gradients ( fragment , forward_gradients , backward_gradients , & displacement , result % hessian ) ! Also compute energy and gradient at reference geometry for completeness call this % calc_gradient ( fragment , disp_result ) result % energy = disp_result % energy result % has_energy = disp_result % has_energy if ( disp_result % has_gradient ) then allocate ( result % gradient ( 3 , n_atoms )) result % gradient = disp_result % gradient result % has_gradient = . true . end if call disp_result % destroy () result % has_hessian = . true . if ( this % verbose ) then call logger % info ( \"  Hessian calculation complete\" ) end if ! Cleanup deallocate ( forward_gradients , backward_gradients ) do i = 1 , n_displacements call forward_geoms ( i )% destroy () call backward_geoms ( i )% destroy () end do deallocate ( forward_geoms , backward_geoms ) end subroutine xtb_calc_hessian","tags":"","url":"proc/xtb_calc_hessian.html"},{"title":"extract_element – metalquicha","text":"public  function extract_element(basis_file, element) result(element_content) Extract the basis set data for a specific element from the basis file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(in) :: basis_file character(len=*), intent(in) :: element Return Value character(len=:), allocatable Calls proc~~extract_element~~CallsGraph proc~extract_element extract_element proc~is_letter is_letter proc~extract_element->proc~is_letter proc~is_uppercase_letter is_uppercase_letter proc~extract_element->proc~is_uppercase_letter proc~uppercase uppercase proc~extract_element->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: at_line_start integer, private :: end_pos integer, private :: i character(len=:), private, allocatable :: search_element integer, private :: start_pos Source Code function extract_element ( basis_file , element ) result ( element_content ) !! Extract the basis set data for a specific element from the basis file type ( basis_file_t ), intent ( in ) :: basis_file character ( len =* ), intent ( in ) :: element character ( len = :), allocatable :: element_content integer :: start_pos , end_pos , i character ( len = :), allocatable :: search_element logical :: at_line_start ! Convert element to uppercase for searching search_element = uppercase ( trim ( element )) ! Find the element name (it appears on its own line) start_pos = index ( basis_file % data_section , new_line ( 'a' ) // trim ( search_element ) // new_line ( 'a' )) if ( start_pos == 0 ) then ! Try without leading newline (might be first element after $DATA) if ( index ( basis_file % data_section , trim ( search_element ) // new_line ( 'a' )) == 1 ) then start_pos = 1 else error stop \"Element not found in basis set file: \" // element end if else start_pos = start_pos + 1 ! Skip the leading newline end if ! Find the next element by looking for a line that: ! - Starts with an uppercase letter ! - Has a second character that is also a letter (not a space or number) ! This distinguishes \"CARBON\" from \"S   3\" end_pos = len ( basis_file % data_section ) at_line_start = . false . i = start_pos + len ( search_element ) + 1 do while ( i < len ( basis_file % data_section )) if ( basis_file % data_section ( i : i ) == new_line ( 'a' )) then at_line_start = . true . i = i + 1 cycle end if if ( at_line_start ) then ! We're at the start of a new line if ( is_uppercase_letter ( basis_file % data_section ( i : i ))) then ! Check if next character is also a letter if ( i + 1 <= len ( basis_file % data_section )) then if ( is_letter ( basis_file % data_section ( i + 1 : i + 1 ))) then ! Found next element! end_pos = i - 1 exit end if end if end if at_line_start = . false . end if i = i + 1 end do ! Extract the section element_content = basis_file % data_section ( start_pos : end_pos ) end function extract_element","tags":"","url":"proc/extract_element.html"},{"title":"strings_equal – metalquicha","text":"public pure function strings_equal(str1, str2) result(equal) Compare two strings after trimming and adjusting (removing leading/trailing whitespace)\nCompare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical Called by proc~~strings_equal~~CalledByGraph proc~strings_equal strings_equal proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~strings_equal proc~find_unique_strings find_unique_strings proc~build_molecular_basis->proc~find_unique_strings proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~strings_equal proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~strings_equal proc~find_unique_strings->proc~strings_equal proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function strings_equal ( str1 , str2 ) result ( equal ) !! Compare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) character ( len =* ), intent ( in ) :: str1 , str2 logical :: equal equal = trim ( adjustl ( str1 )) == trim ( adjustl ( str2 )) end function strings_equal","tags":"","url":"proc/strings_equal.html"},{"title":"is_letter – metalquicha","text":"private pure function is_letter(c) result(is_alpha) Check if character is a letter (A-Z or a-z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_letter~~CalledByGraph proc~is_letter is_letter proc~extract_element extract_element proc~extract_element->proc~is_letter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code pure function is_letter ( c ) result ( is_alpha ) !! Check if character is a letter (A-Z or a-z) character ( len = 1 ), intent ( in ) :: c logical :: is_alpha integer :: ic ic = iachar ( c ) is_alpha = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) . or . & ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) end function is_letter","tags":"","url":"proc/is_letter.html"},{"title":"is_uppercase_letter – metalquicha","text":"private pure function is_uppercase_letter(c) result(is_upper) Check if character is an uppercase letter (A-Z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_uppercase_letter~~CalledByGraph proc~is_uppercase_letter is_uppercase_letter proc~extract_element extract_element proc~extract_element->proc~is_uppercase_letter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code pure function is_uppercase_letter ( c ) result ( is_upper ) !! Check if character is an uppercase letter (A-Z) character ( len = 1 ), intent ( in ) :: c logical :: is_upper integer :: ic ic = iachar ( c ) is_upper = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) end function is_uppercase_letter","tags":"","url":"proc/is_uppercase_letter.html"},{"title":"uppercase – metalquicha","text":"private pure function uppercase(str) result(upper) Convert a string to uppercase, should use pic_ascii! Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:), allocatable Called by proc~~uppercase~~CalledByGraph proc~uppercase uppercase proc~extract_element extract_element proc~extract_element->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: ic Source Code pure function uppercase ( str ) result ( upper ) !! Convert a string to uppercase, should use pic_ascii! character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: upper integer :: i , ic allocate ( character ( len = len ( str )) :: upper ) upper = str do i = 1 , len ( str ) ic = iachar ( str ( i : i )) if ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) then upper ( i : i ) = achar ( ic - 32 ) end if end do end function uppercase","tags":"","url":"proc/uppercase.html"},{"title":"open_basis_file – metalquicha","text":"public  subroutine open_basis_file(basis_file, filename) Open and read a GAMESS formatted basis set file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(out) :: basis_file character(len=*), intent(in) :: filename Variables Type Visibility Attributes Name Initial integer, private :: data_end integer, private :: data_start logical, private :: file_exists integer, private :: file_size integer, private :: iostat integer, private :: unit Source Code subroutine open_basis_file ( basis_file , filename ) !! Open and read a GAMESS formatted basis set file type ( basis_file_t ), intent ( out ) :: basis_file character ( len =* ), intent ( in ) :: filename integer :: unit , iostat , file_size logical :: file_exists integer :: data_start , data_end ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then error stop \"Basis set file not found: \" // filename end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: basis_file % full_content ) ! Open and read entire file open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = iostat ) if ( iostat /= 0 ) error stop \"Error opening file: \" // filename read ( unit , iostat = iostat ) basis_file % full_content if ( iostat /= 0 ) error stop \"Error reading file: \" // filename close ( unit ) ! Extract the $DATA section data_start = index ( basis_file % full_content , \"$DATA\" ) if ( data_start == 0 ) then error stop \"Could not find $DATA section in basis set file\" end if data_end = index ( basis_file % full_content ( data_start :), \"$END\" ) if ( data_end == 0 ) then error stop \"Could not find $END marker in basis set file\" end if ! Store just the data section (between $DATA and $END) basis_file % data_section = basis_file % full_content ( data_start + 5 : data_start + data_end - 2 ) end subroutine open_basis_file","tags":"","url":"proc/open_basis_file.html"},{"title":"find_fragment_intersection – metalquicha","text":"public  function find_fragment_intersection(frag1_atoms, n1, frag2_atoms, n2, intersection, n_intersect) result(has_intersection) Find shared atoms between two fragments (for GMBE with overlapping fragments) This function identifies atoms that appear in both fragments, which is essential\nfor computing intersection-corrected energies in GMBE. Algorithm: O(n1 * n2) brute-force comparison\n- Loop through all atoms in fragment 1\n- For each atom, check if it appears in fragment 2\n- Collect all shared atoms Returns:\n  .true. if fragments share at least one atom, .false. otherwise Output:\n  intersection - allocatable array containing shared atom indices\n  n_intersect - number of shared atoms Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag1_atoms (:) Atom indices in fragment 1 (0-indexed) integer, intent(in) :: n1 Number of atoms in fragment 1 integer, intent(in) :: frag2_atoms (:) Atom indices in fragment 2 (0-indexed) integer, intent(in) :: n2 Number of atoms in fragment 2 integer, intent(out), allocatable :: intersection (:) Shared atom indices integer, intent(out) :: n_intersect Number of shared atoms Return Value logical Called by proc~~find_fragment_intersection~~CalledByGraph proc~find_fragment_intersection find_fragment_intersection proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->proc~find_fragment_intersection proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->proc~find_fragment_intersection proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~process_intersection_derivatives proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: temp_count integer, private, allocatable :: temp_intersection (:) Source Code function find_fragment_intersection ( frag1_atoms , n1 , frag2_atoms , n2 , & intersection , n_intersect ) result ( has_intersection ) !! Find shared atoms between two fragments (for GMBE with overlapping fragments) !! !! This function identifies atoms that appear in both fragments, which is essential !! for computing intersection-corrected energies in GMBE. !! !! Algorithm: O(n1 * n2) brute-force comparison !! - Loop through all atoms in fragment 1 !! - For each atom, check if it appears in fragment 2 !! - Collect all shared atoms !! !! Returns: !!   .true. if fragments share at least one atom, .false. otherwise !! !! Output: !!   intersection - allocatable array containing shared atom indices !!   n_intersect - number of shared atoms integer , intent ( in ) :: frag1_atoms (:) !! Atom indices in fragment 1 (0-indexed) integer , intent ( in ) :: n1 !! Number of atoms in fragment 1 integer , intent ( in ) :: frag2_atoms (:) !! Atom indices in fragment 2 (0-indexed) integer , intent ( in ) :: n2 !! Number of atoms in fragment 2 integer , allocatable , intent ( out ) :: intersection (:) !! Shared atom indices integer , intent ( out ) :: n_intersect !! Number of shared atoms logical :: has_intersection integer :: i , j integer , allocatable :: temp_intersection (:) integer :: temp_count ! Allocate temporary array (max possible size is min(n1, n2)) allocate ( temp_intersection ( min ( n1 , n2 ))) temp_count = 0 ! Find all shared atoms do i = 1 , n1 do j = 1 , n2 if ( frag1_atoms ( i ) == frag2_atoms ( j )) then ! Found a shared atom temp_count = temp_count + 1 temp_intersection ( temp_count ) = frag1_atoms ( i ) exit ! Move to next atom in frag1 end if end do end do ! Set output n_intersect = temp_count has_intersection = ( temp_count > 0 ) ! Allocate and copy result if intersection exists if ( has_intersection ) then allocate ( intersection ( n_intersect )) intersection = temp_intersection ( 1 : n_intersect ) end if deallocate ( temp_intersection ) end function find_fragment_intersection","tags":"","url":"proc/find_fragment_intersection.html"},{"title":"atom_sets_equal – metalquicha","text":"private pure function atom_sets_equal(set1, set2, n_atoms) result(equal) Check if two atom sets are equal (assuming sorted) Arguments Type Intent Optional Attributes Name integer, intent(in) :: set1 (:) integer, intent(in) :: set2 (:) integer, intent(in) :: n_atoms Return Value logical Called by proc~~atom_sets_equal~~CalledByGraph proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~atom_sets_equal proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure function atom_sets_equal ( set1 , set2 , n_atoms ) result ( equal ) !! Check if two atom sets are equal (assuming sorted) integer , intent ( in ) :: set1 (:), set2 (:) integer , intent ( in ) :: n_atoms logical :: equal integer :: i equal = . true . do i = 1 , n_atoms if ( set1 ( i ) /= set2 ( i )) then equal = . false . return end if end do end function atom_sets_equal","tags":"","url":"proc/atom_sets_equal.html"},{"title":"compute_polymer_atoms – metalquicha","text":"public pure subroutine compute_polymer_atoms(sys_geom, polymer, polymer_size, atom_list, n_atoms) Uses mqc_physical_fragment proc~~compute_polymer_atoms~~UsesGraph proc~compute_polymer_atoms compute_polymer_atoms module~mqc_physical_fragment mqc_physical_fragment proc~compute_polymer_atoms->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute the atom list for a polymer (union of atoms from base fragments)\npolymer(:) contains base fragment indices (1-based) Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymer (:) Base fragment indices in this polymer integer, intent(in) :: polymer_size Number of base fragments in polymer integer, intent(out), allocatable :: atom_list (:) Unique atoms in this polymer integer, intent(out) :: n_atoms Number of unique atoms Called by proc~~compute_polymer_atoms~~CalledByGraph proc~compute_polymer_atoms compute_polymer_atoms proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~compute_polymer_atoms proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: already_present integer, private :: frag_idx integer, private :: frag_size integer, private :: i integer, private :: j integer, private, allocatable :: temp_atoms (:) integer, private :: temp_count Source Code pure subroutine compute_polymer_atoms ( sys_geom , polymer , polymer_size , atom_list , n_atoms ) !! Compute the atom list for a polymer (union of atoms from base fragments) !! polymer(:) contains base fragment indices (1-based) use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymer (:) !! Base fragment indices in this polymer integer , intent ( in ) :: polymer_size !! Number of base fragments in polymer integer , allocatable , intent ( out ) :: atom_list (:) !! Unique atoms in this polymer integer , intent ( out ) :: n_atoms !! Number of unique atoms integer , allocatable :: temp_atoms (:) integer :: i , j , frag_idx , frag_size , temp_count logical :: already_present ! Allocate temporary array (worst case: all atoms from all fragments) allocate ( temp_atoms ( sys_geom % total_atoms )) temp_count = 0 ! Loop through each base fragment in the polymer do i = 1 , polymer_size frag_idx = polymer ( i ) if ( frag_idx == 0 ) exit ! Padding zeros frag_size = sys_geom % fragment_sizes ( frag_idx ) ! Add each atom from this fragment (avoid duplicates) do j = 1 , frag_size already_present = . false . ! Check if this atom is already in our list block integer :: k , current_atom current_atom = sys_geom % fragment_atoms ( j , frag_idx ) do k = 1 , temp_count if ( temp_atoms ( k ) == current_atom ) then already_present = . true . exit end if end do end block ! Add if not already present if (. not . already_present ) then temp_count = temp_count + 1 temp_atoms ( temp_count ) = sys_geom % fragment_atoms ( j , frag_idx ) end if end do end do ! Copy to output array n_atoms = temp_count allocate ( atom_list ( n_atoms )) atom_list = temp_atoms ( 1 : n_atoms ) deallocate ( temp_atoms ) end subroutine compute_polymer_atoms","tags":"","url":"proc/compute_polymer_atoms.html"},{"title":"generate_intersections – metalquicha","text":"public  subroutine generate_intersections(sys_geom, monomers, polymers, n_monomers, max_intersection_level, intersections, intersection_sets, intersection_levels, n_intersections) Uses mqc_physical_fragment proc~~generate_intersections~~UsesGraph proc~generate_intersections generate_intersections module~mqc_physical_fragment mqc_physical_fragment proc~generate_intersections->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) For a system with overlapping fragments, this computes k-way intersections\nfollowing the inclusion-exclusion principle for GMBE.\nThe max_intersection_level parameter controls the maximum depth to avoid combinatorial explosion. Algorithm:\n- For each k from 2 to min(max_intersection_level, n_monomers):\n  - Generate all C(n_monomers, k) combinations\n  - For each combination, compute intersection of all k fragments\n  - Store non-empty intersections with their level k Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) Monomer indices integer, intent(inout) :: polymers (:,:) Output: monomers stored here integer, intent(in) :: n_monomers Number of monomers integer, intent(in) :: max_intersection_level Maximum k-way intersection depth integer, intent(out), allocatable :: intersections (:,:) Intersection atom lists integer, intent(out), allocatable :: intersection_sets (:,:) Which k-tuple created each intersection integer, intent(out), allocatable :: intersection_levels (:) Level (k) of each intersection integer, intent(out) :: n_intersections Number of intersections found Calls proc~~generate_intersections~~CallsGraph proc~generate_intersections generate_intersections info info proc~generate_intersections->info proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_intersections->proc~generate_k_way_intersections_for_level to_char to_char proc~generate_intersections->to_char proc~find_fragment_intersection find_fragment_intersection proc~generate_k_way_intersections_for_level->proc~find_fragment_intersection proc~next_combination next_combination proc~generate_k_way_intersections_for_level->proc~next_combination proc~next_combination_init next_combination_init proc~generate_k_way_intersections_for_level->proc~next_combination_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: combination (:) integer, private, allocatable :: current_intersection (:) integer, private :: current_n_intersect logical, private :: has_intersection integer, private :: i integer, private :: idx integer, private :: intersection_count integer, private :: k integer, private :: max_atoms integer, private :: max_intersections integer, private :: max_k_level integer, private, allocatable :: temp_intersection (:) integer, private, allocatable :: temp_intersections (:,:) integer, private, allocatable :: temp_levels (:) integer, private :: temp_n_intersect integer, private, allocatable :: temp_sets (:,:) Source Code subroutine generate_intersections ( sys_geom , monomers , polymers , n_monomers , max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) !! !! For a system with overlapping fragments, this computes k-way intersections !! following the inclusion-exclusion principle for GMBE. !! The max_intersection_level parameter controls the maximum depth to avoid combinatorial explosion. !! !! Algorithm: !! - For each k from 2 to min(max_intersection_level, n_monomers): !!   - Generate all C(n_monomers, k) combinations !!   - For each combination, compute intersection of all k fragments !!   - Store non-empty intersections with their level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:) !! Monomer indices integer , intent ( inout ) :: polymers (:, :) !! Output: monomers stored here integer , intent ( in ) :: n_monomers !! Number of monomers integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth integer , allocatable , intent ( out ) :: intersections (:, :) !! Intersection atom lists integer , allocatable , intent ( out ) :: intersection_sets (:, :) !! Which k-tuple created each intersection integer , allocatable , intent ( out ) :: intersection_levels (:) !! Level (k) of each intersection integer , intent ( out ) :: n_intersections !! Number of intersections found ! Temporaries for storing intersections integer , allocatable :: temp_intersections (:, :) integer , allocatable :: temp_sets (:, :) integer , allocatable :: temp_levels (:) integer , allocatable :: temp_intersection (:) integer , allocatable :: current_intersection (:) integer :: temp_n_intersect , current_n_intersect logical :: has_intersection integer :: k , intersection_count , max_atoms , max_intersections , max_k_level integer :: i , idx integer , allocatable :: combination (:) ! Store monomers in polymers array polymers ( 1 : n_monomers , 1 ) = monomers ( 1 : n_monomers ) if ( n_monomers < 2 ) then n_intersections = 0 return end if ! Count maximum possible intersections: sum of C(n,k) for k=2 to n ! For small n, this is 2&#94;n - n - 1 max_intersections = 2 ** n_monomers - n_monomers - 1 ! Find maximum atoms in any fragment for allocation max_atoms = maxval ( sys_geom % fragment_sizes ( 1 : n_monomers )) ! Allocate temporary arrays allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_monomers , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 ! Determine actual maximum intersection level to use max_k_level = min ( max_intersection_level , n_monomers ) if ( max_k_level < n_monomers ) then call logger % info ( \"Generating k-way intersections up to k=\" // to_char ( max_k_level ) // & \" (limited by max_intersection_level)\" ) else call logger % info ( \"Generating all k-way intersections for GMBE (inclusion-exclusion principle)\" ) end if ! Loop over intersection levels k from 2 to max_k_level do k = 2 , max_k_level ! Generate all C(n_monomers, k) combinations allocate ( combination ( k )) call generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_monomers , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_monomers , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , max_k_level idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else call logger % info ( \"No intersections found (fragments are non-overlapping)\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections","tags":"","url":"proc/generate_intersections.html"},{"title":"generate_polymer_intersections – metalquicha","text":"public  subroutine generate_polymer_intersections(sys_geom, polymers, n_polymers, max_level, intersections, intersection_sets, intersection_levels, n_intersections) Uses pic_io pic_logger mqc_physical_fragment proc~~generate_polymer_intersections~~UsesGraph proc~generate_polymer_intersections generate_polymer_intersections module~mqc_physical_fragment mqc_physical_fragment proc~generate_polymer_intersections->module~mqc_physical_fragment pic_io pic_io proc~generate_polymer_intersections->pic_io pic_logger pic_logger proc~generate_polymer_intersections->pic_logger module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate all k-way intersections for polymers at any level (GMBE-N)\nThis works with dynamically generated polymers, not just base fragments Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymers (:,:) Polymer definitions (n_polymers, max_level) integer, intent(in) :: n_polymers integer, intent(in) :: max_level integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections Calls proc~~generate_polymer_intersections~~CallsGraph proc~generate_polymer_intersections generate_polymer_intersections atom_list atom_list proc~generate_polymer_intersections->atom_list info info proc~generate_polymer_intersections->info proc~compute_polymer_atoms compute_polymer_atoms proc~generate_polymer_intersections->proc~compute_polymer_atoms proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists to_char to_char proc~generate_polymer_intersections->to_char proc~generate_intersections_from_atom_lists->info proc~generate_intersections_from_atom_lists->to_char proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~next_combination next_combination proc~generate_k_way_intersections_from_lists->proc~next_combination proc~next_combination_init next_combination_init proc~generate_k_way_intersections_from_lists->proc~next_combination_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: max_atoms_per_polymer integer, private :: max_intersection_level integer, private, allocatable :: polymer_atoms (:,:) Atom lists for each polymer integer, private, allocatable :: polymer_n_atoms (:) Number of atoms in each polymer integer, private :: polymer_size Source Code subroutine generate_polymer_intersections ( sys_geom , polymers , n_polymers , max_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for polymers at any level (GMBE-N) !! This works with dynamically generated polymers, not just base fragments use mqc_physical_fragment , only : system_geometry_t use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymers (:, :) !! Polymer definitions (n_polymers, max_level) integer , intent ( in ) :: n_polymers , max_level integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer , allocatable :: polymer_atoms (:, :) !! Atom lists for each polymer integer , allocatable :: polymer_n_atoms (:) !! Number of atoms in each polymer integer :: max_atoms_per_polymer integer :: i , polymer_size , max_intersection_level call logger % info ( \"Computing atom compositions for \" // to_char ( n_polymers ) // \" polymers...\" ) ! First, compute atom list for each polymer ! Find max atoms needed max_atoms_per_polymer = 0 do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) ! Worst case: all atoms from all fragments in this polymer max_atoms_per_polymer = max ( max_atoms_per_polymer , polymer_size * maxval ( sys_geom % fragment_sizes )) end do allocate ( polymer_atoms ( max_atoms_per_polymer , n_polymers )) allocate ( polymer_n_atoms ( n_polymers )) polymer_atoms = 0 ! Compute atoms for each polymer do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , polymers ( i , 1 : polymer_size ), polymer_size , atom_list , n_atoms ) polymer_n_atoms ( i ) = n_atoms polymer_atoms ( 1 : n_atoms , i ) = atom_list deallocate ( atom_list ) end block end do call logger % info ( \"Finding intersections between polymers...\" ) ! For GMBE(N), limit intersections to level N+1 to prevent combinatorial explosion ! GMBE(2): dimers → 3-way intersections max ! GMBE(3): trimers → 4-way intersections max max_intersection_level = max_level + 1 call logger % info ( \"Limiting intersections to level \" // to_char ( max_intersection_level ) // & \" (polymer level \" // to_char ( max_level ) // \" + 1)\" ) ! Now generate intersections between these polymer atom sets call generate_intersections_from_atom_lists ( polymer_atoms , polymer_n_atoms , n_polymers , & max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) deallocate ( polymer_atoms , polymer_n_atoms ) end subroutine generate_polymer_intersections","tags":"","url":"proc/generate_polymer_intersections.html"},{"title":"gmbe_enumerate_pie_terms – metalquicha","text":"public  subroutine gmbe_enumerate_pie_terms(sys_geom, primaries, n_primaries, polymer_level, max_k_level, pie_atom_sets, pie_coefficients, n_pie_terms, initial_max_terms) Uses mqc_physical_fragment proc~~gmbe_enumerate_pie_terms~~UsesGraph proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms module~mqc_physical_fragment mqc_physical_fragment proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Enumerate all unique intersections via DFS and accumulate PIE coefficients\nThis implements the GMBE(N) algorithm with inclusion-exclusion principle Algorithm:\n1. For each primary i, start DFS with clique=[i]\n2. Recursively grow cliques by adding overlapping primaries\n3. For each clique of size k, compute intersection and add PIE coefficient:\n   coefficient = (+1) if k odd, (-1) if k even\n4. Accumulate coefficients for each unique atom set Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: primaries (:,:) Primary polymers (n_primaries, polymer_level) integer, intent(in) :: n_primaries Number of primary polymers integer, intent(in) :: polymer_level Level of primaries (1=monomers, 2=dimers, etc.) integer, intent(in) :: max_k_level Maximum clique size (intersection depth limit) integer, intent(out), allocatable :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_terms) integer, intent(out), allocatable :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(out) :: n_pie_terms Number of unique PIE terms integer(kind=int64), intent(in), optional :: initial_max_terms Initial PIE storage capacity Calls proc~~gmbe_enumerate_pie_terms~~CallsGraph proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list error error proc~gmbe_enumerate_pie_terms->error info info proc~gmbe_enumerate_pie_terms->info proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate to_char to_char proc~gmbe_enumerate_pie_terms->to_char proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~grow_pie_storage->error proc~grow_pie_storage->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gmbe_enumerate_pie_terms~~CalledByGraph proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private, parameter :: INITIAL_MAX_PIE_TERMS = 100000_int64 integer, private, allocatable :: candidates (:) Candidate primaries to add integer, private, allocatable :: clique (:) Current clique being built integer, private, allocatable :: current_atoms (:) Current intersection atoms integer, private :: i integer, private :: j integer, private :: max_atoms integer(kind=int64), private :: max_terms integer(kind=default_int), private :: max_terms_i integer, private :: n_candidates integer, private, allocatable :: primary_atoms (:,:) Precomputed atom lists for each primary integer, private, allocatable :: primary_n_atoms (:) Atom counts for each primary integer, private, allocatable :: temp_atom_sets (:,:) integer, private, allocatable :: temp_coefficients (:) Source Code subroutine gmbe_enumerate_pie_terms ( sys_geom , primaries , n_primaries , polymer_level , max_k_level , & pie_atom_sets , pie_coefficients , n_pie_terms , initial_max_terms ) !! Enumerate all unique intersections via DFS and accumulate PIE coefficients !! This implements the GMBE(N) algorithm with inclusion-exclusion principle !! !! Algorithm: !! 1. For each primary i, start DFS with clique=[i] !! 2. Recursively grow cliques by adding overlapping primaries !! 3. For each clique of size k, compute intersection and add PIE coefficient: !!    coefficient = (+1) if k odd, (-1) if k even !! 4. Accumulate coefficients for each unique atom set use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: primaries (:, :) !! Primary polymers (n_primaries, polymer_level) integer , intent ( in ) :: n_primaries !! Number of primary polymers integer , intent ( in ) :: polymer_level !! Level of primaries (1=monomers, 2=dimers, etc.) integer , intent ( in ) :: max_k_level !! Maximum clique size (intersection depth limit) integer , allocatable , intent ( out ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_terms) integer , allocatable , intent ( out ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( out ) :: n_pie_terms !! Number of unique PIE terms integer ( int64 ), intent ( in ), optional :: initial_max_terms !! Initial PIE storage capacity ! Temporary storage for PIE terms (allocate generously) integer ( int64 ), parameter :: INITIAL_MAX_PIE_TERMS = 100000_int64 ! Adjust if needed integer ( int64 ) :: max_terms integer ( default_int ) :: max_terms_i integer , allocatable :: temp_atom_sets (:, :) integer , allocatable :: temp_coefficients (:) integer , allocatable :: primary_atoms (:, :) !! Precomputed atom lists for each primary integer , allocatable :: primary_n_atoms (:) !! Atom counts for each primary integer , allocatable :: clique (:) !! Current clique being built integer , allocatable :: current_atoms (:) !! Current intersection atoms integer , allocatable :: candidates (:) !! Candidate primaries to add integer :: i , j , max_atoms , n_candidates call logger % info ( \"Enumerating GMBE PIE terms via DFS...\" ) ! Find maximum atoms in any fragment max_atoms = sys_geom % total_atoms ! Allocate temporary storage if ( present ( initial_max_terms )) then max_terms = initial_max_terms else max_terms = INITIAL_MAX_PIE_TERMS end if if ( max_terms < 1_int64 ) then call logger % error ( \"Initial PIE term capacity must be positive\" ) error stop \"Invalid initial PIE term capacity\" end if if ( max_terms > int ( huge ( 0_default_int ), int64 )) then call logger % error ( \"Initial PIE term capacity exceeds default integer limit\" ) error stop \"Invalid initial PIE term capacity\" end if max_terms_i = int ( max_terms , default_int ) allocate ( temp_atom_sets ( max_atoms , max_terms_i )) allocate ( temp_coefficients ( max_terms_i )) temp_atom_sets = - 1 temp_coefficients = 0 n_pie_terms = 0_int64 ! Precompute atom lists for all primaries allocate ( primary_atoms ( max_atoms , n_primaries )) allocate ( primary_n_atoms ( n_primaries )) primary_atoms = - 1 do i = 1 , n_primaries block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , primaries ( i , :), polymer_level , atom_list , n_atoms ) primary_n_atoms ( i ) = n_atoms primary_atoms ( 1 : n_atoms , i ) = atom_list ( 1 : n_atoms ) deallocate ( atom_list ) end block end do ! Allocate work arrays allocate ( clique ( max_k_level )) allocate ( current_atoms ( max_atoms )) allocate ( candidates ( n_primaries )) ! Start DFS from each primary do i = 1 , n_primaries ! Initial clique: just primary i clique ( 1 ) = i current_atoms ( 1 : primary_n_atoms ( i )) = primary_atoms ( 1 : primary_n_atoms ( i ), i ) ! Candidates: all primaries after i (to avoid duplicates) n_candidates = n_primaries - i if ( n_candidates > 0 ) then candidates ( 1 : n_candidates ) = [( i + j , j = 1 , n_candidates )] end if ! DFS from this primary call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , 1 , current_atoms ( 1 : primary_n_atoms ( i )), primary_n_atoms ( i ), & candidates , n_candidates , max_k_level , & temp_atom_sets , temp_coefficients , n_pie_terms , max_terms ) end do ! Copy to output arrays if ( n_pie_terms > 0_int64 ) then if ( n_pie_terms > int ( huge ( 0_default_int ), int64 )) then call logger % error ( \"n_pie_terms exceeds default integer limit\" ) error stop \"PIE term count too large for allocation\" end if allocate ( pie_atom_sets ( max_atoms , int ( n_pie_terms , default_int ))) allocate ( pie_coefficients ( int ( n_pie_terms , default_int ))) pie_atom_sets = temp_atom_sets (:, 1 : n_pie_terms ) pie_coefficients = temp_coefficients ( 1 : n_pie_terms ) end if call logger % info ( \"Generated \" // to_char ( n_pie_terms ) // \" unique PIE terms\" ) ! Cleanup deallocate ( temp_atom_sets , temp_coefficients , primary_atoms , primary_n_atoms ) deallocate ( clique , current_atoms , candidates ) end subroutine gmbe_enumerate_pie_terms","tags":"","url":"proc/gmbe_enumerate_pie_terms.html"},{"title":"dfs_pie_accumulate – metalquicha","text":"private recursive subroutine dfs_pie_accumulate(primary_atoms, primary_n_atoms, n_primaries, max_atoms, clique, clique_size, current_atoms, n_current_atoms, candidates, n_candidates, max_k_level, atom_sets, coefficients, n_terms, max_terms) DFS helper: accumulate PIE coefficients for intersections Arguments Type Intent Optional Attributes Name integer, intent(in) :: primary_atoms (:,:) Precomputed atom lists integer, intent(in) :: primary_n_atoms (:) Atom counts integer, intent(in) :: n_primaries integer, intent(in) :: max_atoms integer, intent(in) :: clique (:) Current clique integer, intent(in) :: clique_size Size of current clique integer, intent(in) :: current_atoms (:) Atoms in current intersection integer, intent(in) :: n_current_atoms Number of atoms in intersection integer, intent(in) :: candidates (:) Candidate primaries integer, intent(in) :: n_candidates integer, intent(in) :: max_k_level integer, intent(inout), allocatable :: atom_sets (:,:) integer, intent(inout), allocatable :: coefficients (:) integer(kind=int64), intent(inout) :: n_terms integer(kind=int64), intent(inout) :: max_terms Calls proc~~dfs_pie_accumulate~~CallsGraph proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect error error proc~grow_pie_storage->error to_char to_char proc~grow_pie_storage->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dfs_pie_accumulate~~CalledByGraph proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: candidate_idx integer, private :: candidate_pos logical, private :: found integer, private :: i integer, private :: n_new_atoms integer, private :: n_new_candidates integer, private, allocatable :: new_atoms (:) integer, private, allocatable :: new_candidates (:) integer, private :: sign integer(kind=int64), private :: term_idx Source Code recursive subroutine dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , clique_size , current_atoms , n_current_atoms , & candidates , n_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms ) !! DFS helper: accumulate PIE coefficients for intersections integer , intent ( in ) :: primary_atoms (:, :) !! Precomputed atom lists integer , intent ( in ) :: primary_n_atoms (:) !! Atom counts integer , intent ( in ) :: n_primaries , max_atoms integer , intent ( in ) :: clique (:) !! Current clique integer , intent ( in ) :: clique_size !! Size of current clique integer , intent ( in ) :: current_atoms (:) !! Atoms in current intersection integer , intent ( in ) :: n_current_atoms !! Number of atoms in intersection integer , intent ( in ) :: candidates (:) !! Candidate primaries integer , intent ( in ) :: n_candidates integer , intent ( in ) :: max_k_level integer , allocatable , intent ( inout ) :: atom_sets (:, :) integer , allocatable , intent ( inout ) :: coefficients (:) integer ( int64 ), intent ( inout ) :: n_terms integer ( int64 ), intent ( inout ) :: max_terms integer :: sign , i , candidate_idx , candidate_pos integer ( int64 ) :: term_idx integer , allocatable :: new_atoms (:), new_candidates (:) integer :: n_new_atoms , n_new_candidates logical :: found ! Skip empty intersections if ( n_current_atoms == 0 ) return ! Compute PIE sign: (+1) for odd clique size, (-1) for even sign = merge ( 1 , - 1 , mod ( clique_size , 2 ) == 1 ) ! Find or create entry for this atom set found = . false . do term_idx = 1_int64 , n_terms if ( atom_sets_equal ( atom_sets (:, term_idx ), current_atoms , n_current_atoms )) then coefficients ( term_idx ) = coefficients ( term_idx ) + sign found = . true . exit end if end do if (. not . found ) then ! New atom set if ( n_terms >= max_terms ) then call grow_pie_storage ( atom_sets , coefficients , max_terms , max_atoms ) end if n_terms = n_terms + 1_int64 atom_sets ( 1 : n_current_atoms , n_terms ) = current_atoms ( 1 : n_current_atoms ) atom_sets ( n_current_atoms + 1 :, n_terms ) = - 1 coefficients ( n_terms ) = sign end if ! Stop if we've reached maximum clique size if ( clique_size >= max_k_level ) return if ( n_candidates == 0 ) return ! Try adding each candidate to the clique allocate ( new_atoms ( max_atoms )) allocate ( new_candidates ( n_primaries )) do i = 1 , n_candidates candidate_idx = candidates ( i ) ! Compute intersection with this candidate call intersect_atom_lists ( current_atoms , n_current_atoms , & primary_atoms (:, candidate_idx ), primary_n_atoms ( candidate_idx ), & new_atoms , n_new_atoms ) ! Skip if no intersection if ( n_new_atoms == 0 ) cycle ! New candidates: must come after this one and overlap with new_atoms n_new_candidates = 0 do candidate_pos = i + 1 , n_candidates block integer :: test_candidate , test_n_intersect integer , allocatable :: test_intersect (:) test_candidate = candidates ( candidate_pos ) allocate ( test_intersect ( max_atoms )) call intersect_atom_lists ( new_atoms , n_new_atoms , & primary_atoms (:, test_candidate ), primary_n_atoms ( test_candidate ), & test_intersect , test_n_intersect ) if ( test_n_intersect > 0 ) then n_new_candidates = n_new_candidates + 1 new_candidates ( n_new_candidates ) = test_candidate end if deallocate ( test_intersect ) end block end do ! Recurse block integer :: new_clique ( clique_size + 1 ) new_clique ( 1 : clique_size ) = clique ( 1 : clique_size ) new_clique ( clique_size + 1 ) = candidate_idx call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & new_clique , clique_size + 1 , new_atoms , n_new_atoms , & new_candidates , n_new_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms ) end block end do deallocate ( new_atoms , new_candidates ) end subroutine dfs_pie_accumulate","tags":"","url":"proc/dfs_pie_accumulate.html"},{"title":"generate_intersections_from_atom_lists – metalquicha","text":"private  subroutine generate_intersections_from_atom_lists(atom_lists, n_atoms_list, n_sets, max_k_level, intersections, intersection_sets, intersection_levels, n_intersections) Uses pic_io pic_logger proc~~generate_intersections_from_atom_lists~~UsesGraph proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists pic_io pic_io proc~generate_intersections_from_atom_lists->pic_io pic_logger pic_logger proc~generate_intersections_from_atom_lists->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate k-way intersections from arbitrary atom lists (not tied to sys_geom)\nmax_k_level limits the maximum intersection order to prevent combinatorial explosion Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) (max_atoms, n_sets) integer, intent(in) :: n_atoms_list (:) Number of atoms in each set integer, intent(in) :: n_sets Number of sets (polymers) integer, intent(in) :: max_k_level Maximum intersection level to compute integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections Calls proc~~generate_intersections_from_atom_lists~~CallsGraph proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists info info proc~generate_intersections_from_atom_lists->info proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists to_char to_char proc~generate_intersections_from_atom_lists->to_char proc~next_combination next_combination proc~generate_k_way_intersections_from_lists->proc~next_combination proc~next_combination_init next_combination_init proc~generate_k_way_intersections_from_lists->proc~next_combination_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_intersections_from_atom_lists~~CalledByGraph proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: actual_max_k integer, private, allocatable :: combination (:) integer, private :: idx integer, private :: intersection_count integer, private :: k integer, private :: max_atoms integer, private :: max_intersections integer, private, allocatable :: temp_intersections (:,:) integer, private, allocatable :: temp_levels (:) integer, private, allocatable :: temp_sets (:,:) Source Code subroutine generate_intersections_from_atom_lists ( atom_lists , n_atoms_list , n_sets , max_k_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate k-way intersections from arbitrary atom lists (not tied to sys_geom) !! max_k_level limits the maximum intersection order to prevent combinatorial explosion use pic_logger , only : logger => global_logger use pic_io , only : to_char integer , intent ( in ) :: atom_lists (:, :) !! (max_atoms, n_sets) integer , intent ( in ) :: n_atoms_list (:) !! Number of atoms in each set integer , intent ( in ) :: n_sets !! Number of sets (polymers) integer , intent ( in ) :: max_k_level !! Maximum intersection level to compute integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer :: max_intersections , max_atoms integer , allocatable :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer :: intersection_count , k , idx , actual_max_k integer , allocatable :: combination (:) if ( n_sets < 2 ) then n_intersections = 0 return end if ! Limit k-way intersections to min(max_k_level, n_sets) actual_max_k = min ( max_k_level , n_sets ) max_intersections = 2 ** n_sets - n_sets - 1 max_atoms = maxval ( n_atoms_list ) allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_sets , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 call logger % info ( \"Generating k-way intersections (k=2 to \" // to_char ( actual_max_k ) // \")\" ) ! Loop over intersection levels k from 2 to actual_max_k do k = 2 , actual_max_k allocate ( combination ( k )) call generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_sets , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_sets , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , actual_max_k idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else allocate ( intersections ( 1 , 0 )) allocate ( intersection_sets ( 1 , 0 )) allocate ( intersection_levels ( 0 )) call logger % info ( \"No intersections found\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections_from_atom_lists","tags":"","url":"proc/generate_intersections_from_atom_lists.html"},{"title":"generate_k_way_intersections_for_level – metalquicha","text":"private recursive subroutine generate_k_way_intersections_for_level(sys_geom, monomers, n_monomers, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Uses mqc_physical_fragment proc~~generate_k_way_intersections_for_level~~UsesGraph proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level module~mqc_physical_fragment mqc_physical_fragment proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Helper to generate all k-way intersections at a specific level k Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count Calls proc~~generate_k_way_intersections_for_level~~CallsGraph proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~find_fragment_intersection find_fragment_intersection proc~generate_k_way_intersections_for_level->proc~find_fragment_intersection proc~next_combination next_combination proc~generate_k_way_intersections_for_level->proc~next_combination proc~next_combination_init next_combination_init proc~generate_k_way_intersections_for_level->proc~next_combination_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_k_way_intersections_for_level~~CalledByGraph proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: current_intersection (:) integer, private :: current_n_intersect integer, private :: frag_size logical, private :: has_intersection integer, private :: i integer, private :: j integer, private :: mono_idx integer, private, allocatable :: temp_intersection (:) integer, private :: temp_n_intersect Source Code recursive subroutine generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Helper to generate all k-way intersections at a specific level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:), n_monomers , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , mono_idx , frag_size logical :: has_intersection ! Generate combinations using an iterative approach call next_combination_init ( combination , k ) do ! Compute intersection of all fragments in this combination has_intersection = . false . ! Start with the first fragment in the combination mono_idx = monomers ( combination ( 1 )) frag_size = sys_geom % fragment_sizes ( mono_idx ) allocate ( current_intersection ( frag_size )) current_intersection = sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ) current_n_intersect = frag_size ! Intersect with each subsequent fragment do i = 2 , k mono_idx = monomers ( combination ( i )) frag_size = sys_geom % fragment_sizes ( mono_idx ) has_intersection = find_fragment_intersection ( & current_intersection , current_n_intersect , & sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ), frag_size , & temp_intersection , temp_n_intersect ) if (. not . has_intersection ) then ! Intersection is empty, break early deallocate ( current_intersection ) if ( allocated ( temp_intersection )) deallocate ( temp_intersection ) exit end if ! Replace current_intersection with the new intersection deallocate ( current_intersection ) allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection current_n_intersect = temp_n_intersect deallocate ( temp_intersection ) end do ! If we have a non-empty intersection, store it if ( has_intersection . and . allocated ( current_intersection )) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection temp_sets ( 1 : k , intersection_count ) = monomers ( combination ) temp_levels ( intersection_count ) = k deallocate ( current_intersection ) end if ! Get next combination if (. not . next_combination ( combination , k , n_monomers )) exit end do end subroutine generate_k_way_intersections_for_level","tags":"","url":"proc/generate_k_way_intersections_for_level.html"},{"title":"generate_k_way_intersections_from_lists – metalquicha","text":"private  subroutine generate_k_way_intersections_from_lists(atom_lists, n_atoms_list, n_sets, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Generate all k-way intersections from atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) integer, intent(in) :: n_atoms_list (:) integer, intent(in) :: n_sets integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count Calls proc~~generate_k_way_intersections_from_lists~~CallsGraph proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~next_combination next_combination proc~generate_k_way_intersections_from_lists->proc~next_combination proc~next_combination_init next_combination_init proc~generate_k_way_intersections_from_lists->proc~next_combination_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_k_way_intersections_from_lists~~CalledByGraph proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: current_intersection (:) integer, private :: current_n_intersect logical, private :: has_intersection integer, private :: i integer, private :: j integer, private :: set_idx integer, private, allocatable :: temp_intersection (:) integer, private :: temp_n_intersect Source Code subroutine generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Generate all k-way intersections from atom lists integer , intent ( in ) :: atom_lists (:, :), n_atoms_list (:), n_sets , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , set_idx logical :: has_intersection call next_combination_init ( combination , k ) do ! Compute intersection of all sets in this combination has_intersection = . false . ! Start with the first set in the combination set_idx = combination ( 1 ) allocate ( current_intersection ( n_atoms_list ( set_idx ))) current_intersection = atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) current_n_intersect = n_atoms_list ( set_idx ) ! Intersect with each subsequent set do i = 2 , k set_idx = combination ( i ) allocate ( temp_intersection ( current_n_intersect )) ! Find intersection temp_n_intersect = 0 do j = 1 , current_n_intersect if ( any ( atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) == current_intersection ( j ))) then temp_n_intersect = temp_n_intersect + 1 temp_intersection ( temp_n_intersect ) = current_intersection ( j ) end if end do ! Update current intersection deallocate ( current_intersection ) if ( temp_n_intersect > 0 ) then allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection ( 1 : temp_n_intersect ) current_n_intersect = temp_n_intersect has_intersection = . true . else has_intersection = . false . end if deallocate ( temp_intersection ) if (. not . has_intersection ) exit end do ! Store if we found an intersection if ( has_intersection . and . current_n_intersect > 0 ) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection ( 1 : current_n_intersect ) temp_sets ( 1 : k , intersection_count ) = combination ( 1 : k ) temp_levels ( intersection_count ) = k end if if ( allocated ( current_intersection )) deallocate ( current_intersection ) ! Get next combination if (. not . next_combination ( combination , k , n_sets )) exit end do end subroutine generate_k_way_intersections_from_lists","tags":"","url":"proc/generate_k_way_intersections_from_lists.html"},{"title":"grow_pie_storage – metalquicha","text":"private  subroutine grow_pie_storage(atom_sets, coefficients, max_terms, max_atoms) Grow PIE term storage arrays when capacity is exceeded. Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: atom_sets (:,:) integer, intent(inout), allocatable :: coefficients (:) integer(kind=int64), intent(inout) :: max_terms integer, intent(in) :: max_atoms Calls proc~~grow_pie_storage~~CallsGraph proc~grow_pie_storage grow_pie_storage error error proc~grow_pie_storage->error to_char to_char proc~grow_pie_storage->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~grow_pie_storage~~CalledByGraph proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~grow_pie_storage proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: max_default_int integer, private, allocatable :: new_atom_sets (:,:) integer, private, allocatable :: new_coefficients (:) integer(kind=int64), private :: new_max_terms integer(kind=default_int), private :: new_terms_i integer(kind=default_int), private :: old_terms_i Source Code subroutine grow_pie_storage ( atom_sets , coefficients , max_terms , max_atoms ) !! Grow PIE term storage arrays when capacity is exceeded. integer , allocatable , intent ( inout ) :: atom_sets (:, :) integer , allocatable , intent ( inout ) :: coefficients (:) integer ( int64 ), intent ( inout ) :: max_terms integer , intent ( in ) :: max_atoms integer ( int64 ) :: new_max_terms integer ( default_int ) :: old_terms_i , new_terms_i integer , allocatable :: new_atom_sets (:, :) integer , allocatable :: new_coefficients (:) integer ( int64 ) :: max_default_int max_default_int = int ( huge ( 0_default_int ), int64 ) new_max_terms = max_terms * 2_int64 if ( new_max_terms <= max_terms ) then call logger % error ( \"PIE term capacity overflow\" ) error stop \"PIE term capacity overflow\" end if if ( new_max_terms > max_default_int ) then new_max_terms = max_default_int end if if ( new_max_terms == max_terms ) then call logger % error ( \"Exceeded maximum PIE terms (\" // to_char ( max_terms ) // \")\" ) error stop \"Exceeded maximum PIE terms\" end if old_terms_i = int ( max_terms , default_int ) new_terms_i = int ( new_max_terms , default_int ) allocate ( new_atom_sets ( max_atoms , new_terms_i )) new_atom_sets = - 1 new_atom_sets (:, 1 : old_terms_i ) = atom_sets (:, 1 : old_terms_i ) allocate ( new_coefficients ( new_terms_i )) new_coefficients = 0 new_coefficients ( 1 : old_terms_i ) = coefficients ( 1 : old_terms_i ) call move_alloc ( new_atom_sets , atom_sets ) call move_alloc ( new_coefficients , coefficients ) max_terms = new_max_terms end subroutine grow_pie_storage","tags":"","url":"proc/grow_pie_storage.html"},{"title":"intersect_atom_lists – metalquicha","text":"private pure subroutine intersect_atom_lists(atoms1, n1, atoms2, n2, intersection, n_intersect) Compute intersection of two atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms1 (:) integer, intent(in) :: n1 integer, intent(in) :: atoms2 (:) integer, intent(in) :: n2 integer, intent(out) :: intersection (:) integer, intent(out) :: n_intersect Called by proc~~intersect_atom_lists~~CalledByGraph proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~intersect_atom_lists proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j Source Code pure subroutine intersect_atom_lists ( atoms1 , n1 , atoms2 , n2 , intersection , n_intersect ) !! Compute intersection of two atom lists integer , intent ( in ) :: atoms1 (:), n1 , atoms2 (:), n2 integer , intent ( out ) :: intersection (:) integer , intent ( out ) :: n_intersect integer :: i , j n_intersect = 0 do i = 1 , n1 if ( atoms1 ( i ) < 0 ) cycle do j = 1 , n2 if ( atoms2 ( j ) < 0 ) cycle if ( atoms1 ( i ) == atoms2 ( j )) then n_intersect = n_intersect + 1 intersection ( n_intersect ) = atoms1 ( i ) exit end if end do end do end subroutine intersect_atom_lists","tags":"","url":"proc/intersect_atom_lists.html"},{"title":"ends_with – metalquicha","text":"public  function ends_with(str, suffix) Check if string ends with suffix Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix Return Value logical Called by proc~~ends_with~~CalledByGraph proc~ends_with ends_with program~main main program~main->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: str_len integer, private :: suffix_len Source Code logical function ends_with ( str , suffix ) !! Check if string ends with suffix character ( len =* ), intent ( in ) :: str , suffix integer :: str_len , suffix_len str_len = len_trim ( str ) suffix_len = len_trim ( suffix ) if ( suffix_len > str_len ) then ends_with = . false . return end if ends_with = ( str ( str_len - suffix_len + 1 : str_len ) == suffix ) end function ends_with","tags":"","url":"proc/ends_with.html"},{"title":"get_basename – metalquicha","text":"public  function get_basename() result(basename) Get the base name without “output_” prefix and “.json” suffix\nExample: “output_w1.json” -> “w1” Arguments None Return Value character(len=256) Called by proc~~get_basename~~CalledByGraph proc~get_basename get_basename proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~print_detailed_breakdown_json->proc~get_basename proc~print_gmbe_json print_gmbe_json proc~print_gmbe_json->proc~get_basename proc~print_gmbe_pie_json print_gmbe_pie_json proc~print_gmbe_pie_json->proc~get_basename proc~print_unfragmented_json print_unfragmented_json proc~print_unfragmented_json->proc~get_basename proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_detailed_breakdown_json proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~print_unfragmented_json proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~print_unfragmented_json interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: end_pos integer, private :: start_pos Source Code function get_basename () result ( basename ) !! Get the base name without \"output_\" prefix and \".json\" suffix !! Example: \"output_w1.json\" -> \"w1\" character ( len = 256 ) :: basename integer :: start_pos , end_pos ! Remove \"output_\" prefix (7 characters) start_pos = 8 ! Find \".json\" suffix end_pos = index ( output_json_filename , '.json' , back = . true .) - 1 if ( end_pos > start_pos ) then basename = output_json_filename ( start_pos : end_pos ) else basename = \"unknown\" end if end function get_basename","tags":"","url":"proc/get_basename.html"},{"title":"get_molecule_name – metalquicha","text":"public  function get_molecule_name(filename) result(name) Extract molecule name from filename\nExample: “output_multi_structure_molecule_1.json” -> “molecule_1” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value character(len=256) Called by proc~~get_molecule_name~~CalledByGraph proc~get_molecule_name get_molecule_name proc~read_json_content read_json_content proc~read_json_content->proc~get_molecule_name proc~merge_multi_molecule_json merge_multi_molecule_json proc~merge_multi_molecule_json->proc~read_json_content proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: end_pos integer, private :: start_pos Source Code function get_molecule_name ( filename ) result ( name ) !! Extract molecule name from filename !! Example: \"output_multi_structure_molecule_1.json\" -> \"molecule_1\" character ( len =* ), intent ( in ) :: filename character ( len = 256 ) :: name integer :: start_pos , end_pos ! Find \"_molecule_\" or similar pattern start_pos = index ( filename , '_molecule_' ) if ( start_pos == 0 ) start_pos = index ( filename , '_mol_' ) if ( start_pos > 0 ) then start_pos = start_pos + 1 ! Skip leading underscore end_pos = index ( filename , '.json' ) - 1 if ( end_pos > start_pos ) then name = filename ( start_pos : end_pos ) else name = \"unknown\" end if else name = \"unknown\" end if end function get_molecule_name","tags":"","url":"proc/get_molecule_name.html"},{"title":"get_output_json_filename – metalquicha","text":"public  function get_output_json_filename() result(filename) Get the current JSON output filename Arguments None Return Value character(len=256) Called by proc~~get_output_json_filename~~CalledByGraph proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_gmbe_json print_gmbe_json proc~print_gmbe_json->proc~get_output_json_filename proc~print_gmbe_pie_json print_gmbe_pie_json proc~print_gmbe_pie_json->proc~get_output_json_filename proc~print_unfragmented_json print_unfragmented_json proc~print_unfragmented_json->proc~get_output_json_filename proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~get_output_json_filename proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_detailed_breakdown_json proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~print_unfragmented_json proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~print_unfragmented_json program~main main program~main->proc~run_multi_molecule_calculations program~main->proc~run_calculation interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_output_json_filename () result ( filename ) !! Get the current JSON output filename character ( len = 256 ) :: filename filename = trim ( output_json_filename ) end function get_output_json_filename","tags":"","url":"proc/get_output_json_filename.html"},{"title":"set_molecule_suffix – metalquicha","text":"public  subroutine set_molecule_suffix(suffix) Append a suffix to the output filename (e.g., for multi-molecule mode)\nExample: suffix=”_mol1” -> “output_multi_structure_mol1.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: suffix Called by proc~~set_molecule_suffix~~CalledByGraph proc~set_molecule_suffix set_molecule_suffix proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~set_molecule_suffix program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine set_molecule_suffix ( suffix ) !! Append a suffix to the output filename (e.g., for multi-molecule mode) !! Example: suffix=\"_mol1\" -> \"output_multi_structure_mol1.json\" character ( len =* ), intent ( in ) :: suffix if ( len_trim ( current_basename ) > 0 ) then output_json_filename = \"output_\" // trim ( current_basename ) // trim ( suffix ) // \".json\" end if end subroutine set_molecule_suffix","tags":"","url":"proc/set_molecule_suffix.html"},{"title":"set_output_json_filename – metalquicha","text":"public  subroutine set_output_json_filename(input_filename) Set the JSON output filename based on input filename\nExample: “water.mqc” -> “output_water.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_filename Called by proc~~set_output_json_filename~~CalledByGraph proc~set_output_json_filename set_output_json_filename program~main main program~main->proc~set_output_json_filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename integer, private :: dot_pos integer, private :: slash_pos Source Code subroutine set_output_json_filename ( input_filename ) !! Set the JSON output filename based on input filename !! Example: \"water.mqc\" -> \"output_water.json\" character ( len =* ), intent ( in ) :: input_filename integer :: dot_pos , slash_pos character ( len = 256 ) :: basename ! Find last slash (if any) to extract basename slash_pos = index ( input_filename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = input_filename ( slash_pos + 1 :) else basename = input_filename end if ! Find last dot to remove extension dot_pos = index ( basename , '.' , back = . true .) if ( dot_pos > 0 ) then basename = basename ( 1 : dot_pos - 1 ) end if ! Store basename for later use current_basename = trim ( basename ) ! Construct output filename: output_<basename>.json output_json_filename = \"output_\" // trim ( basename ) // \".json\" end subroutine set_output_json_filename","tags":"","url":"proc/set_output_json_filename.html"},{"title":"compute_mbe_delta – metalquicha","text":"private  function compute_mbe_delta(fragment_idx, fragment, lookup, energies, delta_energies, n) result(delta_E) Uses pic_io proc~~compute_mbe_delta~~UsesGraph proc~compute_mbe_delta compute_mbe_delta pic_io pic_io proc~compute_mbe_delta->pic_io Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas)\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all subset deltaE values\nAll subsets must have been computed already (guaranteed by processing fragments in order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Index of this fragment (already known) integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup Pre-built hash table for lookups real(kind=dp), intent(in) :: energies (:) Pre-computed delta values real(kind=dp), intent(in) :: delta_energies (:) Pre-computed delta values integer, intent(in) :: n Return Value real(kind=dp) Calls proc~~compute_mbe_delta~~CallsGraph proc~compute_mbe_delta compute_mbe_delta error error proc~compute_mbe_delta->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_delta~~CalledByGraph proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_delta proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_MBE_LEVEL = 10 logical, private :: has_next integer, private :: i integer, private :: indices (MAX_MBE_LEVEL) integer, private :: subset (MAX_MBE_LEVEL) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code function compute_mbe_delta ( fragment_idx , fragment , lookup , energies , delta_energies , n ) result ( delta_E ) !! Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas) !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all subset deltaE values !! All subsets must have been computed already (guaranteed by processing fragments in order) integer ( int64 ), intent ( in ) :: fragment_idx !! Index of this fragment (already known) integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup !! Pre-built hash table for lookups real ( dp ), intent ( in ) :: energies (:), delta_energies (:) !! Pre-computed delta values real ( dp ) :: delta_E ! Maximum MBE level supported (decamers) integer , parameter :: MAX_MBE_LEVEL = 10 integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer energy delta_E = energies ( fragment_idx ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx < 0 ) then block use pic_io , only : to_char character ( len = 512 ) :: error_msg integer :: j write ( error_msg , '(a,i0,a,*(i0,1x))' ) \"Subset not found! Fragment idx=\" , fragment_idx , & \" seeking subset: \" , ( subset ( j ), j = 1 , subset_size ) call logger % error ( trim ( error_msg )) write ( error_msg , '(a,*(i0,1x))' ) \"  Full fragment: \" , ( fragment ( j ), j = 1 , n ) call logger % error ( trim ( error_msg )) error stop \"Subset not found in bottom-up MBE!\" end block end if ! Subtract pre-computed delta energy delta_E = delta_E - delta_energies ( subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end function compute_mbe_delta","tags":"","url":"proc/compute_mbe_delta.html"},{"title":"compute_gmbe – metalquicha","text":"public  subroutine compute_gmbe(monomers, n_monomers, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, total_energy, sys_geom, total_gradient, total_hessian, bonds) Uses mqc_gmbe_utils mqc_config_parser mqc_result_types mqc_error mqc_physical_fragment proc~~compute_gmbe~~UsesGraph proc~compute_gmbe compute_gmbe module~mqc_config_parser mqc_config_parser proc~compute_gmbe->module~mqc_config_parser module~mqc_error mqc_error proc~compute_gmbe->module~mqc_error module~mqc_gmbe_utils mqc_gmbe_utils proc~compute_gmbe->module~mqc_gmbe_utils module~mqc_physical_fragment mqc_physical_fragment proc~compute_gmbe->module~mqc_physical_fragment module~mqc_result_types mqc_result_types proc~compute_gmbe->module~mqc_result_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_gmbe_utils->module~mqc_combinatorics pic_io pic_io module~mqc_gmbe_utils->pic_io pic_logger pic_logger module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute generalized many-body expansion (GMBE) energy with optional gradient and/or hessian This is the core routine that handles all GMBE computations using\nthe inclusion-exclusion principle for overlapping fragments.\nOptional arguments control what derivatives are computed:\n  - If sys_geom and total_gradient are present: compute gradient\n  - If total_hessian is also present: compute hessian Arguments Type Intent Optional Attributes Name integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers type( calculation_result_t ), intent(in) :: monomer_results (:) integer, intent(in) :: n_intersections type( calculation_result_t ), intent(in), optional :: intersection_results (:) integer, intent(in), optional :: intersection_sets (:,:) integer, intent(in), optional :: intersection_levels (:) real(kind=dp), intent(out) :: total_energy type( system_geometry_t ), intent(in), optional :: sys_geom real(kind=dp), intent(out), optional :: total_gradient (:,:) real(kind=dp), intent(out), optional :: total_hessian (:,:) type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~compute_gmbe~~CallsGraph proc~compute_gmbe compute_gmbe cart_disp cart_disp proc~compute_gmbe->cart_disp configuration configuration proc~compute_gmbe->configuration error error proc~compute_gmbe->error fc_mdyne fc_mdyne proc~compute_gmbe->fc_mdyne force_constants force_constants proc~compute_gmbe->force_constants frequencies frequencies proc~compute_gmbe->frequencies info info proc~compute_gmbe->info proc~build_fragment_from_indices build_fragment_from_indices proc~compute_gmbe->proc~build_fragment_from_indices proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_gmbe->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~compute_gmbe->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~compute_gmbe->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~compute_gmbe->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~compute_gmbe->proc~fragment_destroy proc~print_gmbe_energy_breakdown print_gmbe_energy_breakdown proc~compute_gmbe->proc~print_gmbe_energy_breakdown proc~print_gmbe_gradient_info print_gmbe_gradient_info proc~compute_gmbe->proc~print_gmbe_gradient_info proc~print_gmbe_intersection_debug print_gmbe_intersection_debug proc~compute_gmbe->proc~print_gmbe_intersection_debug proc~print_vibrational_analysis print_vibrational_analysis proc~compute_gmbe->proc~print_vibrational_analysis proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~redistribute_cap_gradients redistribute_cap_gradients proc~compute_gmbe->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~compute_gmbe->proc~redistribute_cap_hessian reduced_masses reduced_masses proc~compute_gmbe->reduced_masses to_char to_char proc~compute_gmbe->to_char proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~print_gmbe_energy_breakdown->info proc~print_gmbe_gradient_info->info proc~print_gmbe_gradient_info->to_char proc~print_gmbe_intersection_debug->proc~energy_total debug debug proc~print_gmbe_intersection_debug->debug proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol warning warning proc~print_vibrational_analysis->warning proc~process_intersection_derivatives->error proc~process_intersection_derivatives->proc~error_get_full_trace proc~process_intersection_derivatives->proc~error_has_error proc~process_intersection_derivatives->proc~fragment_destroy proc~process_intersection_derivatives->proc~redistribute_cap_gradients proc~process_intersection_derivatives->proc~redistribute_cap_hessian proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~find_fragment_intersection find_fragment_intersection proc~process_intersection_derivatives->proc~find_fragment_intersection proc~get_monomer_atom_list get_monomer_atom_list proc~process_intersection_derivatives->proc~get_monomer_atom_list proc~process_intersection_derivatives->warning proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_fragment_from_atom_list->proc~error_has_error proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~build_fragment_from_atom_list->proc~error_add_context proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: compute_grad logical, private :: compute_hess integer, private :: current_log_level type( error_t ), private :: error type( physical_fragment_t ), private :: fragment logical, private :: has_intersections integer, private :: hess_dim integer, private :: i integer, private :: k integer, private, allocatable :: level_counts (:) real(kind=dp), private, allocatable :: level_energies (:) integer, private :: max_level real(kind=dp), private :: monomer_energy integer, private, allocatable :: monomer_idx (:) real(kind=dp), private :: sign_factor Source Code subroutine compute_gmbe ( monomers , n_monomers , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , & total_energy , & sys_geom , total_gradient , total_hessian , bonds ) !! Compute generalized many-body expansion (GMBE) energy with optional gradient and/or hessian !! !! This is the core routine that handles all GMBE computations using !! the inclusion-exclusion principle for overlapping fragments. !! Optional arguments control what derivatives are computed: !!   - If sys_geom and total_gradient are present: compute gradient !!   - If total_hessian is also present: compute hessian use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_indices , build_fragment_from_atom_list , & redistribute_cap_gradients , redistribute_cap_hessian use mqc_gmbe_utils , only : find_fragment_intersection use mqc_config_parser , only : bond_t use mqc_error , only : error_t ! Required arguments integer , intent ( in ) :: monomers (:) integer , intent ( in ) :: n_monomers type ( calculation_result_t ), intent ( in ) :: monomer_results (:) integer , intent ( in ) :: n_intersections type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) integer , intent ( in ), optional :: intersection_sets (:, :) integer , intent ( in ), optional :: intersection_levels (:) real ( dp ), intent ( out ) :: total_energy ! Optional arguments for gradient computation type ( system_geometry_t ), intent ( in ), optional :: sys_geom real ( dp ), intent ( out ), optional :: total_gradient (:, :) ! Optional arguments for hessian computation real ( dp ), intent ( out ), optional :: total_hessian (:, :) ! Optional bond information for hydrogen cap handling type ( bond_t ), intent ( in ), optional :: bonds (:) ! Local variables integer :: i , k , max_level , current_log_level , hess_dim real ( dp ) :: monomer_energy , sign_factor real ( dp ), allocatable :: level_energies (:) integer , allocatable :: level_counts (:) type ( physical_fragment_t ) :: fragment type ( error_t ) :: error integer , allocatable :: monomer_idx (:) logical :: compute_grad , compute_hess , has_intersections ! Determine what to compute based on optional arguments compute_grad = present ( sys_geom ) . and . present ( total_gradient ) compute_hess = compute_grad . and . present ( total_hessian ) has_intersections = n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels ) ! Initialize outputs if ( compute_grad ) then total_gradient = 0.0_dp end if if ( compute_hess ) then total_hessian = 0.0_dp hess_dim = 3 * sys_geom % total_atoms end if ! Sum monomer energies (and gradients/hessians if requested) monomer_energy = 0.0_dp do i = 1 , n_monomers monomer_energy = monomer_energy + monomer_results ( i )% energy % total () ! Accumulate monomer derivatives if requested if ( compute_grad . and . monomer_results ( i )% has_gradient ) then allocate ( monomer_idx ( 1 )) monomer_idx ( 1 ) = monomers ( i ) call build_fragment_from_indices ( sys_geom , monomer_idx , fragment , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build monomer fragment in GMBE\" end if call redistribute_cap_gradients ( fragment , monomer_results ( i )% gradient , total_gradient ) if ( compute_hess . and . monomer_results ( i )% has_hessian ) then call redistribute_cap_hessian ( fragment , monomer_results ( i )% hessian , total_hessian ) end if call fragment % destroy () deallocate ( monomer_idx ) end if end do ! Start with monomer contribution total_energy = monomer_energy ! Handle intersections with inclusion-exclusion if ( has_intersections ) then max_level = maxval ( intersection_levels ) allocate ( level_energies ( 2 : max_level )) allocate ( level_counts ( 2 : max_level )) level_energies = 0.0_dp level_counts = 0 ! Process intersection energies and derivatives do i = 1 , n_intersections k = intersection_levels ( i ) sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) level_energies ( k ) = level_energies ( k ) + intersection_results ( i )% energy % total () level_counts ( k ) = level_counts ( k ) + 1 ! Handle intersection derivatives if requested if ( compute_grad . and . ( intersection_results ( i )% has_gradient . or . & ( compute_hess . and . intersection_results ( i )% has_hessian ))) then call process_intersection_derivatives ( i , k , sign_factor , intersection_results , & intersection_sets , sys_geom , total_gradient , total_hessian , bonds , & compute_grad , compute_hess , hess_dim ) end if end do ! Apply inclusion-exclusion to energy do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) total_energy = total_energy + sign_factor * level_energies ( k ) end if end do ! Print energy breakdown call print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & max_level , total_energy , . true .) ! Print debug info for intersections call print_gmbe_intersection_debug ( n_intersections , n_monomers , intersection_sets , & intersection_levels , intersection_results ) deallocate ( level_energies , level_counts ) else ! No intersections - just print monomer sum call print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & 0 , total_energy , . false .) end if ! Print gradient/hessian info if ( compute_grad ) then call logger % configuration ( level = current_log_level ) call print_gmbe_gradient_info ( total_gradient , sys_geom , current_log_level ) end if if ( compute_hess ) then call logger % info ( \"GMBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if end subroutine compute_gmbe","tags":"","url":"proc/compute_gmbe.html"},{"title":"compute_mbe – metalquicha","text":"public  subroutine compute_mbe(polymers, fragment_count, max_level, results, total_energy, sys_geom, total_gradient, total_hessian, bonds) Uses mqc_config_parser mqc_result_types proc~~compute_mbe~~UsesGraph proc~compute_mbe compute_mbe module~mqc_config_parser mqc_config_parser proc~compute_mbe->module~mqc_config_parser module~mqc_result_types mqc_result_types proc~compute_mbe->module~mqc_result_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute many-body expansion (MBE) energy with optional gradient and/or hessian This is the core routine that handles all MBE computations.\nOptional arguments control what derivatives are computed:\n  - If sys_geom and total_gradient are present: compute gradient\n  - If total_hessian is also present: compute hessian Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(out) :: total_energy type( system_geometry_t ), intent(in), optional :: sys_geom real(kind=dp), intent(out), optional :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(out), optional :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~compute_mbe~~CallsGraph proc~compute_mbe compute_mbe cart_disp cart_disp proc~compute_mbe->cart_disp configuration configuration proc~compute_mbe->configuration error error proc~compute_mbe->error fc_mdyne fc_mdyne proc~compute_mbe->fc_mdyne force_constants force_constants proc~compute_mbe->force_constants frequencies frequencies proc~compute_mbe->frequencies info info proc~compute_mbe->info proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_mbe->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~compute_mbe->proc~energy_total proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe->proc~print_detailed_breakdown_json proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis reduced_masses reduced_masses proc~compute_mbe->reduced_masses to_char to_char proc~compute_mbe->to_char proc~build_mbe_lookup_table->to_char debug debug proc~build_mbe_lookup_table->debug get_elapsed_time get_elapsed_time proc~build_mbe_lookup_table->get_elapsed_time proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert start start proc~build_mbe_lookup_table->start proc~compute_mbe_delta->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->debug proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~map_fragment_to_system_gradient->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name verbose verbose proc~print_detailed_breakdown->verbose warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->info proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->warning proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal proc~fragment_lookup_insert->fnv_1a_hash proc~fragment_lookup_insert->sort proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe~~CalledByGraph proc~compute_mbe compute_mbe proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: compute_grad logical, private :: compute_hess integer, private :: current_log_level real(kind=dp), private :: delta_E real(kind=dp), private, allocatable :: delta_energies (:) real(kind=dp), private, allocatable :: delta_gradients (:,:,:) real(kind=dp), private, allocatable :: delta_hessians (:,:,:) logical, private :: do_detailed_print real(kind=dp), private, allocatable :: energies (:) integer, private :: fragment_size integer, private :: hess_dim integer(kind=int64), private :: i type( fragment_lookup_t ), private :: lookup integer, private :: nlevel real(kind=dp), private, allocatable :: sum_by_level (:) Source Code subroutine compute_mbe ( polymers , fragment_count , max_level , results , & total_energy , & sys_geom , total_gradient , total_hessian , bonds ) !! Compute many-body expansion (MBE) energy with optional gradient and/or hessian !! !! This is the core routine that handles all MBE computations. !! Optional arguments control what derivatives are computed: !!   - If sys_geom and total_gradient are present: compute gradient !!   - If total_hessian is also present: compute hessian use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t ! Required arguments integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( out ) :: total_energy ! Optional arguments for gradient computation type ( system_geometry_t ), intent ( in ), optional :: sys_geom real ( dp ), intent ( out ), optional :: total_gradient (:, :) !! (3, total_atoms) ! Optional arguments for hessian computation real ( dp ), intent ( out ), optional :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) ! Optional bond information for hydrogen cap handling type ( bond_t ), intent ( in ), optional :: bonds (:) ! Local variables integer ( int64 ) :: i integer :: fragment_size , nlevel , current_log_level , hess_dim real ( dp ), allocatable :: sum_by_level (:), delta_energies (:), energies (:) real ( dp ), allocatable :: delta_gradients (:, :, :), delta_hessians (:, :, :) real ( dp ) :: delta_E logical :: do_detailed_print , compute_grad , compute_hess type ( fragment_lookup_t ) :: lookup ! Determine what to compute based on optional arguments compute_grad = present ( sys_geom ) . and . present ( total_gradient ) compute_hess = compute_grad . and . present ( total_hessian ) ! Validate inputs for gradient computation if ( compute_grad ) then do i = 1_int64 , fragment_count if (. not . results ( i )% has_gradient ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have gradient!\" ) error stop \"Missing gradient in compute_mbe_internal\" end if end do end if ! Validate inputs for hessian computation if ( compute_hess ) then do i = 1_int64 , fragment_count if (. not . results ( i )% has_hessian ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have Hessian!\" ) error stop \"Missing Hessian in compute_mbe_internal\" end if end do hess_dim = 3 * sys_geom % total_atoms end if ! Get logger configuration call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) ! Allocate energy arrays (always needed) allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) allocate ( energies ( fragment_count )) sum_by_level = 0.0_dp delta_energies = 0.0_dp ! Extract total energies from results do i = 1_int64 , fragment_count energies ( i ) = results ( i )% energy % total () end do ! Allocate gradient arrays if needed if ( compute_grad ) then allocate ( delta_gradients ( 3 , sys_geom % total_atoms , fragment_count )) delta_gradients = 0.0_dp total_gradient = 0.0_dp end if ! Allocate hessian arrays if needed if ( compute_hess ) then allocate ( delta_hessians ( hess_dim , hess_dim , fragment_count )) delta_hessians = 0.0_dp total_hessian = 0.0_dp end if ! Build hash table for fast fragment lookups call build_mbe_lookup_table ( polymers , fragment_count , max_level , lookup ) ! Bottom-up computation: process fragments by size (1-body, then 2-body, etc.) ! This makes the algorithm independent of input fragment order ! We process by n-mer level to ensure all subsets are computed before they're needed do nlevel = 1 , max_level do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) ! Only process fragments of the current nlevel if ( fragment_size /= nlevel ) cycle if ( fragment_size == 1 ) then ! 1-body: delta = value (no subsets to subtract) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) if ( compute_grad ) then call map_fragment_to_system_gradient ( results ( i )% gradient , & polymers ( i , 1 : fragment_size ), sys_geom , delta_gradients (:, :, i ), bonds ) end if if ( compute_hess ) then call map_fragment_to_system_hessian ( results ( i )% hessian , & polymers ( i , 1 : fragment_size ), sys_geom , delta_hessians (:, :, i ), bonds ) end if else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: delta = value - sum(all subset deltas) delta_E = compute_mbe_delta ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E if ( compute_grad ) then call compute_mbe_gradient ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_gradients , fragment_size , sys_geom , bonds ) end if if ( compute_hess ) then call compute_mbe_hessian ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_hessians , fragment_size , sys_geom , bonds ) end if end if end do end do ! Clean up lookup table call lookup % destroy () ! Compute totals total_energy = sum ( sum_by_level ) if ( compute_grad ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then total_gradient = total_gradient + delta_gradients (:, :, i ) end if end do end if if ( compute_hess ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then total_hessian = total_hessian + delta_hessians (:, :, i ) end if end do end if ! Print energy breakdown (always) call print_mbe_energy_breakdown ( sum_by_level , max_level , total_energy ) ! Print gradient info if computed if ( compute_grad ) then call print_mbe_gradient_info ( total_gradient , sys_geom , current_log_level ) end if ! Print hessian info if computed if ( compute_hess ) then call logger % info ( \"MBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if ! Print detailed breakdown if requested if ( do_detailed_print ) then call print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) end if ! Write JSON output with appropriate arguments if ( compute_hess ) then call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy , total_gradient , total_hessian , results ) else if ( compute_grad ) then call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy , total_gradient , results = results ) else call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy , results = results ) end if ! Cleanup deallocate ( sum_by_level , delta_energies , energies ) if ( allocated ( delta_gradients )) deallocate ( delta_gradients ) if ( allocated ( delta_hessians )) deallocate ( delta_hessians ) end subroutine compute_mbe","tags":"","url":"proc/compute_mbe.html"},{"title":"build_mbe_lookup_table – metalquicha","text":"private  subroutine build_mbe_lookup_table(polymers, fragment_count, max_level, lookup) Build hash table for fast fragment lookups Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( fragment_lookup_t ), intent(inout) :: lookup Calls proc~~build_mbe_lookup_table~~CallsGraph proc~build_mbe_lookup_table build_mbe_lookup_table debug debug proc~build_mbe_lookup_table->debug get_elapsed_time get_elapsed_time proc~build_mbe_lookup_table->get_elapsed_time proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert start start proc~build_mbe_lookup_table->start to_char to_char proc~build_mbe_lookup_table->to_char proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_mbe_lookup_table~~CalledByGraph proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe compute_mbe proc~compute_mbe->proc~build_mbe_lookup_table proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: fragment_size integer(kind=int64), private :: i type(timer_type), private :: lookup_timer Source Code subroutine build_mbe_lookup_table ( polymers , fragment_count , max_level , lookup ) !! Build hash table for fast fragment lookups integer , intent ( in ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: max_level type ( fragment_lookup_t ), intent ( inout ) :: lookup integer ( int64 ) :: i integer :: fragment_size type ( timer_type ) :: lookup_timer call lookup_timer % start () call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) call lookup % insert ( polymers ( i , :), fragment_size , i ) end do call lookup_timer % stop () call logger % debug ( \"Time to build lookup table: \" // to_char ( lookup_timer % get_elapsed_time ()) // \" s\" ) call logger % debug ( \"Hash table size: \" // to_char ( lookup % table_size ) // & \", entries: \" // to_char ( lookup % n_entries )) end subroutine build_mbe_lookup_table","tags":"","url":"proc/build_mbe_lookup_table.html"},{"title":"compute_mbe_gradient – metalquicha","text":"private  subroutine compute_mbe_gradient(fragment_idx, fragment, lookup, results, delta_gradients, n, sys_geom, bonds) Uses mqc_config_parser mqc_result_types proc~~compute_mbe_gradient~~UsesGraph proc~compute_mbe_gradient compute_mbe_gradient module~mqc_config_parser mqc_config_parser proc~compute_mbe_gradient->module~mqc_config_parser module~mqc_result_types mqc_result_types proc~compute_mbe_gradient->module~mqc_result_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Bottom-up computation of n-body gradient correction\nExactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs)\nAll gradients are in system coordinates, so subtraction is simple Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_gradients (:,:,:) (3, total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps Calls proc~~compute_mbe_gradient~~CallsGraph proc~compute_mbe_gradient compute_mbe_gradient proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_gradient->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_gradient->proc~get_next_combination proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort configuration configuration proc~map_fragment_to_system_gradient->configuration debug debug proc~map_fragment_to_system_gradient->debug error error proc~map_fragment_to_system_gradient->error proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~map_fragment_to_system_gradient->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_gradient~~CalledByGraph proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_gradient proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_MBE_LEVEL = 10 logical, private :: has_next integer, private :: i integer, private :: indices (MAX_MBE_LEVEL) integer, private :: subset (MAX_MBE_LEVEL) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code subroutine compute_mbe_gradient ( fragment_idx , fragment , lookup , results , delta_gradients , n , sys_geom , bonds ) !! Bottom-up computation of n-body gradient correction !! Exactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs) !! All gradients are in system coordinates, so subtraction is simple use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_gradients (:, :, :) !! (3, total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps ! Maximum MBE level supported (decamers) integer , parameter :: MAX_MBE_LEVEL = 10 integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer gradient mapped to system coordinates call map_fragment_to_system_gradient ( results ( fragment_idx )% gradient , fragment , & sys_geom , delta_gradients (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) ! This is EXACTLY like the energy calculation, but for each gradient component do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx < 0 ) error stop \"Subset not found in MBE gradient!\" ! Subtract pre-computed delta gradient (simple array subtraction in system coords) delta_gradients (:, :, fragment_idx ) = delta_gradients (:, :, fragment_idx ) - & delta_gradients (:, :, subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end subroutine compute_mbe_gradient","tags":"","url":"proc/compute_mbe_gradient.html"},{"title":"compute_mbe_hessian – metalquicha","text":"private  subroutine compute_mbe_hessian(fragment_idx, fragment, lookup, results, delta_hessians, n, sys_geom, bonds) Uses mqc_config_parser mqc_result_types mqc_error proc~~compute_mbe_hessian~~UsesGraph proc~compute_mbe_hessian compute_mbe_hessian module~mqc_config_parser mqc_config_parser proc~compute_mbe_hessian->module~mqc_config_parser module~mqc_error mqc_error proc~compute_mbe_hessian->module~mqc_error module~mqc_result_types mqc_result_types proc~compute_mbe_hessian->module~mqc_result_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Bottom-up computation of n-body Hessian correction\nMirrors MBE gradient logic but for second derivatives Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_hessians (:,:,:) (3 total_atoms, 3 total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~compute_mbe_hessian~~CallsGraph proc~compute_mbe_hessian compute_mbe_hessian proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_hessian->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_hessian->proc~get_next_combination proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_indices->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_hessian~~CalledByGraph proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_MBE_LEVEL = 10 logical, private :: has_next integer, private :: hess_dim integer, private :: i integer, private :: indices (MAX_MBE_LEVEL) integer, private :: subset (MAX_MBE_LEVEL) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code subroutine compute_mbe_hessian ( fragment_idx , fragment , lookup , results , delta_hessians , n , sys_geom , bonds ) !! Bottom-up computation of n-body Hessian correction !! Mirrors MBE gradient logic but for second derivatives use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t use mqc_error , only : error_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_hessians (:, :, :) !! (3*total_atoms, 3*total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) ! Maximum MBE level supported (decamers) integer , parameter :: MAX_MBE_LEVEL = 10 integer :: subset_size , i , hess_dim integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next hess_dim = 3 * sys_geom % total_atoms ! Start with the full n-mer Hessian mapped to system coordinates call map_fragment_to_system_hessian ( results ( fragment_idx )% hessian , fragment , & sys_geom , delta_hessians (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do has_next = . true . do while ( has_next ) do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx > 0 ) then ! Subtract this subset's delta Hessian delta_hessians (:, :, fragment_idx ) = delta_hessians (:, :, fragment_idx ) - & delta_hessians (:, :, subset_idx ) end if call get_next_combination ( indices , subset_size , n , has_next ) end do end do end subroutine compute_mbe_hessian","tags":"","url":"proc/compute_mbe_hessian.html"},{"title":"get_monomer_atom_list – metalquicha","text":"private  subroutine get_monomer_atom_list(sys_geom, monomer_idx, atom_list, n_atoms) Build 0-indexed atom list for a monomer, handling fixed or variable-sized fragments. Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_idx integer, intent(out), allocatable :: atom_list (:) integer, intent(out) :: n_atoms Called by proc~~get_monomer_atom_list~~CalledByGraph proc~get_monomer_atom_list get_monomer_atom_list proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->proc~get_monomer_atom_list proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~process_intersection_derivatives Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: base_idx integer, private :: i Source Code subroutine get_monomer_atom_list ( sys_geom , monomer_idx , atom_list , n_atoms ) !! Build 0-indexed atom list for a monomer, handling fixed or variable-sized fragments. type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_idx integer , allocatable , intent ( out ) :: atom_list (:) integer , intent ( out ) :: n_atoms integer :: i , base_idx if ( allocated ( sys_geom % fragment_atoms )) then n_atoms = sys_geom % fragment_sizes ( monomer_idx ) if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = sys_geom % fragment_atoms ( 1 : n_atoms , monomer_idx ) else allocate ( atom_list ( 0 )) end if else n_atoms = sys_geom % atoms_per_monomer if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) base_idx = ( monomer_idx - 1 ) * sys_geom % atoms_per_monomer do i = 1 , n_atoms atom_list ( i ) = base_idx + ( i - 1 ) end do else allocate ( atom_list ( 0 )) end if end if end subroutine get_monomer_atom_list","tags":"","url":"proc/get_monomer_atom_list.html"},{"title":"map_fragment_to_system_gradient – metalquicha","text":"private  subroutine map_fragment_to_system_gradient(frag_grad, monomers, sys_geom, sys_grad, bonds) Uses pic_logger mqc_physical_fragment mqc_config_parser mqc_error proc~~map_fragment_to_system_gradient~~UsesGraph proc~map_fragment_to_system_gradient map_fragment_to_system_gradient module~mqc_config_parser mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_config_parser module~mqc_error mqc_error proc~map_fragment_to_system_gradient->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment proc~map_fragment_to_system_gradient->module~mqc_physical_fragment pic_logger pic_logger proc~map_fragment_to_system_gradient->pic_logger module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Map fragment gradient to system gradient coordinates with hydrogen cap redistribution This function rebuilds the fragment to get local→global mappings and cap information,\nthen redistributes gradients including hydrogen caps to their original atoms. If bonds are not present, uses the old simple mapping (no caps possible). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_grad (:,:) (3, natoms_frag) integer, intent(in) :: monomers (:) Monomer indices in fragment type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_grad (:,:) (3, total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps Calls proc~~map_fragment_to_system_gradient~~CallsGraph proc~map_fragment_to_system_gradient map_fragment_to_system_gradient configuration configuration proc~map_fragment_to_system_gradient->configuration debug debug proc~map_fragment_to_system_gradient->debug error error proc~map_fragment_to_system_gradient->error proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~map_fragment_to_system_gradient->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~map_fragment_to_system_gradient~~CalledByGraph proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: current_log_level type( error_t ), private :: error integer, private :: frag_atom_idx type( physical_fragment_t ), private :: fragment integer, private :: i_atom integer, private :: i_mon integer, private :: sys_atom_idx Source Code subroutine map_fragment_to_system_gradient ( frag_grad , monomers , sys_geom , sys_grad , bonds ) !! Map fragment gradient to system gradient coordinates with hydrogen cap redistribution !! !! This function rebuilds the fragment to get local→global mappings and cap information, !! then redistributes gradients including hydrogen caps to their original atoms. !! !! If bonds are not present, uses the old simple mapping (no caps possible). use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_gradients use mqc_config_parser , only : bond_t use mqc_error , only : error_t use pic_logger , only : verbose_level real ( dp ), intent ( in ) :: frag_grad (:, :) !! (3, natoms_frag) integer , intent ( in ) :: monomers (:) !! Monomer indices in fragment type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_grad (:, :) !! (3, total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps type ( physical_fragment_t ) :: fragment type ( error_t ) :: error integer :: i_mon , i_atom , frag_atom_idx , sys_atom_idx integer :: current_log_level ! Explicitly zero out the entire sys_grad array sys_grad = 0.0_dp ! Debug output call logger % configuration ( level = current_log_level ) if ( current_log_level >= debug_level ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,*(i0,1x))' ) \"  Mapping fragment with \" , size ( monomers ), \" monomers: \" , monomers call logger % debug ( trim ( debug_msg )) write ( debug_msg , '(a,i0,a)' ) \"  Fragment has \" , size ( frag_grad , 2 ), \" atoms\" call logger % debug ( trim ( debug_msg )) end block end if if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build fragment in gradient mapping\" end if ! Use new gradient redistribution with cap handling call redistribute_cap_gradients ( fragment , frag_grad , sys_grad ) ! Clean up call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment gradient to system positions (fixed-size monomers only) frag_atom_idx = 0 do i_mon = 1 , size ( monomers ) do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_idx = frag_atom_idx + 1 sys_atom_idx = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom if ( current_log_level >= debug_level . and . i_atom == 1 ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,i0,a,i0)' ) & \"    Monomer \" , monomers ( i_mon ), \": frag atoms \" , & frag_atom_idx , \" -> sys atom \" , sys_atom_idx call logger % debug ( trim ( debug_msg )) end block end if sys_grad (:, sys_atom_idx ) = frag_grad (:, frag_atom_idx ) end do end do end if end subroutine map_fragment_to_system_gradient","tags":"","url":"proc/map_fragment_to_system_gradient.html"},{"title":"map_fragment_to_system_hessian – metalquicha","text":"private  subroutine map_fragment_to_system_hessian(frag_hess, monomers, sys_geom, sys_hess, bonds) Uses mqc_physical_fragment mqc_config_parser mqc_error proc~~map_fragment_to_system_hessian~~UsesGraph proc~map_fragment_to_system_hessian map_fragment_to_system_hessian module~mqc_config_parser mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_config_parser module~mqc_error mqc_error proc~map_fragment_to_system_hessian->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment proc~map_fragment_to_system_hessian->module~mqc_physical_fragment module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_hess (:,:) (3 natoms_frag, 3 natoms_frag) integer, intent(in) :: monomers (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_hess (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~map_fragment_to_system_hessian~~CallsGraph proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_indices->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~map_fragment_to_system_hessian~~CalledByGraph proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( error_t ), private :: error type( physical_fragment_t ), private :: fragment Source Code subroutine map_fragment_to_system_hessian ( frag_hess , monomers , sys_geom , sys_hess , bonds ) !! Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_hessian use mqc_config_parser , only : bond_t use mqc_error , only : error_t real ( dp ), intent ( in ) :: frag_hess (:, :) !! (3*natoms_frag, 3*natoms_frag) integer , intent ( in ) :: monomers (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_hess (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: fragment type ( error_t ) :: error ! Zero out sys_hess = 0.0_dp if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , error , bonds ) call redistribute_cap_hessian ( fragment , frag_hess , sys_hess ) call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment Hessian to system positions (fixed-size monomers only) block integer :: i_mon , j_mon , i_atom , j_atom integer :: frag_atom_i , frag_atom_j , sys_atom_i , sys_atom_j integer :: frag_row_start , frag_col_start , sys_row_start , sys_col_start integer :: n_monomers n_monomers = size ( monomers ) frag_atom_i = 0 ! Map each monomer's atoms do i_mon = 1 , n_monomers do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_i = frag_atom_i + 1 sys_atom_i = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom frag_row_start = ( frag_atom_i - 1 ) * 3 + 1 sys_row_start = ( sys_atom_i - 1 ) * 3 + 1 ! Map this atom's Hessian blocks with all other atoms in fragment frag_atom_j = 0 do j_mon = 1 , n_monomers do j_atom = 1 , sys_geom % atoms_per_monomer frag_atom_j = frag_atom_j + 1 sys_atom_j = ( monomers ( j_mon ) - 1 ) * sys_geom % atoms_per_monomer + j_atom frag_col_start = ( frag_atom_j - 1 ) * 3 + 1 sys_col_start = ( sys_atom_j - 1 ) * 3 + 1 ! Copy the 3×3 block for this atom pair sys_hess ( sys_row_start : sys_row_start + 2 , sys_col_start : sys_col_start + 2 ) = & frag_hess ( frag_row_start : frag_row_start + 2 , frag_col_start : frag_col_start + 2 ) end do end do end do end do end block end if end subroutine map_fragment_to_system_hessian","tags":"","url":"proc/map_fragment_to_system_hessian.html"},{"title":"print_gmbe_energy_breakdown – metalquicha","text":"private  subroutine print_gmbe_energy_breakdown(monomer_energy, n_monomers, level_energies, level_counts, max_level, total_energy, has_intersections) Print GMBE energy breakdown using inclusion-exclusion principle Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: monomer_energy integer, intent(in) :: n_monomers real(kind=dp), intent(in), optional :: level_energies (:) integer, intent(in), optional :: level_counts (:) integer, intent(in) :: max_level real(kind=dp), intent(in) :: total_energy logical, intent(in) :: has_intersections Calls proc~~print_gmbe_energy_breakdown~~CallsGraph proc~print_gmbe_energy_breakdown print_gmbe_energy_breakdown info info proc~print_gmbe_energy_breakdown->info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_gmbe_energy_breakdown~~CalledByGraph proc~print_gmbe_energy_breakdown print_gmbe_energy_breakdown proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_gmbe_energy_breakdown Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: k character(len=256), private :: line real(kind=dp), private :: sign_factor Source Code subroutine print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & max_level , total_energy , has_intersections ) !! Print GMBE energy breakdown using inclusion-exclusion principle real ( dp ), intent ( in ) :: monomer_energy integer , intent ( in ) :: n_monomers real ( dp ), intent ( in ), optional :: level_energies (:) integer , intent ( in ), optional :: level_counts (:) integer , intent ( in ) :: max_level real ( dp ), intent ( in ) :: total_energy logical , intent ( in ) :: has_intersections integer :: k real ( dp ) :: sign_factor character ( len = 256 ) :: line if ( has_intersections ) then call logger % info ( \"GMBE Energy breakdown (Inclusion-Exclusion Principle):\" ) write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"):  \" , monomer_energy call logger % info ( trim ( line )) do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) if ( sign_factor > 0.0_dp ) then write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  +\" , level_energies ( k ) else write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  \" , level_energies ( k ) end if call logger % info ( trim ( line )) end if end do write ( line , '(a,f20.10)' ) \"  Total GMBE:      \" , total_energy call logger % info ( trim ( line )) else call logger % info ( \"GMBE Energy breakdown:\" ) write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"): \" , monomer_energy call logger % info ( trim ( line )) write ( line , '(a,f20.10)' ) \"  Total GMBE:  \" , total_energy call logger % info ( trim ( line )) end if end subroutine print_gmbe_energy_breakdown","tags":"","url":"proc/print_gmbe_energy_breakdown.html"},{"title":"print_gmbe_gradient_info – metalquicha","text":"private  subroutine print_gmbe_gradient_info(total_gradient, sys_geom, current_log_level) Print GMBE gradient information Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_gradient (:,:) type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: current_log_level Calls proc~~print_gmbe_gradient_info~~CallsGraph proc~print_gmbe_gradient_info print_gmbe_gradient_info info info proc~print_gmbe_gradient_info->info to_char to_char proc~print_gmbe_gradient_info->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_gmbe_gradient_info~~CalledByGraph proc~print_gmbe_gradient_info print_gmbe_gradient_info proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_gmbe_gradient_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: grad_line integer, private :: iatom Source Code subroutine print_gmbe_gradient_info ( total_gradient , sys_geom , current_log_level ) !! Print GMBE gradient information real ( dp ), intent ( in ) :: total_gradient (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: current_log_level integer :: iatom character ( len = 256 ) :: grad_line call logger % info ( \"GMBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end do call logger % info ( \" \" ) end if end subroutine print_gmbe_gradient_info","tags":"","url":"proc/print_gmbe_gradient_info.html"},{"title":"print_gmbe_intersection_debug – metalquicha","text":"private  subroutine print_gmbe_intersection_debug(n_intersections, n_monomers, intersection_sets, intersection_levels, intersection_results) Uses mqc_result_types proc~~print_gmbe_intersection_debug~~UsesGraph proc~print_gmbe_intersection_debug print_gmbe_intersection_debug module~mqc_result_types mqc_result_types proc~print_gmbe_intersection_debug->module~mqc_result_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib pic_types pic_types module~mqc_result_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Print debug information about GMBE intersections Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_intersections integer, intent(in) :: n_monomers integer, intent(in) :: intersection_sets (:,:) integer, intent(in) :: intersection_levels (:) type( calculation_result_t ), intent(in) :: intersection_results (:) Calls proc~~print_gmbe_intersection_debug~~CallsGraph proc~print_gmbe_intersection_debug print_gmbe_intersection_debug debug debug proc~print_gmbe_intersection_debug->debug proc~energy_total energy_t%energy_total proc~print_gmbe_intersection_debug->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_gmbe_intersection_debug~~CalledByGraph proc~print_gmbe_intersection_debug print_gmbe_intersection_debug proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_gmbe_intersection_debug Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=512), private :: detail_line integer, private :: i integer, private :: j integer, private :: set_size character(len=256), private :: set_str real(kind=dp), private :: sign_factor Source Code subroutine print_gmbe_intersection_debug ( n_intersections , n_monomers , intersection_sets , & intersection_levels , intersection_results ) !! Print debug information about GMBE intersections use mqc_result_types , only : calculation_result_t integer , intent ( in ) :: n_intersections , n_monomers integer , intent ( in ) :: intersection_sets (:, :) integer , intent ( in ) :: intersection_levels (:) type ( calculation_result_t ), intent ( in ) :: intersection_results (:) integer :: i , j , set_size real ( dp ) :: sign_factor character ( len = 512 ) :: detail_line character ( len = 256 ) :: set_str if ( n_intersections > 0 ) then call logger % debug ( \"GMBE intersection details:\" ) do i = 1 , n_intersections set_str = \"(\" set_size = 0 do j = 1 , n_monomers if ( intersection_sets ( j , i ) > 0 ) then if ( set_size > 0 ) set_str = trim ( set_str ) // \",\" write ( set_str , '(a,i0)' ) trim ( set_str ), intersection_sets ( j , i ) set_size = set_size + 1 end if end do set_str = trim ( set_str ) // \")\" sign_factor = real (( - 1 ) ** ( intersection_levels ( i ) + 1 ), dp ) write ( detail_line , '(a,i0,a,i0,a,a,a,f16.8)' ) & \"  Intersection \" , i , \": level=\" , intersection_levels ( i ), & \" fragments=\" , trim ( set_str ), \" energy=\" , intersection_results ( i )% energy % total () call logger % debug ( trim ( detail_line )) end do end if end subroutine print_gmbe_intersection_debug","tags":"","url":"proc/print_gmbe_intersection_debug.html"},{"title":"print_mbe_energy_breakdown – metalquicha","text":"private  subroutine print_mbe_energy_breakdown(sum_by_level, max_level, total_energy) Print MBE energy breakdown to logger Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sum_by_level (:) integer, intent(in) :: max_level real(kind=dp), intent(in) :: total_energy Calls proc~~print_mbe_energy_breakdown~~CallsGraph proc~print_mbe_energy_breakdown print_mbe_energy_breakdown info info proc~print_mbe_energy_breakdown->info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_mbe_energy_breakdown~~CalledByGraph proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_mbe_energy_breakdown proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: energy_line integer, private :: nlevel Source Code subroutine print_mbe_energy_breakdown ( sum_by_level , max_level , total_energy ) !! Print MBE energy breakdown to logger real ( dp ), intent ( in ) :: sum_by_level (:) integer , intent ( in ) :: max_level real ( dp ), intent ( in ) :: total_energy integer :: nlevel character ( len = 256 ) :: energy_line call logger % info ( \"MBE Energy breakdown:\" ) do nlevel = 1 , max_level if ( abs ( sum_by_level ( nlevel )) > 1e-15_dp ) then write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , nlevel , \"-body:  \" , sum_by_level ( nlevel ) call logger % info ( trim ( energy_line )) end if end do write ( energy_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( energy_line )) end subroutine print_mbe_energy_breakdown","tags":"","url":"proc/print_mbe_energy_breakdown.html"},{"title":"print_mbe_gradient_info – metalquicha","text":"private  subroutine print_mbe_gradient_info(total_gradient, sys_geom, current_log_level) Print MBE gradient information Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_gradient (:,:) type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: current_log_level Calls proc~~print_mbe_gradient_info~~CallsGraph proc~print_mbe_gradient_info print_mbe_gradient_info info info proc~print_mbe_gradient_info->info to_char to_char proc~print_mbe_gradient_info->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_mbe_gradient_info~~CalledByGraph proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_mbe_gradient_info proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: grad_line integer, private :: iatom Source Code subroutine print_mbe_gradient_info ( total_gradient , sys_geom , current_log_level ) !! Print MBE gradient information real ( dp ), intent ( in ) :: total_gradient (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: current_log_level integer :: iatom character ( len = 256 ) :: grad_line call logger % info ( \"MBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total MBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end do call logger % info ( \" \" ) end if end subroutine print_mbe_gradient_info","tags":"","url":"proc/print_mbe_gradient_info.html"},{"title":"process_intersection_derivatives – metalquicha","text":"private  subroutine process_intersection_derivatives(inter_idx, k, sign_factor, intersection_results, intersection_sets, sys_geom, total_gradient, total_hessian, bonds, compute_grad, compute_hess, hess_dim) Uses mqc_gmbe_utils mqc_config_parser mqc_result_types mqc_error mqc_physical_fragment proc~~process_intersection_derivatives~~UsesGraph proc~process_intersection_derivatives process_intersection_derivatives module~mqc_config_parser mqc_config_parser proc~process_intersection_derivatives->module~mqc_config_parser module~mqc_error mqc_error proc~process_intersection_derivatives->module~mqc_error module~mqc_gmbe_utils mqc_gmbe_utils proc~process_intersection_derivatives->module~mqc_gmbe_utils module~mqc_physical_fragment mqc_physical_fragment proc~process_intersection_derivatives->module~mqc_physical_fragment module~mqc_result_types mqc_result_types proc~process_intersection_derivatives->module~mqc_result_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_gmbe_utils->module~mqc_combinatorics pic_io pic_io module~mqc_gmbe_utils->pic_io pic_logger pic_logger module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Process derivatives for a single intersection fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: inter_idx integer, intent(in) :: k real(kind=dp), intent(in) :: sign_factor type( calculation_result_t ), intent(in) :: intersection_results (:) integer, intent(in) :: intersection_sets (:,:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: total_gradient (:,:) real(kind=dp), intent(inout), optional :: total_hessian (:,:) type( bond_t ), intent(in), optional :: bonds (:) logical, intent(in) :: compute_grad logical, intent(in) :: compute_hess integer, intent(in) :: hess_dim Calls proc~~process_intersection_derivatives~~CallsGraph proc~process_intersection_derivatives process_intersection_derivatives error error proc~process_intersection_derivatives->error proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~error_get_full_trace error_t%error_get_full_trace proc~process_intersection_derivatives->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~process_intersection_derivatives->proc~error_has_error proc~find_fragment_intersection find_fragment_intersection proc~process_intersection_derivatives->proc~find_fragment_intersection proc~fragment_destroy physical_fragment_t%fragment_destroy proc~process_intersection_derivatives->proc~fragment_destroy proc~get_monomer_atom_list get_monomer_atom_list proc~process_intersection_derivatives->proc~get_monomer_atom_list proc~redistribute_cap_gradients redistribute_cap_gradients proc~process_intersection_derivatives->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~process_intersection_derivatives->proc~redistribute_cap_hessian warning warning proc~process_intersection_derivatives->warning proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~process_intersection_derivatives~~CalledByGraph proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~process_intersection_derivatives Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: current_atoms (:) integer, private :: current_n logical, private :: has_intersection type( error_t ), private :: inter_error type( physical_fragment_t ), private :: inter_fragment integer, private, allocatable :: intersect_atoms (:) integer, private :: j integer, private :: n_intersect integer, private, allocatable :: next_atoms (:) integer, private :: next_n real(kind=dp), private, allocatable :: term_gradient (:,:) real(kind=dp), private, allocatable :: term_hessian (:,:) Source Code subroutine process_intersection_derivatives ( inter_idx , k , sign_factor , intersection_results , & intersection_sets , sys_geom , total_gradient , & total_hessian , bonds , compute_grad , compute_hess , hess_dim ) !! Process derivatives for a single intersection fragment use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_atom_list , & redistribute_cap_gradients , redistribute_cap_hessian use mqc_gmbe_utils , only : find_fragment_intersection use mqc_config_parser , only : bond_t use mqc_error , only : error_t integer , intent ( in ) :: inter_idx , k real ( dp ), intent ( in ) :: sign_factor type ( calculation_result_t ), intent ( in ) :: intersection_results (:) integer , intent ( in ) :: intersection_sets (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: total_gradient (:, :) real ( dp ), intent ( inout ), optional :: total_hessian (:, :) type ( bond_t ), intent ( in ), optional :: bonds (:) logical , intent ( in ) :: compute_grad , compute_hess integer , intent ( in ) :: hess_dim integer :: j , current_n , next_n , n_intersect integer , allocatable :: current_atoms (:), next_atoms (:), intersect_atoms (:) real ( dp ), allocatable :: term_gradient (:, :), term_hessian (:, :) logical :: has_intersection type ( physical_fragment_t ) :: inter_fragment type ( error_t ) :: inter_error ! Build the intersection atom list call get_monomer_atom_list ( sys_geom , intersection_sets ( 1 , inter_idx ), current_atoms , current_n ) if ( current_n > 0 ) then do j = 2 , k call get_monomer_atom_list ( sys_geom , intersection_sets ( j , inter_idx ), next_atoms , next_n ) has_intersection = find_fragment_intersection ( current_atoms , current_n , & next_atoms , next_n , & intersect_atoms , n_intersect ) deallocate ( current_atoms , next_atoms ) if (. not . has_intersection ) then current_n = 0 exit end if current_n = n_intersect allocate ( current_atoms ( current_n )) current_atoms = intersect_atoms deallocate ( intersect_atoms ) end do end if if ( current_n > 0 ) then call build_fragment_from_atom_list ( sys_geom , current_atoms , current_n , & inter_fragment , inter_error , bonds ) if ( inter_error % has_error ()) then call logger % error ( inter_error % get_full_trace ()) error stop \"Failed to build intersection fragment in GMBE\" end if if ( compute_grad . and . intersection_results ( inter_idx )% has_gradient ) then allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp call redistribute_cap_gradients ( inter_fragment , intersection_results ( inter_idx )% gradient , & term_gradient ) total_gradient = total_gradient + sign_factor * term_gradient deallocate ( term_gradient ) end if if ( compute_hess . and . intersection_results ( inter_idx )% has_hessian ) then allocate ( term_hessian ( hess_dim , hess_dim )) term_hessian = 0.0_dp call redistribute_cap_hessian ( inter_fragment , intersection_results ( inter_idx )% hessian , & term_hessian ) total_hessian = total_hessian + sign_factor * term_hessian deallocate ( term_hessian ) end if call inter_fragment % destroy () else call logger % warning ( \"GMBE intersection has no atoms; skipping derivatives\" ) end if if ( allocated ( current_atoms )) deallocate ( current_atoms ) end subroutine process_intersection_derivatives","tags":"","url":"proc/process_intersection_derivatives.html"},{"title":"run_calculation – metalquicha","text":"public  subroutine run_calculation(world_comm, node_comm, config, sys_geom, bonds, result_out) Main calculation dispatcher - routes to fragmented or unfragmented calculation Determines calculation type based on nlevel and dispatches to appropriate\ncalculation routine with proper MPI setup and validation.\nIf result_out is present, returns result instead of writing JSON (for dynamics/optimization) Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator type( driver_config_t ), intent(in) :: config Driver configuration type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( calculation_result_t ), intent(out), optional :: result_out Optional result output Calls proc~~run_calculation~~CallsGraph proc~run_calculation run_calculation info info proc~run_calculation->info omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation to_char to_char proc~run_calculation->to_char warning warning proc~run_calculation->warning proc~run_fragmented_calculation->info proc~run_fragmented_calculation->omp_set_num_threads proc~run_fragmented_calculation->to_char allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_coordinator node_coordinator proc~run_fragmented_calculation->interface~node_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation->proc~apply_distance_screening proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation->proc~sort_fragments_by_size verbose verbose proc~run_fragmented_calculation->verbose proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~run_unfragmented_calculation->verbose proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~node_worker node_worker interface~node_worker->proc~node_worker proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~apply_distance_screening->info proc~apply_distance_screening->to_char proc~calculate_monomer_distance calculate_monomer_distance proc~apply_distance_screening->proc~calculate_monomer_distance proc~combine_util combine_util proc~combine->proc~combine_util proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->to_char atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list error error proc~gmbe_enumerate_pie_terms->error proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration proc~gmbe_pie_coordinator->error fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies get_elapsed_time get_elapsed_time proc~gmbe_pie_coordinator->get_elapsed_time iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses start start proc~gmbe_pie_coordinator->start proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->cart_disp proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->error proc~serial_gmbe_pie_processor->fc_mdyne proc~serial_gmbe_pie_processor->force_constants proc~serial_gmbe_pie_processor->frequencies interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor->reduced_masses proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~combine_util->proc~combine_util proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect barrier barrier proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->verbose proc~global_coordinator->error proc~global_coordinator->get_elapsed_time proc~global_coordinator->iprobe proc~global_coordinator->irecv proc~global_coordinator->isend proc~global_coordinator->proc~result_irecv proc~global_coordinator->start debug debug proc~global_coordinator->debug mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~node_coordinator->to_char proc~node_coordinator->error proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->to_char proc~node_worker->error proc~node_worker->interface~do_fragment_work proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~error_get_full_trace proc~node_worker->proc~error_has_error proc~node_worker->proc~fragment_destroy proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~result_isend proc~node_worker->recv proc~print_gmbe_pie_json->info proc~print_gmbe_pie_json->error proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_pie_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~print_vibrational_analysis->warning proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~result_irecv->irecv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~serial_fragment_processor->info proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->to_char proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->verbose proc~serial_fragment_processor->configuration proc~serial_fragment_processor->error proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~error_get_full_trace proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char proc~unfragmented_calculation->cart_disp proc~unfragmented_calculation->configuration proc~unfragmented_calculation->error proc~unfragmented_calculation->fc_mdyne proc~unfragmented_calculation->force_constants proc~unfragmented_calculation->frequencies proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~error_get_full_trace proc~unfragmented_calculation->proc~error_has_error proc~unfragmented_calculation->proc~print_vibrational_analysis proc~unfragmented_calculation->reduced_masses eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~build_fragment_from_indices->proc~error_has_error proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~error_add_context proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->error proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_mbe->info proc~compute_mbe->to_char proc~compute_mbe->cart_disp proc~compute_mbe->configuration proc~compute_mbe->error proc~compute_mbe->fc_mdyne proc~compute_mbe->force_constants proc~compute_mbe->frequencies proc~compute_mbe->proc~compute_vibrational_analysis proc~compute_mbe->proc~energy_total proc~compute_mbe->proc~print_vibrational_analysis proc~compute_mbe->reduced_masses proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe->proc~print_detailed_breakdown_json proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->warning proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->configuration proc~do_fragment_work->error proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~grow_pie_storage->to_char proc~grow_pie_storage->error proc~print_unfragmented_json->info proc~print_unfragmented_json->error proc~print_unfragmented_json->proc~energy_total proc~print_unfragmented_json->proc~get_basename proc~print_unfragmented_json->proc~get_output_json_filename proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~result_isend->isend send send proc~result_isend->send proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_calculation~~CalledByGraph proc~run_calculation run_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Loop counter integer, private :: max_level Maximum fragment level (nlevel from config) Source Code subroutine run_calculation ( world_comm , node_comm , config , sys_geom , bonds , result_out ) !! Main calculation dispatcher - routes to fragmented or unfragmented calculation !! !! Determines calculation type based on nlevel and dispatches to appropriate !! calculation routine with proper MPI setup and validation. !! If result_out is present, returns result instead of writing JSON (for dynamics/optimization) type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator type ( driver_config_t ), intent ( in ) :: config !! Driver configuration type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( calculation_result_t ), intent ( out ), optional :: result_out !! Optional result output ! Local variables integer :: max_level !! Maximum fragment level (nlevel from config) integer :: i !! Loop counter ! Set max_level from config max_level = config % nlevel if ( world_comm % rank () == 0 ) then call logger % info ( \"============================================\" ) call logger % info ( \"Loaded geometry:\" ) call logger % info ( \"  Total monomers: \" // to_char ( sys_geom % n_monomers )) call logger % info ( \"  Atoms per monomer: \" // to_char ( sys_geom % atoms_per_monomer )) call logger % info ( \"  Total atoms: \" // to_char ( sys_geom % total_atoms )) call logger % info ( \"  Fragment level: \" // to_char ( max_level )) call logger % info ( \"============================================\" ) end if ! Warn if overlapping fragments flag is set but nlevel=0 if ( config % allow_overlapping_fragments . and . max_level == 0 ) then if ( world_comm % rank () == 0 ) then call logger % warning ( \"allow_overlapping_fragments is set to true, but nlevel=0\" ) call logger % warning ( \"Running unfragmented calculation - overlapping fragments flag will be ignored\" ) end if end if ! GMBE (overlapping fragments) with inclusion-exclusion principle ! GMBE(1): Base fragments are monomers ! GMBE(N): Base fragments are N-mers (e.g., dimers for N=2) ! Algorithm: Generate primaries, use DFS to enumerate overlapping cliques, ! accumulate PIE coefficients per unique atom set, evaluate each once if ( max_level == 0 ) then call omp_set_num_threads ( 1 ) call run_unfragmented_calculation ( world_comm , sys_geom , config % method , config % calc_type , bonds , config , result_out ) else call run_fragmented_calculation ( world_comm , node_comm , config % method , config % calc_type , sys_geom , max_level , & config % allow_overlapping_fragments , & config % max_intersection_level , bonds , config ) end if end subroutine run_calculation","tags":"","url":"proc/run_calculation.html"},{"title":"run_multi_molecule_calculations – metalquicha","text":"public  subroutine run_multi_molecule_calculations(world_comm, node_comm, mqc_config) Uses mqc_config_parser mqc_error mqc_json mqc_io_helpers mqc_config_adapter proc~~run_multi_molecule_calculations~~UsesGraph proc~run_multi_molecule_calculations run_multi_molecule_calculations module~mqc_config_adapter mqc_config_adapter proc~run_multi_molecule_calculations->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_parser module~mqc_error mqc_error proc~run_multi_molecule_calculations->module~mqc_error module~mqc_io_helpers mqc_io_helpers proc~run_multi_molecule_calculations->module~mqc_io_helpers module~mqc_json mqc_json proc~run_multi_molecule_calculations->module~mqc_json module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_error module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment pic_logger pic_logger module~mqc_config_adapter->pic_logger pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types pic_io pic_io module~mqc_json->pic_io module~mqc_json->pic_logger module~mqc_calc_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Run calculations for multiple molecules with MPI parallelization\nEach molecule is independent, so assign one molecule per rank Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm type( mqc_config_t ), intent(in) :: mqc_config Calls proc~~run_multi_molecule_calculations~~CallsGraph proc~run_multi_molecule_calculations run_multi_molecule_calculations abort_comm abort_comm proc~run_multi_molecule_calculations->abort_comm barrier barrier proc~run_multi_molecule_calculations->barrier error error proc~run_multi_molecule_calculations->error info info proc~run_multi_molecule_calculations->info proc~config_to_driver config_to_driver proc~run_multi_molecule_calculations->proc~config_to_driver proc~config_to_system_geometry config_to_system_geometry proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~error_add_context error_t%error_add_context proc~run_multi_molecule_calculations->proc~error_add_context proc~error_get_full_trace error_t%error_get_full_trace proc~run_multi_molecule_calculations->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~run_multi_molecule_calculations->proc~error_has_error proc~get_output_json_filename get_output_json_filename proc~run_multi_molecule_calculations->proc~get_output_json_filename proc~merge_multi_molecule_json merge_multi_molecule_json proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~set_molecule_suffix set_molecule_suffix proc~run_multi_molecule_calculations->proc~set_molecule_suffix proc~system_destroy system_geometry_t%system_destroy proc~run_multi_molecule_calculations->proc~system_destroy to_char to_char proc~run_multi_molecule_calculations->to_char verbose verbose proc~run_multi_molecule_calculations->verbose proc~config_to_system_geometry->proc~error_add_context proc~config_to_system_geometry->proc~error_has_error proc~error_set error_t%error_set proc~config_to_system_geometry->proc~error_set proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~error_get_full_trace->proc~error_has_error proc~merge_multi_molecule_json->error proc~merge_multi_molecule_json->info proc~merge_multi_molecule_json->to_char proc~read_json_content read_json_content proc~merge_multi_molecule_json->proc~read_json_content proc~run_calculation->info proc~run_calculation->to_char omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation warning warning proc~run_calculation->warning proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~molecule_to_system_geometry->proc~error_set proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name proc~run_fragmented_calculation->info proc~run_fragmented_calculation->to_char proc~run_fragmented_calculation->verbose proc~run_fragmented_calculation->omp_set_num_threads allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_coordinator node_coordinator proc~run_fragmented_calculation->interface~node_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation->proc~apply_distance_screening proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation->proc~sort_fragments_by_size proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char proc~run_unfragmented_calculation->verbose interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~node_worker node_worker interface~node_worker->proc~node_worker proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~apply_distance_screening->info proc~apply_distance_screening->to_char proc~calculate_monomer_distance calculate_monomer_distance proc~apply_distance_screening->proc~calculate_monomer_distance proc~combine_util combine_util proc~combine->proc~combine_util to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~gmbe_enumerate_pie_terms->error proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->to_char atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies get_elapsed_time get_elapsed_time proc~gmbe_pie_coordinator->get_elapsed_time iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses start start proc~gmbe_pie_coordinator->start proc~initialize_fragmented_system->proc~error_add_context proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~serial_gmbe_pie_processor->error proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->cart_disp proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->fc_mdyne proc~serial_gmbe_pie_processor->force_constants proc~serial_gmbe_pie_processor->frequencies interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor->reduced_masses proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_add_context proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_fragment_overlap->to_char proc~check_fragment_overlap->proc~error_set proc~combine_util->proc~combine_util proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~global_coordinator->error proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->verbose proc~global_coordinator->get_elapsed_time proc~global_coordinator->iprobe proc~global_coordinator->irecv proc~global_coordinator->isend proc~global_coordinator->proc~result_irecv proc~global_coordinator->start debug debug proc~global_coordinator->debug mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~node_coordinator->error proc~node_coordinator->to_char proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->error proc~node_worker->proc~error_get_full_trace proc~node_worker->proc~error_has_error proc~node_worker->to_char proc~node_worker->interface~do_fragment_work proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~fragment_destroy proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~result_isend proc~node_worker->recv proc~print_gmbe_pie_json->error proc~print_gmbe_pie_json->info proc~print_gmbe_pie_json->proc~get_output_json_filename proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~print_vibrational_analysis->info proc~print_vibrational_analysis->warning proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~result_irecv->irecv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~serial_fragment_processor->error proc~serial_fragment_processor->info proc~serial_fragment_processor->proc~error_get_full_trace proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->to_char proc~serial_fragment_processor->verbose proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->configuration proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~unfragmented_calculation->error proc~unfragmented_calculation->info proc~unfragmented_calculation->proc~error_get_full_trace proc~unfragmented_calculation->proc~error_has_error proc~unfragmented_calculation->to_char proc~unfragmented_calculation->cart_disp proc~unfragmented_calculation->configuration proc~unfragmented_calculation->fc_mdyne proc~unfragmented_calculation->force_constants proc~unfragmented_calculation->frequencies proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~print_vibrational_analysis proc~unfragmented_calculation->reduced_masses eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_multi_molecule_calculations~~CalledByGraph proc~run_multi_molecule_calculations run_multi_molecule_calculations program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: color type( driver_config_t ), private :: config type( error_t ), private :: error logical, private :: has_fragmented_molecules integer, private :: imol character(len=256), private, allocatable :: individual_json_files (:) type(comm_t), private :: mol_comm character(len=:), private, allocatable :: mol_name type(comm_t), private :: mol_node_comm integer, private :: molecules_processed integer, private :: my_rank integer, private :: num_ranks type( system_geometry_t ), private :: sys_geom Source Code subroutine run_multi_molecule_calculations ( world_comm , node_comm , mqc_config ) !! Run calculations for multiple molecules with MPI parallelization !! Each molecule is independent, so assign one molecule per rank use mqc_config_parser , only : mqc_config_t use mqc_config_adapter , only : config_to_system_geometry use mqc_error , only : error_t use mqc_io_helpers , only : set_molecule_suffix , get_output_json_filename use mqc_json , only : merge_multi_molecule_json type ( comm_t ), intent ( in ) :: world_comm type ( comm_t ), intent ( in ) :: node_comm type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ) :: config type ( system_geometry_t ) :: sys_geom type ( comm_t ) :: mol_comm , mol_node_comm type ( error_t ) :: error integer :: imol , my_rank , num_ranks , color integer :: molecules_processed character ( len = :), allocatable :: mol_name logical :: has_fragmented_molecules character ( len = 256 ), allocatable :: individual_json_files (:) my_rank = world_comm % rank () num_ranks = world_comm % size () ! Allocate array to track individual JSON files for merging allocate ( individual_json_files ( mqc_config % nmol )) ! Check if any molecules have fragments (nlevel > 0) has_fragmented_molecules = . false . do imol = 1 , mqc_config % nmol if ( mqc_config % molecules ( imol )% nfrag > 0 ) then has_fragmented_molecules = . true . exit end if end do if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"Multi-molecule mode: \" // to_char ( mqc_config % nmol ) // \" molecules\" ) call logger % info ( \"MPI ranks: \" // to_char ( num_ranks )) if ( has_fragmented_molecules ) then call logger % info ( \"Mode: Sequential execution (fragmented molecules detected)\" ) call logger % info ( \"  Each molecule will use all \" // to_char ( num_ranks ) // \" rank(s) for its calculation\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Mode: Sequential execution (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) call logger % info ( \"Note: More ranks than molecules - ranks \" // to_char ( mqc_config % nmol ) // & \" to \" // to_char ( num_ranks - 1 ) // \" will be idle\" ) else call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) end if call logger % info ( \"============================================\" ) call logger % info ( \" \" ) end if ! Determine execution mode: ! 1. Sequential: Single rank OR fragmented molecules (each molecule needs all ranks) ! 2. Parallel: Multiple ranks AND unfragmented molecules (distribute molecules across ranks) molecules_processed = 0 if ( num_ranks == 1 . or . has_fragmented_molecules ) then ! Sequential mode: process all molecules one after another ! Each molecule uses all available ranks for its calculation do imol = 1 , mqc_config % nmol ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Processing molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) end if ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then call error % add_context ( \"mqc_driver:run_multi_molecule_calculation\" ) if ( my_rank == 0 ) then call logger % error ( \"Error converting geometry for \" // mol_name // \": \" // error % get_full_trace ()) end if call abort_comm ( world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % molecules ( imol )% bonds ) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () if ( my_rank == 0 ) then call logger % info ( \"Completed molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) end if molecules_processed = molecules_processed + 1 end do else ! Multiple ranks: distribute molecules across ranks in round-robin fashion molecules_processed = 0 do imol = 1 , mqc_config % nmol ! This rank processes molecules where (imol - 1) mod num_ranks == my_rank if ( mod ( imol - 1 , num_ranks ) == my_rank ) then ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Processing molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then call error % add_context ( \"mqc_driver:run_multi_molecule_calculation\" ) call logger % error ( \"Rank \" // to_char ( my_rank ) // \": Error converting geometry for \" // mol_name // \": \" // error % get_full_trace ()) call abort_comm ( world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % molecules ( imol )% bonds ) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Completed molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) molecules_processed = molecules_processed + 1 end if end do if ( molecules_processed == 0 ) then ! Idle rank - no molecules assigned call logger % verbose ( \"Rank \" // to_char ( my_rank ) // \": No molecules assigned (idle)\" ) end if end if ! Synchronize all ranks call world_comm % barrier () ! In parallel execution, rank 0 needs to reconstruct all JSON filenames for merging ! since each rank only populated its own entry if ( my_rank == 0 . and . num_ranks > 1 . and . . not . has_fragmented_molecules ) then ! Rank 0 constructs filenames for all molecules do imol = 1 , mqc_config % nmol ! Get molecule name if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if ! Construct JSON filename pattern: output_<basename>_<molname>.json ! This mirrors what get_output_json_filename() returns after set_molecule_suffix() call set_molecule_suffix ( \"_\" // trim ( mol_name )) individual_json_files ( imol ) = get_output_json_filename () end do end if ! Merge individual JSON files into one combined file (rank 0 only) if ( my_rank == 0 ) then call merge_multi_molecule_json ( individual_json_files , mqc_config % nmol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"All \" // to_char ( mqc_config % nmol ) // \" molecules completed\" ) if ( has_fragmented_molecules ) then call logger % info ( \"Execution: Sequential (each molecule used all ranks)\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Execution: Sequential (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Execution: Parallel (active ranks: \" // to_char ( mqc_config % nmol ) // \"/\" // to_char ( num_ranks ) // \")\" ) else call logger % info ( \"Execution: Parallel (all ranks active)\" ) end if call logger % info ( \"============================================\" ) end if end subroutine run_multi_molecule_calculations","tags":"","url":"proc/run_multi_molecule_calculations.html"},{"title":"run_fragmented_calculation – metalquicha","text":"private  subroutine run_fragmented_calculation(world_comm, node_comm, method, calc_type, sys_geom, max_level, allow_overlapping_fragments, max_intersection_level, bonds, driver_config) Handle fragmented calculation (nlevel > 0) Generates fragments, distributes work across MPI processes organized in nodes,\nand coordinates many-body expansion calculation using hierarchical parallelism.\nIf allow_overlapping_fragments=true, uses GMBE with intersection correction. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator integer(kind=int32), intent(in) :: method Quantum chemistry method integer(kind=int32), intent(in) :: calc_type Calculation type type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info integer, intent(in) :: max_level Maximum fragment level for MBE logical, intent(in) :: allow_overlapping_fragments Use GMBE for overlapping fragments integer, intent(in) :: max_intersection_level Maximum k-way intersection depth for GMBE type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( driver_config_t ), intent(in) :: driver_config Driver configuration with cutoffs Calls proc~~run_fragmented_calculation~~CallsGraph proc~run_fragmented_calculation run_fragmented_calculation allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast info info proc~run_fragmented_calculation->info interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_coordinator node_coordinator proc~run_fragmented_calculation->interface~node_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads omp_set_num_threads omp_set_num_threads proc~run_fragmented_calculation->omp_set_num_threads proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation->proc~apply_distance_screening proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation->proc~sort_fragments_by_size to_char to_char proc~run_fragmented_calculation->to_char verbose verbose proc~run_fragmented_calculation->verbose proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~node_worker node_worker interface~node_worker->proc~node_worker proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~apply_distance_screening->info proc~apply_distance_screening->to_char proc~calculate_monomer_distance calculate_monomer_distance proc~apply_distance_screening->proc~calculate_monomer_distance proc~combine_util combine_util proc~combine->proc~combine_util proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->to_char atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list error error proc~gmbe_enumerate_pie_terms->error proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration proc~gmbe_pie_coordinator->error fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies get_elapsed_time get_elapsed_time proc~gmbe_pie_coordinator->get_elapsed_time iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses start start proc~gmbe_pie_coordinator->start proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->cart_disp proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->error proc~serial_gmbe_pie_processor->fc_mdyne proc~serial_gmbe_pie_processor->force_constants proc~serial_gmbe_pie_processor->frequencies interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~calc_type_to_string calc_type_to_string proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor->reduced_masses proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~combine_util->proc~combine_util proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->verbose proc~global_coordinator->error proc~global_coordinator->get_elapsed_time proc~global_coordinator->iprobe proc~global_coordinator->irecv proc~global_coordinator->isend proc~global_coordinator->proc~result_irecv proc~global_coordinator->start debug debug proc~global_coordinator->debug mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~node_coordinator->to_char proc~node_coordinator->error proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->to_char proc~node_worker->error proc~node_worker->interface~do_fragment_work proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~error_get_full_trace proc~node_worker->proc~error_has_error proc~node_worker->proc~fragment_destroy proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~result_isend proc~node_worker->recv proc~print_gmbe_pie_json->info proc~print_gmbe_pie_json->error proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_pie_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol warning warning proc~print_vibrational_analysis->warning proc~result_irecv->irecv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~serial_fragment_processor->info proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->to_char proc~serial_fragment_processor->verbose proc~serial_fragment_processor->configuration proc~serial_fragment_processor->error proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~error_get_full_trace proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~build_fragment_from_indices->proc~error_has_error proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~error_add_context proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->error proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_mbe->info proc~compute_mbe->to_char proc~compute_mbe->cart_disp proc~compute_mbe->configuration proc~compute_mbe->error proc~compute_mbe->fc_mdyne proc~compute_mbe->force_constants proc~compute_mbe->frequencies proc~compute_mbe->proc~compute_vibrational_analysis proc~compute_mbe->proc~energy_total proc~compute_mbe->proc~print_vibrational_analysis proc~compute_mbe->reduced_masses proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe->proc~print_detailed_breakdown_json proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~do_fragment_work->configuration proc~do_fragment_work->error proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~grow_pie_storage->to_char proc~grow_pie_storage->error proc~result_isend->isend send send proc~result_isend->send proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~build_mbe_lookup_table->to_char proc~build_mbe_lookup_table->get_elapsed_time proc~build_mbe_lookup_table->start proc~build_mbe_lookup_table->debug proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~compute_mbe_delta->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_has_error proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_gradient->debug proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~mass_weight_hessian->proc~element_mass proc~print_detailed_breakdown->verbose proc~print_detailed_breakdown->warning header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name proc~print_detailed_breakdown_json->info proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->warning proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_fragment_xyz->proc~to_angstrom proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->info proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->error proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_fragmented_calculation~~CalledByGraph proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: all_node_leader_ranks (:) Node leader status for all ranks integer, private :: global_node_rank Global rank if this process leads a node, -1 otherwise integer, private :: i Loop counters integer, private, allocatable :: intersection_levels (:) Level k of each intersection (n_intersections) integer, private, allocatable :: intersection_sets (:,:) k-tuples for each intersection (n_monomers, n_intersections) integer, private, allocatable :: intersections (:,:) Intersection atom lists (max_atoms, n_intersections) integer, private :: j Loop counters integer, private, allocatable :: monomers (:) Temporary monomer list for fragment generation integer(kind=int64), private :: n_expected_frags Expected number of fragments based on combinatorics (int64 to handle large systems) integer, private :: n_intersections Counts for GMBE integer, private :: n_monomers Counts for GMBE integer(kind=int64), private :: n_pie_terms Number of unique PIE terms integer, private :: n_primaries Number of primary polymers integer(kind=int64), private :: n_primaries_i64 For binomial calculation integer(kind=int64), private :: n_rows Number of rows needed for polymers array (int64 to handle large systems) integer, private, allocatable :: node_leader_ranks (:) Ranks of processes that lead each node integer, private :: num_nodes Number of compute nodes integer, private, allocatable :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, private, allocatable :: pie_coefficients (:) PIE coefficient for each term integer, private, allocatable :: polymers (:,:) Fragment composition array (fragment, monomer_indices) integer(kind=int64), private :: total_fragments Total number of fragments generated (int64 to handle large systems) Source Code subroutine run_fragmented_calculation ( world_comm , node_comm , method , calc_type , sys_geom , max_level , & allow_overlapping_fragments , max_intersection_level , bonds , driver_config ) !! Handle fragmented calculation (nlevel > 0) !! !! Generates fragments, distributes work across MPI processes organized in nodes, !! and coordinates many-body expansion calculation using hierarchical parallelism. !! If allow_overlapping_fragments=true, uses GMBE with intersection correction. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator integer ( int32 ), intent ( in ) :: method !! Quantum chemistry method integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info integer , intent ( in ) :: max_level !! Maximum fragment level for MBE logical , intent ( in ) :: allow_overlapping_fragments !! Use GMBE for overlapping fragments integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth for GMBE type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( driver_config_t ), intent ( in ) :: driver_config !! Driver configuration with cutoffs integer ( int64 ) :: total_fragments !! Total number of fragments generated (int64 to handle large systems) integer , allocatable :: polymers (:, :) !! Fragment composition array (fragment, monomer_indices) integer :: num_nodes !! Number of compute nodes integer :: i , j !! Loop counters integer , allocatable :: node_leader_ranks (:) !! Ranks of processes that lead each node integer , allocatable :: monomers (:) !! Temporary monomer list for fragment generation integer ( int64 ) :: n_expected_frags !! Expected number of fragments based on combinatorics (int64 to handle large systems) integer ( int64 ) :: n_rows !! Number of rows needed for polymers array (int64 to handle large systems) integer :: global_node_rank !! Global rank if this process leads a node, -1 otherwise integer , allocatable :: all_node_leader_ranks (:) !! Node leader status for all ranks ! GMBE-specific variables (old approach - kept for compatibility) integer , allocatable :: intersections (:, :) !! Intersection atom lists (max_atoms, n_intersections) integer , allocatable :: intersection_sets (:, :) !! k-tuples for each intersection (n_monomers, n_intersections) integer , allocatable :: intersection_levels (:) !! Level k of each intersection (n_intersections) integer :: n_intersections , n_monomers !! Counts for GMBE ! GMBE PIE-based variables (new approach) integer :: n_primaries !! Number of primary polymers integer ( int64 ) :: n_primaries_i64 !! For binomial calculation integer , allocatable :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , allocatable :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ) :: n_pie_terms !! Number of unique PIE terms ! Generate fragments if ( world_comm % rank () == 0 ) then if ( allow_overlapping_fragments ) then ! GMBE mode: PIE-based inclusion-exclusion ! GMBE(1): primaries are monomers ! GMBE(N): primaries are N-mers (e.g., dimers for N=2) ! Generate primaries if ( max_level == 1 ) then ! GMBE(1): primaries are base monomers n_primaries = sys_geom % n_monomers allocate ( polymers ( n_primaries , 1 )) do i = 1 , n_primaries polymers ( i , 1 ) = i end do else ! GMBE(N): primaries are all C(M, N) N-tuples n_primaries_i64 = binomial ( sys_geom % n_monomers , max_level ) n_primaries = int ( n_primaries_i64 ) allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_primaries , max_level )) polymers = 0 call create_monomer_list ( monomers ) total_fragments = 0_int64 call combine ( monomers , sys_geom % n_monomers , max_level , polymers , total_fragments ) n_primaries = int ( total_fragments ) deallocate ( monomers ) ! Apply distance-based screening to primaries if cutoffs are provided if ( max_level > 1 ) then ! Only screen if primaries are n-mers (not for GMBE(1) where primaries are monomers) total_fragments = int ( n_primaries , int64 ) call apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) n_primaries = int ( total_fragments ) end if ! Sort primaries by size (largest first) ! TODO: Currently disabled - see comment in MBE section above ! total_fragments = int(n_primaries, int64) call sort_fragments_by_size ( polymers , total_fragments , max_level ) end if call logger % info ( \"Generated \" // to_char ( n_primaries ) // \" primary \" // to_char ( max_level ) // \"-mers for GMBE(\" // & to_char ( max_level ) // \")\" ) ! Use DFS to enumerate PIE terms with coefficients call gmbe_enumerate_pie_terms ( sys_geom , polymers , n_primaries , max_level , max_intersection_level , & pie_atom_sets , pie_coefficients , n_pie_terms ) call logger % info ( \"GMBE PIE enumeration complete: \" // to_char ( n_pie_terms ) // \" unique subsystems to evaluate\" ) ! For now: total_fragments = n_pie_terms (each PIE term is a subsystem to evaluate) total_fragments = n_pie_terms else ! Standard MBE mode ! Calculate expected number of fragments n_expected_frags = get_nfrags ( sys_geom % n_monomers , max_level ) n_rows = n_expected_frags ! Allocate monomer list and polymers array allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_rows , max_level )) polymers = 0 ! Create monomer list [1, 2, 3, ..., n_monomers] call create_monomer_list ( monomers ) ! Generate all fragments (includes monomers in polymers array) total_fragments = 0_int64 ! First add monomers do i = 1 , sys_geom % n_monomers total_fragments = total_fragments + 1_int64 polymers ( total_fragments , 1 ) = i end do ! Then add n-mers for n >= 2 call generate_fragment_list ( monomers , max_level , polymers , total_fragments ) deallocate ( monomers ) ! Apply distance-based screening if cutoffs are provided call apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) ! Sort fragments by size (largest first) for better load balancing ! TODO: Currently disabled - MBE assembly is now order-independent (uses nested loops), ! but sorting still causes \"Subset not found\" errors in real validation cases. ! Unit tests pass with arbitrary order, so there may be an issue with the hash table ! or fragment generation in production code. Needs investigation. call sort_fragments_by_size ( polymers , total_fragments , max_level ) call logger % info ( \"Generated fragments:\" ) call logger % info ( \"  Total fragments: \" // to_char ( total_fragments )) call logger % info ( \"  Max level: \" // to_char ( max_level )) end if end if ! Broadcast total_fragments to all ranks call bcast ( world_comm , total_fragments , 1 , 0 ) ! Determine node leaders global_node_rank = - 1 if ( node_comm % rank () == 0 ) global_node_rank = world_comm % rank () allocate ( all_node_leader_ranks ( world_comm % size ())) call allgather ( world_comm , global_node_rank , all_node_leader_ranks ) num_nodes = count ( all_node_leader_ranks /= - 1 ) if ( world_comm % rank () == 0 ) then call logger % info ( \"Running with \" // to_char ( num_nodes ) // \" node(s)\" ) end if allocate ( node_leader_ranks ( num_nodes )) i = 0 do j = 1 , world_comm % size () if ( all_node_leader_ranks ( j ) /= - 1 ) then i = i + 1 node_leader_ranks ( i ) = all_node_leader_ranks ( j ) end if end do deallocate ( all_node_leader_ranks ) ! Execute appropriate role if ( world_comm % size () == 1 ) then ! Single rank: process fragments serially call logger % info ( \"Running in serial mode (single MPI rank)\" ) if ( allow_overlapping_fragments ) then ! GMBE serial processing with PIE coefficients call serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , sys_geom , method , calc_type , bonds ) else ! Standard MBE serial processing call serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method , calc_type , bonds ) end if else if ( world_comm % leader () . and . node_comm % leader ()) then ! Global coordinator (rank 0, node leader on node 0) call omp_set_num_threads ( omp_get_max_threads ()) call logger % verbose ( \"Rank 0: Acting as global coordinator\" ) if ( allow_overlapping_fragments ) then ! GMBE MPI processing - PIE-based approach call gmbe_pie_coordinator ( world_comm , node_comm , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method , calc_type , bonds ) else ! Standard MBE MPI processing call global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , calc_type , bonds ) end if else if ( node_comm % leader ()) then ! Node coordinator (node leader on other nodes) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as node coordinator\" ) ! Node coordinator works for both MBE and GMBE (receives fragments from global coordinator) call node_coordinator ( world_comm , node_comm , calc_type ) else ! Worker call omp_set_num_threads ( 1 ) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as worker\" ) ! Worker processes work for both MBE and GMBE (fragment_type distinguishes them) call node_worker ( world_comm , node_comm , sys_geom , method , calc_type , bonds ) end if ! Cleanup if ( world_comm % rank () == 0 ) then if ( allocated ( polymers )) deallocate ( polymers ) if ( allocated ( node_leader_ranks )) deallocate ( node_leader_ranks ) if ( allocated ( intersections )) deallocate ( intersections ) if ( allocated ( intersection_sets )) deallocate ( intersection_sets ) if ( allocated ( intersection_levels )) deallocate ( intersection_levels ) if ( allocated ( pie_atom_sets )) deallocate ( pie_atom_sets ) if ( allocated ( pie_coefficients )) deallocate ( pie_coefficients ) end if end subroutine run_fragmented_calculation","tags":"","url":"proc/run_fragmented_calculation.html"},{"title":"run_unfragmented_calculation – metalquicha","text":"private  subroutine run_unfragmented_calculation(world_comm, sys_geom, method, calc_type, bonds, driver_config, result_out) Handle unfragmented calculation (nlevel=0) For single-molecule mode: Only rank 0 runs (validates single rank)\nFor multi-molecule mode: ALL ranks can run (each with their own molecule)\nFor Hessian calculations with multiple ranks: Uses distributed parallelization\nIf result_out is present, returns result instead of writing JSON Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type( system_geometry_t ), intent(in) :: sys_geom Complete system geometry integer(kind=int32), intent(in) :: method Quantum chemistry method integer(kind=int32), intent(in) :: calc_type Calculation type type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( driver_config_t ), intent(in), optional :: driver_config Driver configuration type( calculation_result_t ), intent(out), optional :: result_out Optional result output Calls proc~~run_unfragmented_calculation~~CallsGraph proc~run_unfragmented_calculation run_unfragmented_calculation info info proc~run_unfragmented_calculation->info interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string to_char to_char proc~run_unfragmented_calculation->to_char verbose verbose proc~run_unfragmented_calculation->verbose proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation barrier barrier proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char cart_disp cart_disp proc~unfragmented_calculation->cart_disp configuration configuration proc~unfragmented_calculation->configuration eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues error error proc~unfragmented_calculation->error fc_mdyne fc_mdyne proc~unfragmented_calculation->fc_mdyne force_constants force_constants proc~unfragmented_calculation->force_constants frequencies frequencies proc~unfragmented_calculation->frequencies interface~do_fragment_work do_fragment_work proc~unfragmented_calculation->interface~do_fragment_work proc~check_duplicate_atoms check_duplicate_atoms proc~unfragmented_calculation->proc~check_duplicate_atoms proc~compute_vibrational_analysis compute_vibrational_analysis proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~energy_total energy_t%energy_total proc~unfragmented_calculation->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~unfragmented_calculation->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~unfragmented_calculation->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json proc~print_vibrational_analysis print_vibrational_analysis proc~unfragmented_calculation->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian reduced_masses reduced_masses proc~unfragmented_calculation->reduced_masses proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~print_unfragmented_json->info proc~print_unfragmented_json->error proc~print_unfragmented_json->proc~energy_total proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->configuration proc~do_fragment_work->error proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~hessian_coordinator->info proc~hessian_coordinator->to_char proc~hessian_coordinator->cart_disp proc~hessian_coordinator->configuration proc~hessian_coordinator->fc_mdyne proc~hessian_coordinator->force_constants proc~hessian_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~hessian_coordinator->proc~energy_total proc~hessian_coordinator->proc~fragment_compute_nelec proc~hessian_coordinator->proc~print_unfragmented_json proc~hessian_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator->proc~result_destroy proc~hessian_coordinator->reduced_masses get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time iprobe iprobe proc~hessian_coordinator->iprobe irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~method_type_to_string proc~hessian_coordinator->proc~xtb_calc_gradient recv recv proc~hessian_coordinator->recv start start proc~hessian_coordinator->start vib_freqs vib_freqs proc~hessian_coordinator->vib_freqs proc~hessian_worker->to_char proc~hessian_worker->error proc~hessian_worker->proc~fragment_compute_nelec proc~hessian_worker->proc~result_destroy abort_comm abort_comm proc~hessian_worker->abort_comm proc~hessian_worker->irecv proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~hessian_worker->proc~method_type_to_string proc~hessian_worker->proc~xtb_calc_gradient send send proc~hessian_worker->send proc~mass_weight_hessian->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~result_reset->proc~energy_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_unfragmented_calculation~~CalledByGraph proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine run_unfragmented_calculation ( world_comm , sys_geom , method , calc_type , bonds , driver_config , result_out ) !! Handle unfragmented calculation (nlevel=0) !! !! For single-molecule mode: Only rank 0 runs (validates single rank) !! For multi-molecule mode: ALL ranks can run (each with their own molecule) !! For Hessian calculations with multiple ranks: Uses distributed parallelization !! If result_out is present, returns result instead of writing JSON type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( system_geometry_t ), intent ( in ) :: sys_geom !! Complete system geometry integer ( int32 ), intent ( in ) :: method !! Quantum chemistry method integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( driver_config_t ), intent ( in ), optional :: driver_config !! Driver configuration type ( calculation_result_t ), intent ( out ), optional :: result_out !! Optional result output ! For Hessian calculations with multiple ranks, use distributed approach if ( calc_type == CALC_TYPE_HESSIAN . and . world_comm % size () > 1 ) then if ( world_comm % rank () == 0 ) then call logger % info ( \" \" ) call logger % info ( \"Running distributed unfragmented Hessian calculation\" ) call logger % info ( \"  MPI ranks: \" // to_char ( world_comm % size ())) call logger % info ( \" \" ) end if call distributed_unfragmented_hessian ( world_comm , sys_geom , method , driver_config ) return end if ! Check if this is multi-molecule mode or single-molecule mode ! In multi-molecule mode, each rank processes its own molecule ! In single-molecule mode, only rank 0 should work if ( world_comm % size () == 1 . or . world_comm % rank () == 0 ) then ! Either single-rank calculation, or rank 0 in multi-rank setup call logger % info ( \" \" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) call logger % info ( \" \" ) call unfragmented_calculation ( sys_geom , method , calc_type , bonds , result_out ) else if ( sys_geom % total_atoms > 0 ) then ! Multi-molecule mode: non-zero rank with a molecule call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Running unfragmented calculation\" ) call unfragmented_calculation ( sys_geom , method , calc_type , bonds , result_out ) end if end subroutine run_unfragmented_calculation","tags":"","url":"proc/run_unfragmented_calculation.html"},{"title":"merge_multi_molecule_json – metalquicha","text":"public  subroutine merge_multi_molecule_json(individual_files, nmol) Uses mqc_io_helpers proc~~merge_multi_molecule_json~~UsesGraph proc~merge_multi_molecule_json merge_multi_molecule_json module~mqc_io_helpers mqc_io_helpers proc~merge_multi_molecule_json->module~mqc_io_helpers Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Merge individual molecule JSON files into a single combined file Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: individual_files (:) integer, intent(in) :: nmol Calls proc~~merge_multi_molecule_json~~CallsGraph proc~merge_multi_molecule_json merge_multi_molecule_json error error proc~merge_multi_molecule_json->error info info proc~merge_multi_molecule_json->info proc~read_json_content read_json_content proc~merge_multi_molecule_json->proc~read_json_content to_char to_char proc~merge_multi_molecule_json->to_char proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~merge_multi_molecule_json~~CalledByGraph proc~merge_multi_molecule_json merge_multi_molecule_json proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename integer, private :: dot_pos logical, private :: file_exists integer, private :: imol integer, private :: io_stat character(len=10000), private :: line character(len=256), private :: output_file integer, private :: slash_pos integer, private :: unit_in integer, private :: unit_out Source Code subroutine merge_multi_molecule_json ( individual_files , nmol ) !! Merge individual molecule JSON files into a single combined file use mqc_io_helpers , only : get_molecule_name character ( len = 256 ), intent ( in ) :: individual_files (:) integer , intent ( in ) :: nmol integer :: imol , unit_in , unit_out , io_stat , slash_pos , dot_pos character ( len = 10000 ) :: line character ( len = 256 ) :: output_file , basename logical :: file_exists ! Determine combined output filename from first individual file ! Example: \"output_multi_structure_molecule_1.json\" -> \"output_multi_structure.json\" basename = individual_files ( 1 ) slash_pos = index ( basename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = basename ( slash_pos + 1 :) end if ! Remove \"_molecule_1\" or similar suffix dot_pos = index ( basename , '_molecule_' ) if ( dot_pos > 0 ) then output_file = basename ( 1 : dot_pos - 1 ) // \".json\" else output_file = \"output_combined.json\" end if ! Open combined output file open ( newunit = unit_out , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Merging \" // to_char ( nmol ) // \" molecule JSON files into \" // trim ( output_file )) ! Write opening brace and top-level key (basename without \"output_\" and \".json\") dot_pos = index ( output_file , '.json' ) if ( dot_pos > 0 ) then basename = output_file ( 8 : dot_pos - 1 ) ! Skip \"output_\" else basename = \"combined\" end if write ( unit_out , '(a)' ) \"{\" write ( unit_out , '(a)' ) '  \"' // trim ( basename ) // '\": {' ! Process each individual JSON file do imol = 1 , nmol inquire ( file = trim ( individual_files ( imol )), exist = file_exists ) if (. not . file_exists ) cycle open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) cycle ! Read all lines from the individual JSON file call read_json_content ( unit_in , imol , unit_out , individual_files ( imol )) close ( unit_in ) ! Delete individual file open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'readwrite' ) close ( unit_in , status = 'delete' ) end do ! Close last molecule write ( unit_out , '(a)' ) '    }' ! Close top-level key and file write ( unit_out , '(a)' ) '  }' write ( unit_out , '(a)' ) '}' close ( unit_out ) call logger % info ( \"Combined JSON written to \" // trim ( output_file )) end subroutine merge_multi_molecule_json","tags":"","url":"proc/merge_multi_molecule_json.html"},{"title":"read_json_content – metalquicha","text":"private  subroutine read_json_content(unit_in, mol_index, unit_out, filename) Uses mqc_io_helpers proc~~read_json_content~~UsesGraph proc~read_json_content read_json_content module~mqc_io_helpers mqc_io_helpers proc~read_json_content->module~mqc_io_helpers Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Read and write JSON content from an individual molecule file\nProperly handles nested structures from fragmented calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit_in integer, intent(in) :: mol_index integer, intent(in) :: unit_out character(len=*), intent(in) :: filename Calls proc~~read_json_content~~CallsGraph proc~read_json_content read_json_content error error proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_json_content~~CalledByGraph proc~read_json_content read_json_content proc~merge_multi_molecule_json merge_multi_molecule_json proc~merge_multi_molecule_json->proc~read_json_content proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=10000), private, allocatable :: all_lines (:) integer, private :: i integer, private :: io_stat character(len=10000), private :: line integer, private :: nlines Source Code subroutine read_json_content ( unit_in , mol_index , unit_out , filename ) !! Read and write JSON content from an individual molecule file !! Properly handles nested structures from fragmented calculations use mqc_io_helpers , only : get_molecule_name integer , intent ( in ) :: unit_in , mol_index , unit_out character ( len =* ), intent ( in ) :: filename character ( len = 10000 ), allocatable :: all_lines (:) character ( len = 10000 ) :: line integer :: io_stat , nlines , i ! Read all lines into memory allocate ( all_lines ( 1000 )) ! Reasonable size for most JSON files nlines = 0 do read ( unit_in , '(a)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit nlines = nlines + 1 if ( nlines > size ( all_lines )) then ! Reallocate if needed call logger % error ( \"JSON file too large: \" // trim ( filename )) return end if all_lines ( nlines ) = line end do ! Lines structure: ! 1: \"{\" ! 2: '  \"molecule_name\": {' ! 3..(n-2): content ! n-1: \"  }\" ! n: \"}\" if ( nlines < 3 ) then call logger % error ( \"Invalid JSON structure: \" // trim ( filename )) return end if ! Write molecule key (extracted from filename) if ( mol_index > 1 ) write ( unit_out , '(a)' ) '    },' write ( unit_out , '(a)' ) '    \"' // trim ( get_molecule_name ( filename )) // '\" : {' ! Write all content lines (from line 3 to line n-2) do i = 3 , nlines - 2 write ( unit_out , '(a)' ) '  ' // trim ( all_lines ( i )) ! Add 2 spaces for proper indentation end do deallocate ( all_lines ) end subroutine read_json_content","tags":"","url":"proc/read_json_content.html"},{"title":"gmbe_pie_coordinator – metalquicha","text":"public  subroutine gmbe_pie_coordinator(world_comm, node_comm, pie_atom_sets, pie_coefficients, n_pie_terms, node_leader_ranks, num_nodes, sys_geom, method, calc_type, bonds) Uses mqc_calc_types mqc_physical_fragment mqc_error pic_logger proc~~gmbe_pie_coordinator~~UsesGraph proc~gmbe_pie_coordinator gmbe_pie_coordinator module~mqc_calc_types mqc_calc_types proc~gmbe_pie_coordinator->module~mqc_calc_types module~mqc_error mqc_error proc~gmbe_pie_coordinator->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment proc~gmbe_pie_coordinator->module~mqc_physical_fragment pic_logger pic_logger proc~gmbe_pie_coordinator->pic_logger pic_types pic_types module~mqc_calc_types->pic_types module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. MPI coordinator for PIE-based GMBE calculations\nDistributes PIE terms across MPI ranks and accumulates results Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(in) :: n_pie_terms integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~gmbe_pie_coordinator~~CallsGraph proc~gmbe_pie_coordinator gmbe_pie_coordinator cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration error error proc~gmbe_pie_coordinator->error fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies get_elapsed_time get_elapsed_time proc~gmbe_pie_coordinator->get_elapsed_time info info proc~gmbe_pie_coordinator->info iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses start start proc~gmbe_pie_coordinator->start to_char to_char proc~gmbe_pie_coordinator->to_char verbose verbose proc~gmbe_pie_coordinator->verbose proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_atom_list->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~print_gmbe_pie_json->error proc~print_gmbe_pie_json->info proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_pie_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol warning warning proc~print_vibrational_analysis->warning proc~result_irecv->irecv recv recv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gmbe_pie_coordinator~~CalledByGraph proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(timer_type), private :: coord_timer integer(kind=int64), private :: current_term_idx integer, private :: dummy_msg integer, private :: finished_nodes logical, private :: handling_local_workers logical, private :: has_pending integer, private :: hess_dim integer, private :: local_dummy integer, private :: local_finished_workers type(MPI_Status), private :: local_status type(request_t), private :: req integer, private :: request_source type( calculation_result_t ), private, allocatable :: results (:) integer(kind=int64), private :: results_received type(MPI_Status), private :: status integer(kind=int64), private :: term_idx real(kind=dp), private :: total_energy real(kind=dp), private, allocatable :: total_gradient (:,:) real(kind=dp), private, allocatable :: total_hessian (:,:) integer, private :: worker_source integer(kind=int64), private :: worker_term_map (node_comm%size()) Source Code subroutine gmbe_pie_coordinator ( world_comm , node_comm , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method , calc_type , bonds ) !! MPI coordinator for PIE-based GMBE calculations !! Distributes PIE terms across MPI ranks and accumulates results use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian type ( comm_t ), intent ( in ) :: world_comm , node_comm integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( in ) :: n_pie_terms integer , intent ( in ) :: node_leader_ranks (:), num_nodes type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method , calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( timer_type ) :: coord_timer integer ( int64 ) :: current_term_idx , results_received , term_idx integer :: finished_nodes integer :: request_source , dummy_msg type ( MPI_Status ) :: status , local_status logical :: handling_local_workers , has_pending integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer ( int64 ) :: worker_term_map ( node_comm % size ()) integer :: worker_source real ( dp ) :: total_energy real ( dp ), allocatable :: total_gradient (:, :) real ( dp ), allocatable :: total_hessian (:, :) integer :: hess_dim ! MPI request handles type ( request_t ) :: req if ( int ( size ( pie_atom_sets , 2 ), int64 ) < n_pie_terms . or . & int ( size ( pie_coefficients ), int64 ) < n_pie_terms ) then call logger % error ( \"PIE term arrays are smaller than n_pie_terms\" ) error stop \"Invalid PIE term array sizes\" end if current_term_idx = n_pie_terms finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( node_comm % size () > 1 ) results_received = 0_int64 worker_term_map = 0 allocate ( results ( n_pie_terms )) call logger % verbose ( \"GMBE PIE coordinator starting with \" // to_char ( n_pie_terms ) // & \" PIE terms for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers if ( handling_local_workers ) then do call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE if ( worker_term_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no term was assigned!\" ) error stop \"Invalid worker_term_map state\" end if call result_irecv ( results ( worker_term_map ( worker_source )), node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) worker_term_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , n_pie_terms / 10_int64 )) == 0 . or . & results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit call irecv ( world_comm , term_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( term_idx ), world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , n_pie_terms / 10_int64 )) == 0 . or . & results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_term_idx >= 1 ) then call send_pie_term_to_node ( world_comm , current_term_idx , pie_atom_sets , request_source ) current_term_idx = current_term_idx - 1 else call isend ( world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < node_comm % size () - 1 ) then call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then if ( worker_term_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_term_idx >= 1 ) then call send_pie_term_to_worker ( node_comm , current_term_idx , pie_atom_sets , local_status % MPI_SOURCE ) worker_term_map ( local_status % MPI_SOURCE ) = current_term_idx current_term_idx = current_term_idx - 1 else call isend ( node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= node_comm % size () - 1 & . and . results_received >= n_pie_terms ) then handling_local_workers = . false . finished_nodes = finished_nodes + 1 end if end do call logger % verbose ( \"GMBE PIE coordinator finished all terms\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all PIE terms \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Accumulate results with PIE coefficients call logger % info ( \" \" ) call logger % info ( \"Computing GMBE PIE energy...\" ) call coord_timer % start () total_energy = 0.0_dp do term_idx = 1_int64 , n_pie_terms total_energy = total_energy + real ( pie_coefficients ( term_idx ), dp ) * results ( term_idx )% energy % total () end do ! Handle gradients if computed if ( calc_type == CALC_TYPE_GRADIENT ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp do term_idx = 1_int64 , n_pie_terms if ( results ( term_idx )% has_gradient ) then ! Map fragment gradient to system coordinates block use mqc_error , only : error_t real ( dp ), allocatable :: term_gradient (:, :) type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) call phys_frag % destroy () deallocate ( atom_list ) end if ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system block use pic_logger , only : info_level integer :: iatom , current_log_level call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end block deallocate ( total_gradient ) end if ! Handle Hessians if computed if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp ! Also allocate gradient for Hessian calculations if (. not . allocated ( total_gradient )) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if do term_idx = 1_int64 , n_pie_terms if ( results ( term_idx )% has_hessian . or . results ( term_idx )% has_gradient ) then block use mqc_error , only : error_t real ( dp ), allocatable :: term_gradient (:, :), term_hessian (:, :) type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) ! Redistribute gradient if present if ( results ( term_idx )% has_gradient ) then allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end if ! Redistribute Hessian if present if ( results ( term_idx )% has_hessian ) then allocate ( term_hessian ( hess_dim , hess_dim )) term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( term_idx )% hessian , term_hessian ) total_hessian = total_hessian + real ( pie_coefficients ( term_idx ), dp ) * term_hessian deallocate ( term_hessian ) end if call phys_frag % destroy () deallocate ( atom_list ) end if end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print Hessian information call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if call coord_timer % stop () call logger % info ( \"Time to compute GMBE PIE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) call logger % info ( \" \" ) ! Write JSON output (reuse existing function) block real ( dp ), allocatable :: pie_energies (:) allocate ( pie_energies ( n_pie_terms )) do term_idx = 1_int64 , n_pie_terms pie_energies ( term_idx ) = results ( term_idx )% energy % total () end do call print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) deallocate ( pie_energies ) end block deallocate ( results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) end subroutine gmbe_pie_coordinator","tags":"","url":"proc/gmbe_pie_coordinator.html"},{"title":"serial_gmbe_pie_processor – metalquicha","text":"public  subroutine serial_gmbe_pie_processor(pie_atom_sets, pie_coefficients, n_pie_terms, sys_geom, method, calc_type, bonds) Uses mqc_calc_types mqc_physical_fragment mqc_error pic_logger proc~~serial_gmbe_pie_processor~~UsesGraph proc~serial_gmbe_pie_processor serial_gmbe_pie_processor module~mqc_calc_types mqc_calc_types proc~serial_gmbe_pie_processor->module~mqc_calc_types module~mqc_error mqc_error proc~serial_gmbe_pie_processor->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment proc~serial_gmbe_pie_processor->module~mqc_physical_fragment pic_logger pic_logger proc~serial_gmbe_pie_processor->pic_logger pic_types pic_types module~mqc_calc_types->pic_types module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Serial GMBE processor using PIE coefficients\nEvaluates each unique atom set once and sums with PIE coefficients\nSupports energy-only, energy+gradient, and energy+gradient+Hessian calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(in) :: n_pie_terms type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~serial_gmbe_pie_processor~~CallsGraph proc~serial_gmbe_pie_processor serial_gmbe_pie_processor cart_disp cart_disp proc~serial_gmbe_pie_processor->cart_disp configuration configuration proc~serial_gmbe_pie_processor->configuration error error proc~serial_gmbe_pie_processor->error fc_mdyne fc_mdyne proc~serial_gmbe_pie_processor->fc_mdyne force_constants force_constants proc~serial_gmbe_pie_processor->force_constants frequencies frequencies proc~serial_gmbe_pie_processor->frequencies info info proc~serial_gmbe_pie_processor->info interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~calc_type_to_string calc_type_to_string proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~compute_vibrational_analysis compute_vibrational_analysis proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~serial_gmbe_pie_processor->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~serial_gmbe_pie_processor->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~print_vibrational_analysis print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~redistribute_cap_gradients redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian reduced_masses reduced_masses proc~serial_gmbe_pie_processor->reduced_masses to_char to_char proc~serial_gmbe_pie_processor->to_char verbose verbose proc~serial_gmbe_pie_processor->verbose proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~print_gmbe_pie_json->error proc~print_gmbe_pie_json->info proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_pie_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol warning warning proc~print_vibrational_analysis->warning proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~do_fragment_work->configuration proc~do_fragment_work->error proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~mass_weight_hessian->proc~element_mass proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->info proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~serial_gmbe_pie_processor~~CalledByGraph proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: atom_list (:) integer, private :: coeff integer, private :: current_log_level type( error_t ), private :: error integer, private :: hess_dim integer, private :: iatom integer, private :: max_atoms integer, private :: n_atoms type( physical_fragment_t ), private :: phys_frag real(kind=dp), private, allocatable :: pie_energies (:) Store individual energies for JSON output type( calculation_result_t ), private, allocatable :: results (:) real(kind=dp), private :: term_energy real(kind=dp), private, allocatable :: term_gradient (:,:) Temporary gradient for each term real(kind=dp), private, allocatable :: term_hessian (:,:) Temporary Hessian for each term integer(kind=int64), private :: term_idx real(kind=dp), private :: total_energy real(kind=dp), private, allocatable :: total_gradient (:,:) Total gradient (3, total_atoms) real(kind=dp), private, allocatable :: total_hessian (:,:) Total Hessian (3 total_atoms, 3 total_atoms) Source Code subroutine serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , sys_geom , method , calc_type , bonds ) !! Serial GMBE processor using PIE coefficients !! Evaluates each unique atom set once and sums with PIE coefficients !! Supports energy-only, energy+gradient, and energy+gradient+Hessian calculations use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN , CALC_TYPE_ENERGY , calc_type_to_string use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian use mqc_error , only : error_t use pic_logger , only : info_level integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( in ) :: n_pie_terms type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method , calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: phys_frag type ( calculation_result_t ), allocatable :: results (:) type ( error_t ) :: error integer :: n_atoms , max_atoms , iatom , current_log_level , hess_dim integer ( int64 ) :: term_idx integer , allocatable :: atom_list (:) real ( dp ) :: total_energy , term_energy real ( dp ), allocatable :: pie_energies (:) !! Store individual energies for JSON output real ( dp ), allocatable :: total_gradient (:, :) !! Total gradient (3, total_atoms) real ( dp ), allocatable :: term_gradient (:, :) !! Temporary gradient for each term real ( dp ), allocatable :: total_hessian (:, :) !! Total Hessian (3*total_atoms, 3*total_atoms) real ( dp ), allocatable :: term_hessian (:, :) !! Temporary Hessian for each term integer :: coeff if ( int ( size ( pie_atom_sets , 2 ), int64 ) < n_pie_terms . or . & int ( size ( pie_coefficients ), int64 ) < n_pie_terms ) then call logger % error ( \"PIE term arrays are smaller than n_pie_terms\" ) error stop \"Invalid PIE term array sizes\" end if call logger % info ( \"Processing \" // to_char ( n_pie_terms ) // \" unique PIE terms...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) total_energy = 0.0_dp max_atoms = size ( pie_atom_sets , 1 ) allocate ( pie_energies ( n_pie_terms )) allocate ( results ( n_pie_terms )) ! Allocate gradient and Hessian arrays if needed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) allocate ( term_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp end if do term_idx = 1_int64 , n_pie_terms coeff = pie_coefficients ( term_idx ) ! Skip terms with zero coefficient (shouldn't happen, but safety check) if ( coeff == 0 ) then pie_energies ( term_idx ) = 0.0_dp ! Mark as skipped cycle end if ! Extract atom list for this term n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms == 0 ) then pie_energies ( term_idx ) = 0.0_dp ! Mark as skipped cycle end if allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment from atom list call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build intersection fragment\" end if ! Compute energy (and gradient if requested) call do_fragment_work ( term_idx , results ( term_idx ), method , phys_frag , calc_type ) term_energy = results ( term_idx )% energy % total () ! Store energy for JSON output pie_energies ( term_idx ) = term_energy ! Accumulate with PIE coefficient total_energy = total_energy + real ( coeff , dp ) * term_energy ! Accumulate gradient if present if (( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) . and . & results ( term_idx )% has_gradient ) then ! Map fragment gradient to system coordinates with proper cap handling term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( coeff , dp ) * term_gradient end if ! Accumulate Hessian if present if ( calc_type == CALC_TYPE_HESSIAN . and . results ( term_idx )% has_hessian ) then ! Map fragment Hessian to system coordinates with proper cap handling term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( term_idx )% hessian , term_hessian ) ! Accumulate with PIE coefficient total_hessian = total_hessian + real ( coeff , dp ) * term_hessian end if call logger % verbose ( \"PIE term \" // to_char ( term_idx ) // \"/\" // to_char ( n_pie_terms ) // & \": \" // to_char ( n_atoms ) // \" atoms, coeff=\" // to_char ( coeff ) // & \", E=\" // to_char ( term_energy )) deallocate ( atom_list ) call phys_frag % destroy () end do call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) ! Print gradient info if computed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end if ! Print Hessian info if computed if ( calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if call logger % info ( \" \" ) ! Write JSON output call print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) deallocate ( pie_energies , results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( term_gradient )) deallocate ( term_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) if ( allocated ( term_hessian )) deallocate ( term_hessian ) end subroutine serial_gmbe_pie_processor","tags":"","url":"proc/serial_gmbe_pie_processor.html"},{"title":"send_pie_term_to_node – metalquicha","text":"private  subroutine send_pie_term_to_node(world_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to remote node coordinator Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank Calls proc~~send_pie_term_to_node~~CallsGraph proc~send_pie_term_to_node send_pie_term_to_node isend isend proc~send_pie_term_to_node->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_pie_term_to_node~~CalledByGraph proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: atom_list (:) integer(kind=int32), private :: fragment_type integer, private :: max_atoms integer, private :: n_atoms type(request_t), private :: req (4) Source Code subroutine send_pie_term_to_node ( world_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to remote node coordinator type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( world_comm , term_idx , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , n_atoms , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , atom_list , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_node","tags":"","url":"proc/send_pie_term_to_node.html"},{"title":"send_pie_term_to_worker – metalquicha","text":"private  subroutine send_pie_term_to_worker(node_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to local worker Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank Calls proc~~send_pie_term_to_worker~~CallsGraph proc~send_pie_term_to_worker send_pie_term_to_worker isend isend proc~send_pie_term_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_pie_term_to_worker~~CalledByGraph proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: atom_list (:) integer(kind=int32), private :: fragment_type integer, private :: max_atoms integer, private :: n_atoms type(request_t), private :: req (4) Source Code subroutine send_pie_term_to_worker ( node_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to local worker type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( node_comm , term_idx , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , n_atoms , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , atom_list , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_worker","tags":"","url":"proc/send_pie_term_to_worker.html"},{"title":"normalize_basis_name – metalquicha","text":"public pure function normalize_basis_name(basis_name) result(normalized) Normalize basis set name to filename-safe format Rules:\n  * -> s\n  + -> p\n  Remove parentheses and commas Examples:\n  6-31G -> 6-31Gs\n  6-31+G -> 6-31pGs\n  6-31G(d)    -> 6-31Gd\n  6-311G(d,p) -> 6-311Gdp\n  6-311++G**  -> 6-311ppGss\n  cc-pVDZ     -> cc-pVDZ (unchanged) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name Return Value character(len=:), allocatable Called by proc~~normalize_basis_name~~CalledByGraph proc~normalize_basis_name normalize_basis_name proc~find_basis_file find_basis_file proc~find_basis_file->proc~normalize_basis_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: buffer integer, private :: i logical, private :: in_parens integer, private :: out_pos Source Code pure function normalize_basis_name ( basis_name ) result ( normalized ) !! Normalize basis set name to filename-safe format !! !! Rules: !!   * -> s !!   + -> p !!   Remove parentheses and commas !! !! Examples: !!   6-31G*      -> 6-31Gs !!   6-31+G*     -> 6-31pGs !!   6-31G(d)    -> 6-31Gd !!   6-311G(d,p) -> 6-311Gdp !!   6-311++G**  -> 6-311ppGss !!   cc-pVDZ     -> cc-pVDZ (unchanged) character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable :: normalized integer :: i , out_pos character ( len = 256 ) :: buffer logical :: in_parens buffer = \"\" out_pos = 0 in_parens = . false . do i = 1 , len_trim ( basis_name ) select case ( basis_name ( i : i )) case ( '*' ) ! Star becomes 's' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 's' case ( '+' ) ! Plus becomes 'p' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 'p' case ( '(' ) ! Start of parentheses - we'll extract contents in_parens = . true . case ( ')' ) ! End of parentheses in_parens = . false . case ( ',' , ' ' ) ! Skip commas and spaces (inside or outside parentheses) continue case default ! Copy character as-is out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = basis_name ( i : i ) end select end do normalized = trim ( buffer ( 1 : out_pos )) end function normalize_basis_name","tags":"","url":"proc/normalize_basis_name.html"},{"title":"find_basis_file – metalquicha","text":"public  subroutine find_basis_file(basis_name, filename, error) Find basis set file using normalized name Search strategy:\n  1. Normalize the basis name (e.g., 6-31G* -> 6-31Gs)\n  2. Look for basis_sets/{normalized}.txt\n  3. If not found, return error This is a simple, straightforward approach that assumes\nthe JSON/mqc input provides the correct basis set name. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name character(len=:), intent(out), allocatable :: filename type( error_t ), intent(out) :: error Calls proc~~find_basis_file~~CallsGraph proc~find_basis_file find_basis_file proc~error_set error_t%error_set proc~find_basis_file->proc~error_set proc~normalize_basis_name normalize_basis_name proc~find_basis_file->proc~normalize_basis_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: file_exists character(len=512), private :: filepath character(len=:), private, allocatable :: normalized Source Code subroutine find_basis_file ( basis_name , filename , error ) !! Find basis set file using normalized name !! !! Search strategy: !!   1. Normalize the basis name (e.g., 6-31G* -> 6-31Gs) !!   2. Look for basis_sets/{normalized}.txt !!   3. If not found, return error !! !! This is a simple, straightforward approach that assumes !! the JSON/mqc input provides the correct basis set name. character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable , intent ( out ) :: filename type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: normalized logical :: file_exists character ( len = 512 ) :: filepath ! Normalize the basis name normalized = normalize_basis_name ( basis_name ) ! Construct file path: basis_sets/{normalized}.txt filepath = \"basis_sets/\" // trim ( normalized ) // \".txt\" ! Check if file exists inquire ( file = trim ( filepath ), exist = file_exists ) if ( file_exists ) then filename = trim ( filepath ) else call error % set ( ERROR_IO , \"Basis set file not found: \" // trim ( filepath ) // & \" (from basis name: \" // trim ( basis_name ) // \")\" ) end if end subroutine find_basis_file","tags":"","url":"proc/find_basis_file.html"},{"title":"ang_mom_char_to_int – metalquicha","text":"public pure function ang_mom_char_to_int(ang_mom_char) result(ang_mom) Convert angular momentum character to integer Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6\nSpecial case: L=-1 (combined S+P shell, requires splitting) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ang_mom_char Angular momentum symbol Return Value integer Corresponding integer value Called by proc~~ang_mom_char_to_int~~CalledByGraph proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~ang_mom_char_to_int proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function ang_mom_char_to_int ( ang_mom_char ) result ( ang_mom ) !! Convert angular momentum character to integer !! !! Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6 !! Special case: L=-1 (combined S+P shell, requires splitting) character ( len = 1 ), intent ( in ) :: ang_mom_char !! Angular momentum symbol integer :: ang_mom !! Corresponding integer value select case ( ang_mom_char ) case ( 'S' ) ang_mom = 0 case ( 'P' ) ang_mom = 1 case ( 'D' ) ang_mom = 2 case ( 'F' ) ang_mom = 3 case ( 'G' ) ang_mom = 4 case ( 'H' ) ang_mom = 5 case ( 'I' ) ang_mom = 6 case ( 'L' ) ang_mom = - 1 ! Special case: L shells are split into S+P case default ang_mom = - 1 end select end function ang_mom_char_to_int","tags":"","url":"proc/ang_mom_char_to_int.html"},{"title":"ang_mom_int_to_char – metalquicha","text":"public pure function ang_mom_int_to_char(ang_mom) result(ang_mom_char) Convert angular momentum integer to character Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I\nReturns ‘?’ for invalid input values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ang_mom Angular momentum quantum number Return Value character(len=1) Corresponding symbol character Source Code pure function ang_mom_int_to_char ( ang_mom ) result ( ang_mom_char ) !! Convert angular momentum integer to character !! !! Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I !! Returns '?' for invalid input values. integer , intent ( in ) :: ang_mom !! Angular momentum quantum number character ( len = 1 ) :: ang_mom_char !! Corresponding symbol character select case ( ang_mom ) case ( 0 ) ang_mom_char = 'S' case ( 1 ) ang_mom_char = 'P' case ( 2 ) ang_mom_char = 'D' case ( 3 ) ang_mom_char = 'F' case ( 4 ) ang_mom_char = 'G' case ( 5 ) ang_mom_char = 'H' case ( 6 ) ang_mom_char = 'I' case default ang_mom_char = '?' end select end function ang_mom_int_to_char","tags":"","url":"proc/ang_mom_int_to_char.html"},{"title":"classify_line – metalquicha","text":"public pure function classify_line(line) result(line_type) Classify a line from a gamess formatted basis set file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer Calls proc~~classify_line~~CallsGraph proc~classify_line classify_line proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~classify_line~~CalledByGraph proc~classify_line classify_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: line_trim Source Code pure function classify_line ( line ) result ( line_type ) !! Classify a line from a gamess formatted basis set file character ( len =* ), intent ( in ) :: line integer :: line_type character ( len = :), allocatable :: line_trim line_trim = trim ( adjustl ( line )) if ( is_blank_or_control ( line_trim )) then line_type = LINE_UNKNOWN else if ( is_function_line ( line_trim )) then line_type = LINE_FUNCTION else if ( is_shell_header ( line_trim )) then line_type = LINE_SHELL else line_type = LINE_ATOM end if end function classify_line","tags":"","url":"proc/classify_line.html"},{"title":"is_blank_or_control – metalquicha","text":"private pure function is_blank_or_control(line) result(res) Check if a line is blank or a control line (starts with ‘$’) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_blank_or_control~~CalledByGraph proc~is_blank_or_control is_blank_or_control proc~classify_line classify_line proc~classify_line->proc~is_blank_or_control proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: trimmed_len Source Code pure function is_blank_or_control ( line ) result ( res ) !! Check if a line is blank or a control line (starts with '$') character ( len =* ), intent ( in ) :: line logical :: res integer :: trimmed_len trimmed_len = len_trim ( line ) if ( trimmed_len == 0 ) then res = . true . else res = ( line ( 1 : 1 ) == '$' ) end if end function is_blank_or_control","tags":"","url":"proc/is_blank_or_control.html"},{"title":"is_function_line – metalquicha","text":"private pure function is_function_line(line) result(res) Check if a line is a function coefficient line (starts with a number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_function_line~~CalledByGraph proc~is_function_line is_function_line proc~classify_line classify_line proc~classify_line->proc~is_function_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: first_char Source Code pure function is_function_line ( line ) result ( res ) !! Check if a line is a function coefficient line (starts with a number) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char if ( len_trim ( line ) == 0 ) then res = . false . return end if first_char = line ( 1 : 1 ) res = ( first_char >= '0' . and . first_char <= '9' ) end function is_function_line","tags":"","url":"proc/is_function_line.html"},{"title":"is_shell_header – metalquicha","text":"private pure function is_shell_header(line) result(res) Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_shell_header~~CalledByGraph proc~is_shell_header is_shell_header proc~classify_line classify_line proc~classify_line->proc~is_shell_header proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: dummy character(len=1), private :: first_char integer, private :: ios Source Code pure function is_shell_header ( line ) result ( res ) !! Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char integer :: ios , dummy res = . false . if ( len_trim ( line ) == 0 ) return first_char = line ( 1 : 1 ) if (. not . any ( first_char == [ 'S' , 'P' , 'D' , 'F' , 'G' , 'H' , 'I' , 'L' ])) return read ( line ( 2 :), * , iostat = ios ) dummy res = ( ios == 0 ) end function is_shell_header","tags":"","url":"proc/is_shell_header.html"},{"title":"build_molecular_basis – metalquicha","text":"public  subroutine build_molecular_basis(basis_string, element_names, mol_basis, error) Build molecular basis from geometry and basis file\nOnly parses unique elements, then copies basis data to atoms Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_names (:) Element for each atom in geometry order type( molecular_basis_type ), intent(out) :: mol_basis type( error_t ), intent(out) :: error Calls proc~~build_molecular_basis~~CallsGraph proc~build_molecular_basis build_molecular_basis proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~build_molecular_basis->proc~atomic_basis_destroy proc~basis_set_allocate_elements molecular_basis_type%basis_set_allocate_elements proc~build_molecular_basis->proc~basis_set_allocate_elements proc~copy_atomic_basis copy_atomic_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~error_add_context error_t%error_add_context proc~build_molecular_basis->proc~error_add_context proc~error_get_message error_t%error_get_message proc~build_molecular_basis->proc~error_get_message proc~error_has_error error_t%error_has_error proc~build_molecular_basis->proc~error_has_error proc~error_set error_t%error_set proc~build_molecular_basis->proc~error_set proc~find_unique_strings find_unique_strings proc~build_molecular_basis->proc~find_unique_strings proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~strings_equal strings_equal proc~build_molecular_basis->proc~strings_equal proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis->proc~allocate_basis_shells proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis->proc~cgto_allocate_arrays proc~find_unique_strings->proc~strings_equal proc~parse_element_basis->proc~error_add_context proc~parse_element_basis->proc~error_has_error proc~parse_element_basis->proc~error_set proc~parse_element_basis->proc~allocate_basis_shells proc~count_shells_for_element count_shells_for_element proc~parse_element_basis->proc~count_shells_for_element proc~fill_element_basis fill_element_basis proc~parse_element_basis->proc~fill_element_basis proc~count_shells_for_element->proc~error_set proc~count_shells_for_element->proc~strings_equal proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~fill_element_basis->proc~error_set proc~fill_element_basis->proc~strings_equal proc~fill_element_basis->proc~cgto_allocate_arrays proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~fill_element_basis->proc~classify_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom integer, private :: iunique integer, private :: match_idx integer, private :: natoms integer, private :: nunique type( atomic_basis_type ), private, allocatable :: unique_bases (:) character(len=:), private, allocatable :: unique_elements (:) Source Code subroutine build_molecular_basis ( basis_string , element_names , mol_basis , error ) !! Build molecular basis from geometry and basis file !! Only parses unique elements, then copies basis data to atoms character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_names (:) !! Element for each atom in geometry order type ( molecular_basis_type ), intent ( out ) :: mol_basis type ( error_t ), intent ( out ) :: error integer :: iatom , natoms , iunique , nunique character ( len = :), allocatable :: unique_elements (:) type ( atomic_basis_type ), allocatable :: unique_bases (:) integer :: match_idx match_idx = 0 natoms = size ( element_names ) ! Find unique elements call find_unique_strings ( element_names , unique_elements , nunique ) print * , \"Found \" , nunique , \" unique elements out of \" , natoms , \" atoms\" ! Allocate for unique bases allocate ( unique_bases ( nunique )) ! Parse basis for each unique element do iunique = 1 , nunique print * , \"Parsing basis for: \" , trim ( unique_elements ( iunique )) call parse_element_basis ( basis_string , unique_elements ( iunique ), & unique_bases ( iunique ), error ) if ( error % has_error ()) then ! Prepend context to error message call error % add_context ( \"mqc_basis_reader:read_basis_from_string\" ) call error % set ( ERROR_PARSE , \"Failed to parse basis for element \" // & trim ( unique_elements ( iunique )) // \": \" // error % get_message ()) return end if end do ! Allocate molecular basis and assign to each atom call mol_basis % allocate_elements ( natoms ) do iatom = 1 , natoms ! Find which unique element this atom corresponds to do iunique = 1 , nunique if ( strings_equal ( element_names ( iatom ), unique_elements ( iunique ))) then match_idx = iunique exit end if end do ! Copy the basis data call copy_atomic_basis ( unique_bases ( match_idx ), mol_basis % elements ( iatom )) end do ! Clean up do iunique = 1 , nunique call unique_bases ( iunique )% destroy () end do end subroutine build_molecular_basis","tags":"","url":"proc/build_molecular_basis.html"},{"title":"parse_element_basis – metalquicha","text":"public pure subroutine parse_element_basis(basis_string, element_name, atom_basis, error) Parse basis set for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(out) :: atom_basis type( error_t ), intent(out) :: error Calls proc~~parse_element_basis~~CallsGraph proc~parse_element_basis parse_element_basis proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~parse_element_basis->proc~allocate_basis_shells proc~count_shells_for_element count_shells_for_element proc~parse_element_basis->proc~count_shells_for_element proc~error_add_context error_t%error_add_context proc~parse_element_basis->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_element_basis->proc~error_has_error proc~error_set error_t%error_set proc~parse_element_basis->proc~error_set proc~fill_element_basis fill_element_basis proc~parse_element_basis->proc~fill_element_basis proc~count_shells_for_element->proc~error_set proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~strings_equal strings_equal proc~count_shells_for_element->proc~strings_equal proc~fill_element_basis->proc~error_set proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~fill_element_basis->proc~cgto_allocate_arrays proc~fill_element_basis->proc~classify_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~fill_element_basis->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_element_basis~~CalledByGraph proc~parse_element_basis parse_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: nshells Source Code pure subroutine parse_element_basis ( basis_string , element_name , atom_basis , error ) !! Parse basis set for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( out ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: nshells ! Pass 1: Find the element and count its shells call count_shells_for_element ( basis_string , element_name , nshells , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_basis_reader:parse_element_basis\" ) return end if if ( nshells == 0 ) then call error % set ( ERROR_PARSE , \"Element \" // trim ( element_name ) // \" not found in basis file\" ) return end if ! ! Allocate shells atom_basis % element = trim ( element_name ) call atom_basis % allocate_shells ( nshells ) ! ! Pass 2: Parse and fill shell data call fill_element_basis ( basis_string , element_name , atom_basis , error ) end subroutine parse_element_basis","tags":"","url":"proc/parse_element_basis.html"},{"title":"copy_atomic_basis – metalquicha","text":"private pure subroutine copy_atomic_basis(source, dest) Deep copy of atomic basis data from source to dest Arguments Type Intent Optional Attributes Name type( atomic_basis_type ), intent(in) :: source type( atomic_basis_type ), intent(out) :: dest Calls proc~~copy_atomic_basis~~CallsGraph proc~copy_atomic_basis copy_atomic_basis proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis->proc~allocate_basis_shells proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis->proc~cgto_allocate_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_atomic_basis~~CalledByGraph proc~copy_atomic_basis copy_atomic_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ishell Source Code pure subroutine copy_atomic_basis ( source , dest ) !! Deep copy of atomic basis data from source to dest type ( atomic_basis_type ), intent ( in ) :: source type ( atomic_basis_type ), intent ( out ) :: dest integer :: ishell dest % element = source % element call dest % allocate_shells ( source % nshells ) do ishell = 1 , source % nshells dest % shells ( ishell )% ang_mom = source % shells ( ishell )% ang_mom call dest % shells ( ishell )% allocate_arrays ( source % shells ( ishell )% nfunc ) dest % shells ( ishell )% exponents = source % shells ( ishell )% exponents dest % shells ( ishell )% coefficients = source % shells ( ishell )% coefficients end do end subroutine copy_atomic_basis","tags":"","url":"proc/copy_atomic_basis.html"},{"title":"count_shells_for_element – metalquicha","text":"private pure subroutine count_shells_for_element(basis_string, element_name, nshells, error) Count the number of shells for a specific element in a GAMESS formatted basis string, Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name integer, intent(out) :: nshells type( error_t ), intent(out) :: error Calls proc~~count_shells_for_element~~CallsGraph proc~count_shells_for_element count_shells_for_element proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~error_set error_t%error_set proc~count_shells_for_element->proc~error_set proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~strings_equal strings_equal proc~count_shells_for_element->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~count_shells_for_element~~CalledByGraph proc~count_shells_for_element count_shells_for_element proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: ang_mom logical, private :: found_element logical, private :: in_target_element character(len=256), private :: line integer, private :: line_end integer, private :: line_start integer, private :: line_type Source Code pure subroutine count_shells_for_element ( basis_string , element_name , nshells , error ) !! Count the number of shells for a specific element in a GAMESS formatted basis string, character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name integer , intent ( out ) :: nshells type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_target_element , found_element character ( len = 1 ) :: ang_mom nshells = 0 in_target_element = . false . found_element = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) case ( LINE_ATOM ) ! Check if this is our target element if ( strings_equal ( line , element_name )) then in_target_element = . true . found_element = . true . else ! Different element - stop counting if we were in target if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Extract angular momentum line = adjustl ( line ) ang_mom = line ( 1 : 1 ) ! L shells become 2 shells (S + P) if ( ang_mom == 'L' ) then nshells = nshells + 2 else nshells = nshells + 1 end if end if case ( LINE_UNKNOWN ) ! Skip blank lines and comments continue case default ! Skip any other line types (e.g., LINE_FUNCTION) continue end select line_start = line_end end do ! Check if we found the element at all if (. not . found_element ) then call error % set ( ERROR_PARSE , \"Element not found in basis string: \" // trim ( element_name )) end if end subroutine count_shells_for_element","tags":"","url":"proc/count_shells_for_element.html"},{"title":"fill_element_basis – metalquicha","text":"private pure subroutine fill_element_basis(basis_string, element_name, atom_basis, error) Fill in the shell data for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(inout) :: atom_basis type( error_t ), intent(out) :: error Calls proc~~fill_element_basis~~CallsGraph proc~fill_element_basis fill_element_basis proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~fill_element_basis->proc~cgto_allocate_arrays proc~classify_line classify_line proc~fill_element_basis->proc~classify_line proc~error_set error_t%error_set proc~fill_element_basis->proc~error_set proc~get_next_line get_next_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~strings_equal strings_equal proc~fill_element_basis->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_element_basis~~CalledByGraph proc~fill_element_basis fill_element_basis proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: ang_mom real(kind=dp), private :: coeff_p real(kind=dp), private :: coeff_s real(kind=dp), private :: exponent integer, private :: func_num logical, private :: has_p integer, private :: ifunc logical, private :: in_data_block logical, private :: in_target_element integer, private :: ishell integer, private :: l_shell_p_idx integer, private :: l_shell_s_idx character(len=256), private :: line integer, private :: line_end integer, private :: line_start integer, private :: line_type integer, private :: nfunc logical, private :: reading_l_shell integer, private :: stat Source Code pure subroutine fill_element_basis ( basis_string , element_name , atom_basis , error ) !! Fill in the shell data for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( inout ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_data_block , in_target_element character ( len = 1 ) :: ang_mom integer :: nfunc , func_num , ishell , ifunc real ( dp ) :: exponent , coeff_s , coeff_p logical :: has_p ! L shell handling: we split into two shells, need to track both logical :: reading_l_shell integer :: l_shell_s_idx , l_shell_p_idx integer :: stat in_data_block = . false . in_target_element = . false . ishell = 0 reading_l_shell = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) ! case (LINE_UNKNOWN) !   if (index(line, '$DATA') > 0) then !     in_data_block = .true. !   else if (index(line, '$END') > 0) then !     exit !   end if case ( LINE_ATOM ) if ( strings_equal ( line , element_name )) then in_target_element = . true . else if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Parse shell header call parse_shell_header ( line , ang_mom , nfunc , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse shell header: \" // trim ( line )) return end if if ( ang_mom == 'L' ) then ! L shell: create two shells (S and P) reading_l_shell = . true . ishell = ishell + 1 l_shell_s_idx = ishell atom_basis % shells ( ishell )% ang_mom = 0 ! S call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ishell = ishell + 1 l_shell_p_idx = ishell atom_basis % shells ( ishell )% ang_mom = 1 ! P call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 ! Reset function counter else ! Regular shell reading_l_shell = . false . ishell = ishell + 1 ! Set angular momentum (S=0, P=1, D=2, F=3, G=4, H=5, I=6) atom_basis % shells ( ishell )% ang_mom = ang_mom_char_to_int ( ang_mom ) call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 end if end if case ( LINE_FUNCTION ) if ( in_target_element ) then call parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse function line: \" // trim ( line )) return end if ifunc = ifunc + 1 if ( reading_l_shell ) then if (. not . has_p ) then call error % set ( ERROR_PARSE , \"L shell requires both S and P coefficients\" ) return end if ! Store in both S and P shells atom_basis % shells ( l_shell_s_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_s_idx )% coefficients ( ifunc ) = coeff_s atom_basis % shells ( l_shell_p_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_p_idx )% coefficients ( ifunc ) = coeff_p else ! Store in current shell atom_basis % shells ( ishell )% exponents ( ifunc ) = exponent atom_basis % shells ( ishell )% coefficients ( ifunc ) = coeff_s end if end if case default ! Skip unknown line types (e.g., LINE_UNKNOWN, blank lines, comments) continue end select line_start = line_end end do end subroutine fill_element_basis","tags":"","url":"proc/fill_element_basis.html"},{"title":"find_unique_strings – metalquicha","text":"private pure subroutine find_unique_strings(input_array, unique_array, nunique) Find unique strings in an array\nReturns array of unique strings and count Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_array (:) character(len=:), intent(out), allocatable :: unique_array (:) integer, intent(out) :: nunique Calls proc~~find_unique_strings~~CallsGraph proc~find_unique_strings find_unique_strings proc~strings_equal strings_equal proc~find_unique_strings->proc~strings_equal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_unique_strings~~CalledByGraph proc~find_unique_strings find_unique_strings proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~find_unique_strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i logical, private :: is_unique integer, private :: j integer, private :: n character(len=len), private, allocatable :: temp_unique (:) Source Code pure subroutine find_unique_strings ( input_array , unique_array , nunique ) !! Find unique strings in an array !! Returns array of unique strings and count character ( len =* ), intent ( in ) :: input_array (:) character ( len = :), allocatable , intent ( out ) :: unique_array (:) integer , intent ( out ) :: nunique integer :: i , j , n logical :: is_unique character ( len = len ( input_array )), allocatable :: temp_unique (:) n = size ( input_array ) allocate ( temp_unique ( n )) ! Max possible size nunique = 0 do i = 1 , n is_unique = . true . ! Check if we've already seen this string do j = 1 , nunique if ( strings_equal ( input_array ( i ), temp_unique ( j ))) then is_unique = . false . exit end if end do if ( is_unique ) then nunique = nunique + 1 temp_unique ( nunique ) = input_array ( i ) end if end do ! Allocate output array with exact size and copy allocate ( character ( len = len ( input_array )) :: unique_array ( nunique )) unique_array = temp_unique ( 1 : nunique ) end subroutine find_unique_strings","tags":"","url":"proc/find_unique_strings.html"},{"title":"get_next_line – metalquicha","text":"private pure subroutine get_next_line(string, line_start, line, line_end) Extract the next line from a string starting at line_start Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: line_start character(len=*), intent(out) :: line integer, intent(out) :: line_end Called by proc~~get_next_line~~CalledByGraph proc~get_next_line get_next_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~get_next_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~get_next_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: newline_pos Source Code pure subroutine get_next_line ( string , line_start , line , line_end ) !! Extract the next line from a string starting at line_start character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: line_start character ( len =* ), intent ( out ) :: line integer , intent ( out ) :: line_end integer :: newline_pos if ( line_start > len ( string )) then line = '' line_end = 0 return end if newline_pos = index ( string ( line_start :), new_line ( 'a' )) if ( newline_pos == 0 ) then ! Last line (no newline at end) line = string ( line_start :) line_end = len ( string ) + 1 else line = string ( line_start : line_start + newline_pos - 2 ) line_end = line_start + newline_pos end if end subroutine get_next_line","tags":"","url":"proc/get_next_line.html"},{"title":"parse_function_line – metalquicha","text":"private pure subroutine parse_function_line(line, func_num, exponent, coeff_s, coeff_p, has_p, stat) Parse function line (e.g., “1 1.0 2.0” or “1 1.0 2.0 3.0” for L shells) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(out) :: func_num real(kind=dp), intent(out) :: exponent real(kind=dp), intent(out) :: coeff_s real(kind=dp), intent(out), optional :: coeff_p logical, intent(out) :: has_p integer, intent(out) :: stat Called by proc~~parse_function_line~~CalledByGraph proc~parse_function_line parse_function_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~parse_function_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: temp_p Source Code pure subroutine parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) !! Parse function line (e.g., \"1 1.0 2.0\" or \"1 1.0 2.0 3.0\" for L shells) character ( len =* ), intent ( in ) :: line integer , intent ( out ) :: func_num real ( dp ), intent ( out ) :: exponent real ( dp ), intent ( out ) :: coeff_s real ( dp ), intent ( out ), optional :: coeff_p logical , intent ( out ) :: has_p integer , intent ( out ) :: stat real ( dp ) :: temp_p has_p = . false . ! Try to read 4 values (func_num, exponent, coeff_s, coeff_p) read ( line , * , iostat = stat ) func_num , exponent , coeff_s , temp_p if ( stat == 0 ) then ! Successfully read 4 values - this is an L shell has_p = . true . if ( present ( coeff_p )) coeff_p = temp_p else ! Try reading just 3 values (func_num, exponent, coeff_s) read ( line , * , iostat = stat ) func_num , exponent , coeff_s end if end subroutine parse_function_line","tags":"","url":"proc/parse_function_line.html"},{"title":"parse_shell_header – metalquicha","text":"private pure subroutine parse_shell_header(line, ang_mom, nfunc, stat) Parse shell header line (e.g., “S 2” or “L 3”) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(out) :: ang_mom integer, intent(out) :: nfunc integer, intent(out) :: stat Called by proc~~parse_shell_header~~CalledByGraph proc~parse_shell_header parse_shell_header proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~parse_shell_header proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: line_trim Source Code pure subroutine parse_shell_header ( line , ang_mom , nfunc , stat ) !! Parse shell header line (e.g., \"S 2\" or \"L 3\") character ( len =* ), intent ( in ) :: line character ( len = 1 ), intent ( out ) :: ang_mom integer , intent ( out ) :: nfunc integer , intent ( out ) :: stat character ( len = 256 ) :: line_trim line_trim = adjustl ( line ) ang_mom = line_trim ( 1 : 1 ) ! Read the number of functions read ( line_trim ( 2 :), * , iostat = stat ) nfunc end subroutine parse_shell_header","tags":"","url":"proc/parse_shell_header.html"},{"title":"int_to_string – metalquicha","text":"private pure function int_to_string(i) result(str) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Called by proc~~int_to_string~~CalledByGraph proc~int_to_string int_to_string proc~read_xyz_string read_xyz_string proc~read_xyz_string->proc~int_to_string proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: buffer Source Code pure function int_to_string ( i ) result ( str ) !! Convert integer to string integer , intent ( in ) :: i character ( len = :), allocatable :: str character ( len = 20 ) :: buffer write ( buffer , '(I0)' ) i str = trim ( adjustl ( buffer )) end function int_to_string","tags":"","url":"proc/int_to_string.html"},{"title":"read_xyz_file – metalquicha","text":"public  subroutine read_xyz_file(filename, geom, error) Read molecular geometry from XYZ format file Parses standard XYZ files with format:\nLine 1: Number of atoms\nLine 2: Comment/title line\nLines 3+: Element X Y Z (coordinates in Angstrom) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Path to XYZ file type( geometry_type ), intent(out) :: geom Parsed molecular geometry type( error_t ), intent(out) :: error Error handling Calls proc~~read_xyz_file~~CallsGraph proc~read_xyz_file read_xyz_file proc~error_add_context error_t%error_add_context proc~read_xyz_file->proc~error_add_context proc~error_has_error error_t%error_has_error proc~read_xyz_file->proc~error_has_error proc~error_set error_t%error_set proc~read_xyz_file->proc~error_set proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~read_xyz_string->proc~error_set proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_xyz_file~~CalledByGraph proc~read_xyz_file read_xyz_file proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: file_contents Full file content buffer logical, private :: file_exists Whether file exists on disk integer, private :: file_size File size in bytes integer, private :: io_stat I/O operation status integer, private :: unit File unit number Source Code subroutine read_xyz_file ( filename , geom , error ) !! Read molecular geometry from XYZ format file !! !! Parses standard XYZ files with format: !! Line 1: Number of atoms !! Line 2: Comment/title line !! Lines 3+: Element X Y Z (coordinates in Angstrom) character ( len =* ), intent ( in ) :: filename !! Path to XYZ file type ( geometry_type ), intent ( out ) :: geom !! Parsed molecular geometry type ( error_t ), intent ( out ) :: error !! Error handling integer :: unit !! File unit number integer :: io_stat !! I/O operation status integer :: file_size !! File size in bytes logical :: file_exists !! Whether file exists on disk character ( len = :), allocatable :: file_contents !! Full file content buffer ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"XYZ file not found: \" // trim ( filename )) return end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: file_contents ) ! Open and read entire file as stream open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening file: \" // trim ( filename )) return end if read ( unit , iostat = io_stat ) file_contents close ( unit ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error reading file: \" // trim ( filename )) return end if ! Parse the contents call read_xyz_string ( file_contents , geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_xyz_reader:read_xyz_file\" ) return end if end subroutine read_xyz_file","tags":"","url":"proc/read_xyz_file.html"},{"title":"read_xyz_string – metalquicha","text":"public pure subroutine read_xyz_string(xyz_string, geom, error) Parse molecular geometry from XYZ format string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xyz_string type( geometry_type ), intent(out) :: geom type( error_t ), intent(out) :: error Calls proc~~read_xyz_string~~CallsGraph proc~read_xyz_string read_xyz_string proc~error_set error_t%error_set proc~read_xyz_string->proc~error_set proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_xyz_string~~CalledByGraph proc~read_xyz_string read_xyz_string proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: element integer, private :: iatom integer, private :: io_stat character(len=:), private, allocatable :: lines (:) integer, private :: nlines real(kind=dp), private :: x real(kind=dp), private :: y real(kind=dp), private :: z Source Code pure subroutine read_xyz_string ( xyz_string , geom , error ) !! Parse molecular geometry from XYZ format string character ( len =* ), intent ( in ) :: xyz_string type ( geometry_type ), intent ( out ) :: geom type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: lines (:) integer :: nlines , iatom , io_stat character ( len = 256 ) :: element real ( dp ) :: x , y , z ! Split into lines call split_lines ( xyz_string , lines , nlines ) if ( nlines < 2 ) then call error % set ( ERROR_PARSE , \"XYZ file must have at least 2 lines (natoms + comment)\" ) return end if ! Read number of atoms from first line read ( lines ( 1 ), * , iostat = io_stat ) geom % natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to read number of atoms from first line\" ) return end if if ( geom % natoms < 0 ) then call error % set ( ERROR_PARSE , \"Number of atoms must be non-negative\" ) return end if ! Store comment line geom % comment = trim ( adjustl ( lines ( 2 ))) ! Check we have enough lines if ( nlines < 2 + geom % natoms ) then call error % set ( ERROR_PARSE , \"XYZ file has insufficient lines: expected \" // & trim ( int_to_string ( 2 + geom % natoms )) // \", got \" // & trim ( int_to_string ( nlines ))) return end if ! Allocate arrays allocate ( character ( len = MAX_ELEMENT_SYMBOL_LEN ) :: geom % elements ( geom % natoms )) allocate ( geom % coords ( 3 , geom % natoms )) ! Read atom data do iatom = 1 , geom % natoms read ( lines ( 2 + iatom ), * , iostat = io_stat ) element , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse atom data on line \" // & trim ( int_to_string ( 2 + iatom )) // \": '\" // & trim ( lines ( 2 + iatom )) // \"'\" ) return end if geom % elements ( iatom ) = trim ( adjustl ( element )) geom % coords ( 1 , iatom ) = x geom % coords ( 2 , iatom ) = y geom % coords ( 3 , iatom ) = z end do end subroutine read_xyz_string","tags":"","url":"proc/read_xyz_string.html"},{"title":"split_lines – metalquicha","text":"public pure subroutine split_lines(text, lines, nlines) Split input text into lines based on CR, LF, or CRLF line endings\nTrailing newlines do not create empty lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text character(len=:), intent(out), allocatable :: lines (:) integer, intent(out) :: nlines Called by proc~~split_lines~~CalledByGraph proc~split_lines split_lines proc~read_xyz_string read_xyz_string proc~read_xyz_string->proc~split_lines proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: line_end integer, private :: line_start integer, private :: max_line_len character(len=:), private, allocatable :: temp_lines (:) Source Code pure subroutine split_lines ( text , lines , nlines ) !! Split input text into lines based on CR, LF, or CRLF line endings !! Trailing newlines do not create empty lines character ( len =* ), intent ( in ) :: text character ( len = :), allocatable , intent ( out ) :: lines (:) integer , intent ( out ) :: nlines integer :: i , line_start , line_end , max_line_len character ( len = :), allocatable :: temp_lines (:) if ( len ( text ) == 0 ) then nlines = 0 allocate ( character ( len = 1 ) :: lines ( 0 )) return end if ! Pass 1: Count lines and find maximum line length nlines = 0 max_line_len = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 ! Skip both CR and LF else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 max_line_len = max ( max_line_len , len ( text ) - line_start + 1 ) end if ! Handle empty text or ensure at least length 1 if ( max_line_len == 0 ) max_line_len = 1 ! Allocate output array allocate ( character ( len = max_line_len ) :: temp_lines ( nlines )) ! Pass 2: Extract lines nlines = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = len ( text ) - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if ! Copy to output (use explicit loop for Intel compiler compatibility) allocate ( character ( len = max_line_len ) :: lines ( nlines )) block integer :: iline do iline = 1 , nlines lines ( iline ) = temp_lines ( iline ) end do end block end subroutine split_lines","tags":"","url":"proc/split_lines.html"},{"title":"send_fragment_to_node – metalquicha","text":"subroutine send_fragment_to_node(world_comm, fragment_idx, polymers, dest_rank) Send fragment data to remote node coordinator\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank Calls proc~~send_fragment_to_node~~CallsGraph proc~send_fragment_to_node send_fragment_to_node isend isend proc~send_fragment_to_node->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_fragment_to_node~~CalledByGraph proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator global_coordinator proc~global_coordinator->proc~send_fragment_to_node interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: fragment_idx_int64 integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size integer(kind=int32), private :: fragment_type type(request_t), private :: req (4) Source Code subroutine send_fragment_to_node ( world_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to remote node coordinator !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int64 ) :: fragment_idx_int64 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int64 = int ( fragment_idx , kind = int64 ) call isend ( world_comm , fragment_idx_int64 , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , fragment_size , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , fragment_indices , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_node","tags":"","url":"proc/send_fragment_to_node.html"},{"title":"send_fragment_to_worker – metalquicha","text":"subroutine send_fragment_to_worker(node_comm, fragment_idx, polymers, dest_rank) Send fragment data to local worker\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank Calls proc~~send_fragment_to_worker~~CallsGraph proc~send_fragment_to_worker send_fragment_to_worker isend isend proc~send_fragment_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_fragment_to_worker~~CalledByGraph proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator global_coordinator proc~global_coordinator->proc~send_fragment_to_worker interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: fragment_idx_int64 integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size integer(kind=int32), private :: fragment_type type(request_t), private :: req (4) Source Code subroutine send_fragment_to_worker ( node_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to local worker !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int64 ) :: fragment_idx_int64 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int64 = int ( fragment_idx , kind = int64 ) call isend ( node_comm , fragment_idx_int64 , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , fragment_size , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , fragment_indices , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_worker","tags":"","url":"proc/send_fragment_to_worker.html"},{"title":"parse_method_string – metalquicha","text":"private  function parse_method_string(method_str) result(method_type) Parse method string from input file (e.g., “XTB-GFN1” -> gfn1) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Return Value integer(kind=int32) Calls proc~~parse_method_string~~CallsGraph proc~parse_method_string parse_method_string proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_method_string~~CalledByGraph proc~parse_method_string parse_method_string proc~parse_model_section parse_model_section proc~parse_model_section->proc~parse_method_string proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_model_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: dash_pos integer, private :: i character(len=:), private, allocatable :: lower_str character(len=:), private, allocatable :: method_part Source Code function parse_method_string ( method_str ) result ( method_type ) !! Parse method string from input file (e.g., \"XTB-GFN1\" -> gfn1) character ( len =* ), intent ( in ) :: method_str integer ( int32 ) :: method_type character ( len = :), allocatable :: lower_str , method_part integer :: dash_pos , i ! Convert to lowercase allocate ( character ( len = len_trim ( method_str )) :: lower_str ) lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Handle \"XTB-GFN1\" format -> extract \"gfn1\" if ( index ( lower_str , 'xtb' ) > 0 ) then dash_pos = index ( lower_str , '-' ) if ( dash_pos > 0 ) then method_part = lower_str ( dash_pos + 1 :) else method_part = lower_str end if else method_part = lower_str end if method_type = method_type_from_string ( method_part ) end function parse_method_string","tags":"","url":"proc/parse_method_string.html"},{"title":"strip_comment – metalquicha","text":"private pure function strip_comment(line) result(stripped) Remove comments (! or #) from a line and trim result Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value character(len=:), allocatable Called by proc~~strip_comment~~CalledByGraph proc~strip_comment strip_comment proc~parse_aimd_section parse_aimd_section proc~parse_aimd_section->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~parse_driver_section parse_driver_section proc~parse_driver_section->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragment->proc~strip_comment proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~strip_comment proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~strip_comment proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_generic->proc~skip_to_end proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_generic->proc~strip_comment proc~parse_hessian_section parse_hessian_section proc~parse_hessian_section->proc~strip_comment proc~parse_model_section parse_model_section proc~parse_model_section->proc~strip_comment proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~strip_comment proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~skip_to_end proc~parse_scf_section parse_scf_section proc~parse_scf_section->proc~strip_comment proc~parse_schema_section parse_schema_section proc~parse_schema_section->proc~strip_comment proc~parse_single_molecule->proc~strip_comment proc~parse_single_molecule->proc~skip_to_end proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic parse_structure_generic proc~parse_structure_generic->proc~strip_comment proc~parse_system_section parse_system_section proc~parse_system_section->proc~strip_comment proc~skip_to_end->proc~strip_comment proc~parse_connectivity_section parse_connectivity_section proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_section parse_geometry_section proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_structure_section parse_structure_section proc~parse_structure_section->proc~parse_structure_generic proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_aimd_section proc~read_mqc_file->proc~parse_driver_section proc~read_mqc_file->proc~parse_fragmentation_section proc~read_mqc_file->proc~parse_hessian_section proc~read_mqc_file->proc~parse_model_section proc~read_mqc_file->proc~parse_molecules_section proc~read_mqc_file->proc~parse_scf_section proc~read_mqc_file->proc~parse_schema_section proc~read_mqc_file->proc~parse_system_section proc~read_mqc_file->proc~skip_to_end proc~read_mqc_file->proc~parse_connectivity_section proc~read_mqc_file->proc~parse_fragments_section proc~read_mqc_file->proc~parse_geometry_section proc~read_mqc_file->proc~parse_structure_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: comment_pos Source Code pure function strip_comment ( line ) result ( stripped ) !! Remove comments (! or #) from a line and trim result character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: stripped integer :: comment_pos ! Find first occurrence of ! or # comment_pos = index ( line , '!' ) if ( comment_pos == 0 ) comment_pos = index ( line , '#' ) if ( comment_pos > 0 ) then ! Comment found - take everything before it stripped = trim ( adjustl ( line ( 1 : comment_pos - 1 ))) else ! No comment - use full line stripped = trim ( adjustl ( line )) end if end function strip_comment","tags":"","url":"proc/strip_comment.html"},{"title":"read_mqc_file – metalquicha","text":"public  subroutine read_mqc_file(filename, config, error) Read and parse a .mqc format input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( mqc_config_t ), intent(out) :: config type( error_t ), intent(out) :: error Calls proc~~read_mqc_file~~CallsGraph proc~read_mqc_file read_mqc_file proc~error_add_context error_t%error_add_context proc~read_mqc_file->proc~error_add_context proc~error_has_error error_t%error_has_error proc~read_mqc_file->proc~error_has_error proc~error_set error_t%error_set proc~read_mqc_file->proc~error_set proc~parse_aimd_section parse_aimd_section proc~read_mqc_file->proc~parse_aimd_section proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_driver_section parse_driver_section proc~read_mqc_file->proc~parse_driver_section proc~parse_fragmentation_section parse_fragmentation_section proc~read_mqc_file->proc~parse_fragmentation_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_geometry_section parse_geometry_section proc~read_mqc_file->proc~parse_geometry_section proc~parse_hessian_section parse_hessian_section proc~read_mqc_file->proc~parse_hessian_section proc~parse_model_section parse_model_section proc~read_mqc_file->proc~parse_model_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_scf_section parse_scf_section proc~read_mqc_file->proc~parse_scf_section proc~parse_schema_section parse_schema_section proc~read_mqc_file->proc~parse_schema_section proc~parse_structure_section parse_structure_section proc~read_mqc_file->proc~parse_structure_section proc~parse_system_section parse_system_section proc~read_mqc_file->proc~parse_system_section proc~skip_to_end skip_to_end proc~read_mqc_file->proc~skip_to_end proc~parse_aimd_section->proc~error_set proc~strip_comment strip_comment proc~parse_aimd_section->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_driver_section->proc~error_set proc~calc_type_from_string calc_type_from_string proc~parse_driver_section->proc~calc_type_from_string proc~parse_driver_section->proc~strip_comment proc~parse_fragmentation_section->proc~error_add_context proc~parse_fragmentation_section->proc~error_has_error proc~parse_fragmentation_section->proc~error_set proc~parse_fragmentation_section->proc~strip_comment proc~validate_cutoffs validate_cutoffs proc~parse_fragmentation_section->proc~validate_cutoffs proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_hessian_section->proc~error_set proc~parse_hessian_section->proc~strip_comment proc~parse_model_section->proc~error_set proc~parse_method_string parse_method_string proc~parse_model_section->proc~parse_method_string proc~parse_model_section->proc~strip_comment proc~parse_molecules_section->proc~error_add_context proc~parse_molecules_section->proc~error_has_error proc~parse_molecules_section->proc~error_set proc~parse_molecules_section->proc~skip_to_end proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~strip_comment proc~parse_scf_section->proc~error_set proc~parse_scf_section->proc~strip_comment proc~parse_schema_section->proc~error_set proc~parse_schema_section->proc~strip_comment proc~parse_structure_generic parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~parse_system_section->proc~error_set proc~parse_system_section->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_add_context proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string proc~parse_single_molecule->proc~error_add_context proc~parse_single_molecule->proc~error_has_error proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_single_molecule->proc~strip_comment proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~validate_cutoffs->proc~error_set proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_mqc_file~~CalledByGraph proc~read_mqc_file read_mqc_file program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: file_exists integer, private :: io_stat character(len=MAX_LINE_LEN), private :: line type( error_t ), private :: parse_error integer, private :: unit Source Code subroutine read_mqc_file ( filename , config , error ) !! Read and parse a .mqc format input file character ( len =* ), intent ( in ) :: filename type ( mqc_config_t ), intent ( out ) :: config type ( error_t ), intent ( out ) :: error integer :: unit , io_stat character ( len = MAX_LINE_LEN ) :: line logical :: file_exists type ( error_t ) :: parse_error inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"Input file not found: \" // trim ( filename )) return end if open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening input file: \" // trim ( filename )) return end if ! Set defaults config % log_level = \"info\" ! Read file line by line and dispatch to section parsers do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for section start if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%schema' ) call parse_schema_section ( unit , config , parse_error ) case ( '%model' ) call parse_model_section ( unit , config , parse_error ) case ( '%driver' ) call parse_driver_section ( unit , config , parse_error ) case ( '%structure' ) call parse_structure_section ( unit , config , parse_error ) case ( '%geometry' ) call parse_geometry_section ( unit , config , parse_error ) case ( '%fragments' ) call parse_fragments_section ( unit , config , parse_error ) case ( '%connectivity' ) call parse_connectivity_section ( unit , config , parse_error ) case ( '%scf' ) call parse_scf_section ( unit , config , parse_error ) case ( '%hessian' ) call parse_hessian_section ( unit , config , parse_error ) case ( '%aimd' ) call parse_aimd_section ( unit , config , parse_error ) case ( '%fragmentation' ) call parse_fragmentation_section ( unit , config , parse_error ) case ( '%system' ) call parse_system_section ( unit , config , parse_error ) case ( '%molecules' ) call parse_molecules_section ( unit , config , parse_error ) case default ! Skip unknown sections call skip_to_end ( unit , parse_error ) end select if ( parse_error % has_error ()) then error = parse_error call error % add_context ( \"mqc_config_parser:read_mqc_file\" ) close ( unit ) return end if end if end do close ( unit ) ! Validate required fields if (. not . allocated ( config % schema_name )) then call error % set ( ERROR_VALIDATION , \"Missing required section: %schema\" ) return end if ! Validate geometry: required for single-molecule mode, not for multi-molecule mode if ( config % nmol == 0 ) then ! Single molecule mode: require top-level geometry if (. not . allocated ( config % geometry % coords ) . or . config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"Missing required section: %geometry\" ) return end if else ! Multi-molecule mode: each molecule must have geometry (validated during parsing) ! No additional validation needed here end if end subroutine read_mqc_file","tags":"","url":"proc/read_mqc_file.html"},{"title":"config_destroy – metalquicha","text":"private  subroutine config_destroy(this) Clean up allocated memory in mqc_config_t Type Bound mqc_config_t Arguments Type Intent Optional Attributes Name class( mqc_config_t ), intent(inout) :: this Calls proc~~config_destroy~~CallsGraph proc~config_destroy mqc_config_t%config_destroy proc~geometry_destroy geometry_type%geometry_destroy proc~config_destroy->proc~geometry_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine config_destroy ( this ) !! Clean up allocated memory in mqc_config_t class ( mqc_config_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % schema_name )) deallocate ( this % schema_name ) if ( allocated ( this % schema_version )) deallocate ( this % schema_version ) if ( allocated ( this % units )) deallocate ( this % units ) if ( allocated ( this % basis )) deallocate ( this % basis ) if ( allocated ( this % aux_basis )) deallocate ( this % aux_basis ) if ( allocated ( this % log_level )) deallocate ( this % log_level ) if ( allocated ( this % frag_method )) deallocate ( this % frag_method ) if ( allocated ( this % embedding )) deallocate ( this % embedding ) if ( allocated ( this % cutoff_method )) deallocate ( this % cutoff_method ) if ( allocated ( this % distance_metric )) deallocate ( this % distance_metric ) if ( allocated ( this % fragment_cutoffs )) deallocate ( this % fragment_cutoffs ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) ! Clean up molecules array (multi-molecule mode) if ( allocated ( this % molecules )) then do i = 1 , size ( this % molecules ) call this % molecules ( i )% destroy () end do deallocate ( this % molecules ) end if end subroutine config_destroy","tags":"","url":"proc/config_destroy.html"},{"title":"input_fragment_destroy – metalquicha","text":"private  subroutine input_fragment_destroy(this) Clean up allocated memory in input_fragment_t Type Bound input_fragment_t Arguments Type Intent Optional Attributes Name class( input_fragment_t ), intent(inout) :: this Source Code subroutine input_fragment_destroy ( this ) !! Clean up allocated memory in input_fragment_t class ( input_fragment_t ), intent ( inout ) :: this if ( allocated ( this % indices )) deallocate ( this % indices ) end subroutine input_fragment_destroy","tags":"","url":"proc/input_fragment_destroy.html"},{"title":"molecule_destroy – metalquicha","text":"private  subroutine molecule_destroy(this) Clean up allocated memory in molecule_t Type Bound molecule_t Arguments Type Intent Optional Attributes Name class( molecule_t ), intent(inout) :: this Calls proc~~molecule_destroy~~CallsGraph proc~molecule_destroy molecule_t%molecule_destroy proc~geometry_destroy geometry_type%geometry_destroy proc~molecule_destroy->proc~geometry_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine molecule_destroy ( this ) !! Clean up allocated memory in molecule_t class ( molecule_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % name )) deallocate ( this % name ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) end subroutine molecule_destroy","tags":"","url":"proc/molecule_destroy.html"},{"title":"parse_aimd_section – metalquicha","text":"private  subroutine parse_aimd_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_aimd_section~~CallsGraph proc~parse_aimd_section parse_aimd_section proc~error_set error_t%error_set proc~parse_aimd_section->proc~error_set proc~strip_comment strip_comment proc~parse_aimd_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_aimd_section~~CalledByGraph proc~parse_aimd_section parse_aimd_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_aimd_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_aimd_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %aimd section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'dt' , 'timestep' ) read ( value , * , iostat = io_stat ) config % aimd_dt case ( 'nsteps' , 'steps' ) read ( value , * , iostat = io_stat ) config % aimd_nsteps case ( 'initial_temperature' , 'temperature' ) read ( value , * , iostat = io_stat ) config % aimd_initial_temperature case ( 'output_frequency' , 'output_freq' ) read ( value , * , iostat = io_stat ) config % aimd_output_frequency case default call error % set ( ERROR_PARSE , \"Unknown key in %aimd section: \" // trim ( key )) return end select end do end subroutine parse_aimd_section","tags":"","url":"proc/parse_aimd_section.html"},{"title":"parse_connectivity_generic – metalquicha","text":"private  subroutine parse_connectivity_generic(unit, nbonds, nbroken, bonds, error) Generic parser for %connectivity section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nbonds integer, intent(inout) :: nbroken type( bond_t ), intent(inout), allocatable :: bonds (:) type( error_t ), intent(out) :: error Calls proc~~parse_connectivity_generic~~CallsGraph proc~parse_connectivity_generic parse_connectivity_generic proc~error_set error_t%error_set proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_connectivity_generic~~CalledByGraph proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section parse_connectivity_section proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_connectivity proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_connectivity_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_i integer, private :: atom_j integer, private :: eq_pos integer, private :: ibond integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line integer, private :: nbonds_local integer, private :: order character(len=MAX_LINE_LEN), private :: status_str character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_connectivity_generic ( unit , nbonds , nbroken , bonds , error ) !! Generic parser for %connectivity section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nbonds , nbroken type ( bond_t ), allocatable , intent ( inout ) :: bonds (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value , status_str integer :: io_stat , eq_pos , nbonds_local , ibond integer :: atom_i , atom_j , order nbonds_local = 0 ! First pass: read nbonds do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %connectivity section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbonds' ) then read ( value , * , iostat = io_stat ) nbonds_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nbonds value\" ) return end if exit end if end if end do if ( nbonds_local == 0 ) then ! No bonds, just skip to end call skip_to_end ( unit , error ) return end if nbonds = nbonds_local allocate ( bonds ( nbonds )) ! Read bonds ibond = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for key=value pairs (like nbroken=9) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbroken' ) then read ( value , * , iostat = io_stat ) nbroken end if cycle end if if ( trim ( strip_comment ( line )) == 'end' ) exit ! Parse bond line: atom_i atom_j order broken/preserved read ( line , * , iostat = io_stat ) atom_i , atom_j , order , status_str if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid bond format in %connectivity section\" ) return end if ibond = ibond + 1 if ( ibond > nbonds ) then call error % set ( ERROR_PARSE , \"More bonds than declared nbonds\" ) return end if bonds ( ibond )% atom_i = atom_i bonds ( ibond )% atom_j = atom_j bonds ( ibond )% order = order bonds ( ibond )% is_broken = ( trim ( status_str ) == 'broken' ) end do end subroutine parse_connectivity_generic","tags":"","url":"proc/parse_connectivity_generic.html"},{"title":"parse_connectivity_section – metalquicha","text":"private  subroutine parse_connectivity_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_connectivity_section~~CallsGraph proc~parse_connectivity_section parse_connectivity_section proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section->proc~parse_connectivity_generic proc~error_set error_t%error_set proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_connectivity_section~~CalledByGraph proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_connectivity_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_connectivity_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , config % nbonds , config % nbroken , config % bonds , error ) end subroutine parse_connectivity_section","tags":"","url":"proc/parse_connectivity_section.html"},{"title":"parse_driver_section – metalquicha","text":"private  subroutine parse_driver_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_driver_section~~CallsGraph proc~parse_driver_section parse_driver_section proc~calc_type_from_string calc_type_from_string proc~parse_driver_section->proc~calc_type_from_string proc~error_set error_t%error_set proc~parse_driver_section->proc~error_set proc~strip_comment strip_comment proc~parse_driver_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_driver_section~~CalledByGraph proc~parse_driver_section parse_driver_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_driver_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_driver_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %driver section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'type' ) config % calc_type = calc_type_from_string ( trim ( value )) if ( config % calc_type == CALC_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid calc_type: \" // trim ( value )) return end if case default call error % set ( ERROR_PARSE , \"Unknown key in %driver section: \" // trim ( key )) return end select end do end subroutine parse_driver_section","tags":"","url":"proc/parse_driver_section.html"},{"title":"parse_fragment – metalquicha","text":"private  subroutine parse_fragment(unit, fragment, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error Calls proc~~parse_fragment~~CallsGraph proc~parse_fragment parse_fragment proc~error_add_context error_t%error_add_context proc~parse_fragment->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_fragment->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragment->proc~error_set proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~strip_comment strip_comment proc~parse_fragment->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragment~~CalledByGraph proc~parse_fragment parse_fragment proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments parse_molecule_fragments proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos logical, private :: in_indices integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_fragment ( unit , fragment , error ) integer , intent ( in ) :: unit type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_indices in_indices = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragment\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_indices ) then in_indices = . false . cycle else exit end if end if if ( trim ( line ) == '%indices' ) then in_indices = . true . cycle end if if ( in_indices ) then ! Read indices call parse_indices_line ( line , fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_single_fragment_section\" ) return end if else eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) fragment % charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) fragment % multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in fragment properties: \" // trim ( key )) return end select end if end if end do end subroutine parse_fragment","tags":"","url":"proc/parse_fragment.html"},{"title":"parse_fragmentation_section – metalquicha","text":"private  subroutine parse_fragmentation_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_fragmentation_section~~CallsGraph proc~parse_fragmentation_section parse_fragmentation_section proc~error_add_context error_t%error_add_context proc~parse_fragmentation_section->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_fragmentation_section->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragmentation_section->proc~error_set proc~strip_comment strip_comment proc~parse_fragmentation_section->proc~strip_comment proc~validate_cutoffs validate_cutoffs proc~parse_fragmentation_section->proc~validate_cutoffs proc~validate_cutoffs->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragmentation_section~~CalledByGraph proc~parse_fragmentation_section parse_fragmentation_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragmentation_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos logical, private :: in_cutoffs integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_fragmentation_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_cutoffs in_cutoffs = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragmentation section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_cutoffs ) then ! Validate cutoffs before leaving the cutoffs section call validate_cutoffs ( config , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_fragmentation_section\" ) return end if in_cutoffs = . false . cycle else exit end if end if if ( trim ( line ) == '%cutoffs' ) then in_cutoffs = . true . cycle end if eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( in_cutoffs ) then ! Parse cutoffs: numeric keys like \"2\", \"3\", \"4\", etc. ! representing n-mer level (2=dimer, 3=trimer, etc.) block integer :: nmer_level real ( dp ) :: cutoff_value ! Try to read the key as an integer (n-mer level) read ( key , * , iostat = io_stat ) nmer_level if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid n-mer level in cutoffs (expected integer): \" // trim ( key )) return end if ! Validate n-mer level if ( nmer_level < 2 ) then call error % set ( ERROR_PARSE , \"N-mer level must be >= 2 in cutoffs\" ) return end if if ( nmer_level > 10 ) then call error % set ( ERROR_PARSE , \"N-mer level too large in cutoffs (max 10 for decamer)\" ) return end if ! Read the cutoff value read ( value , * , iostat = io_stat ) cutoff_value if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid cutoff value: \" // trim ( value )) return end if ! Allocate array if not yet allocated (up to decamer = 10) if (. not . allocated ( config % fragment_cutoffs )) then allocate ( config % fragment_cutoffs ( 10 )) config % fragment_cutoffs = - 1.0_dp ! Initialize with sentinel value end if ! Store the cutoff value at the appropriate index config % fragment_cutoffs ( nmer_level ) = cutoff_value end block else select case ( trim ( key )) case ( 'method' ) config % frag_method = trim ( value ) case ( 'level' ) read ( value , * , iostat = io_stat ) config % frag_level if ( io_stat == 0 ) then if ( config % frag_level < 0 ) then call error % set ( ERROR_VALIDATION , \"Fragmentation level must be >= 0 (0 = unfragmented)\" ) return end if if ( config % frag_level > 10 ) then call error % set ( ERROR_VALIDATION , & \"Fragmentation level must be <= 10 (decamers). Higher levels not supported.\" ) return end if end if case ( 'allow_overlapping_fragments' ) config % allow_overlapping_fragments = ( trim ( value ) == 'true' ) case ( 'max_intersection_level' ) read ( value , * , iostat = io_stat ) config % max_intersection_level if ( io_stat == 0 ) then if ( config % max_intersection_level < 1 ) then call error % set ( ERROR_VALIDATION , \"max_intersection_level must be >= 1\" ) return end if if ( config % max_intersection_level > 10 ) then call error % set ( ERROR_VALIDATION , & \"max_intersection_level must be <= 10 (decamers). Higher levels not supported.\" ) return end if end if case ( 'embedding' ) config % embedding = trim ( value ) case ( 'cutoff_method' ) config % cutoff_method = trim ( value ) case ( 'distance_metric' ) config % distance_metric = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %fragmentation section: \" // trim ( key )) return end select end if end do end subroutine parse_fragmentation_section","tags":"","url":"proc/parse_fragmentation_section.html"},{"title":"parse_fragments_generic – metalquicha","text":"private  subroutine parse_fragments_generic(unit, nfrag, fragments, error) Generic parser for %fragments section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nfrag type( input_fragment_t ), intent(inout), allocatable :: fragments (:) type( error_t ), intent(out) :: error Calls proc~~parse_fragments_generic~~CallsGraph proc~parse_fragments_generic parse_fragments_generic proc~error_add_context error_t%error_add_context proc~parse_fragments_generic->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_fragments_generic->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragments_generic->proc~error_set proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~skip_to_end skip_to_end proc~parse_fragments_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragments_generic~~CalledByGraph proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments parse_molecule_fragments proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: ifrag integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=256), private :: msg integer, private :: nfrag_local character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_fragments_generic ( unit , nfrag , fragments , error ) !! Generic parser for %fragments section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nfrag type ( input_fragment_t ), allocatable , intent ( inout ) :: fragments (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nfrag_local , ifrag nfrag_local = 0 ! First pass: read nfrag do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragments section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nfrag' ) then read ( value , * , iostat = io_stat ) nfrag_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nfrag value\" ) return end if exit end if end if end do if ( nfrag_local == 0 ) then ! No fragments, just skip to end call skip_to_end ( unit , error ) return end if nfrag = nfrag_local allocate ( fragments ( nfrag )) ! Parse individual fragments ifrag = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%fragment' ) then ifrag = ifrag + 1 if ( ifrag > nfrag ) then call error % set ( ERROR_PARSE , \"More fragments than declared nfrag\" ) return end if call parse_fragment ( unit , fragments ( ifrag ), error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_molecule_fragments\" ) return end if end if end do if ( ifrag /= nfrag ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nfrag , \" fragments, found \" , ifrag call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_fragments_generic","tags":"","url":"proc/parse_fragments_generic.html"},{"title":"parse_fragments_section – metalquicha","text":"private  subroutine parse_fragments_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_fragments_section~~CallsGraph proc~parse_fragments_section parse_fragments_section proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~error_add_context error_t%error_add_context proc~parse_fragments_generic->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_fragments_generic->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragments_generic->proc~error_set proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~skip_to_end skip_to_end proc~parse_fragments_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragments_section~~CalledByGraph proc~parse_fragments_section parse_fragments_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_fragments_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , config % nfrag , config % fragments , error ) end subroutine parse_fragments_section","tags":"","url":"proc/parse_fragments_section.html"},{"title":"parse_geometry_generic – metalquicha","text":"private  subroutine parse_geometry_generic(unit, geom, error) Generic parser for %geometry section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( geometry_type ), intent(inout) :: geom type( error_t ), intent(out) :: error Calls proc~~parse_geometry_generic~~CallsGraph proc~parse_geometry_generic parse_geometry_generic proc~error_set error_t%error_set proc~parse_geometry_generic->proc~error_set proc~strip_comment strip_comment proc~parse_geometry_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_geometry_generic~~CalledByGraph proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section parse_geometry_section proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_molecule_geometry parse_molecule_geometry proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_geometry proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_geometry_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=MAX_LINE_LEN), private :: elem integer, private :: i integer, private :: io_stat character(len=MAX_LINE_LEN), private :: line integer, private :: natoms real(kind=dp), private :: x real(kind=dp), private :: y real(kind=dp), private :: z Source Code subroutine parse_geometry_generic ( unit , geom , error ) !! Generic parser for %geometry section (works for both config and molecule) integer , intent ( in ) :: unit type ( geometry_type ), intent ( inout ) :: geom type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , elem integer :: io_stat , natoms , i real ( dp ) :: x , y , z ! Read number of atoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading natoms in %geometry section\" ) return end if read ( line , * , iostat = io_stat ) natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid natoms in %geometry section\" ) return end if geom % natoms = natoms ! Read blank line (comment line in XYZ format) read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading comment line in %geometry section\" ) return end if geom % comment = trim ( line ) ! Allocate arrays allocate ( character ( len = 4 ) :: geom % elements ( natoms )) allocate ( geom % coords ( 3 , natoms )) ! Read coordinates do i = 1 , natoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry coordinates\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) then call error % set ( ERROR_PARSE , \"Unexpected 'end' while reading geometry\" ) return end if read ( line , * , iostat = io_stat ) elem , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid coordinate format in %geometry section\" ) return end if geom % elements ( i ) = trim ( elem ) geom % coords ( 1 , i ) = x geom % coords ( 2 , i ) = y geom % coords ( 3 , i ) = z end do ! Read 'end' marker read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_VALIDATION , \"Missing 'end' in %geometry section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) /= 'end' ) then call error % set ( ERROR_PARSE , \"Expected 'end' after geometry coordinates\" ) return end if end subroutine parse_geometry_generic","tags":"","url":"proc/parse_geometry_generic.html"},{"title":"parse_geometry_section – metalquicha","text":"private  subroutine parse_geometry_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_geometry_section~~CallsGraph proc~parse_geometry_section parse_geometry_section proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~error_set error_t%error_set proc~parse_geometry_generic->proc~error_set proc~strip_comment strip_comment proc~parse_geometry_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_geometry_section~~CalledByGraph proc~parse_geometry_section parse_geometry_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_geometry_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_geometry_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , config % geometry , error ) end subroutine parse_geometry_section","tags":"","url":"proc/parse_geometry_section.html"},{"title":"parse_hessian_section – metalquicha","text":"private  subroutine parse_hessian_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_hessian_section~~CallsGraph proc~parse_hessian_section parse_hessian_section proc~error_set error_t%error_set proc~parse_hessian_section->proc~error_set proc~strip_comment strip_comment proc~parse_hessian_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_hessian_section~~CalledByGraph proc~parse_hessian_section parse_hessian_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_hessian_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_hessian_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %hessian section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'finite_difference_displacement' , 'displacement' ) read ( value , * , iostat = io_stat ) config % hessian_displacement case default call error % set ( ERROR_PARSE , \"Unknown key in %hessian section: \" // trim ( key )) return end select end do end subroutine parse_hessian_section","tags":"","url":"proc/parse_hessian_section.html"},{"title":"parse_indices_line – metalquicha","text":"private  subroutine parse_indices_line(line, fragment, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error Calls proc~~parse_indices_line~~CallsGraph proc~parse_indices_line parse_indices_line proc~error_set error_t%error_set proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_indices_line~~CalledByGraph proc~parse_indices_line parse_indices_line proc~parse_fragment parse_fragment proc~parse_fragment->proc~parse_indices_line proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments parse_molecule_fragments proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: count integer, private :: i integer, private :: idx integer, private :: io_stat integer, private, allocatable :: new_indices (:) integer, private :: pos integer, private, allocatable :: temp_indices (:) character(len=MAX_LINE_LEN), private :: temp_line Source Code subroutine parse_indices_line ( line , fragment , error ) character ( len =* ), intent ( in ) :: line type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error integer :: io_stat , pos , count , i , idx character ( len = MAX_LINE_LEN ) :: temp_line integer , allocatable :: temp_indices (:), new_indices (:) temp_line = line ! Count how many integers count = 0 do read ( temp_line , * , iostat = io_stat ) idx if ( io_stat /= 0 ) exit count = count + 1 ! Remove the read integer from temp_line pos = scan ( temp_line , ' ' ) if ( pos == 0 ) exit temp_line = adjustl ( temp_line ( pos :)) end do if ( count == 0 ) return ! Allocate temporary array allocate ( temp_indices ( count )) ! Read the integers read ( line , * , iostat = io_stat ) temp_indices if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading fragment indices\" ) deallocate ( temp_indices ) return end if ! Append to existing indices if ( allocated ( fragment % indices )) then allocate ( new_indices ( size ( fragment % indices ) + count )) new_indices ( 1 : size ( fragment % indices )) = fragment % indices new_indices ( size ( fragment % indices ) + 1 :) = temp_indices call move_alloc ( new_indices , fragment % indices ) else call move_alloc ( temp_indices , fragment % indices ) end if end subroutine parse_indices_line","tags":"","url":"proc/parse_indices_line.html"},{"title":"parse_model_section – metalquicha","text":"private  subroutine parse_model_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_model_section~~CallsGraph proc~parse_model_section parse_model_section proc~error_set error_t%error_set proc~parse_model_section->proc~error_set proc~parse_method_string parse_method_string proc~parse_model_section->proc~parse_method_string proc~strip_comment strip_comment proc~parse_model_section->proc~strip_comment proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_model_section~~CalledByGraph proc~parse_model_section parse_model_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_model_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_model_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %model section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'method' ) ! Parse method string (e.g., \"XTB-GFN1\" -> \"gfn1\") config % method = parse_method_string ( trim ( value )) if ( config % method == METHOD_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid method: \" // trim ( value )) return end if case ( 'basis' ) config % basis = trim ( value ) case ( 'aux_basis' ) config % aux_basis = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %model section: \" // trim ( key )) return end select end do end subroutine parse_model_section","tags":"","url":"proc/parse_model_section.html"},{"title":"parse_molecule_connectivity – metalquicha","text":"private  subroutine parse_molecule_connectivity(unit, mol, error) Parse %connectivity section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_connectivity~~CallsGraph proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_connectivity_generic parse_connectivity_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~error_set error_t%error_set proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_connectivity~~CalledByGraph proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_connectivity ( unit , mol , error ) !! Parse %connectivity section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , mol % nbonds , mol % nbroken , mol % bonds , error ) end subroutine parse_molecule_connectivity","tags":"","url":"proc/parse_molecule_connectivity.html"},{"title":"parse_molecule_fragments – metalquicha","text":"private  subroutine parse_molecule_fragments(unit, mol, error) Parse %fragments section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_fragments~~CallsGraph proc~parse_molecule_fragments parse_molecule_fragments proc~parse_fragments_generic parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~error_add_context error_t%error_add_context proc~parse_fragments_generic->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_fragments_generic->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragments_generic->proc~error_set proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~skip_to_end skip_to_end proc~parse_fragments_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_fragments~~CalledByGraph proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_fragments ( unit , mol , error ) !! Parse %fragments section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , mol % nfrag , mol % fragments , error ) end subroutine parse_molecule_fragments","tags":"","url":"proc/parse_molecule_fragments.html"},{"title":"parse_molecule_geometry – metalquicha","text":"private  subroutine parse_molecule_geometry(unit, mol, error) Parse %geometry section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_geometry~~CallsGraph proc~parse_molecule_geometry parse_molecule_geometry proc~parse_geometry_generic parse_geometry_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~error_set error_t%error_set proc~parse_geometry_generic->proc~error_set proc~strip_comment strip_comment proc~parse_geometry_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_geometry~~CalledByGraph proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_geometry ( unit , mol , error ) !! Parse %geometry section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , mol % geometry , error ) end subroutine parse_molecule_geometry","tags":"","url":"proc/parse_molecule_geometry.html"},{"title":"parse_molecule_structure – metalquicha","text":"private  subroutine parse_molecule_structure(unit, mol, error) Parse %structure section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_structure~~CallsGraph proc~parse_molecule_structure parse_molecule_structure proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~error_set error_t%error_set proc~parse_structure_generic->proc~error_set proc~strip_comment strip_comment proc~parse_structure_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_structure~~CalledByGraph proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_structure ( unit , mol , error ) !! Parse %structure section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , mol % charge , mol % multiplicity , error ) end subroutine parse_molecule_structure","tags":"","url":"proc/parse_molecule_structure.html"},{"title":"parse_molecules_section – metalquicha","text":"private  subroutine parse_molecules_section(unit, config, error) Parse %molecules section containing multiple %molecule blocks Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_molecules_section~~CallsGraph proc~parse_molecules_section parse_molecules_section proc~error_add_context error_t%error_add_context proc~parse_molecules_section->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_molecules_section->proc~error_has_error proc~error_set error_t%error_set proc~parse_molecules_section->proc~error_set proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~skip_to_end skip_to_end proc~parse_molecules_section->proc~skip_to_end proc~strip_comment strip_comment proc~parse_molecules_section->proc~strip_comment proc~parse_single_molecule->proc~error_add_context proc~parse_single_molecule->proc~error_has_error proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_single_molecule->proc~strip_comment proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_fragments_generic parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_add_context proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecules_section~~CalledByGraph proc~parse_molecules_section parse_molecules_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: imol integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=256), private :: msg integer, private :: nmol character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_molecules_section ( unit , config , error ) !! Parse %molecules section containing multiple %molecule blocks integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nmol , imol nmol = 0 ! First pass: read nmol do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecules section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nmol' ) then read ( value , * , iostat = io_stat ) nmol if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nmol value\" ) return end if exit end if end if end do if ( nmol == 0 ) then ! No molecules, just skip to end call skip_to_end ( unit , error ) return end if config % nmol = nmol allocate ( config % molecules ( nmol )) ! Parse individual molecules imol = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%molecule' ) then imol = imol + 1 if ( imol > nmol ) then call error % set ( ERROR_PARSE , \"More molecules than declared nmol\" ) return end if call parse_single_molecule ( unit , config % molecules ( imol ), error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_molecules_section\" ) return end if end if end do if ( imol /= nmol ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nmol , \" molecules, found \" , imol call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_molecules_section","tags":"","url":"proc/parse_molecules_section.html"},{"title":"parse_scf_section – metalquicha","text":"private  subroutine parse_scf_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_scf_section~~CallsGraph proc~parse_scf_section parse_scf_section proc~error_set error_t%error_set proc~parse_scf_section->proc~error_set proc~strip_comment strip_comment proc~parse_scf_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_scf_section~~CalledByGraph proc~parse_scf_section parse_scf_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_scf_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_scf_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %scf section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'maxiter' ) read ( value , * , iostat = io_stat ) config % scf_maxiter case ( 'tolerance' ) read ( value , * , iostat = io_stat ) config % scf_tolerance case default call error % set ( ERROR_PARSE , \"Unknown key in %scf section: \" // trim ( key )) return end select end do end subroutine parse_scf_section","tags":"","url":"proc/parse_scf_section.html"},{"title":"parse_schema_section – metalquicha","text":"private  subroutine parse_schema_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_schema_section~~CallsGraph proc~parse_schema_section parse_schema_section proc~error_set error_t%error_set proc~parse_schema_section->proc~error_set proc~strip_comment strip_comment proc~parse_schema_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_schema_section~~CalledByGraph proc~parse_schema_section parse_schema_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_schema_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_schema_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Unexpected end of file in %schema section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'name' ) config % schema_name = trim ( value ) case ( 'version' ) config % schema_version = trim ( value ) case ( 'index_base' ) read ( value , * , iostat = io_stat ) config % index_base case ( 'units' ) config % units = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %schema section: \" // trim ( key )) return end select end do end subroutine parse_schema_section","tags":"","url":"proc/parse_schema_section.html"},{"title":"parse_single_molecule – metalquicha","text":"private  subroutine parse_single_molecule(unit, mol, error) Parse a single %molecule block with its sections Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_single_molecule~~CallsGraph proc~parse_single_molecule parse_single_molecule proc~error_add_context error_t%error_add_context proc~parse_single_molecule->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_single_molecule->proc~error_has_error proc~error_set error_t%error_set proc~parse_single_molecule->proc~error_set proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~skip_to_end skip_to_end proc~parse_single_molecule->proc~skip_to_end proc~strip_comment strip_comment proc~parse_single_molecule->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_fragments_generic parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_add_context proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_single_molecule~~CalledByGraph proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_single_molecule ( unit , mol , error ) !! Parse a single %molecule block with its sections integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecule\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit ! Check for key=value pairs (like name) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'name' ) then mol % name = trim ( value ) cycle end if end if ! Check for subsections if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%structure' ) call parse_molecule_structure ( unit , mol , error ) case ( '%geometry' ) call parse_molecule_geometry ( unit , mol , error ) case ( '%fragments' ) call parse_molecule_fragments ( unit , mol , error ) case ( '%connectivity' ) call parse_molecule_connectivity ( unit , mol , error ) case default ! Skip unknown subsections call skip_to_end ( unit , error ) end select if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_single_molecule\" ) return end if end if end do end subroutine parse_single_molecule","tags":"","url":"proc/parse_single_molecule.html"},{"title":"parse_structure_generic – metalquicha","text":"private  subroutine parse_structure_generic(unit, charge, multiplicity, error) Generic parser for %structure section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: charge integer, intent(inout) :: multiplicity type( error_t ), intent(out) :: error Calls proc~~parse_structure_generic~~CallsGraph proc~parse_structure_generic parse_structure_generic proc~error_set error_t%error_set proc~parse_structure_generic->proc~error_set proc~strip_comment strip_comment proc~parse_structure_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_structure_generic~~CalledByGraph proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure parse_molecule_structure proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_structure_section parse_structure_section proc~parse_structure_section->proc~parse_structure_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_structure proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_structure_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_structure_generic ( unit , charge , multiplicity , error ) !! Generic parser for %structure section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: charge , multiplicity type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %structure section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in %structure section: \" // trim ( key )) return end select end do end subroutine parse_structure_generic","tags":"","url":"proc/parse_structure_generic.html"},{"title":"parse_structure_section – metalquicha","text":"private  subroutine parse_structure_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_structure_section~~CallsGraph proc~parse_structure_section parse_structure_section proc~parse_structure_generic parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~error_set error_t%error_set proc~parse_structure_generic->proc~error_set proc~strip_comment strip_comment proc~parse_structure_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_structure_section~~CalledByGraph proc~parse_structure_section parse_structure_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_structure_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_structure_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , config % charge , config % multiplicity , error ) end subroutine parse_structure_section","tags":"","url":"proc/parse_structure_section.html"},{"title":"parse_system_section – metalquicha","text":"private  subroutine parse_system_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_system_section~~CallsGraph proc~parse_system_section parse_system_section proc~error_set error_t%error_set proc~parse_system_section->proc~error_set proc~strip_comment strip_comment proc~parse_system_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_system_section~~CalledByGraph proc~parse_system_section parse_system_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_system_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_system_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %system section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'log_level' ) config % log_level = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %system section: \" // trim ( key )) return end select end do end subroutine parse_system_section","tags":"","url":"proc/parse_system_section.html"},{"title":"skip_to_end – metalquicha","text":"private  subroutine skip_to_end(unit, error) Skip lines until ‘end’ marker is found Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( error_t ), intent(out) :: error Calls proc~~skip_to_end~~CallsGraph proc~skip_to_end skip_to_end proc~error_set error_t%error_set proc~skip_to_end->proc~error_set proc~strip_comment strip_comment proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~skip_to_end~~CalledByGraph proc~skip_to_end skip_to_end proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_generic->proc~skip_to_end proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~skip_to_end proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~skip_to_end proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_single_molecule->proc~skip_to_end proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~skip_to_end proc~read_mqc_file->proc~parse_molecules_section proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: io_stat character(len=MAX_LINE_LEN), private :: line Source Code subroutine skip_to_end ( unit , error ) !! Skip lines until 'end' marker is found integer , intent ( in ) :: unit type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line integer :: io_stat do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file while skipping section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) exit end do end subroutine skip_to_end","tags":"","url":"proc/skip_to_end.html"},{"title":"validate_cutoffs – metalquicha","text":"private  subroutine validate_cutoffs(config, error) Validate that fragment cutoffs are monotonically decreasing\nFor n-mer level N, cutoff(N) must be <= cutoff(N-1) Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: config type( error_t ), intent(out) :: error Calls proc~~validate_cutoffs~~CallsGraph proc~validate_cutoffs validate_cutoffs proc~error_set error_t%error_set proc~validate_cutoffs->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~validate_cutoffs~~CalledByGraph proc~validate_cutoffs validate_cutoffs proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~validate_cutoffs proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragmentation_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: cutoff_high real(kind=dp), private :: cutoff_low integer, private :: i integer, private :: level_high integer, private :: level_low character(len=256), private :: msg Source Code subroutine validate_cutoffs ( config , error ) !! Validate that fragment cutoffs are monotonically decreasing !! For n-mer level N, cutoff(N) must be <= cutoff(N-1) type ( mqc_config_t ), intent ( in ) :: config type ( error_t ), intent ( out ) :: error integer :: i , level_low , level_high real ( dp ) :: cutoff_low , cutoff_high character ( len = 256 ) :: msg if (. not . allocated ( config % fragment_cutoffs )) return ! Check monotonicity for consecutive levels with defined cutoffs do i = 2 , size ( config % fragment_cutoffs ) level_low = i - 1 level_high = i cutoff_low = config % fragment_cutoffs ( level_low ) cutoff_high = config % fragment_cutoffs ( level_high ) ! Skip if either cutoff is not defined (negative or zero sentinel value) if ( cutoff_low <= 0.0_dp . or . cutoff_high <= 0.0_dp ) cycle ! Validate monotonic decreasing if ( cutoff_high > cutoff_low ) then write ( msg , '(a,i0,a,f0.2,a,i0,a,f0.2,a)' ) & \"Fragment cutoffs must be monotonically decreasing: \" , & level_high , \"-mer cutoff (\" , cutoff_high , \") cannot be larger than \" , & level_low , \"-mer cutoff (\" , cutoff_low , \"). Check %cutoffs section.\" call error % set ( ERROR_PARSE , trim ( msg )) return end if end do end subroutine validate_cutoffs","tags":"","url":"proc/validate_cutoffs.html"},{"title":"compute_energy_and_forces – metalquicha","text":"public  subroutine compute_energy_and_forces(sys_geom, driver_config, world_comm, node_comm, energy, gradient, hessian, bonds) Uses mqc_config_adapter mqc_driver proc~~compute_energy_and_forces~~UsesGraph proc~compute_energy_and_forces compute_energy_and_forces module~mqc_config_adapter mqc_config_adapter proc~compute_energy_and_forces->module~mqc_config_adapter module~mqc_driver mqc_driver proc~compute_energy_and_forces->module~mqc_driver module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment pic_logger pic_logger module~mqc_config_adapter->pic_logger pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_driver->module~mqc_config_adapter module~mqc_calc_types mqc_calc_types module~mqc_driver->module~mqc_calc_types module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_error module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_io_helpers mqc_io_helpers module~mqc_driver->module~mqc_io_helpers module~mqc_json mqc_json module~mqc_driver->module~mqc_json module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_method_types mqc_method_types module~mqc_driver->module~mqc_method_types module~mqc_driver->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_driver->module~mqc_result_types omp_lib omp_lib module~mqc_driver->omp_lib pic_io pic_io module~mqc_driver->pic_io module~mqc_driver->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_driver->pic_mpi_lib module~mqc_driver->pic_types module~mqc_calc_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->pic_io module~mqc_gmbe_fragment_distribution_scheme->pic_logger module~mqc_gmbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_gmbe_fragment_distribution_scheme->pic_types module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis pic_timer pic_timer module~mqc_gmbe_fragment_distribution_scheme->pic_timer module~mqc_json->pic_io module~mqc_json->pic_logger module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe->pic_timer module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme~2->omp_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_io module~mqc_mbe_fragment_distribution_scheme~2->pic_logger module~mqc_mbe_fragment_distribution_scheme~2->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mpi_tags pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme~2->pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme~2->pic_timer module~mqc_method_types->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_geometry->pic_types module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_mbe_io->module~mqc_elements module~mqc_mbe_io->module~mqc_io_helpers module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_types module~mqc_method_xtb->pic_timer mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute energy and forces for current geometry\nThis is the main interface for optimization/dynamics codes Master rank provides updated geometry, all ranks compute fragments,\nresults are returned on master rank only Usage:\n  1. Master rank updates sys_geom%coordinates\n  2. Call this subroutine (all ranks)\n  3. Master rank receives energy/gradient/hessian\n  4. Master rank updates geometry based on forces\n  5. Repeat from step 1 Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(inout) :: sys_geom type( driver_config_t ), intent(in) :: driver_config type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm real(kind=dp), intent(out) :: energy real(kind=dp), intent(out), optional :: gradient (:,:) (3, total_atoms) real(kind=dp), intent(out), optional :: hessian (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~compute_energy_and_forces~~CallsGraph proc~compute_energy_and_forces compute_energy_and_forces error error proc~compute_energy_and_forces->error proc~energy_total energy_t%energy_total proc~compute_energy_and_forces->proc~energy_total proc~result_destroy calculation_result_t%result_destroy proc~compute_energy_and_forces->proc~result_destroy proc~run_calculation run_calculation proc~compute_energy_and_forces->proc~run_calculation proc~sync_geometry_to_workers sync_geometry_to_workers proc~compute_energy_and_forces->proc~sync_geometry_to_workers proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset info info proc~run_calculation->info omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation to_char to_char proc~run_calculation->to_char warning warning proc~run_calculation->warning proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~run_fragmented_calculation->info proc~run_fragmented_calculation->omp_set_num_threads proc~run_fragmented_calculation->to_char allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_coordinator node_coordinator proc~run_fragmented_calculation->interface~node_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation->proc~apply_distance_screening proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation->proc~sort_fragments_by_size verbose verbose proc~run_fragmented_calculation->verbose proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~run_unfragmented_calculation->verbose proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~node_worker node_worker interface~node_worker->proc~node_worker proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~apply_distance_screening->info proc~apply_distance_screening->to_char proc~calculate_monomer_distance calculate_monomer_distance proc~apply_distance_screening->proc~calculate_monomer_distance proc~combine_util combine_util proc~combine->proc~combine_util proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~gmbe_enumerate_pie_terms->error proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->to_char atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->proc~energy_total proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies get_elapsed_time get_elapsed_time proc~gmbe_pie_coordinator->get_elapsed_time iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses start start proc~gmbe_pie_coordinator->start proc~serial_gmbe_pie_processor->error proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->cart_disp proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->fc_mdyne proc~serial_gmbe_pie_processor->force_constants proc~serial_gmbe_pie_processor->frequencies interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~error_get_full_trace error_t%error_get_full_trace proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor->reduced_masses proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~combine_util->proc~combine_util proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect barrier barrier proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~global_coordinator->error proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->verbose proc~global_coordinator->get_elapsed_time proc~global_coordinator->iprobe proc~global_coordinator->irecv proc~global_coordinator->isend proc~global_coordinator->proc~result_irecv proc~global_coordinator->start debug debug proc~global_coordinator->debug mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~node_coordinator->error proc~node_coordinator->to_char proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->error proc~node_worker->to_char proc~node_worker->interface~do_fragment_work proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~error_get_full_trace proc~node_worker->proc~error_has_error proc~node_worker->proc~fragment_destroy proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~result_isend proc~node_worker->recv proc~print_gmbe_pie_json->error proc~print_gmbe_pie_json->info proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_pie_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~print_vibrational_analysis->warning proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~result_irecv->irecv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~serial_fragment_processor->error proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->info proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->to_char proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->verbose proc~serial_fragment_processor->configuration proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~error_get_full_trace proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~unfragmented_calculation->error proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~result_destroy proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char proc~unfragmented_calculation->cart_disp proc~unfragmented_calculation->configuration proc~unfragmented_calculation->fc_mdyne proc~unfragmented_calculation->force_constants proc~unfragmented_calculation->frequencies proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~unfragmented_calculation->proc~error_get_full_trace proc~unfragmented_calculation->proc~error_has_error proc~unfragmented_calculation->proc~print_vibrational_analysis proc~unfragmented_calculation->reduced_masses eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: need_gradient logical, private :: need_hessian type( calculation_result_t ), private :: result Source Code subroutine compute_energy_and_forces ( sys_geom , driver_config , world_comm , node_comm , & energy , gradient , hessian , bonds ) !! Compute energy and forces for current geometry !! This is the main interface for optimization/dynamics codes !! !! Master rank provides updated geometry, all ranks compute fragments, !! results are returned on master rank only !! !! Usage: !!   1. Master rank updates sys_geom%coordinates !!   2. Call this subroutine (all ranks) !!   3. Master rank receives energy/gradient/hessian !!   4. Master rank updates geometry based on forces !!   5. Repeat from step 1 use mqc_driver , only : run_calculation use mqc_config_adapter , only : driver_config_t type ( system_geometry_t ), intent ( inout ) :: sys_geom type ( driver_config_t ), intent ( in ) :: driver_config type ( comm_t ), intent ( in ) :: world_comm , node_comm real ( dp ), intent ( out ) :: energy real ( dp ), intent ( out ), optional :: gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( out ), optional :: hessian (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ) :: result logical :: need_gradient , need_hessian ! Determine what we need based on what's requested need_gradient = present ( gradient ) need_hessian = present ( hessian ) ! Synchronize geometry from master to all ranks ! (Master may have updated coordinates for optimization/dynamics) call sync_geometry_to_workers ( sys_geom , world_comm ) ! Call the main calculation driver ! This handles both fragmented and unfragmented cases call run_calculation ( world_comm , node_comm , driver_config , sys_geom , bonds , result ) ! Extract results (only valid on master rank) if ( world_comm % rank () == 0 ) then energy = result % energy % total () if ( need_gradient . and . result % has_gradient ) then gradient = result % gradient else if ( need_gradient ) then call logger % error ( \"Gradient requested but not computed!\" ) error stop \"Missing gradient in compute_energy_and_forces\" end if if ( need_hessian . and . result % has_hessian ) then hessian = result % hessian else if ( need_hessian ) then call logger % error ( \"Hessian requested but not computed!\" ) error stop \"Missing Hessian in compute_energy_and_forces\" end if ! Clean up call result % destroy () end if end subroutine compute_energy_and_forces","tags":"","url":"proc/compute_energy_and_forces.html"},{"title":"sync_geometry_to_workers – metalquicha","text":"public  subroutine sync_geometry_to_workers(sys_geom, comm) Synchronize geometry coordinates from master rank to all worker ranks\nThis is needed when master rank updates coordinates for optimization/dynamics TODO: Implement explicit broadcast if needed. Currently, the fragmented\ncalculation infrastructure may already handle geometry distribution.\nFor unfragmented calculations on master rank only, this is not needed. Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(inout) :: sys_geom type(comm_t), intent(in) :: comm Called by proc~~sync_geometry_to_workers~~CalledByGraph proc~sync_geometry_to_workers sync_geometry_to_workers proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~sync_geometry_to_workers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sync_geometry_to_workers ( sys_geom , comm ) !! Synchronize geometry coordinates from master rank to all worker ranks !! This is needed when master rank updates coordinates for optimization/dynamics !! !! TODO: Implement explicit broadcast if needed. Currently, the fragmented !! calculation infrastructure may already handle geometry distribution. !! For unfragmented calculations on master rank only, this is not needed. type ( system_geometry_t ), intent ( inout ) :: sys_geom type ( comm_t ), intent ( in ) :: comm ! NOTE: For now, we rely on the existing calculation infrastructure ! to handle geometry as needed. If explicit broadcasting is required, ! we can add MPI send/recv logic here later. end subroutine sync_geometry_to_workers","tags":"","url":"proc/sync_geometry_to_workers.html"},{"title":"get_frag_level_name – metalquicha","text":"private  function get_frag_level_name(frag_level) result(level_name) Map body level (n-mer) to descriptive name\nSupports up to decamers (10-mers), then falls back to “N-mers” format Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag_level Return Value character(len=32) Called by proc~~get_frag_level_name~~CalledByGraph proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown print_detailed_breakdown proc~print_detailed_breakdown->proc~get_frag_level_name proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown_json proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_frag_level_name ( frag_level ) result ( level_name ) !! Map body level (n-mer) to descriptive name !! Supports up to decamers (10-mers), then falls back to \"N-mers\" format integer , intent ( in ) :: frag_level character ( len = 32 ) :: level_name select case ( frag_level ) case ( 1 ) level_name = \"monomers\" case ( 2 ) level_name = \"dimers\" case ( 3 ) level_name = \"trimers\" case ( 4 ) level_name = \"tetramers\" case ( 5 ) level_name = \"pentamers\" case ( 6 ) level_name = \"hexamers\" case ( 7 ) level_name = \"heptamers\" case ( 8 ) level_name = \"octamers\" case ( 9 ) level_name = \"nonamers\" case ( 10 ) level_name = \"decamers\" case default ! For levels > 10, use generic format write ( level_name , '(i0,a)' ) frag_level , \"-mers\" end select end function get_frag_level_name","tags":"","url":"proc/get_frag_level_name.html"},{"title":"print_detailed_breakdown – metalquicha","text":"public  subroutine print_detailed_breakdown(polymers, fragment_count, max_level, energies, delta_energies) Print detailed energy breakdown for each fragment\nShows full energy and deltaE correction for all monomers, dimers, trimers, etc.\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) Calls proc~~print_detailed_breakdown~~CallsGraph proc~print_detailed_breakdown print_detailed_breakdown header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name verbose verbose proc~print_detailed_breakdown->verbose warning warning proc~print_detailed_breakdown->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_detailed_breakdown~~CalledByGraph proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_detailed_breakdown proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: count_by_level character(len=512), private :: energy_line integer, private :: frag_level integer, private :: fragment_size character(len=512), private :: fragment_str integer(kind=int64), private :: i integer, private :: j Source Code subroutine print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) !! Print detailed energy breakdown for each fragment !! Shows full energy and deltaE correction for all monomers, dimers, trimers, etc. !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) integer ( int64 ) :: i integer :: fragment_size , j , frag_level character ( len = 512 ) :: fragment_str , energy_line integer ( int64 ) :: count_by_level call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) call logger % verbose ( \"Detailed Energy Breakdown by Fragment\" ) call logger % verbose ( \"============================================\" ) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). Using generic N-mers notation.\" ) end if do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then call logger % verbose ( \" \" ) block character ( len = 256 ) :: header character ( len = 32 ) :: level_name level_name = get_frag_level_name ( frag_level ) write ( header , '(a,a,i0,a)' ) trim ( level_name ), \" (\" , count_by_level , \" fragments):\" ! Capitalize first letter if ( len_trim ( level_name ) > 0 ) then if ( level_name ( 1 : 1 ) >= 'a' . and . level_name ( 1 : 1 ) <= 'z' ) then header ( 1 : 1 ) = achar ( iachar ( header ( 1 : 1 )) - 32 ) end if end if call logger % verbose ( trim ( header )) end block call logger % verbose ( \"--------------------------------------------\" ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then fragment_str = \"[\" do j = 1 , fragment_size if ( j > 1 ) then write ( fragment_str , '(a,a,i0)' ) trim ( fragment_str ), \",\" , polymers ( i , j ) else write ( fragment_str , '(a,i0)' ) trim ( fragment_str ), polymers ( i , j ) end if end do write ( fragment_str , '(a,a)' ) trim ( fragment_str ), \"]\" if ( frag_level == 1 ) then write ( energy_line , '(a,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ) else write ( energy_line , '(a,a,f20.10,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ), & \"   deltaE: \" , delta_energies ( i ) end if call logger % verbose ( trim ( energy_line )) end if end do end if end do call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) end subroutine print_detailed_breakdown","tags":"","url":"proc/print_detailed_breakdown.html"},{"title":"print_detailed_breakdown_json – metalquicha","text":"public  subroutine print_detailed_breakdown_json(polymers, fragment_count, max_level, energies, delta_energies, sum_by_level, total_energy, total_gradient, total_hessian, results) Uses mqc_result_types proc~~print_detailed_breakdown_json~~UsesGraph proc~print_detailed_breakdown_json print_detailed_breakdown_json module~mqc_result_types mqc_result_types proc~print_detailed_breakdown_json->module~mqc_result_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib pic_types pic_types module~mqc_result_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Write detailed energy breakdown to results.json file\nOutputs structured JSON with all fragment energies and deltaE corrections\nOptionally includes total gradient and Hessian if provided\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) real(kind=dp), intent(in) :: sum_by_level (:) real(kind=dp), intent(in) :: total_energy real(kind=dp), intent(in), optional :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(in), optional :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) type( calculation_result_t ), intent(in), optional :: results (:) Fragment results with distance info Calls proc~~print_detailed_breakdown_json~~CallsGraph proc~print_detailed_breakdown_json print_detailed_breakdown_json error error proc~print_detailed_breakdown_json->error info info proc~print_detailed_breakdown_json->info proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename warning warning proc~print_detailed_breakdown_json->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_detailed_breakdown_json~~CalledByGraph proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_detailed_breakdown_json proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename integer(kind=int64), private :: count_by_level logical, private :: first_fragment logical, private :: first_level integer, private :: frag_level integer, private :: fragment_size integer(kind=int64), private :: i integer, private :: iatom integer, private :: io_stat integer, private :: j character(len=512), private :: json_line character(len=32), private :: level_name character(len=256), private :: output_file integer, private :: total_atoms integer, private :: unit Source Code subroutine print_detailed_breakdown_json ( polymers , fragment_count , max_level , & energies , delta_energies , sum_by_level , total_energy , & total_gradient , total_hessian , results ) !! Write detailed energy breakdown to results.json file !! Outputs structured JSON with all fragment energies and deltaE corrections !! Optionally includes total gradient and Hessian if provided !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. use mqc_result_types , only : calculation_result_t integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) real ( dp ), intent ( in ) :: sum_by_level (:), total_energy real ( dp ), intent ( in ), optional :: total_gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( in ), optional :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) type ( calculation_result_t ), intent ( in ), optional :: results (:) !! Fragment results with distance info integer ( int64 ) :: i integer :: fragment_size , j , frag_level , unit , io_stat , iatom character ( len = 512 ) :: json_line integer ( int64 ) :: count_by_level logical :: first_level , first_fragment character ( len = 32 ) :: level_name integer :: total_atoms character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing JSON output to \" // trim ( output_file )) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). JSON will use generic N-mers notation.\" ) end if write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '    \"levels\": [' first_level = . true . do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then if (. not . first_level ) then write ( unit , '(a)' ) '      },' end if first_level = . false . write ( unit , '(a)' ) '      {' level_name = get_frag_level_name ( frag_level ) write ( json_line , '(a,i0,a)' ) '        \"frag_level\": ' , frag_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,a,a)' ) '        \"name\": \"' , trim ( level_name ), '\",' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '        \"count\": ' , count_by_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '        \"total_energy\": ' , sum_by_level ( frag_level ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '        \"fragments\": [' first_fragment = . true . do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then if (. not . first_fragment ) then write ( unit , '(a)' ) '          },' end if first_fragment = . false . write ( unit , '(a)' ) '          {' json_line = '            \"indices\": [' do j = 1 , fragment_size if ( j > 1 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , polymers ( i , j ) else write ( json_line , '(a,i0)' ) trim ( json_line ), polymers ( i , j ) end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '            \"energy\": ' , energies ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) ! Add distance field if available if ( present ( results )) then write ( json_line , '(a,f20.10)' ) '            \"distance\": ' , results ( i )% distance if ( frag_level > 1 ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '            \"delta_energy\": ' , delta_energies ( i ) end if else if ( frag_level > 1 ) then write ( json_line , '(a,f20.10)' ) '            \"delta_energy\": ' , delta_energies ( i ) end if end if write ( unit , '(a)' ) trim ( json_line ) end if end do if (. not . first_fragment ) then write ( unit , '(a)' ) '          }' end if write ( unit , '(a)' ) '        ]' end if end do if (. not . first_level ) then write ( unit , '(a)' ) '      }' end if ! Close levels array (with comma if we have more fields) if ( present ( total_gradient ) . or . present ( total_hessian )) then write ( unit , '(a)' ) '    ],' else write ( unit , '(a)' ) '    ]' end if ! Add gradient norm if present (inside basename object) if ( present ( total_gradient )) then write ( json_line , '(a,f20.10)' ) '    \"gradient_norm\": ' , sqrt ( sum ( total_gradient ** 2 )) if ( present ( total_hessian )) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian Frobenius norm if present (inside basename object) if ( present ( total_hessian )) then write ( json_line , '(a,f20.10)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( total_hessian ** 2 )) write ( unit , '(a)' ) trim ( json_line ) end if ! Close basename object write ( unit , '(a)' ) '  }' ! Close outer object write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine print_detailed_breakdown_json","tags":"","url":"proc/print_detailed_breakdown_json.html"},{"title":"print_fragment_xyz – metalquicha","text":"public  subroutine print_fragment_xyz(fragment_idx, phys_frag) Print fragment geometry in XYZ format Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx type( physical_fragment_t ), intent(in) :: phys_frag Calls proc~~print_fragment_xyz~~CallsGraph proc~print_fragment_xyz print_fragment_xyz info info proc~print_fragment_xyz->info proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom to_char to_char proc~print_fragment_xyz->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_fragment_xyz~~CalledByGraph proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: coord_line integer, private :: i character(len=2), private :: symbol Source Code subroutine print_fragment_xyz ( fragment_idx , phys_frag ) !! Print fragment geometry in XYZ format integer ( int64 ), intent ( in ) :: fragment_idx type ( physical_fragment_t ), intent ( in ) :: phys_frag integer :: i character ( len = 2 ) :: symbol character ( len = 256 ) :: coord_line call logger % info ( \"=========================================\" ) call logger % info ( \" Fragment \" // to_char ( fragment_idx )) call logger % info ( \" Number of atoms: \" // to_char ( phys_frag % n_atoms )) call logger % info ( \" Coordinates in Angstroms:\" ) call logger % info ( \"-----------------------------------------\" ) do i = 1 , phys_frag % n_atoms symbol = element_number_to_symbol ( phys_frag % element_numbers ( i )) ! Convert from Bohr back to Angstroms for printing write ( coord_line , '(a2,3f15.8)' ) symbol , to_angstrom ( phys_frag % coordinates ( 1 : 3 , i )) call logger % info ( trim ( coord_line )) end do call logger % info ( \"=========================================\" ) end subroutine print_fragment_xyz","tags":"","url":"proc/print_fragment_xyz.html"},{"title":"print_gmbe_json – metalquicha","text":"public  subroutine print_gmbe_json(n_monomers, monomer_indices, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, total_energy) Write GMBE calculation results to output JSON file\nOutputs structured JSON with monomers, intersections, and total energy\nIntersection parameters are optional and should be omitted when n_intersections=0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_monomers integer, intent(in) :: monomer_indices (:) type( calculation_result_t ), intent(in) :: monomer_results (:) integer, intent(in) :: n_intersections type( calculation_result_t ), intent(in), optional :: intersection_results (:) integer, intent(in), optional :: intersection_sets (:,:) (n_monomers, n_intersections) integer, intent(in), optional :: intersection_levels (:) real(kind=dp), intent(in) :: total_energy Calls proc~~print_gmbe_json~~CallsGraph proc~print_gmbe_json print_gmbe_json error error proc~print_gmbe_json->error info info proc~print_gmbe_json->info proc~energy_total energy_t%energy_total proc~print_gmbe_json->proc~energy_total proc~get_basename get_basename proc~print_gmbe_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_json->proc~get_output_json_filename proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename logical, private :: first_intersection logical, private :: first_level integer, private :: i integer, private :: io_stat integer, private :: j character(len=512), private :: json_line integer, private :: k integer, private :: level_count integer, private :: max_level character(len=256), private :: output_file integer, private :: unit Source Code subroutine print_gmbe_json ( n_monomers , monomer_indices , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , total_energy ) !! Write GMBE calculation results to output JSON file !! Outputs structured JSON with monomers, intersections, and total energy !! Intersection parameters are optional and should be omitted when n_intersections=0 integer , intent ( in ) :: n_monomers integer , intent ( in ) :: monomer_indices (:) type ( calculation_result_t ), intent ( in ) :: monomer_results (:) integer , intent ( in ) :: n_intersections type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) integer , intent ( in ), optional :: intersection_sets (:, :) !! (n_monomers, n_intersections) integer , intent ( in ), optional :: intersection_levels (:) real ( dp ), intent ( in ) :: total_energy integer :: i , j , k , max_level , unit , io_stat character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename logical :: first_level , first_intersection integer :: level_count output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing GMBE JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) ! Monomers section write ( unit , '(a)' ) '    \"monomers\": {' write ( json_line , '(a,i0,a)' ) '      \"count\": ' , n_monomers , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"fragments\": [' do i = 1 , n_monomers write ( unit , '(a)' ) '        {' write ( json_line , '(a,i0,a)' ) '          \"index\": ' , monomer_indices ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '          \"energy\": ' , monomer_results ( i )% energy % total () write ( unit , '(a)' ) trim ( json_line ) if ( i < n_monomers ) then write ( unit , '(a)' ) '        },' else write ( unit , '(a)' ) '        }' end if end do write ( unit , '(a)' ) '      ]' ! Add comma after monomers if we have intersections if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then write ( unit , '(a)' ) '    },' else write ( unit , '(a)' ) '    }' end if ! Intersections section if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then max_level = maxval ( intersection_levels ) write ( unit , '(a)' ) '    \"intersections\": {' write ( json_line , '(a,i0,a)' ) '      \"total_count\": ' , n_intersections , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"levels\": [' first_level = . true . do k = 2 , max_level ! Count intersections at this level level_count = 0 do i = 1 , n_intersections if ( intersection_levels ( i ) == k ) level_count = level_count + 1 end do if ( level_count > 0 ) then if (. not . first_level ) then write ( unit , '(a)' ) '        },' end if first_level = . false . write ( unit , '(a)' ) '        {' write ( json_line , '(a,i0,a)' ) '          \"level\": ' , k , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '          \"count\": ' , level_count , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '          \"fragments\": [' first_intersection = . true . do i = 1 , n_intersections if ( intersection_levels ( i ) == k ) then if (. not . first_intersection ) then write ( unit , '(a)' ) '            },' end if first_intersection = . false . write ( unit , '(a)' ) '            {' ! Write indices json_line = '              \"indices\": [' do j = 1 , n_monomers if ( intersection_sets ( j , i ) > 0 ) then if ( j > 1 . and . intersection_sets ( j - 1 , i ) > 0 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , intersection_sets ( j , i ) else write ( json_line , '(a,i0)' ) trim ( json_line ), intersection_sets ( j , i ) end if end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '              \"energy\": ' , intersection_results ( i )% energy % total () write ( unit , '(a)' ) trim ( json_line ) end if end do if (. not . first_intersection ) then write ( unit , '(a)' ) '            }' end if write ( unit , '(a)' ) '          ]' end if end do if (. not . first_level ) then write ( unit , '(a)' ) '        }' end if write ( unit , '(a)' ) '      ]' write ( unit , '(a)' ) '    }' end if write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"GMBE JSON output written successfully to \" // trim ( output_file )) end subroutine print_gmbe_json","tags":"","url":"proc/print_gmbe_json.html"},{"title":"print_gmbe_pie_json – metalquicha","text":"public  subroutine print_gmbe_pie_json(pie_atom_sets, pie_coefficients, pie_energies, n_pie_terms, total_energy, total_gradient, total_hessian) Write GMBE PIE calculation results to output JSON file\nOutputs structured JSON with PIE terms (atom sets with coefficients and energies)\nOptionally includes total gradient and Hessian norms Arguments Type Intent Optional Attributes Name integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term real(kind=dp), intent(in) :: pie_energies (:) Raw energy for each term integer(kind=int64), intent(in) :: n_pie_terms real(kind=dp), intent(in) :: total_energy real(kind=dp), intent(in), optional :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(in), optional :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) Calls proc~~print_gmbe_pie_json~~CallsGraph proc~print_gmbe_pie_json print_gmbe_pie_json error error proc~print_gmbe_pie_json->error info info proc~print_gmbe_pie_json->info proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_pie_json->proc~get_output_json_filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_gmbe_pie_json~~CalledByGraph proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename logical, private :: first_term integer(kind=int64), private :: i integer, private :: io_stat integer, private :: j character(len=512), private :: json_line integer, private :: max_atoms integer, private :: n_atoms integer(kind=int64), private :: n_nonzero_terms character(len=256), private :: output_file integer, private :: unit Source Code subroutine print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) !! Write GMBE PIE calculation results to output JSON file !! Outputs structured JSON with PIE terms (atom sets with coefficients and energies) !! Optionally includes total gradient and Hessian norms integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term real ( dp ), intent ( in ) :: pie_energies (:) !! Raw energy for each term integer ( int64 ), intent ( in ) :: n_pie_terms real ( dp ), intent ( in ) :: total_energy real ( dp ), intent ( in ), optional :: total_gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( in ), optional :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) integer :: j , max_atoms , n_atoms integer ( int64 ) :: i , n_nonzero_terms integer :: unit , io_stat logical :: first_term character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing GMBE PIE JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) ! Add gradient if present if ( present ( total_gradient )) then write ( json_line , '(a,f20.10,a)' ) '    \"gradient_norm\": ' , sqrt ( sum ( total_gradient ** 2 )), ',' write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian if present if ( present ( total_hessian )) then write ( json_line , '(a,f20.10,a)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( total_hessian ** 2 )), ',' write ( unit , '(a)' ) trim ( json_line ) end if ! PIE terms section ! First count non-zero coefficient terms n_nonzero_terms = 0_int64 do i = 1_int64 , n_pie_terms if ( pie_coefficients ( i ) /= 0 ) n_nonzero_terms = n_nonzero_terms + 1 end do write ( unit , '(a)' ) '    \"pie_terms\": {' write ( json_line , '(a,i0,a)' ) '      \"count\": ' , n_nonzero_terms , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"terms\": [' max_atoms = size ( pie_atom_sets , 1 ) first_term = . true . do i = 1_int64 , n_pie_terms ! Skip terms with zero coefficient if ( pie_coefficients ( i ) == 0 ) cycle if (. not . first_term ) write ( unit , '(a)' ) '        },' first_term = . false . write ( unit , '(a)' ) '        {' ! Extract atom list size n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , i ) >= 0 ) n_atoms = n_atoms + 1 end do ! Write atom indices json_line = '          \"atom_indices\": [' do j = 1 , n_atoms if ( j > 1 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , pie_atom_sets ( j , i ) else write ( json_line , '(a,i0)' ) trim ( json_line ), pie_atom_sets ( j , i ) end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '          \"coefficient\": ' , pie_coefficients ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '          \"energy\": ' , pie_energies ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '          \"weighted_energy\": ' , & real ( pie_coefficients ( i ), dp ) * pie_energies ( i ) write ( unit , '(a)' ) trim ( json_line ) end do if (. not . first_term ) write ( unit , '(a)' ) '        }' write ( unit , '(a)' ) '      ]' write ( unit , '(a)' ) '    }' write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"GMBE PIE JSON output written successfully to \" // trim ( output_file )) end subroutine print_gmbe_pie_json","tags":"","url":"proc/print_gmbe_pie_json.html"},{"title":"print_unfragmented_json – metalquicha","text":"public  subroutine print_unfragmented_json(result) Write unfragmented calculation results to output JSON file\nOutputs structured JSON with energy and optionally gradient Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result Calls proc~~print_unfragmented_json~~CallsGraph proc~print_unfragmented_json print_unfragmented_json error error proc~print_unfragmented_json->error info info proc~print_unfragmented_json->info proc~energy_total energy_t%energy_total proc~print_unfragmented_json->proc~energy_total proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_unfragmented_json~~CalledByGraph proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~print_unfragmented_json proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~print_unfragmented_json interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename integer, private :: iatom integer, private :: io_stat character(len=512), private :: json_line character(len=256), private :: output_file integer, private :: total_atoms integer, private :: unit Source Code subroutine print_unfragmented_json ( result ) !! Write unfragmented calculation results to output JSON file !! Outputs structured JSON with energy and optionally gradient type ( calculation_result_t ), intent ( in ) :: result integer :: unit , io_stat , iatom , total_atoms character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) if ( result % has_energy ) then write ( json_line , '(a,f25.15)' ) '    \"total_energy\": ' , result % energy % total () if ( result % has_gradient . or . result % has_hessian ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add gradient norm if present if ( result % has_gradient ) then write ( json_line , '(a,f25.15)' ) '    \"gradient_norm\": ' , sqrt ( sum ( result % gradient ** 2 )) if ( result % has_hessian ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian Frobenius norm if present if ( result % has_hessian ) then write ( json_line , '(a,f25.15)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( result % hessian ** 2 )) write ( unit , '(a)' ) trim ( json_line ) end if write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine print_unfragmented_json","tags":"","url":"proc/print_unfragmented_json.html"},{"title":"calculate_monomer_distance – metalquicha","text":"public pure function calculate_monomer_distance(sys_geom, monomer_indices) result(min_distance) Calculate minimal atomic distance between monomers in a fragment\nFor single monomer (size 1), returns 0.0\nFor multi-monomer fragments, returns minimal distance between atoms in different monomers\nResult is in Angstrom Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) Return Value real(kind=dp) Calls proc~~calculate_monomer_distance~~CallsGraph proc~calculate_monomer_distance calculate_monomer_distance proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculate_monomer_distance~~CalledByGraph proc~calculate_monomer_distance calculate_monomer_distance proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->proc~calculate_monomer_distance proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_indices proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~apply_distance_screening interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe interface~node_worker->proc~node_worker interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_end_i integer, private :: atom_end_j integer, private :: atom_start_i integer, private :: atom_start_j real(kind=dp), private :: dist real(kind=dp), private :: dx real(kind=dp), private :: dy real(kind=dp), private :: dz integer, private :: i integer, private :: iatom logical, private :: is_variable_size integer, private :: j integer, private :: jatom integer, private :: mon_i integer, private :: mon_j integer, private :: n_monomers Source Code pure function calculate_monomer_distance ( sys_geom , monomer_indices ) result ( min_distance ) !! Calculate minimal atomic distance between monomers in a fragment !! For single monomer (size 1), returns 0.0 !! For multi-monomer fragments, returns minimal distance between atoms in different monomers !! Result is in Angstrom type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) real ( dp ) :: min_distance integer :: n_monomers , i , j , iatom , jatom integer :: mon_i , mon_j integer :: atom_start_i , atom_end_i , atom_start_j , atom_end_j real ( dp ) :: dist , dx , dy , dz logical :: is_variable_size n_monomers = size ( monomer_indices ) ! Monomers have distance 0 if ( n_monomers == 1 ) then min_distance = 0.0_dp return end if ! Check if we have variable-sized fragments is_variable_size = allocated ( sys_geom % fragment_sizes ) ! Initialize with huge value min_distance = huge ( 1.0_dp ) ! Loop over all pairs of monomers do i = 1 , n_monomers - 1 mon_i = monomer_indices ( i ) do j = i + 1 , n_monomers mon_j = monomer_indices ( j ) if ( is_variable_size ) then ! Variable-sized fragments do iatom = 1 , sys_geom % fragment_sizes ( mon_i ) atom_start_i = sys_geom % fragment_atoms ( iatom , mon_i ) + 1 ! Convert to 1-indexed do jatom = 1 , sys_geom % fragment_sizes ( mon_j ) atom_start_j = sys_geom % fragment_atoms ( jatom , mon_j ) + 1 ! Convert to 1-indexed ! Calculate distance (coordinates in Bohr) dx = sys_geom % coordinates ( 1 , atom_start_i ) - sys_geom % coordinates ( 1 , atom_start_j ) dy = sys_geom % coordinates ( 2 , atom_start_i ) - sys_geom % coordinates ( 2 , atom_start_j ) dz = sys_geom % coordinates ( 3 , atom_start_i ) - sys_geom % coordinates ( 3 , atom_start_j ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_distance ) min_distance = dist end do end do else ! Fixed-sized monomers atom_start_i = ( mon_i - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_i = mon_i * sys_geom % atoms_per_monomer atom_start_j = ( mon_j - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_j = mon_j * sys_geom % atoms_per_monomer ! Loop over all atom pairs do iatom = atom_start_i , atom_end_i do jatom = atom_start_j , atom_end_j ! Calculate distance (coordinates in Bohr) dx = sys_geom % coordinates ( 1 , iatom ) - sys_geom % coordinates ( 1 , jatom ) dy = sys_geom % coordinates ( 2 , iatom ) - sys_geom % coordinates ( 2 , jatom ) dz = sys_geom % coordinates ( 3 , iatom ) - sys_geom % coordinates ( 3 , jatom ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_distance ) min_distance = dist end do end do end if end do end do ! Convert from Bohr to Angstrom min_distance = to_angstrom ( min_distance ) end function calculate_monomer_distance","tags":"","url":"proc/calculate_monomer_distance.html"},{"title":"to_angstrom – metalquicha","text":"public pure elemental function to_angstrom(bohr_value) result(angstrom_value) Convert coordinate from Bohr to Angstrom Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: bohr_value Return Value real(kind=dp) Called by proc~~to_angstrom~~CalledByGraph proc~to_angstrom to_angstrom proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->proc~to_angstrom proc~calculate_monomer_distance calculate_monomer_distance proc~calculate_monomer_distance->proc~to_angstrom proc~print_fragment_xyz print_fragment_xyz proc~print_fragment_xyz->proc~to_angstrom proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->proc~calculate_monomer_distance proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_indices proc~node_worker->interface~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~apply_distance_screening interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->interface~do_fragment_work proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe interface~node_worker->proc~node_worker interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental function to_angstrom ( bohr_value ) result ( angstrom_value ) !! Convert coordinate from Bohr to Angstrom real ( dp ), intent ( in ) :: bohr_value real ( dp ) :: angstrom_value angstrom_value = bohr_value * bohr_radius end function to_angstrom","tags":"","url":"proc/to_angstrom.html"},{"title":"to_bohr – metalquicha","text":"public pure elemental function to_bohr(angstrom_value) result(bohr_value) Convert coordinate from Angstrom to Bohr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: angstrom_value Return Value real(kind=dp) Called by proc~~to_bohr~~CalledByGraph proc~to_bohr to_bohr proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~geometry_to_system_unfragmented->proc~to_bohr proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~to_bohr proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~to_bohr proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental function to_bohr ( angstrom_value ) result ( bohr_value ) !! Convert coordinate from Angstrom to Bohr real ( dp ), intent ( in ) :: angstrom_value real ( dp ) :: bohr_value bohr_value = angstrom_value / bohr_radius end function to_bohr","tags":"","url":"proc/to_bohr.html"},{"title":"build_fragment_from_atom_list – metalquicha","text":"public  subroutine build_fragment_from_atom_list(sys_geom, atom_indices, n_atoms, fragment, error, bonds) Build a fragment from explicit atom list (for GMBE intersection fragments) Similar to build_fragment_from_indices but takes atom indices directly instead of\nmonomer indices. Used for building intersection fragments in GMBE calculations.\nIntersection fragments are ALWAYS NEUTRAL (charge=0, multiplicity=1). Example: atom_indices = [3, 4, 5] builds fragment from atoms 3, 4, 5 of the system Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: atom_indices (:) 0-indexed atom indices integer, intent(in) :: n_atoms Number of atoms in list type( physical_fragment_t ), intent(out) :: fragment type( error_t ), intent(out) :: error type( bond_t ), intent(in), optional :: bonds (:) Connectivity for capping Calls proc~~build_fragment_from_atom_list~~CallsGraph proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_atom_list->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_fragment_from_atom_list~~CalledByGraph proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker node_worker interface~node_worker->proc~node_worker proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~process_intersection_derivatives proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_global_idx integer, private :: frag_atom_idx integer, private :: i integer, private :: n_caps Source Code subroutine build_fragment_from_atom_list ( sys_geom , atom_indices , n_atoms , fragment , error , bonds ) !! Build a fragment from explicit atom list (for GMBE intersection fragments) !! !! Similar to build_fragment_from_indices but takes atom indices directly instead of !! monomer indices. Used for building intersection fragments in GMBE calculations. !! Intersection fragments are ALWAYS NEUTRAL (charge=0, multiplicity=1). !! !! Example: atom_indices = [3, 4, 5] builds fragment from atoms 3, 4, 5 of the system type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: atom_indices (:) !! 0-indexed atom indices integer , intent ( in ) :: n_atoms !! Number of atoms in list type ( physical_fragment_t ), intent ( out ) :: fragment type ( error_t ), intent ( out ) :: error type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity for capping integer :: i , frag_atom_idx , atom_global_idx integer :: n_caps ! Count how many caps we need call count_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping (atom_indices are 0-indexed, add 1 for Fortran arrays) do i = 1 , n_atoms atom_global_idx = atom_indices ( i ) + 1 ! Convert to 1-indexed fragment % element_numbers ( i ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, i ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( i ) = atom_global_idx ! Store 1-indexed global position end do ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , sys_geom , fragment , n_atoms ) end if ! Intersection fragments are ALWAYS NEUTRAL ! Rationale: For polypeptides, intersections are backbone atoms; ! charged side chains are in non-overlapping regions fragment % charge = 0 fragment % multiplicity = 1 call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:build_fragment_from_atom_list\" ) return end if end subroutine build_fragment_from_atom_list","tags":"","url":"proc/build_fragment_from_atom_list.html"},{"title":"build_fragment_from_indices – metalquicha","text":"public  subroutine build_fragment_from_indices(sys_geom, monomer_indices, fragment, error, bonds) Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds Extracts atoms from specified monomers and adds hydrogen caps where bonds are broken.\nCaps are always added at the end of the atom list.\nSupports both fixed-size (identical monomers) and variable-sized fragments. Example: monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5\n         If connectivity shows broken bonds, hydrogens are capped at positions of missing atoms Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) type( physical_fragment_t ), intent(out) :: fragment type( error_t ), intent(out) :: error type( bond_t ), intent(in), optional :: bonds (:) Connectivity information for capping Calls proc~~build_fragment_from_indices~~CallsGraph proc~build_fragment_from_indices build_fragment_from_indices proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_indices->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_fragment_from_indices~~CalledByGraph proc~build_fragment_from_indices build_fragment_from_indices proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_indices proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~global_coordinator->proc~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_end integer, private :: atom_global_idx integer, private :: atom_i integer, private :: atom_j integer, private :: atom_start integer, private, allocatable :: atoms_in_fragment (:) List of all atom indices in this fragment integer, private :: atoms_per_monomer integer, private :: frag_atom_idx integer, private :: i integer, private :: iatom integer, private :: j integer, private :: mono_idx integer, private :: n_atoms_no_caps integer, private :: n_caps integer, private :: n_monomers_in_frag logical, private :: use_explicit_fragments Source Code subroutine build_fragment_from_indices ( sys_geom , monomer_indices , fragment , error , bonds ) !! Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds !! !! Extracts atoms from specified monomers and adds hydrogen caps where bonds are broken. !! Caps are always added at the end of the atom list. !! Supports both fixed-size (identical monomers) and variable-sized fragments. !! !! Example: monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5 !!          If connectivity shows broken bonds, hydrogens are capped at positions of missing atoms type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) type ( physical_fragment_t ), intent ( out ) :: fragment type ( error_t ), intent ( out ) :: error type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity information for capping integer :: n_monomers_in_frag , atoms_per_monomer , n_atoms_no_caps integer :: i , j , mono_idx , atom_start , atom_end , frag_atom_idx integer :: atom_i , atom_j , n_caps integer , allocatable :: atoms_in_fragment (:) !! List of all atom indices in this fragment integer :: iatom , atom_global_idx logical :: use_explicit_fragments n_monomers_in_frag = size ( monomer_indices ) ! Determine if we're using explicit fragment definitions or regular monomer-based use_explicit_fragments = allocated ( sys_geom % fragment_atoms ) if ( use_explicit_fragments ) then ! Variable-sized fragments: count total atoms from fragment definitions n_atoms_no_caps = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) n_atoms_no_caps = n_atoms_no_caps + sys_geom % fragment_sizes ( mono_idx ) end do ! Build list of atom indices (0-indexed) from explicit fragment definitions allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) iatom = iatom + 1 atoms_in_fragment ( iatom ) = sys_geom % fragment_atoms ( j , mono_idx ) end do end do else ! Fixed-size monomers: use atoms_per_monomer atoms_per_monomer = sys_geom % atoms_per_monomer n_atoms_no_caps = n_monomers_in_frag * atoms_per_monomer ! Build list of atom indices in this fragment (0-indexed to match bond indices) allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer do atom_i = 0 , atoms_per_monomer - 1 iatom = iatom + 1 atoms_in_fragment ( iatom ) = atom_start + atom_i end do end do end if ! Count how many caps we need call count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms_no_caps + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms_no_caps )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping frag_atom_idx = 0 if ( use_explicit_fragments ) then ! Variable-sized: copy atoms based on explicit fragment definitions do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) frag_atom_idx = frag_atom_idx + 1 ! fragment_atoms is 0-indexed, so +1 for Fortran arrays atom_global_idx = sys_geom % fragment_atoms ( j , mono_idx ) + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( frag_atom_idx ) = atom_global_idx ! Store 1-indexed global position end do end do else ! Fixed-size: use atoms_per_monomer do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer + 1 atom_end = mono_idx * atoms_per_monomer ! Copy coordinates and elements do atom_i = atom_start , atom_end frag_atom_idx = frag_atom_idx + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_i ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_i ) fragment % local_to_global ( frag_atom_idx ) = atom_i ! Store 1-indexed global position end do end do end if ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , n_atoms_no_caps ) end if ! Set electronic structure properties from system geometry if ( use_explicit_fragments . and . allocated ( sys_geom % fragment_charges ) . and . & allocated ( sys_geom % fragment_multiplicities )) then ! Explicit fragments: sum charges and multiplicities from constituent fragments fragment % charge = 0 fragment % multiplicity = 1 ! Start with singlet assumption do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) fragment % charge = fragment % charge + sys_geom % fragment_charges ( mono_idx ) end do ! For single fragment, use its specific multiplicity if ( n_monomers_in_frag == 1 ) then fragment % multiplicity = sys_geom % fragment_multiplicities ( monomer_indices ( 1 )) else ! For multi-fragment composites, multiplicity needs careful treatment ! For now, default to system multiplicity (this may need refinement) fragment % multiplicity = sys_geom % multiplicity end if else ! Fixed-size monomers: use system defaults fragment % charge = sys_geom % charge fragment % multiplicity = sys_geom % multiplicity end if call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:build_fragment_from_indices\" ) return end if ! Calculate minimal distance between monomers in this fragment fragment % distance = calculate_monomer_distance ( sys_geom , monomer_indices ) deallocate ( atoms_in_fragment ) end subroutine build_fragment_from_indices","tags":"","url":"proc/build_fragment_from_indices.html"},{"title":"check_duplicate_atoms – metalquicha","text":"public  subroutine check_duplicate_atoms(fragment, error) Uses pic_io pic_logger proc~~check_duplicate_atoms~~UsesGraph proc~check_duplicate_atoms check_duplicate_atoms pic_io pic_io proc~check_duplicate_atoms->pic_io pic_logger pic_logger proc~check_duplicate_atoms->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Validate that fragment has no spatially overlapping atoms\nChecks if any two atoms are too close together (< 0.01 Bohr)\nThis catches bugs in geometry construction or fragment building Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment type( error_t ), intent(out) :: error Calls proc~~check_duplicate_atoms~~CallsGraph proc~check_duplicate_atoms check_duplicate_atoms error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_duplicate_atoms~~CalledByGraph proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~check_duplicate_atoms interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: MIN_ATOM_DISTANCE = 0.01_dp Bohr - atoms closer than this are overlapping real(kind=dp), private :: distance real(kind=dp), private :: dx real(kind=dp), private :: dy real(kind=dp), private :: dz integer, private :: i integer, private :: j integer, private :: n_atoms Source Code subroutine check_duplicate_atoms ( fragment , error ) !! Validate that fragment has no spatially overlapping atoms !! Checks if any two atoms are too close together (< 0.01 Bohr) !! This catches bugs in geometry construction or fragment building use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( physical_fragment_t ), intent ( in ) :: fragment type ( error_t ), intent ( out ) :: error integer :: i , j , n_atoms real ( dp ) :: distance , dx , dy , dz real ( dp ), parameter :: MIN_ATOM_DISTANCE = 0.01_dp !! Bohr - atoms closer than this are overlapping ! Only check non-cap atoms (caps can be close to replaced atoms) n_atoms = fragment % n_atoms - fragment % n_caps if ( n_atoms < 2 ) return do i = 1 , n_atoms - 1 do j = i + 1 , n_atoms dx = fragment % coordinates ( 1 , i ) - fragment % coordinates ( 1 , j ) dy = fragment % coordinates ( 2 , i ) - fragment % coordinates ( 2 , j ) dz = fragment % coordinates ( 3 , i ) - fragment % coordinates ( 3 , j ) distance = sqrt ( dx * dx + dy * dy + dz * dz ) if ( distance < MIN_ATOM_DISTANCE ) then ! Build detailed error message call error % set ( ERROR_VALIDATION , & \"Fragment contains overlapping atoms \" // to_char ( i ) // \" and \" // to_char ( j ) // & \" (distance: \" // to_char ( distance ) // \" Bohr). \" // & \"This indicates bad input geometry or a bug in fragment construction.\" ) ! Log detailed information for debugging call logger % error ( \"ERROR: Fragment contains overlapping atoms!\" ) call logger % error ( \"  Atoms \" // to_char ( i ) // \" and \" // to_char ( j ) // \" are too close together\" ) call logger % error ( \"  Distance: \" // to_char ( distance ) // \" Bohr (\" // & to_char ( distance * 0.529177_dp ) // \" Angstrom)\" ) call logger % error ( \"  Atom \" // to_char ( i ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( i )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , i )) // \", \" // & to_char ( fragment % coordinates ( 2 , i )) // \", \" // & to_char ( fragment % coordinates ( 3 , i )) // \") Bohr\" ) call logger % error ( \"  Atom \" // to_char ( j ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( j )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , j )) // \", \" // & to_char ( fragment % coordinates ( 2 , j )) // \", \" // & to_char ( fragment % coordinates ( 3 , j )) // \") Bohr\" ) return end if end do end do end subroutine check_duplicate_atoms","tags":"","url":"proc/check_duplicate_atoms.html"},{"title":"initialize_system_geometry – metalquicha","text":"public  subroutine initialize_system_geometry(full_geom_file, monomer_file, sys_geom, error) Read full geometry and monomer template, initialize system_geometry_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full_geom_file character(len=*), intent(in) :: monomer_file type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error Calls proc~~initialize_system_geometry~~CallsGraph proc~initialize_system_geometry initialize_system_geometry proc~element_symbol_to_number element_symbol_to_number proc~initialize_system_geometry->proc~element_symbol_to_number proc~error_add_context error_t%error_add_context proc~initialize_system_geometry->proc~error_add_context proc~error_has_error error_t%error_has_error proc~initialize_system_geometry->proc~error_has_error proc~error_set error_t%error_set proc~initialize_system_geometry->proc~error_set proc~geometry_destroy geometry_type%geometry_destroy proc~initialize_system_geometry->proc~geometry_destroy proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~to_bohr to_bohr proc~initialize_system_geometry->proc~to_bohr to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~read_xyz_file->proc~error_add_context proc~read_xyz_file->proc~error_has_error proc~read_xyz_file->proc~error_set proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~read_xyz_string->proc~error_set proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( geometry_type ), private :: full_geom integer, private :: i type( geometry_type ), private :: monomer_geom Source Code subroutine initialize_system_geometry ( full_geom_file , monomer_file , sys_geom , error ) !! Read full geometry and monomer template, initialize system_geometry_t character ( len =* ), intent ( in ) :: full_geom_file , monomer_file type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error type ( geometry_type ) :: full_geom , monomer_geom integer :: i call read_xyz_file ( full_geom_file , full_geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:initialize_system_geometry\" ) return end if ! Read monomer template ! this will be changed once we have a proper input file parsing call read_xyz_file ( monomer_file , monomer_geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:initialize_system_geometry\" ) call full_geom % destroy () return end if ! Validate that full geometry is a multiple of monomer size sys_geom % atoms_per_monomer = monomer_geom % natoms sys_geom % total_atoms = full_geom % natoms if ( mod ( sys_geom % total_atoms , sys_geom % atoms_per_monomer ) /= 0 ) then call error % set ( ERROR_VALIDATION , \"Full geometry atoms not a multiple of monomer atoms\" ) call full_geom % destroy () call monomer_geom % destroy () return end if sys_geom % n_monomers = sys_geom % total_atoms / sys_geom % atoms_per_monomer ! TODO JORGE: this can be a sys_geom%allocate() allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( full_geom % elements ( i )) end do ! Store coordinates in Bohr (convert from Angstroms) ! TODO JORGE: need a way to handle units sys_geom % coordinates = to_bohr ( full_geom % coords ) call full_geom % destroy () call monomer_geom % destroy () end subroutine initialize_system_geometry","tags":"","url":"proc/initialize_system_geometry.html"},{"title":"redistribute_cap_gradients – metalquicha","text":"public  subroutine redistribute_cap_gradients(fragment, fragment_gradient, system_gradient) Redistribute hydrogen cap gradients to original atoms This subroutine handles gradient redistribution for fragments with hydrogen caps.\nHydrogen caps are virtual atoms added at broken bonds - their gradients represent\nforces at the bond breakpoint and must be transferred to the original atoms they replace. Algorithm:\n  1. For real atoms (indices 1 to n_atoms - n_caps):\n     Accumulate gradient to system using local_to_global mapping\n  2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms):\n     Add cap gradient to the original atom it replaces (from cap_replaces_atom) Example:\n  Fragment: [C, C, H_cap] where H_cap replaces atom 5 in system\n  Fragment gradient: [(3,1), (3,2), (3,3)]\n  - Atoms 1,2: accumulate to system using local_to_global\n  - Atom 3 (cap): add gradient to system atom 5 (cap_replaces_atom(1) + 1) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_gradient (:,:) (3, n_atoms_fragment) real(kind=dp), intent(inout) :: system_gradient (:,:) (3, n_atoms_system) Called by proc~~redistribute_cap_gradients~~CalledByGraph proc~redistribute_cap_gradients redistribute_cap_gradients proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~redistribute_cap_gradients proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~process_intersection_derivatives->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: global_idx integer, private :: global_original_idx integer, private :: i integer, private :: i_cap integer, private :: local_cap_idx integer, private :: local_idx integer, private :: n_real_atoms Source Code subroutine redistribute_cap_gradients ( fragment , fragment_gradient , system_gradient ) !! Redistribute hydrogen cap gradients to original atoms !! !! This subroutine handles gradient redistribution for fragments with hydrogen caps. !! Hydrogen caps are virtual atoms added at broken bonds - their gradients represent !! forces at the bond breakpoint and must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate gradient to system using local_to_global mapping !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap gradient to the original atom it replaces (from cap_replaces_atom) !! !! Example: !!   Fragment: [C, C, H_cap] where H_cap replaces atom 5 in system !!   Fragment gradient: [(3,1), (3,2), (3,3)] !!   - Atoms 1,2: accumulate to system using local_to_global !!   - Atom 3 (cap): add gradient to system atom 5 (cap_replaces_atom(1) + 1) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_gradient (:, :) !! (3, n_atoms_fragment) real ( dp ), intent ( inout ) :: system_gradient (:, :) !! (3, n_atoms_system) integer :: i , local_idx , global_idx integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate gradients for real atoms using local→global mapping do i = 1 , n_real_atoms global_idx = fragment % local_to_global ( i ) system_gradient (:, global_idx ) = system_gradient (:, global_idx ) + fragment_gradient (:, i ) end do ! Redistribute cap gradients to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap ! cap_replaces_atom is 0-indexed, add 1 for Fortran arrays global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Add cap gradient to the atom it replaces system_gradient (:, global_original_idx ) = system_gradient (:, global_original_idx ) + & fragment_gradient (:, local_cap_idx ) end do end if end subroutine redistribute_cap_gradients","tags":"","url":"proc/redistribute_cap_gradients.html"},{"title":"redistribute_cap_hessian – metalquicha","text":"public  subroutine redistribute_cap_hessian(fragment, fragment_hessian, system_hessian) Redistribute hydrogen cap Hessian to original atoms This subroutine handles Hessian redistribution for fragments with hydrogen caps.\nThe Hessian is a rank-2 tensor (3N × 3N) representing second derivatives of energy\nwith respect to atomic coordinates. Similar to gradient redistribution, cap contributions\nmust be transferred to the original atoms they replace. Algorithm:\n  1. For real atoms (indices 1 to n_atoms - n_caps):\n     Accumulate Hessian blocks to system using local_to_global mapping for both dimensions\n  2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms):\n     Add cap Hessian blocks (row and column) to the original atom it replaces Note: Hessian is stored as a flattened 2D array (3 n_atoms, 3 n_atoms)\n      where rows and columns are grouped by atoms (x,y,z for atom 1, then x,y,z for atom 2, etc.) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_hessian (:,:) (3 n_atoms_fragment, 3 n_atoms_fragment) real(kind=dp), intent(inout) :: system_hessian (:,:) (3 n_atoms_system, 3 n_atoms_system) Called by proc~~redistribute_cap_hessian~~CalledByGraph proc~redistribute_cap_hessian redistribute_cap_hessian proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~redistribute_cap_hessian proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~process_intersection_derivatives->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: global_i integer, private :: global_j integer, private :: global_original_idx integer, private :: global_original_idx_2 integer, private :: i integer, private :: i_cap integer, private :: i_cap_2 integer, private :: icart integer, private :: j integer, private :: jcart integer, private :: local_cap_idx integer, private :: local_cap_idx_2 integer, private :: local_i integer, private :: local_j integer, private :: n_real_atoms Source Code subroutine redistribute_cap_hessian ( fragment , fragment_hessian , system_hessian ) !! Redistribute hydrogen cap Hessian to original atoms !! !! This subroutine handles Hessian redistribution for fragments with hydrogen caps. !! The Hessian is a rank-2 tensor (3N × 3N) representing second derivatives of energy !! with respect to atomic coordinates. Similar to gradient redistribution, cap contributions !! must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate Hessian blocks to system using local_to_global mapping for both dimensions !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap Hessian blocks (row and column) to the original atom it replaces !! !! Note: Hessian is stored as a flattened 2D array (3*n_atoms, 3*n_atoms) !!       where rows and columns are grouped by atoms (x,y,z for atom 1, then x,y,z for atom 2, etc.) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_hessian (:, :) !! (3*n_atoms_fragment, 3*n_atoms_fragment) real ( dp ), intent ( inout ) :: system_hessian (:, :) !! (3*n_atoms_system, 3*n_atoms_system) integer :: i , j , local_i , local_j , global_i , global_j integer :: icart , jcart integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms integer :: i_cap_2 , local_cap_idx_2 , global_original_idx_2 n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate Hessian blocks for real atoms using local→global mapping ! Both row (i) and column (j) dimensions need mapping do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) ! Copy 3×3 block for atom pair (i,j) do icart = 0 , 2 ! x, y, z for atom i do jcart = 0 , 2 ! x, y, z for atom j system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do end do ! Redistribute cap Hessian blocks to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Cap rows: redistribute to original atom (cap derivatives w.r.t. all other atoms) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do ! Cap columns: redistribute to original atom (all other atoms' derivatives w.r.t. cap) do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( local_cap_idx - 1 ) + jcart + 1 ) end do end do end do ! Cap-cap blocks: redistribute to original atom diagonal block do i_cap_2 = 1 , fragment % n_caps local_cap_idx_2 = n_real_atoms + i_cap_2 global_original_idx_2 = fragment % cap_replaces_atom ( i_cap_2 ) + 1 do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( local_cap_idx_2 - 1 ) + jcart + 1 ) end do end do end do end do end if end subroutine redistribute_cap_hessian","tags":"","url":"proc/redistribute_cap_hessian.html"},{"title":"add_hydrogen_caps – metalquicha","text":"private  subroutine add_hydrogen_caps(atoms_in_fragment, bonds, sys_geom, fragment, base_atom_count) Add hydrogen caps to fragment for broken bonds\nCaps are placed at the position of the atom outside the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in) :: bonds (:) type( system_geometry_t ), intent(in) :: sys_geom type( physical_fragment_t ), intent(inout) :: fragment integer, intent(in) :: base_atom_count Number of non-cap atoms Called by proc~~add_hydrogen_caps~~CalledByGraph proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: atom_i_in_frag logical, private :: atom_j_in_frag integer, private :: cap_idx integer, private :: ibond Source Code subroutine add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , base_atom_count ) !! Add hydrogen caps to fragment for broken bonds !! Caps are placed at the position of the atom outside the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ) :: bonds (:) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( physical_fragment_t ), intent ( inout ) :: fragment integer , intent ( in ) :: base_atom_count !! Number of non-cap atoms integer :: ibond , cap_idx logical :: atom_i_in_frag , atom_j_in_frag if ( fragment % n_caps == 0 ) return cap_idx = 0 do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) if ( atom_i_in_frag . and . . not . atom_j_in_frag ) then ! atom_i is in fragment, atom_j is not → cap at position of atom_j cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_j (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_j + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_j else if ( atom_j_in_frag . and . . not . atom_i_in_frag ) then ! atom_j is in fragment, atom_i is not → cap at position of atom_i cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_i (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_i + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_i end if end do end subroutine add_hydrogen_caps","tags":"","url":"proc/add_hydrogen_caps.html"},{"title":"count_hydrogen_caps – metalquicha","text":"private  subroutine count_hydrogen_caps(atoms_in_fragment, bonds, n_caps) Count how many hydrogen caps are needed for a fragment\nA cap is needed when exactly one atom of a broken bond is in the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in), optional :: bonds (:) integer, intent(out) :: n_caps Called by proc~~count_hydrogen_caps~~CalledByGraph proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: atom_i_in_frag logical, private :: atom_j_in_frag integer, private :: ibond Source Code subroutine count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) !! Count how many hydrogen caps are needed for a fragment !! A cap is needed when exactly one atom of a broken bond is in the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ), optional :: bonds (:) integer , intent ( out ) :: n_caps integer :: ibond logical :: atom_i_in_frag , atom_j_in_frag n_caps = 0 if (. not . present ( bonds )) return do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle ! Check if exactly one atom of this bond is in the fragment atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) ! Add cap only if one atom in fragment, other not (XOR condition) if (( atom_i_in_frag . and . . not . atom_j_in_frag ) . or . & (. not . atom_i_in_frag . and . atom_j_in_frag )) then n_caps = n_caps + 1 end if end do end subroutine count_hydrogen_caps","tags":"","url":"proc/count_hydrogen_caps.html"},{"title":"fragment_compute_nelec – metalquicha","text":"private  subroutine fragment_compute_nelec(this) Compute number of electrons from atomic numbers and charge Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this Called by proc~~fragment_compute_nelec~~CalledByGraph proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~fragment_compute_nelec proc~hessian_worker hessian_worker proc~hessian_worker->proc~fragment_compute_nelec proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~fragment_compute_nelec interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: nuclear_charge Source Code subroutine fragment_compute_nelec ( this ) !! Compute number of electrons from atomic numbers and charge class ( physical_fragment_t ), intent ( inout ) :: this integer :: nuclear_charge nuclear_charge = sum ( this % element_numbers ) this % nelec = nuclear_charge - this % charge end subroutine fragment_compute_nelec","tags":"","url":"proc/fragment_compute_nelec.html"},{"title":"fragment_destroy – metalquicha","text":"private  subroutine fragment_destroy(this) Clean up allocated memory in physical_fragment_t Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this Calls proc~~fragment_destroy~~CallsGraph proc~fragment_destroy physical_fragment_t%fragment_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_destroy~~CalledByGraph proc~fragment_destroy physical_fragment_t%fragment_destroy proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~fragment_destroy proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~process_intersection_derivatives->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fragment_destroy ( this ) !! Clean up allocated memory in physical_fragment_t class ( physical_fragment_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % cap_replaces_atom )) deallocate ( this % cap_replaces_atom ) if ( allocated ( this % local_to_global )) deallocate ( this % local_to_global ) if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if this % n_atoms = 0 this % charge = 0 this % multiplicity = 1 this % nelec = 0 this % n_caps = 0 end subroutine fragment_destroy","tags":"","url":"proc/fragment_destroy.html"},{"title":"fragment_set_basis – metalquicha","text":"private  subroutine fragment_set_basis(this, basis) Set the basis set for this fragment Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis Calls proc~~fragment_set_basis~~CallsGraph proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_set_basis->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fragment_set_basis ( this , basis ) !! Set the basis set for this fragment class ( physical_fragment_t ), intent ( inout ) :: this type ( molecular_basis_type ), intent ( in ) :: basis if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if allocate ( this % basis ) this % basis = basis end subroutine fragment_set_basis","tags":"","url":"proc/fragment_set_basis.html"},{"title":"system_destroy – metalquicha","text":"private  subroutine system_destroy(this) Clean up allocated memory in system_geometry_t Type Bound system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this Called by proc~~system_destroy~~CalledByGraph proc~system_destroy system_geometry_t%system_destroy proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~system_destroy program~main main program~main->proc~system_destroy program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine system_destroy ( this ) !! Clean up allocated memory in system_geometry_t class ( system_geometry_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % fragment_sizes )) deallocate ( this % fragment_sizes ) if ( allocated ( this % fragment_atoms )) deallocate ( this % fragment_atoms ) if ( allocated ( this % fragment_charges )) deallocate ( this % fragment_charges ) if ( allocated ( this % fragment_multiplicities )) deallocate ( this % fragment_multiplicities ) this % n_monomers = 0 this % atoms_per_monomer = 0 this % total_atoms = 0 end subroutine system_destroy","tags":"","url":"proc/system_destroy.html"},{"title":"binomial – metalquicha","text":"public pure function binomial(n, r) result(c) Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) Calculates “n choose r” using iterative algorithm to avoid\nfactorial overflow for large numbers.\nUses int64 to handle large combinatorial values that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n Total number of items integer(kind=default_int), intent(in) :: r Number of items to choose Return Value integer(kind=int64) Binomial coefficient result Called by proc~~binomial~~CalledByGraph proc~binomial binomial proc~get_nfrags get_nfrags proc~get_nfrags->proc~binomial proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~binomial proc~run_fragmented_calculation->proc~get_nfrags proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i Loop counter Source Code pure function binomial ( n , r ) result ( c ) !! Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) !! !! Calculates \"n choose r\" using iterative algorithm to avoid !! factorial overflow for large numbers. !! Uses int64 to handle large combinatorial values that overflow int32. integer ( default_int ), intent ( in ) :: n !! Total number of items integer ( default_int ), intent ( in ) :: r !! Number of items to choose integer ( int64 ) :: c !! Binomial coefficient result integer ( default_int ) :: i !! Loop counter if ( r == 0 . or . r == n ) then c = 1_int64 else if ( r > n ) then c = 0_int64 else c = 1_int64 do i = 1 , r c = c * int ( n - i + 1 , int64 ) / int ( i , int64 ) end do end if end function binomial","tags":"","url":"proc/binomial.html"},{"title":"get_nfrags – metalquicha","text":"public pure function get_nfrags(n_monomers, max_level) result(n_expected_fragments) Calculate total number of fragments for given system size and max level Computes the sum of binomial coefficients C(n,k) for k=1 to max_level,\nrepresenting all possible fragments from monomers to max_level-mers.\nUses int64 to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n_monomers Number of monomers in system integer(kind=default_int), intent(in) :: max_level Maximum fragment size Return Value integer(kind=int64) Total fragment count Calls proc~~get_nfrags~~CallsGraph proc~get_nfrags get_nfrags proc~binomial binomial proc~get_nfrags->proc~binomial Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nfrags~~CalledByGraph proc~get_nfrags get_nfrags proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~get_nfrags proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i Loop counter Source Code pure function get_nfrags ( n_monomers , max_level ) result ( n_expected_fragments ) !! Calculate total number of fragments for given system size and max level !! !! Computes the sum of binomial coefficients C(n,k) for k=1 to max_level, !! representing all possible fragments from monomers to max_level-mers. !! Uses int64 to handle large fragment counts that overflow int32. integer ( default_int ), intent ( in ) :: n_monomers !! Number of monomers in system integer ( default_int ), intent ( in ) :: max_level !! Maximum fragment size integer ( int64 ) :: n_expected_fragments !! Total fragment count integer ( default_int ) :: i !! Loop counter n_expected_fragments = 0_int64 do i = 1 , max_level n_expected_fragments = n_expected_fragments + binomial ( n_monomers , i ) end do end function get_nfrags","tags":"","url":"proc/get_nfrags.html"},{"title":"next_combination – metalquicha","text":"public  function next_combination(combination, k, n) result(has_next) Generate next combination in lexicographic order\nReturns .true. if there’s a next combination, .false. if we’ve exhausted all Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k integer, intent(in) :: n Return Value logical Called by proc~~next_combination~~CalledByGraph proc~next_combination next_combination proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->proc~next_combination proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_k_way_intersections_from_lists->proc~next_combination proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code function next_combination ( combination , k , n ) result ( has_next ) !! Generate next combination in lexicographic order !! Returns .true. if there's a next combination, .false. if we've exhausted all integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k , n logical :: has_next integer :: i has_next = . true . ! Find the rightmost element that can be incremented i = k do while ( i >= 1 ) if ( combination ( i ) < n - k + i ) then combination ( i ) = combination ( i ) + 1 ! Reset all elements to the right do while ( i < k ) i = i + 1 combination ( i ) = combination ( i - 1 ) + 1 end do return end if i = i - 1 end do ! No more combinations has_next = . false . end function next_combination","tags":"","url":"proc/next_combination.html"},{"title":"calculate_fragment_distances – metalquicha","text":"public  subroutine calculate_fragment_distances(polymers, fragment_count, sys_geom, distances) Uses pic_types mqc_physical_fragment proc~~calculate_fragment_distances~~UsesGraph proc~calculate_fragment_distances calculate_fragment_distances module~mqc_physical_fragment mqc_physical_fragment proc~calculate_fragment_distances->module~mqc_physical_fragment pic_types pic_types proc~calculate_fragment_distances->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calculate minimal atomic distance for each fragment\nFor monomers (1-body), distance is 0.0\nFor n-mers (n >= 2), distance is the minimum distance between atoms\nin different constituent monomers Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: distances (:) Calls proc~~calculate_fragment_distances~~CallsGraph proc~calculate_fragment_distances calculate_fragment_distances proc~to_angstrom to_angstrom proc~calculate_fragment_distances->proc~to_angstrom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_end_i integer, private :: atom_end_j integer, private :: atom_start_i integer, private :: atom_start_j real(kind=dp), private :: dist real(kind=dp), private :: dx real(kind=dp), private :: dy real(kind=dp), private :: dz integer, private :: fragment_size integer, private :: i integer, private :: iatom integer(kind=int64), private :: ifrag logical, private :: is_variable_size integer, private :: j integer, private :: jatom integer, private :: k real(kind=dp), private :: min_dist integer, private :: mon_i integer, private :: mon_j Source Code subroutine calculate_fragment_distances ( polymers , fragment_count , sys_geom , distances ) !! Calculate minimal atomic distance for each fragment !! For monomers (1-body), distance is 0.0 !! For n-mers (n >= 2), distance is the minimum distance between atoms !! in different constituent monomers use pic_types , only : dp use mqc_physical_fragment , only : system_geometry_t , to_angstrom integer ( default_int ), intent ( in ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: fragment_count type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: distances (:) integer ( int64 ) :: ifrag integer :: fragment_size , i , j , iatom , jatom integer :: mon_i , mon_j integer :: atom_start_i , atom_end_i , atom_start_j , atom_end_j integer :: k real ( dp ) :: dist , min_dist real ( dp ) :: dx , dy , dz logical :: is_variable_size ! Check if we have variable-sized fragments is_variable_size = allocated ( sys_geom % fragment_sizes ) do ifrag = 1_int64 , fragment_count fragment_size = count ( polymers ( ifrag , :) > 0 ) if ( fragment_size == 1 ) then ! Monomers have distance 0 distances ( ifrag ) = 0.0_dp else ! For n-mers, calculate minimal distance between atoms in different monomers min_dist = huge ( 1.0_dp ) ! Loop over all pairs of monomers in this fragment do i = 1 , fragment_size - 1 mon_i = polymers ( ifrag , i ) do j = i + 1 , fragment_size mon_j = polymers ( ifrag , j ) if ( is_variable_size ) then ! Variable-sized fragments: use fragment_atoms to get atom indices ! Count atoms in this fragment do iatom = 1 , sys_geom % fragment_sizes ( mon_i ) atom_start_i = sys_geom % fragment_atoms ( iatom , mon_i ) + 1 ! Convert to 1-indexed do jatom = 1 , sys_geom % fragment_sizes ( mon_j ) atom_start_j = sys_geom % fragment_atoms ( jatom , mon_j ) + 1 ! Convert to 1-indexed ! Calculate distance dx = sys_geom % coordinates ( 1 , atom_start_i ) - sys_geom % coordinates ( 1 , atom_start_j ) dy = sys_geom % coordinates ( 2 , atom_start_i ) - sys_geom % coordinates ( 2 , atom_start_j ) dz = sys_geom % coordinates ( 3 , atom_start_i ) - sys_geom % coordinates ( 3 , atom_start_j ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_dist ) min_dist = dist end do end do else ! Fixed-sized monomers: calculate atom range directly atom_start_i = ( mon_i - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_i = mon_i * sys_geom % atoms_per_monomer atom_start_j = ( mon_j - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_j = mon_j * sys_geom % atoms_per_monomer ! Loop over all atoms in monomer i do iatom = atom_start_i , atom_end_i ! Loop over all atoms in monomer j do jatom = atom_start_j , atom_end_j ! Calculate distance (coordinates are in Bohr) dx = sys_geom % coordinates ( 1 , iatom ) - sys_geom % coordinates ( 1 , jatom ) dy = sys_geom % coordinates ( 2 , iatom ) - sys_geom % coordinates ( 2 , jatom ) dz = sys_geom % coordinates ( 3 , iatom ) - sys_geom % coordinates ( 3 , jatom ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_dist ) min_dist = dist end do end do end if end do end do ! Convert from Bohr to Angstrom distances ( ifrag ) = to_angstrom ( min_dist ) end if end do end subroutine calculate_fragment_distances","tags":"","url":"proc/calculate_fragment_distances.html"},{"title":"combine – metalquicha","text":"public recursive subroutine combine(arr, n, r, out_array, count) Generate all combinations of size r from array arr of size n\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count Calls proc~~combine~~CallsGraph proc~combine combine proc~combine_util combine_util proc~combine->proc~combine_util proc~combine_util->proc~combine_util Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~combine~~CalledByGraph proc~combine combine proc~generate_fragment_list generate_fragment_list proc~generate_fragment_list->proc~combine proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~combine proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: data (r) Source Code recursive subroutine combine ( arr , n , r , out_array , count ) !! Generate all combinations of size r from array arr of size n !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:) integer ( default_int ), intent ( in ) :: n , r integer ( default_int ), intent ( inout ) :: out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: data ( r ) call combine_util ( arr , n , r , 1 , data , 1 , out_array , count ) end subroutine combine","tags":"","url":"proc/combine.html"},{"title":"create_monomer_list – metalquicha","text":"public pure subroutine create_monomer_list(monomers) Generate a list of monomer indices from 1 to N Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(inout), allocatable :: monomers (:) Called by proc~~create_monomer_list~~CalledByGraph proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~create_monomer_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: length Source Code pure subroutine create_monomer_list ( monomers ) !! Generate a list of monomer indices from 1 to N integer ( default_int ), allocatable , intent ( inout ) :: monomers (:) integer ( default_int ) :: i , length length = size ( monomers , 1 ) do i = 1 , length monomers ( i ) = i end do end subroutine create_monomer_list","tags":"","url":"proc/create_monomer_list.html"},{"title":"generate_fragment_list – metalquicha","text":"public recursive subroutine generate_fragment_list(monomers, max_level, polymers, count) Generate all possible fragments (combinations of monomers) up to max_level\nUses int64 for count to handle large numbers of fragments that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: monomers (:) integer(kind=default_int), intent(in) :: max_level integer(kind=default_int), intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: count Calls proc~~generate_fragment_list~~CallsGraph proc~generate_fragment_list generate_fragment_list proc~combine combine proc~generate_fragment_list->proc~combine proc~combine_util combine_util proc~combine->proc~combine_util proc~combine_util->proc~combine_util Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_fragment_list~~CalledByGraph proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: n integer(kind=default_int), private :: r Source Code recursive subroutine generate_fragment_list ( monomers , max_level , polymers , count ) !! Generate all possible fragments (combinations of monomers) up to max_level !! Uses int64 for count to handle large numbers of fragments that overflow int32. integer ( default_int ), intent ( in ) :: monomers (:), max_level integer ( default_int ), intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: r , n n = size ( monomers , 1 ) do r = 2 , max_level call combine ( monomers , n , r , polymers , count ) end do end subroutine generate_fragment_list","tags":"","url":"proc/generate_fragment_list.html"},{"title":"get_next_combination – metalquicha","text":"public pure subroutine get_next_combination(indices, k, n, has_next) Generate next combination (updates indices in place)\nhas_next = .true. if there’s a next combination Arguments Type Intent Optional Attributes Name integer, intent(inout) :: indices (:) integer, intent(in) :: k integer, intent(in) :: n logical, intent(out) :: has_next Called by proc~~get_next_combination~~CalledByGraph proc~get_next_combination get_next_combination proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~get_next_combination proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine get_next_combination ( indices , k , n , has_next ) !! Generate next combination (updates indices in place) !! has_next = .true. if there's a next combination integer , intent ( inout ) :: indices (:) integer , intent ( in ) :: k , n logical , intent ( out ) :: has_next integer :: i has_next = . true . i = k do while ( i >= 1 ) if ( indices ( i ) < n - k + i ) then indices ( i ) = indices ( i ) + 1 do while ( i < k ) i = i + 1 indices ( i ) = indices ( i - 1 ) + 1 end do return end if i = i - 1 end do has_next = . false . end subroutine get_next_combination","tags":"","url":"proc/get_next_combination.html"},{"title":"next_combination_init – metalquicha","text":"public  subroutine next_combination_init(combination, k) Initialize combination to [1, 2, …, k] Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k Called by proc~~next_combination_init~~CalledByGraph proc~next_combination_init next_combination_init proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->proc~next_combination_init proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_k_way_intersections_from_lists->proc~next_combination_init proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine next_combination_init ( combination , k ) !! Initialize combination to [1, 2, ..., k] integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k integer :: i do i = 1 , k combination ( i ) = i end do end subroutine next_combination_init","tags":"","url":"proc/next_combination_init.html"},{"title":"print_combos – metalquicha","text":"public  subroutine print_combos(out_array, count, max_len) Print combinations stored in out_array\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: out_array (:,:) integer(kind=int64), intent(in) :: count integer(kind=default_int), intent(in) :: max_len Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: i integer(kind=default_int), private :: j Source Code subroutine print_combos ( out_array , count , max_len ) !! Print combinations stored in out_array !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: out_array (:, :), max_len integer ( int64 ), intent ( in ) :: count integer ( int64 ) :: i integer ( default_int ) :: j do i = 1_int64 , count do j = 1 , max_len if ( out_array ( i , j ) == 0 ) exit write ( * , '(I0)' , advance = 'no' ) out_array ( i , j ) if ( j < max_len . and . out_array ( i , j + 1 ) /= 0 ) then write ( * , '(A)' , advance = 'no' ) \":\" end if end do write ( * , * ) ! newline end do end subroutine print_combos","tags":"","url":"proc/print_combos.html"},{"title":"combine_util – metalquicha","text":"private recursive subroutine combine_util(arr, n, r, index, data, i, out_array, count) Utility for generating combinations recursively\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(in) :: index integer(kind=default_int), intent(inout) :: data (:) integer(kind=default_int), intent(in) :: i integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count Called by proc~~combine_util~~CalledByGraph proc~combine_util combine_util proc~combine_util->proc~combine_util proc~combine combine proc~combine->proc~combine_util proc~generate_fragment_list generate_fragment_list proc~generate_fragment_list->proc~combine proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~combine proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: j Source Code recursive subroutine combine_util ( arr , n , r , index , data , i , out_array , count ) !! Utility for generating combinations recursively !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:), n , r , index , i integer ( default_int ), intent ( inout ) :: data (:), out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: j if ( index > r ) then count = count + 1_int64 out_array ( count , 1 : r ) = data ( 1 : r ) return end if do j = i , n data ( index ) = arr ( j ) call combine_util ( arr , n , r , index + 1 , data , j + 1 , out_array , count ) end do end subroutine combine_util","tags":"","url":"proc/combine_util.html"},{"title":"geometry_destroy – metalquicha","text":"private  subroutine geometry_destroy(this) Clean up allocated memory in geometry_type Type Bound geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this Called by proc~~geometry_destroy~~CalledByGraph proc~geometry_destroy geometry_type%geometry_destroy proc~config_destroy mqc_config_t%config_destroy proc~config_destroy->proc~geometry_destroy proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~geometry_destroy proc~molecule_destroy molecule_t%molecule_destroy proc~molecule_destroy->proc~geometry_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine geometry_destroy ( this ) !! Clean up allocated memory in geometry_type class ( geometry_type ), intent ( inout ) :: this if ( allocated ( this % elements )) deallocate ( this % elements ) if ( allocated ( this % coords )) deallocate ( this % coords ) if ( allocated ( this % comment )) deallocate ( this % comment ) this % natoms = 0 end subroutine geometry_destroy","tags":"","url":"proc/geometry_destroy.html"},{"title":"parse_command_line – metalquicha","text":"public  subroutine parse_command_line(args, error) Parse command line arguments for geometry file and basis set Extracts XYZ file path and basis set name from command line,\nvalidates arguments, and handles help requests. Arguments Type Intent Optional Attributes Name type( cli_args_type ), intent(out) :: args Parsed argument container type( error_t ), intent(out) :: error Error object Calls proc~~parse_command_line~~CallsGraph proc~parse_command_line parse_command_line proc~error_set error_t%error_set proc~parse_command_line->proc~error_set proc~print_usage print_usage proc~parse_command_line->proc~print_usage Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: arg_buffer Temporary argument buffer integer, private :: arg_len Length of current argument integer, private :: nargs Number of command line arguments integer, private :: stat Local status for intrinsic calls Source Code subroutine parse_command_line ( args , error ) !! Parse command line arguments for geometry file and basis set !! !! Extracts XYZ file path and basis set name from command line, !! validates arguments, and handles help requests. type ( cli_args_type ), intent ( out ) :: args !! Parsed argument container type ( error_t ), intent ( out ) :: error !! Error object integer :: nargs !! Number of command line arguments character ( len = 256 ) :: arg_buffer !! Temporary argument buffer integer :: arg_len !! Length of current argument integer :: stat !! Local status for intrinsic calls ! Get number of command line arguments nargs = command_argument_count () ! Check for help flag if ( nargs >= 1 ) then call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading command line argument 1\" ) return end if arg_buffer = trim ( arg_buffer ) if ( arg_buffer == \"-h\" . or . arg_buffer == \"--help\" ) then call print_usage () call error % set ( ERROR_PARSE , \"HELP_REQUESTED\" ) ! Special marker for help return end if end if ! Validate number of arguments if ( nargs < 2 ) then call error % set ( ERROR_PARSE , \"Error: Insufficient arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if if ( nargs > 2 ) then call error % set ( ERROR_PARSE , \"Error: Too many arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if ! Parse argument 1: XYZ file call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry file argument\" ) return end if args % xyz_file = trim ( arg_buffer ) ! Parse argument 2: Basis set name call get_command_argument ( 2 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading basis set name argument\" ) return end if args % basis_name = trim ( arg_buffer ) end subroutine parse_command_line","tags":"","url":"proc/parse_command_line.html"},{"title":"print_usage – metalquicha","text":"public  subroutine print_usage() Print usage information Arguments None Called by proc~~print_usage~~CalledByGraph proc~print_usage print_usage proc~parse_command_line parse_command_line proc~parse_command_line->proc~print_usage Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: prog_name integer, private :: stat Source Code subroutine print_usage () character ( len = 256 ) :: prog_name integer :: stat call get_command_argument ( 0 , prog_name , status = stat ) if ( stat /= 0 ) prog_name = \"pic_basis_reader\" print * print * , \"Usage: \" , trim ( prog_name ), \" <geometry.xyz> <basis_name>\" print * print * , \"Arguments:\" print * , \"  geometry.xyz   XYZ format molecular geometry file\" print * , \"  basis_name     Name of basis set (e.g., 6-31G, 6-311G**)\" print * print * , \"Options:\" print * , \"  -h, --help     Show this help message\" print * print * , \"Example:\" print * , \"  \" , trim ( prog_name ), \" water.xyz 6-31G\" print * end subroutine print_usage","tags":"","url":"proc/print_usage.html"},{"title":"cli_args_destroy – metalquicha","text":"private  subroutine cli_args_destroy(this) Clean up CLI args Type Bound cli_args_type Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this Source Code subroutine cli_args_destroy ( this ) class ( cli_args_type ), intent ( inout ) :: this if ( allocated ( this % xyz_file )) deallocate ( this % xyz_file ) if ( allocated ( this % basis_name )) deallocate ( this % basis_name ) end subroutine cli_args_destroy","tags":"","url":"proc/cli_args_destroy.html"},{"title":"arrays_equal_internal – metalquicha","text":"private pure function arrays_equal_internal(a, b, n) result(equal) Check if two arrays are equal Arguments Type Intent Optional Attributes Name integer, intent(in) :: a (:) integer, intent(in) :: b (:) integer, intent(in) :: n Return Value logical Called by proc~~arrays_equal_internal~~CalledByGraph proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~fragment_lookup_find->proc~arrays_equal_internal proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe_delta->proc~fragment_lookup_find proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure function arrays_equal_internal ( a , b , n ) result ( equal ) !! Check if two arrays are equal integer , intent ( in ) :: a (:), b (:), n logical :: equal integer :: i equal = . true . if ( size ( a ) /= n . or . size ( b ) /= n ) then equal = . false . return end if do i = 1 , n if ( a ( i ) /= b ( i )) then equal = . false . return end if end do end function arrays_equal_internal","tags":"","url":"proc/arrays_equal_internal.html"},{"title":"fragment_lookup_find – metalquicha","text":"private  function fragment_lookup_find(this, monomers, n) result(idx) Find fragment index for given monomer combination Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) Calls proc~~fragment_lookup_find~~CallsGraph proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_find~~CalledByGraph proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe_delta->proc~fragment_lookup_find proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: bucket type( hash_entry_t ), private, pointer :: entry integer(kind=int32), private :: hash_val integer, private :: sorted_key (n) Source Code function fragment_lookup_find ( this , monomers , n ) result ( idx ) !! Find fragment index for given monomer combination class ( fragment_lookup_t ), intent ( in ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ) :: idx integer ( int32 ) :: hash_val integer :: bucket , sorted_key ( n ) type ( hash_entry_t ), pointer :: entry ! Sort monomers for canonical key sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Search chain if ( allocated ( this % table ( bucket )% key )) then if ( arrays_equal_internal ( this % table ( bucket )% key , sorted_key , n )) then idx = this % table ( bucket )% value return end if entry => this % table ( bucket )% next do while ( associated ( entry )) if ( arrays_equal_internal ( entry % key , sorted_key , n )) then idx = entry % value return end if entry => entry % next end do end if ! Not found idx = - 1 end function fragment_lookup_find","tags":"","url":"proc/fragment_lookup_find.html"},{"title":"next_prime_internal – metalquicha","text":"private pure function next_prime_internal(n) result(p) Find next prime number >= n (simple implementation) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer Called by proc~~next_prime_internal~~CalledByGraph proc~next_prime_internal next_prime_internal proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~fragment_lookup_init->proc~next_prime_internal proc~build_mbe_lookup_table build_mbe_lookup_table proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~compute_mbe compute_mbe proc~compute_mbe->proc~build_mbe_lookup_table proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i logical, private :: is_prime Source Code pure function next_prime_internal ( n ) result ( p ) !! Find next prime number >= n (simple implementation) integer , intent ( in ) :: n integer :: p , i logical :: is_prime p = max ( n , 2 ) if ( modulo ( p , 2 ) == 0 ) p = p + 1 do is_prime = . true . do i = 3 , int ( sqrt ( real ( p ))) + 1 , 2 if ( modulo ( p , i ) == 0 ) then is_prime = . false . exit end if end do if ( is_prime ) return p = p + 2 end do end function next_prime_internal","tags":"","url":"proc/next_prime_internal.html"},{"title":"fragment_lookup_destroy – metalquicha","text":"private pure subroutine fragment_lookup_destroy(this) Clean up hash table and all chains Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this Called by proc~~fragment_lookup_destroy~~CalledByGraph proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe compute_mbe proc~compute_mbe->proc~fragment_lookup_destroy proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( hash_entry_t ), private, pointer :: entry integer, private :: i type( hash_entry_t ), private, pointer :: next_entry Source Code pure subroutine fragment_lookup_destroy ( this ) !! Clean up hash table and all chains class ( fragment_lookup_t ), intent ( inout ) :: this integer :: i type ( hash_entry_t ), pointer :: entry , next_entry if (. not . this % initialized ) return do i = 1 , this % table_size ! Free chain entry => this % table ( i )% next do while ( associated ( entry )) next_entry => entry % next if ( allocated ( entry % key )) deallocate ( entry % key ) deallocate ( entry ) entry => next_entry end do ! Free bucket head if ( allocated ( this % table ( i )% key )) deallocate ( this % table ( i )% key ) end do deallocate ( this % table ) this % initialized = . false . end subroutine fragment_lookup_destroy","tags":"","url":"proc/fragment_lookup_destroy.html"},{"title":"fragment_lookup_init – metalquicha","text":"private pure subroutine fragment_lookup_init(this, estimated_entries) Initialize hash table with estimated size Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries Calls proc~~fragment_lookup_init~~CallsGraph proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_init~~CalledByGraph proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table build_mbe_lookup_table proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~compute_mbe compute_mbe proc~compute_mbe->proc~build_mbe_lookup_table proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine fragment_lookup_init ( this , estimated_entries ) !! Initialize hash table with estimated size class ( fragment_lookup_t ), intent ( inout ) :: this integer ( int64 ), intent ( in ) :: estimated_entries integer :: i ! Use prime number close to estimated size for better distribution this % table_size = next_prime_internal ( int ( estimated_entries * 1.3_dp )) allocate ( this % table ( this % table_size )) ! Initialize all entries as empty do i = 1 , this % table_size nullify ( this % table ( i )% next ) end do this % n_entries = 0 this % initialized = . true . end subroutine fragment_lookup_init","tags":"","url":"proc/fragment_lookup_init.html"},{"title":"fragment_lookup_insert – metalquicha","text":"private  subroutine fragment_lookup_insert(this, monomers, n, fragment_idx) Insert a monomer combination -> fragment index mapping Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx Calls proc~~fragment_lookup_insert~~CallsGraph proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_insert~~CalledByGraph proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table build_mbe_lookup_table proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~compute_mbe compute_mbe proc~compute_mbe->proc~build_mbe_lookup_table proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: bucket integer(kind=int32), private :: hash_val type( hash_entry_t ), private, pointer :: new_entry integer, private, allocatable :: sorted_key (:) Source Code subroutine fragment_lookup_insert ( this , monomers , n , fragment_idx ) !! Insert a monomer combination -> fragment index mapping class ( fragment_lookup_t ), intent ( inout ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ), intent ( in ) :: fragment_idx integer ( int32 ) :: hash_val integer :: bucket type ( hash_entry_t ), pointer :: new_entry integer , allocatable :: sorted_key (:) if (. not . this % initialized ) error stop \"Hash table not initialized\" ! Sort monomers for canonical key allocate ( sorted_key ( n )) sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Check if this is the first entry in bucket if (. not . allocated ( this % table ( bucket )% key )) then ! First entry in this bucket - use the head entry allocate ( this % table ( bucket )% key ( n )) this % table ( bucket )% key = sorted_key this % table ( bucket )% value = fragment_idx this % n_entries = this % n_entries + 1 else ! Bucket already has entries - chain new entry allocate ( new_entry ) allocate ( new_entry % key ( n )) new_entry % key = sorted_key new_entry % value = fragment_idx new_entry % next => this % table ( bucket )% next this % table ( bucket )% next => new_entry this % n_entries = this % n_entries + 1 end if deallocate ( sorted_key ) end subroutine fragment_lookup_insert","tags":"","url":"proc/fragment_lookup_insert.html"},{"title":"calc_type_from_string – metalquicha","text":"public pure function calc_type_from_string(calc_type_str) result(calc_type) Convert calculation type string to integer constant Performs case-insensitive comparison and returns appropriate constant.\nReturns CALC_TYPE_UNKNOWN for unrecognized strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: calc_type_str Input string (e.g., “energy”, “gradient”) Return Value integer(kind=int32) Output integer constant Called by proc~~calc_type_from_string~~CalledByGraph proc~calc_type_from_string calc_type_from_string proc~parse_driver_section parse_driver_section proc~parse_driver_section->proc~calc_type_from_string proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_driver_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=len_trim), private :: lower_str Source Code pure function calc_type_from_string ( calc_type_str ) result ( calc_type ) !! Convert calculation type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns CALC_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: calc_type_str !! Input string (e.g., \"energy\", \"gradient\") integer ( int32 ) :: calc_type !! Output integer constant character ( len = len_trim ( calc_type_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( calc_type_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) case ( 'energy' ) calc_type = CALC_TYPE_ENERGY case ( 'gradient' ) calc_type = CALC_TYPE_GRADIENT case ( 'hessian' ) calc_type = CALC_TYPE_HESSIAN case default calc_type = CALC_TYPE_UNKNOWN end select end function calc_type_from_string","tags":"","url":"proc/calc_type_from_string.html"},{"title":"calc_type_to_string – metalquicha","text":"public pure function calc_type_to_string(calc_type) result(calc_type_str) Convert calculation type integer constant to string Provides human-readable string representation of calculation type. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: calc_type Input integer constant Return Value character(len=:), allocatable Output string representation Called by proc~~calc_type_to_string~~CalledByGraph proc~calc_type_to_string calc_type_to_string proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~calc_type_to_string proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~calc_type_to_string interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~calc_type_to_string interface~do_fragment_work do_fragment_work proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->interface~do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~serial_fragment_processor interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations interface~node_worker->proc~node_worker interface~unfragmented_calculation->proc~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function calc_type_to_string ( calc_type ) result ( calc_type_str ) !! Convert calculation type integer constant to string !! !! Provides human-readable string representation of calculation type. integer ( int32 ), intent ( in ) :: calc_type !! Input integer constant character ( len = :), allocatable :: calc_type_str !! Output string representation select case ( calc_type ) case ( CALC_TYPE_ENERGY ) calc_type_str = \"energy\" case ( CALC_TYPE_GRADIENT ) calc_type_str = \"gradient\" case ( CALC_TYPE_HESSIAN ) calc_type_str = \"hessian\" case default calc_type_str = \"unknown\" end select end function calc_type_to_string","tags":"","url":"proc/calc_type_to_string.html"},{"title":"atomic_basis_num_basis_functions – metalquicha","text":"private pure function atomic_basis_num_basis_functions(self) result(nbf) Get total number of basis functions for an atom Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer Calls proc~~atomic_basis_num_basis_functions~~CallsGraph proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~atomic_basis_num_basis_functions~~CalledByGraph proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ishell Source Code pure function atomic_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for an atom class ( atomic_basis_type ), intent ( in ) :: self integer :: nbf integer :: ishell nbf = 0 do ishell = 1 , self % nshells nbf = nbf + self % shells ( ishell )% num_basis_functions () end do end function atomic_basis_num_basis_functions","tags":"","url":"proc/atomic_basis_num_basis_functions.html"},{"title":"cgto_num_basis_functions – metalquicha","text":"private pure function cgto_num_basis_functions(self) result(nbf) Get number of basis functions in a shell (Cartesian) Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer Called by proc~~cgto_num_basis_functions~~CalledByGraph proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function cgto_num_basis_functions ( self ) result ( nbf ) !! Get number of basis functions in a shell (Cartesian) class ( cgto_type ), intent ( in ) :: self integer :: nbf ! Cartesian: (ang_mom+1)*(ang_mom+2)/2 nbf = ( self % ang_mom + 1 ) * ( self % ang_mom + 2 ) / 2 end function cgto_num_basis_functions","tags":"","url":"proc/cgto_num_basis_functions.html"},{"title":"molecular_basis_num_basis_functions – metalquicha","text":"private pure function molecular_basis_num_basis_functions(self) result(nbf) Get total number of basis functions for the molecule Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Calls proc~~molecular_basis_num_basis_functions~~CallsGraph proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom Source Code pure function molecular_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for the molecule class ( molecular_basis_type ), intent ( in ) :: self integer :: nbf integer :: iatom nbf = 0 do iatom = 1 , self % nelements nbf = nbf + self % elements ( iatom )% num_basis_functions () end do end function molecular_basis_num_basis_functions","tags":"","url":"proc/molecular_basis_num_basis_functions.html"},{"title":"allocate_basis_shells – metalquicha","text":"private pure subroutine allocate_basis_shells(self, nshells) Allocate array of shells in an atomic basis Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells Called by proc~~allocate_basis_shells~~CalledByGraph proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis copy_atomic_basis proc~copy_atomic_basis->proc~allocate_basis_shells proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~allocate_basis_shells proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine allocate_basis_shells ( self , nshells ) !! Allocate array of shells in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nshells self % nshells = nshells allocate ( self % shells ( nshells )) end subroutine allocate_basis_shells","tags":"","url":"proc/allocate_basis_shells.html"},{"title":"atomic_basis_destroy – metalquicha","text":"private pure subroutine atomic_basis_destroy(self) Clean up allocated memory in an atomic basis Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self Calls proc~~atomic_basis_destroy~~CallsGraph proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~atomic_basis_destroy~~CalledByGraph proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~atomic_basis_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~fragment_destroy proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~process_intersection_derivatives->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine atomic_basis_destroy ( self ) !! Clean up allocated memory in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % shells )) then do i = 1 , self % nshells call self % shells ( i )% destroy () end do deallocate ( self % shells ) end if if ( allocated ( self % element )) deallocate ( self % element ) self % nshells = 0 end subroutine atomic_basis_destroy","tags":"","url":"proc/atomic_basis_destroy.html"},{"title":"basis_set_allocate_elements – metalquicha","text":"private pure subroutine basis_set_allocate_elements(self, nelements) Allocate array of atomic basis elements in a molecular basis set Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements Called by proc~~basis_set_allocate_elements~~CalledByGraph proc~basis_set_allocate_elements molecular_basis_type%basis_set_allocate_elements proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~basis_set_allocate_elements Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine basis_set_allocate_elements ( self , nelements ) !! Allocate array of atomic basis elements in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nelements self % nelements = nelements allocate ( self % elements ( nelements )) end subroutine basis_set_allocate_elements","tags":"","url":"proc/basis_set_allocate_elements.html"},{"title":"basis_set_destroy – metalquicha","text":"private pure subroutine basis_set_destroy(self) Clean up allocated memory in a molecular basis set Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self Calls proc~~basis_set_destroy~~CallsGraph proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_set_destroy~~CalledByGraph proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~fragment_destroy proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~process_intersection_derivatives->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine basis_set_destroy ( self ) !! Clean up allocated memory in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % elements )) then do i = 1 , self % nelements call self % elements ( i )% destroy () end do deallocate ( self % elements ) end if self % nelements = 0 end subroutine basis_set_destroy","tags":"","url":"proc/basis_set_destroy.html"},{"title":"cgto_allocate_arrays – metalquicha","text":"private pure subroutine cgto_allocate_arrays(self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc Called by proc~~cgto_allocate_arrays~~CalledByGraph proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis copy_atomic_basis proc~copy_atomic_basis->proc~cgto_allocate_arrays proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~cgto_allocate_arrays proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~parse_element_basis->proc~fill_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine cgto_allocate_arrays ( self , nfunc ) !! Allocate arrays for exponents and coefficients in a CGTO class ( cgto_type ), intent ( inout ) :: self integer , intent ( in ) :: nfunc self % nfunc = nfunc allocate ( self % exponents ( nfunc )) allocate ( self % coefficients ( nfunc )) end subroutine cgto_allocate_arrays","tags":"","url":"proc/cgto_allocate_arrays.html"},{"title":"cgto_destroy – metalquicha","text":"private pure subroutine cgto_destroy(self) Clean up allocated memory in a CGTO Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self Called by proc~~cgto_destroy~~CalledByGraph proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~atomic_basis_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~fragment_destroy proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~process_intersection_derivatives->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine cgto_destroy ( self ) !! Clean up allocated memory in a CGTO class ( cgto_type ), intent ( inout ) :: self if ( allocated ( self % exponents )) deallocate ( self % exponents ) if ( allocated ( self % coefficients )) deallocate ( self % coefficients ) self % nfunc = 0 self % ang_mom = 0 end subroutine cgto_destroy","tags":"","url":"proc/cgto_destroy.html"},{"title":"hf_calc_energy – metalquicha","text":"private  subroutine hf_calc_energy(this, fragment, result) Calculate electronic energy using Hartree-Fock method Type Bound hf_method_t Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~hf_calc_energy~~CallsGraph proc~hf_calc_energy hf_method_t%hf_calc_energy proc~energy_total energy_t%energy_total proc~hf_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hf_calc_energy~~CalledByGraph proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_gradient->proc~hf_calc_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hf_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement actual HF calculation ! 1. Convert fragment%basis to libcint format ! 2. Build one-electron integrals (S, T, V) ! 3. Run SCF iterations ! 4. Calculate final energy print * , \"HF: Calculating energy for fragment with\" , fragment % n_atoms , \"atoms\" print * , \"HF: nelec =\" , fragment % nelec print * , \"HF: charge =\" , fragment % charge print * , \"HF: multiplicity =\" , fragment % multiplicity ! Dummy result result % energy % scf = - 1.0_dp ! Placeholder result % has_energy = . true . print * , \"HF: Dummy energy =\" , result % energy % total () end subroutine hf_calc_energy","tags":"","url":"proc/hf_calc_energy.html"},{"title":"hf_calc_gradient – metalquicha","text":"private  subroutine hf_calc_gradient(this, fragment, result) Calculate energy gradient using Hartree-Fock method Type Bound hf_method_t Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~hf_calc_gradient~~CallsGraph proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_gradient->proc~hf_calc_energy proc~energy_total energy_t%energy_total proc~hf_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hf_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement gradient calculation ! 1. Calculate energy (call calc_energy) ! 2. Calculate gradient using integral derivatives print * , \"HF: Calculating gradient for fragment with\" , fragment % n_atoms , \"atoms\" ! First get energy call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . print * , \"HF: Dummy gradient allocated\" end subroutine hf_calc_gradient","tags":"","url":"proc/hf_calc_gradient.html"},{"title":"null_hessian – metalquicha","text":"private  subroutine null_hessian(this, fragment, result) Placeholder for Hessian calculation Type Bound hf_method_t Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code subroutine null_hessian ( this , fragment , result ) !! Placeholder for Hessian calculation class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result print * , \"HF: Hessian calculation not implemented yet.\" result % has_hessian = . false . end subroutine null_hessian","tags":"","url":"proc/null_hessian.html"},{"title":"compute_cartesian_displacements – metalquicha","text":"public  subroutine compute_cartesian_displacements(eigenvectors, element_numbers, cartesian_displacements, normalize_max) Convert mass-weighted eigenvectors to Cartesian displacements. The Cartesian displacement for coordinate i in mode k is:\n  x_{i,k} = L_mw_{i,k} / √(m_i) The output can be normalized in two ways:\n- normalize_max=.true. (default): normalize so max|x| = 1 for each mode (Gaussian convention)\n- normalize_max=.false.: normalize so Σ_i x²_{i,k} = 1 Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvectors (:,:) Mass-weighted eigenvectors (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N), columns are modes logical, intent(in), optional :: normalize_max If true, normalize so max displacement = 1 (default: true) Calls proc~~compute_cartesian_displacements~~CallsGraph proc~compute_cartesian_displacements compute_cartesian_displacements proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_cartesian_displacements~~CalledByGraph proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom integer, private :: icoord integer, private :: idx real(kind=dp), private :: inv_sqrt_mass integer, private :: k real(kind=dp), private :: mass real(kind=dp), private :: max_disp integer, private :: n_atoms integer, private :: n_coords real(kind=dp), private :: norm logical, private :: use_max_norm Source Code subroutine compute_cartesian_displacements ( eigenvectors , element_numbers , & cartesian_displacements , normalize_max ) !! Convert mass-weighted eigenvectors to Cartesian displacements. !! !! The Cartesian displacement for coordinate i in mode k is: !!   x_{i,k} = L_mw_{i,k} / √(m_i) !! !! The output can be normalized in two ways: !! - normalize_max=.true. (default): normalize so max|x| = 1 for each mode (Gaussian convention) !! - normalize_max=.false.: normalize so Σ_i x²_{i,k} = 1 real ( dp ), intent ( in ) :: eigenvectors (:, :) !! Mass-weighted eigenvectors (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N), columns are modes logical , intent ( in ), optional :: normalize_max !! If true, normalize so max displacement = 1 (default: true) integer :: n_atoms , n_coords , iatom , icoord , k , idx real ( dp ) :: mass , inv_sqrt_mass , norm , max_disp logical :: use_max_norm n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms use_max_norm = . true . if ( present ( normalize_max )) use_max_norm = normalize_max allocate ( cartesian_displacements ( n_coords , n_coords )) ! Convert from mass-weighted to Cartesian: x = L_mw / √m do k = 1 , n_coords do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) inv_sqrt_mass = 1.0_dp / sqrt ( mass ) do icoord = 1 , 3 idx = 3 * ( iatom - 1 ) + icoord cartesian_displacements ( idx , k ) = eigenvectors ( idx , k ) * inv_sqrt_mass end do end do end do ! Normalize each mode do k = 1 , n_coords if ( use_max_norm ) then ! Gaussian convention: normalize so max |displacement| = 1 max_disp = maxval ( abs ( cartesian_displacements (:, k ))) if ( max_disp > 1.0e-14_dp ) then cartesian_displacements (:, k ) = cartesian_displacements (:, k ) / max_disp end if else ! Standard normalization: Σ_i x²_{i,k} = 1 norm = sqrt ( sum ( cartesian_displacements (:, k ) ** 2 )) if ( norm > 1.0e-14_dp ) then cartesian_displacements (:, k ) = cartesian_displacements (:, k ) / norm end if end if end do end subroutine compute_cartesian_displacements","tags":"","url":"proc/compute_cartesian_displacements.html"},{"title":"compute_force_constants – metalquicha","text":"public  subroutine compute_force_constants(eigenvalues, reduced_masses, force_constants, force_constants_mdyne) Compute force constants for each normal mode. From the harmonic oscillator relation:\n  ω² = k/μ  →  k = ω² × μ = eigenvalue × μ Returns force constants in both atomic units (Hartree/Bohr²) and mdyne/Å. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvalues (:) Eigenvalues from mass-weighted Hessian diagonalization (1/amu) real(kind=dp), intent(in) :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(out), allocatable :: force_constants (:) Force constants in atomic units (Hartree/Bohr²) real(kind=dp), intent(out), optional, allocatable :: force_constants_mdyne (:) Force constants in mdyne/Å (common experimental unit) Called by proc~~compute_force_constants~~CalledByGraph proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: k integer, private :: n_modes Source Code subroutine compute_force_constants ( eigenvalues , reduced_masses , force_constants , & force_constants_mdyne ) !! Compute force constants for each normal mode. !! !! From the harmonic oscillator relation: !!   ω² = k/μ  →  k = ω² × μ = eigenvalue × μ !! !! Returns force constants in both atomic units (Hartree/Bohr²) and mdyne/Å. real ( dp ), intent ( in ) :: eigenvalues (:) !! Eigenvalues from mass-weighted Hessian diagonalization (1/amu) real ( dp ), intent ( in ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), allocatable , intent ( out ) :: force_constants (:) !! Force constants in atomic units (Hartree/Bohr²) real ( dp ), allocatable , intent ( out ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å (common experimental unit) integer :: n_modes , k n_modes = size ( eigenvalues ) allocate ( force_constants ( n_modes )) ! k = eigenvalue × μ (eigenvalue has units Hartree/(Bohr²·amu), μ in amu) ! So force_constant has units Hartree/Bohr² do k = 1 , n_modes if ( eigenvalues ( k ) >= 0.0_dp ) then force_constants ( k ) = eigenvalues ( k ) * reduced_masses ( k ) else ! Imaginary frequency mode - report absolute value force_constants ( k ) = - abs ( eigenvalues ( k )) * reduced_masses ( k ) end if end do ! Optionally convert to mdyne/Å if ( present ( force_constants_mdyne )) then allocate ( force_constants_mdyne ( n_modes )) force_constants_mdyne = force_constants * AU_TO_MDYNE_ANG end if end subroutine compute_force_constants","tags":"","url":"proc/compute_force_constants.html"},{"title":"compute_reduced_masses – metalquicha","text":"public  subroutine compute_reduced_masses(eigenvectors, element_numbers, reduced_masses) Compute reduced masses for each normal mode. The reduced mass μ_k for mode k is defined as:\n  μ_k = 1 / Σ_i (L_mw_{i,k}² / m_i) where L_mw is the mass-weighted eigenvector (normalized to 1).\nThis formula arises from the relationship Q_k = Σ_i √m_i * x_i * L_mw_{i,k}\nand ensures that the harmonic oscillator relation ω² = k/μ holds. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvectors (:,:) Mass-weighted eigenvectors from diagonalization (3 N x 3 N)\nColumns are normal modes, assumed normalized (Σ_i L²_{i,k} = 1) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: reduced_masses (:) Reduced masses in amu (one per mode) Calls proc~~compute_reduced_masses~~CallsGraph proc~compute_reduced_masses compute_reduced_masses proc~element_mass element_mass proc~compute_reduced_masses->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_reduced_masses~~CalledByGraph proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom integer, private :: icoord integer, private :: idx integer, private :: k real(kind=dp), private :: mass integer, private :: n_atoms integer, private :: n_coords real(kind=dp), private :: sum_over_mass Source Code subroutine compute_reduced_masses ( eigenvectors , element_numbers , reduced_masses ) !! Compute reduced masses for each normal mode. !! !! The reduced mass μ_k for mode k is defined as: !!   μ_k = 1 / Σ_i (L_mw_{i,k}² / m_i) !! !! where L_mw is the mass-weighted eigenvector (normalized to 1). !! This formula arises from the relationship Q_k = Σ_i √m_i * x_i * L_mw_{i,k} !! and ensures that the harmonic oscillator relation ω² = k/μ holds. real ( dp ), intent ( in ) :: eigenvectors (:, :) !! Mass-weighted eigenvectors from diagonalization (3*N x 3*N) !! Columns are normal modes, assumed normalized (Σ_i L²_{i,k} = 1) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: reduced_masses (:) !! Reduced masses in amu (one per mode) integer :: n_atoms , n_coords , iatom , icoord , k , idx real ( dp ) :: mass , sum_over_mass n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms allocate ( reduced_masses ( n_coords )) ! For each normal mode k do k = 1 , n_coords sum_over_mass = 0.0_dp ! Sum over all 3N coordinates: Σ_i (L²_{i,k} / m_i) do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) do icoord = 1 , 3 idx = 3 * ( iatom - 1 ) + icoord sum_over_mass = sum_over_mass + eigenvectors ( idx , k ) ** 2 / mass end do end do ! μ_k = 1 / Σ_i (L²_{i,k} / m_i) if ( sum_over_mass > 1.0e-14_dp ) then reduced_masses ( k ) = 1.0_dp / sum_over_mass else ! Near-zero contribution (e.g., trans/rot mode) - assign a large mass reduced_masses ( k ) = 1.0e10_dp end if end do end subroutine compute_reduced_masses","tags":"","url":"proc/compute_reduced_masses.html"},{"title":"compute_vibrational_analysis – metalquicha","text":"public  subroutine compute_vibrational_analysis(hessian, element_numbers, frequencies, reduced_masses, force_constants, cartesian_displacements, eigenvalues_out, eigenvectors_out, coordinates, project_trans_rot, force_constants_mdyne) Perform complete vibrational analysis from Hessian matrix. This is a convenience wrapper that computes:\n- Vibrational frequencies in cm⁻¹\n- Reduced masses in amu\n- Force constants in Hartree/Bohr² (and optionally mdyne/Å)\n- Cartesian displacement vectors (normalized) Optionally projects out translation/rotation modes. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Hessian matrix in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: frequencies (:) Vibrational frequencies in cm⁻¹ real(kind=dp), intent(out), allocatable :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(out), allocatable :: force_constants (:) Force constants in Hartree/Bohr² real(kind=dp), intent(out), allocatable :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N) real(kind=dp), intent(out), optional, allocatable :: eigenvalues_out (:) Raw eigenvalues from diagonalization real(kind=dp), intent(out), optional, allocatable :: eigenvectors_out (:,:) Mass-weighted eigenvectors real(kind=dp), intent(in), optional :: coordinates (:,:) Atomic coordinates in Bohr (3, N) - required for projection logical, intent(in), optional :: project_trans_rot If true, project out translation/rotation modes real(kind=dp), intent(out), optional, allocatable :: force_constants_mdyne (:) Force constants in mdyne/Å Calls proc~~compute_vibrational_analysis~~CallsGraph proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass error error proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_vibrational_analysis~~CalledByGraph proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: eigenvalues (:) real(kind=dp), private, allocatable :: eigenvectors (:,:) Source Code subroutine compute_vibrational_analysis ( hessian , element_numbers , frequencies , & reduced_masses , force_constants , & cartesian_displacements , & eigenvalues_out , eigenvectors_out , & coordinates , project_trans_rot , & force_constants_mdyne ) !! Perform complete vibrational analysis from Hessian matrix. !! !! This is a convenience wrapper that computes: !! - Vibrational frequencies in cm⁻¹ !! - Reduced masses in amu !! - Force constants in Hartree/Bohr² (and optionally mdyne/Å) !! - Cartesian displacement vectors (normalized) !! !! Optionally projects out translation/rotation modes. real ( dp ), intent ( in ) :: hessian (:, :) !! Hessian matrix in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ real ( dp ), allocatable , intent ( out ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), allocatable , intent ( out ) :: force_constants (:) !! Force constants in Hartree/Bohr² real ( dp ), allocatable , intent ( out ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N) real ( dp ), allocatable , intent ( out ), optional :: eigenvalues_out (:) !! Raw eigenvalues from diagonalization real ( dp ), allocatable , intent ( out ), optional :: eigenvectors_out (:, :) !! Mass-weighted eigenvectors real ( dp ), intent ( in ), optional :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) - required for projection logical , intent ( in ), optional :: project_trans_rot !! If true, project out translation/rotation modes real ( dp ), allocatable , intent ( out ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å real ( dp ), allocatable :: eigenvalues (:) real ( dp ), allocatable :: eigenvectors (:, :) ! First compute frequencies and eigenvectors call compute_vibrational_frequencies ( hessian , element_numbers , frequencies , & eigenvalues_out = eigenvalues , & eigenvectors = eigenvectors , & coordinates = coordinates , & project_trans_rot = project_trans_rot ) ! Compute reduced masses from eigenvectors call compute_reduced_masses ( eigenvectors , element_numbers , reduced_masses ) ! Compute force constants from eigenvalues and reduced masses call compute_force_constants ( eigenvalues , reduced_masses , force_constants , & force_constants_mdyne ) ! Compute Cartesian displacements from eigenvectors call compute_cartesian_displacements ( eigenvectors , element_numbers , & cartesian_displacements ) ! Optionally return eigenvalues and eigenvectors if ( present ( eigenvalues_out )) then allocate ( eigenvalues_out ( size ( eigenvalues ))) eigenvalues_out = eigenvalues end if if ( present ( eigenvectors_out )) then allocate ( eigenvectors_out ( size ( eigenvectors , 1 ), size ( eigenvectors , 2 ))) eigenvectors_out = eigenvectors end if deallocate ( eigenvalues , eigenvectors ) end subroutine compute_vibrational_analysis","tags":"","url":"proc/compute_vibrational_analysis.html"},{"title":"compute_vibrational_frequencies – metalquicha","text":"public  subroutine compute_vibrational_frequencies(hessian, element_numbers, frequencies, eigenvalues_out, eigenvectors, coordinates, project_trans_rot, projected_hessian_out) Compute vibrational frequencies from the Hessian matrix. Algorithm:\n1. Mass-weight the Hessian: H_mw = M&#94;{-1/2} * H * M&#94;{-1/2}\n2. Optionally project out translation/rotation modes\n3. Diagonalize H_mw to get eigenvalues\n4. Convert eigenvalues to frequencies in cm⁻¹ Negative eigenvalues produce negative frequencies (imaginary modes,\nindicating transition states or saddle points). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Hessian matrix in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: frequencies (:) Vibrational frequencies in cm⁻¹ (3 N modes, or 3 N-6 if projected) real(kind=dp), intent(out), optional, allocatable :: eigenvalues_out (:) Raw eigenvalues from diagonalization (Hartree/Bohr²/amu) real(kind=dp), intent(out), optional, allocatable :: eigenvectors (:,:) Normal mode eigenvectors (3 N x 3 N), columns are modes real(kind=dp), intent(in), optional :: coordinates (:,:) Atomic coordinates in Bohr (3, N) - required for projection logical, intent(in), optional :: project_trans_rot If true, project out translation/rotation modes (requires coordinates) real(kind=dp), intent(out), optional, allocatable :: projected_hessian_out (:,:) Mass-weighted Hessian after trans/rot projection (before diagonalization) Calls proc~~compute_vibrational_frequencies~~CallsGraph proc~compute_vibrational_frequencies compute_vibrational_frequencies error error proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~element_mass element_mass proc~mass_weight_hessian->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_vibrational_frequencies~~CalledByGraph proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: do_projection real(kind=dp), private, allocatable :: eigenvalues (:) integer, private :: i integer, private :: info real(kind=dp), private, allocatable :: mw_hessian (:,:) integer, private :: n_coords Source Code subroutine compute_vibrational_frequencies ( hessian , element_numbers , frequencies , & eigenvalues_out , eigenvectors , & coordinates , project_trans_rot , & projected_hessian_out ) !! Compute vibrational frequencies from the Hessian matrix. !! !! Algorithm: !! 1. Mass-weight the Hessian: H_mw = M&#94;{-1/2} * H * M&#94;{-1/2} !! 2. Optionally project out translation/rotation modes !! 3. Diagonalize H_mw to get eigenvalues !! 4. Convert eigenvalues to frequencies in cm⁻¹ !! !! Negative eigenvalues produce negative frequencies (imaginary modes, !! indicating transition states or saddle points). real ( dp ), intent ( in ) :: hessian (:, :) !! Hessian matrix in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ (3*N modes, or 3*N-6 if projected) real ( dp ), allocatable , intent ( out ), optional :: eigenvalues_out (:) !! Raw eigenvalues from diagonalization (Hartree/Bohr²/amu) real ( dp ), allocatable , intent ( out ), optional :: eigenvectors (:, :) !! Normal mode eigenvectors (3*N x 3*N), columns are modes real ( dp ), intent ( in ), optional :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) - required for projection logical , intent ( in ), optional :: project_trans_rot !! If true, project out translation/rotation modes (requires coordinates) real ( dp ), allocatable , intent ( out ), optional :: projected_hessian_out (:, :) !! Mass-weighted Hessian after trans/rot projection (before diagonalization) real ( dp ), allocatable :: mw_hessian (:, :) real ( dp ), allocatable :: eigenvalues (:) integer :: n_coords , info , i logical :: do_projection n_coords = size ( hessian , 1 ) ! Check if projection is requested do_projection = . false . if ( present ( project_trans_rot )) then if ( project_trans_rot ) then if (. not . present ( coordinates )) then ! Cannot project without coordinates - fall back to no projection call logger % warning ( \"Missing coordinates, not projecting out tran/rot motions\" ) do_projection = . false . else do_projection = . true . end if end if end if ! Mass-weight the Hessian call mass_weight_hessian ( hessian , element_numbers , mw_hessian ) ! Optionally project out translation/rotation modes if ( do_projection ) then call project_translation_rotation ( mw_hessian , coordinates , element_numbers ) end if ! Return projected Hessian if requested (before diagonalization destroys it) if ( present ( projected_hessian_out )) then allocate ( projected_hessian_out ( n_coords , n_coords )) projected_hessian_out = mw_hessian end if ! Allocate eigenvalue storage allocate ( eigenvalues ( n_coords )) ! Diagonalize the mass-weighted Hessian ! pic_syev overwrites mw_hessian with eigenvectors (if jobz='V', default) call pic_syev ( mw_hessian , eigenvalues , info = info ) if ( info /= 0 ) then ! Eigenvalue decomposition failed call logger % error ( \"Eigenvalue decomposition in vibrational frequencies failed\" ) allocate ( frequencies ( n_coords )) frequencies = 0.0_dp return end if ! Convert eigenvalues to frequencies in cm⁻¹ allocate ( frequencies ( n_coords )) do i = 1 , n_coords if ( eigenvalues ( i ) >= 0.0_dp ) then ! Real frequency frequencies ( i ) = sqrt ( eigenvalues ( i ) * AU_TO_CM1 ) else ! Imaginary frequency (negative eigenvalue) - report as negative frequencies ( i ) = - sqrt ( abs ( eigenvalues ( i )) * AU_TO_CM1 ) end if end do ! Return eigenvalues if requested if ( present ( eigenvalues_out )) then allocate ( eigenvalues_out ( n_coords )) eigenvalues_out = eigenvalues end if ! Return eigenvectors if requested if ( present ( eigenvectors )) then allocate ( eigenvectors ( n_coords , n_coords )) eigenvectors = mw_hessian end if deallocate ( eigenvalues , mw_hessian ) end subroutine compute_vibrational_frequencies","tags":"","url":"proc/compute_vibrational_frequencies.html"},{"title":"mass_weight_hessian – metalquicha","text":"public  subroutine mass_weight_hessian(hessian, element_numbers, mw_hessian) Apply mass weighting to Hessian matrix. H_mw(i,j) = H(i,j) / sqrt(m_i * m_j) where m_i is the mass of the atom corresponding to coordinate i.\nEach atom contributes 3 coordinates (x, y, z). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Input Hessian in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: mw_hessian (:,:) Mass-weighted Hessian (3 N x 3 N) Calls proc~~mass_weight_hessian~~CallsGraph proc~mass_weight_hessian mass_weight_hessian proc~element_mass element_mass proc~mass_weight_hessian->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mass_weight_hessian~~CalledByGraph proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: iatom integer, private :: icoord real(kind=dp), private, allocatable :: inv_sqrt_mass (:) integer, private :: j real(kind=dp), private :: mass integer, private :: n_atoms integer, private :: n_coords Source Code subroutine mass_weight_hessian ( hessian , element_numbers , mw_hessian ) !! Apply mass weighting to Hessian matrix. !! !! H_mw(i,j) = H(i,j) / sqrt(m_i * m_j) !! !! where m_i is the mass of the atom corresponding to coordinate i. !! Each atom contributes 3 coordinates (x, y, z). real ( dp ), intent ( in ) :: hessian (:, :) !! Input Hessian in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: mw_hessian (:, :) !! Mass-weighted Hessian (3*N x 3*N) real ( dp ), allocatable :: inv_sqrt_mass (:) integer :: n_atoms , n_coords , iatom , icoord , i , j real ( dp ) :: mass n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms ! Build inverse square root mass vector (each mass repeated 3x for x,y,z) allocate ( inv_sqrt_mass ( n_coords )) do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) do icoord = 1 , 3 inv_sqrt_mass ( 3 * ( iatom - 1 ) + icoord ) = 1.0_dp / sqrt ( mass ) end do end do ! Apply mass weighting: H_mw(i,j) = H(i,j) * inv_sqrt_mass(i) * inv_sqrt_mass(j) allocate ( mw_hessian ( n_coords , n_coords )) do j = 1 , n_coords do i = 1 , n_coords mw_hessian ( i , j ) = hessian ( i , j ) * inv_sqrt_mass ( i ) * inv_sqrt_mass ( j ) end do end do deallocate ( inv_sqrt_mass ) end subroutine mass_weight_hessian","tags":"","url":"proc/mass_weight_hessian.html"},{"title":"print_vibrational_analysis – metalquicha","text":"public  subroutine print_vibrational_analysis(frequencies, reduced_masses, force_constants, cartesian_displacements, element_numbers, force_constants_mdyne, print_displacements, n_atoms) Print vibrational analysis results in a formatted table. Output format is similar to Gaussian, with frequencies grouped in columns.\nOptionally prints Cartesian displacement vectors for each mode. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frequencies (:) Vibrational frequencies in cm⁻¹ real(kind=dp), intent(in) :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(in) :: force_constants (:) Force constants in Hartree/Bohr² (or mdyne/Å if force_constants_mdyne provided) real(kind=dp), intent(in) :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom real(kind=dp), intent(in), optional :: force_constants_mdyne (:) Force constants in mdyne/Å (if provided, these are printed instead) logical, intent(in), optional :: print_displacements If true, print Cartesian displacement vectors (default: true) integer, intent(in), optional :: n_atoms Number of atoms (if not provided, derived from size of element_numbers) Calls proc~~print_vibrational_analysis~~CallsGraph proc~print_vibrational_analysis print_vibrational_analysis info info proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol warning warning proc~print_vibrational_analysis->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vibrational_analysis~~CalledByGraph proc~print_vibrational_analysis print_vibrational_analysis proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=3), private :: coord_label logical, private :: do_print_disp character(len=2), private :: elem_sym character(len=16), private :: fc_str real(kind=dp), private :: fc_value character(len=16), private :: freq_str integer, private :: iatom integer, private :: icoord integer, private :: igroup integer, private :: imode integer, private :: k character(len=512), private :: line character(len=16), private :: mass_str integer, private :: mode_end integer, private :: mode_start integer, private :: modes_in_group integer, private :: n_at integer, private :: n_groups integer, private :: n_modes Source Code subroutine print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cartesian_displacements , element_numbers , & force_constants_mdyne , print_displacements , & n_atoms ) !! Print vibrational analysis results in a formatted table. !! !! Output format is similar to Gaussian, with frequencies grouped in columns. !! Optionally prints Cartesian displacement vectors for each mode. real ( dp ), intent ( in ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ real ( dp ), intent ( in ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), intent ( in ) :: force_constants (:) !! Force constants in Hartree/Bohr² (or mdyne/Å if force_constants_mdyne provided) real ( dp ), intent ( in ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom real ( dp ), intent ( in ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å (if provided, these are printed instead) logical , intent ( in ), optional :: print_displacements !! If true, print Cartesian displacement vectors (default: true) integer , intent ( in ), optional :: n_atoms !! Number of atoms (if not provided, derived from size of element_numbers) integer :: n_modes , n_at , n_groups , igroup , imode , iatom , icoord , k integer :: mode_start , mode_end , modes_in_group logical :: do_print_disp character ( len = 512 ) :: line character ( len = 16 ) :: freq_str , mass_str , fc_str character ( len = 2 ) :: elem_sym character ( len = 3 ) :: coord_label real ( dp ) :: fc_value n_modes = size ( frequencies ) if ( present ( n_atoms )) then n_at = n_atoms else n_at = size ( element_numbers ) end if do_print_disp = . true . if ( present ( print_displacements )) do_print_disp = print_displacements call logger % info ( \" \" ) call logger % info ( \"============================================================\" ) call logger % info ( \"                  VIBRATIONAL ANALYSIS\" ) call logger % info ( \"============================================================\" ) call logger % info ( \" \" ) ! Print in groups of 3 modes (like Gaussian) n_groups = ( n_modes + 2 ) / 3 do igroup = 1 , n_groups mode_start = ( igroup - 1 ) * 3 + 1 mode_end = min ( igroup * 3 , n_modes ) modes_in_group = mode_end - mode_start + 1 ! Mode numbers header line = \"                    \" do k = mode_start , mode_end write ( freq_str , '(i12)' ) k line = trim ( line ) // freq_str end do call logger % info ( trim ( line )) ! Frequencies (show \"i\" only for significant imaginary frequencies) line = \" Frequencies --  \" do k = mode_start , mode_end if ( frequencies ( k ) < 0.0_dp . and . abs ( frequencies ( k )) > 1 0.0_dp ) then ! Significant imaginary frequency - show with \"i\" write ( freq_str , '(f12.4,a)' ) abs ( frequencies ( k )), \"i\" else ! Real or near-zero frequency write ( freq_str , '(f12.4)' ) abs ( frequencies ( k )) end if line = trim ( line ) // freq_str end do call logger % info ( trim ( line )) ! Reduced masses line = \" Red. masses --  \" do k = mode_start , mode_end write ( mass_str , '(f12.4)' ) reduced_masses ( k ) line = trim ( line ) // mass_str end do call logger % info ( trim ( line )) ! Force constants if ( present ( force_constants_mdyne )) then line = \" Frc consts  --  \" do k = mode_start , mode_end write ( fc_str , '(f12.4)' ) force_constants_mdyne ( k ) line = trim ( line ) // fc_str end do else line = \" Frc consts  --  \" do k = mode_start , mode_end write ( fc_str , '(f12.6)' ) force_constants ( k ) line = trim ( line ) // fc_str end do end if call logger % info ( trim ( line )) ! Cartesian displacements if ( do_print_disp ) then call logger % info ( \" Atom          X         Y         Z       X         Y         Z       X         Y         Z\" ) do iatom = 1 , n_at elem_sym = element_number_to_symbol ( element_numbers ( iatom )) ! Build line with atom info and displacements for each mode write ( line , '(i4,1x,a2)' ) iatom , elem_sym do k = mode_start , mode_end do icoord = 1 , 3 write ( freq_str , '(f10.5)' ) cartesian_displacements ( 3 * ( iatom - 1 ) + icoord , k ) line = trim ( line ) // freq_str end do end do call logger % info ( trim ( line )) end do end if call logger % info ( \" \" ) end do ! Summary statistics call logger % info ( \"------------------------------------------------------------\" ) call logger % info ( \" Summary:\" ) ! Count real vs imaginary frequencies block integer :: n_real , n_imag , n_zero real ( dp ) :: zero_thresh zero_thresh = 1 0.0_dp ! frequencies below 10 cm⁻¹ considered \"zero\" n_real = 0 n_imag = 0 n_zero = 0 do k = 1 , n_modes if ( abs ( frequencies ( k )) < zero_thresh ) then n_zero = n_zero + 1 else if ( frequencies ( k ) < 0.0_dp ) then n_imag = n_imag + 1 else n_real = n_real + 1 end if end do write ( line , '(a,i5)' ) \"   Total modes:              \" , n_modes call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Real frequencies:         \" , n_real call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Imaginary frequencies:    \" , n_imag call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Near-zero (trans/rot):    \" , n_zero call logger % info ( trim ( line )) if ( n_imag > 0 ) then call logger % warning ( \"System has imaginary frequencies - may be a transition state\" ) end if end block call logger % info ( \"============================================================\" ) call logger % info ( \" \" ) end subroutine print_vibrational_analysis","tags":"","url":"proc/print_vibrational_analysis.html"},{"title":"project_translation_rotation – metalquicha","text":"public  subroutine project_translation_rotation(mw_hessian, coordinates, element_numbers) Project out translation and rotation modes from mass-weighted Hessian. Builds 6 vectors (3 translation + 3 rotation) in mass-weighted coordinates,\northonormalizes them using SVD, then projects them out:\n  H_proj = (I - D @ D&#94;T) @ H @ (I - D @ D&#94;T) This sets the 6 translation/rotation eigenvalues to exactly zero. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: mw_hessian (:,:) Mass-weighted Hessian (modified in place) real(kind=dp), intent(in) :: coordinates (:,:) Atomic coordinates in Bohr (3, N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) Calls proc~~project_translation_rotation~~CallsGraph proc~project_translation_rotation project_translation_rotation pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~element_mass element_mass proc~project_translation_rotation->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~project_translation_rotation~~CalledByGraph proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: D (:,:) real(kind=dp), private, allocatable :: D_orth (:,:) real(kind=dp), private, allocatable :: S (:) real(kind=dp), private, allocatable :: U (:,:) real(kind=dp), private, allocatable :: VT (:,:) real(kind=dp), private, allocatable :: com (:) integer, private :: i integer, private :: iatom integer, private :: idx integer, private :: info integer, private :: j integer, private :: k real(kind=dp), private :: mass integer, private :: n_atoms integer, private :: n_coords integer, private :: n_modes real(kind=dp), private :: norm real(kind=dp), private, allocatable :: proj (:,:) real(kind=dp), private, allocatable :: r (:,:) real(kind=dp), private, allocatable :: sqrt_mass (:) real(kind=dp), private, allocatable :: temp (:,:) real(kind=dp), private :: total_mass Source Code subroutine project_translation_rotation ( mw_hessian , coordinates , element_numbers ) !! Project out translation and rotation modes from mass-weighted Hessian. !! !! Builds 6 vectors (3 translation + 3 rotation) in mass-weighted coordinates, !! orthonormalizes them using SVD, then projects them out: !!   H_proj = (I - D @ D&#94;T) @ H @ (I - D @ D&#94;T) !! !! This sets the 6 translation/rotation eigenvalues to exactly zero. real ( dp ), intent ( inout ) :: mw_hessian (:, :) !! Mass-weighted Hessian (modified in place) real ( dp ), intent ( in ) :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable :: D (:, :) ! Translation/rotation vectors (3N, 6) real ( dp ), allocatable :: com (:) ! Center of mass real ( dp ), allocatable :: r (:, :) ! Coordinates relative to COM real ( dp ), allocatable :: sqrt_mass (:) ! sqrt(mass) for each atom real ( dp ), allocatable :: S (:) ! Singular values real ( dp ), allocatable :: U (:, :) ! Left singular vectors real ( dp ), allocatable :: VT (:, :) ! Right singular vectors (transposed) real ( dp ), allocatable :: D_orth (:, :) ! Orthonormalized D vectors real ( dp ), allocatable :: proj (:, :) ! Projector matrix real ( dp ), allocatable :: temp (:, :) ! Temporary matrix real ( dp ) :: total_mass , mass , norm integer :: n_atoms , n_coords , iatom , i , j , k , n_modes , info integer :: idx n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms ! Allocate arrays allocate ( D ( n_coords , 6 )) allocate ( com ( 3 )) allocate ( r ( 3 , n_atoms )) allocate ( sqrt_mass ( n_atoms )) ! Compute sqrt(mass) for each atom and total mass total_mass = 0.0_dp do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) sqrt_mass ( iatom ) = sqrt ( mass ) total_mass = total_mass + mass end do ! Compute center of mass com = 0.0_dp do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) com (:) = com (:) + mass * coordinates (:, iatom ) end do com = com / total_mass ! Compute coordinates relative to center of mass do iatom = 1 , n_atoms r (:, iatom ) = coordinates (:, iatom ) - com (:) end do ! Initialize D to zero D = 0.0_dp ! Build translation vectors (mass-weighted) ! D_trans_k: displacement along axis k, weighted by sqrt(mass) do iatom = 1 , n_atoms idx = 3 * ( iatom - 1 ) ! Translation along x D ( idx + 1 , 1 ) = sqrt_mass ( iatom ) ! Translation along y D ( idx + 2 , 2 ) = sqrt_mass ( iatom ) ! Translation along z D ( idx + 3 , 3 ) = sqrt_mass ( iatom ) end do ! Build rotation vectors (mass-weighted) ! D_rot_k: rotation around axis k, proportional to r × e_k, weighted by sqrt(mass) do iatom = 1 , n_atoms idx = 3 * ( iatom - 1 ) ! Rotation around x-axis: r × e_x = (0, r_z, -r_y) D ( idx + 2 , 4 ) = sqrt_mass ( iatom ) * r ( 3 , iatom ) D ( idx + 3 , 4 ) = - sqrt_mass ( iatom ) * r ( 2 , iatom ) ! Rotation around y-axis: r × e_y = (-r_z, 0, r_x) D ( idx + 1 , 5 ) = - sqrt_mass ( iatom ) * r ( 3 , iatom ) D ( idx + 3 , 5 ) = sqrt_mass ( iatom ) * r ( 1 , iatom ) ! Rotation around z-axis: r × e_z = (r_y, -r_x, 0) D ( idx + 1 , 6 ) = sqrt_mass ( iatom ) * r ( 2 , iatom ) D ( idx + 2 , 6 ) = - sqrt_mass ( iatom ) * r ( 1 , iatom ) end do ! Normalize each column of D do k = 1 , 6 norm = sqrt ( sum ( D (:, k ) ** 2 )) if ( norm > 1.0e-10_dp ) then D (:, k ) = D (:, k ) / norm end if end do ! Orthonormalize D using SVD: D = U @ S @ VT ! The orthonormal basis is given by the columns of U corresponding to non-zero singular values allocate ( S ( 6 )) allocate ( U ( n_coords , 6 )) allocate ( VT ( 6 , 6 )) ! pic_gesvd(A, S, U, VT, info) - A is input, U and VT are separate outputs call pic_gesvd ( D , S , U , VT , info = info ) ! Count non-zero singular values (determines number of modes to project) n_modes = 0 do k = 1 , 6 if ( S ( k ) > 1.0e-10_dp ) n_modes = n_modes + 1 end do ! Build orthonormalized D matrix from U (columns with non-zero singular values) allocate ( D_orth ( n_coords , n_modes )) j = 0 do k = 1 , 6 if ( S ( k ) > 1.0e-10_dp ) then j = j + 1 D_orth (:, j ) = U (:, k ) end if end do ! Build projector: P = I - D_orth @ D_orth&#94;T allocate ( proj ( n_coords , n_coords )) proj = 0.0_dp do i = 1 , n_coords proj ( i , i ) = 1.0_dp end do ! Subtract D_orth @ D_orth&#94;T do i = 1 , n_coords do j = 1 , n_coords do k = 1 , n_modes proj ( i , j ) = proj ( i , j ) - D_orth ( i , k ) * D_orth ( j , k ) end do end do end do ! Apply projection: H_proj = P @ H @ P allocate ( temp ( n_coords , n_coords )) ! temp = H @ P do i = 1 , n_coords do j = 1 , n_coords temp ( i , j ) = 0.0_dp do k = 1 , n_coords temp ( i , j ) = temp ( i , j ) + mw_hessian ( i , k ) * proj ( k , j ) end do end do end do ! H_proj = P @ temp do i = 1 , n_coords do j = 1 , n_coords mw_hessian ( i , j ) = 0.0_dp do k = 1 , n_coords mw_hessian ( i , j ) = mw_hessian ( i , j ) + proj ( i , k ) * temp ( k , j ) end do end do end do ! Cleanup deallocate ( D , com , r , sqrt_mass , S , U , VT , D_orth , proj , temp ) end subroutine project_translation_rotation","tags":"","url":"proc/project_translation_rotation.html"},{"title":"element_mass – metalquicha","text":"public pure function element_mass(atomic_number) result(mass) Return atomic mass in atomic mass units (amu) for a given atomic number\nUses standard atomic weights from IUPAC Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value real(kind=dp) Called by proc~~element_mass~~CalledByGraph proc~element_mass element_mass proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses compute_reduced_masses proc~compute_reduced_masses->proc~element_mass proc~mass_weight_hessian mass_weight_hessian proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation project_translation_rotation proc~project_translation_rotation->proc~element_mass proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~unfragmented_calculation->proc~compute_vibrational_frequencies interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function element_mass ( atomic_number ) result ( mass ) !! Return atomic mass in atomic mass units (amu) for a given atomic number !! Uses standard atomic weights from IUPAC integer , intent ( in ) :: atomic_number real ( dp ) :: mass select case ( atomic_number ) case ( 1 : 118 ) mass = element_masses ( atomic_number ) case default mass = 0.0_dp ! Unknown element end select end function element_mass","tags":"","url":"proc/element_mass.html"},{"title":"element_number_to_symbol – metalquicha","text":"public pure function element_number_to_symbol(atomic_number) result(symbol) Convert atomic number to element symbol\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value character(len=2) Called by proc~~element_number_to_symbol~~CalledByGraph proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms check_duplicate_atoms proc~check_duplicate_atoms->proc~element_number_to_symbol proc~print_fragment_xyz print_fragment_xyz proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_vibrational_analysis print_vibrational_analysis proc~print_vibrational_analysis->proc~element_number_to_symbol proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_vibrational_analysis proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~print_vibrational_analysis proc~unfragmented_calculation->interface~do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~node_worker->interface~do_fragment_work proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~serial_fragment_processor->interface~do_fragment_work interface~global_coordinator->proc~global_coordinator interface~node_worker->proc~node_worker interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function element_number_to_symbol ( atomic_number ) result ( symbol ) !! Convert atomic number to element symbol !! Covers the complete periodic table (elements 1-118) integer , intent ( in ) :: atomic_number character ( len = 2 ) :: symbol select case ( atomic_number ) case ( 1 : 118 ) symbol = element_symbols ( atomic_number ) case default symbol = 'Xx' ! Unknown end select end function element_number_to_symbol","tags":"","url":"proc/element_number_to_symbol.html"},{"title":"element_symbol_to_number – metalquicha","text":"public pure function element_symbol_to_number(symbol) result(atomic_number) Convert element symbol to atomic number\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Return Value integer Calls proc~~element_symbol_to_number~~CallsGraph proc~element_symbol_to_number element_symbol_to_number to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~element_symbol_to_number~~CalledByGraph proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~element_symbol_to_number proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=2), private :: sym Source Code pure function element_symbol_to_number ( symbol ) result ( atomic_number ) !! Convert element symbol to atomic number !! Covers the complete periodic table (elements 1-118) character ( len =* ), intent ( in ) :: symbol integer :: atomic_number character ( len = 2 ) :: sym ! Normalize: uppercase first letter, lowercase second sym = adjustl ( symbol ) if ( len_trim ( sym ) >= 1 ) sym ( 1 : 1 ) = to_upper ( sym ( 1 : 1 )) if ( len_trim ( sym ) >= 2 ) sym ( 2 : 2 ) = to_lower ( sym ( 2 : 2 )) ! Search for symbol in table atomic_number = findloc ( element_symbols , sym , dim = 1 ) end function element_symbol_to_number","tags":"","url":"proc/element_symbol_to_number.html"},{"title":"print_logo – metalquicha","text":"public  subroutine print_logo() Print the PIC Chemistry ASCII sunflower logo Arguments None Called by proc~~print_logo~~CalledByGraph proc~print_logo print_logo program~main main program~main->proc~print_logo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine print_logo () !! Print the PIC Chemistry ASCII sunflower logo write ( * , '(A)' ) ' ' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                        __   __' write ( * , '(A)' ) '                     .-(  ''.''  )-.' write ( * , '(A)' ) '                    (   \\  |  /   )' write ( * , '(A)' ) '                   ( ''`-.;;;;;.-''` )' write ( * , '(A)' ) '                  ( :-==;;;;;;;==-: )' write ( * , '(A)' ) '                   (  .-'';;;;;''-.  )' write ( * , '(A)' ) '                    (``  /  |  \\  ``)' write ( * , '(A)' ) '                     ''-(__.''.__)-''' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                      (Art by jgs)' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '    ╔═══════════════════════════════════════════════╗' write ( * , '(A)' ) '    ║              Met\"al q\"uicha                   ║' write ( * , '(A)' ) '    ║                (Sunflower)                    ║' write ( * , '(A)' ) '    ║   A hastily put together Fortran code for     ║' write ( * , '(A)' ) '    ║     Fragmented Based Quantum Chemistry        ║' write ( * , '(A)' ) '    ║                                               ║' write ( * , '(A)' ) '    ║        Coded up by Jorge as a hobby           ║' write ( * , '(A)' ) '    ╚═══════════════════════════════════════════════╝' write ( * , '(A)' ) ' ' end subroutine print_logo","tags":"","url":"proc/print_logo.html"},{"title":"serial_fragment_processor – metalquicha","text":"module subroutine serial_fragment_processor(total_fragments, polymers, max_level, sys_geom, method, calc_type, bonds) Interface → Uses mqc_error proc~~serial_fragment_processor~~UsesGraph proc~serial_fragment_processor serial_fragment_processor module~mqc_error mqc_error proc~serial_fragment_processor->module~mqc_error Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Process all fragments serially in single-rank mode\nThis is used when running with only 1 MPI rank Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~serial_fragment_processor~~CallsGraph proc~serial_fragment_processor serial_fragment_processor configuration configuration proc~serial_fragment_processor->configuration error error proc~serial_fragment_processor->error get_elapsed_time get_elapsed_time proc~serial_fragment_processor->get_elapsed_time info info proc~serial_fragment_processor->info interface~do_fragment_work do_fragment_work proc~serial_fragment_processor->interface~do_fragment_work omp_get_max_threads omp_get_max_threads proc~serial_fragment_processor->omp_get_max_threads omp_set_num_threads omp_set_num_threads proc~serial_fragment_processor->omp_set_num_threads proc~build_fragment_from_indices build_fragment_from_indices proc~serial_fragment_processor->proc~build_fragment_from_indices proc~calc_type_to_string calc_type_to_string proc~serial_fragment_processor->proc~calc_type_to_string proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~energy_total energy_t%energy_total proc~serial_fragment_processor->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~serial_fragment_processor->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~serial_fragment_processor->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~serial_fragment_processor->proc~fragment_destroy start start proc~serial_fragment_processor->start to_char to_char proc~serial_fragment_processor->to_char verbose verbose proc~serial_fragment_processor->verbose proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~compute_mbe->configuration proc~compute_mbe->error proc~compute_mbe->info proc~compute_mbe->proc~energy_total proc~compute_mbe->to_char cart_disp cart_disp proc~compute_mbe->cart_disp fc_mdyne fc_mdyne proc~compute_mbe->fc_mdyne force_constants force_constants proc~compute_mbe->force_constants frequencies frequencies proc~compute_mbe->frequencies proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_mbe->proc~compute_vibrational_analysis proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe->proc~print_detailed_breakdown_json proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis reduced_masses reduced_masses proc~compute_mbe->reduced_masses proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_mbe_lookup_table->get_elapsed_time proc~build_mbe_lookup_table->start proc~build_mbe_lookup_table->to_char debug debug proc~build_mbe_lookup_table->debug proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~compute_mbe_delta->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~do_fragment_work->configuration proc~do_fragment_work->error proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_has_error proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_gradient->debug proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->verbose header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->info proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->warning proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal proc~fragment_lookup_insert->fnv_1a_hash proc~fragment_lookup_insert->sort proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_fragment_xyz->proc~to_angstrom proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->info proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~serial_fragment_processor~~CalledByGraph proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: calc_type_local type(timer_type), private :: coord_timer integer, private :: current_log_level type( error_t ), private :: error integer(kind=int64), private :: frag_idx integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size integer, private :: iatom real(kind=dp), private :: mbe_total_energy real(kind=dp), private, allocatable :: mbe_total_gradient (:,:) real(kind=dp), private, allocatable :: mbe_total_hessian (:,:) type( physical_fragment_t ), private :: phys_frag type( calculation_result_t ), private, allocatable :: results (:) Source Code module subroutine serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method , calc_type , bonds ) !! Process all fragments serially in single-rank mode !! This is used when running with only 1 MPI rank use mqc_error , only : error_t integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: polymers (:, :), max_level type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int64 ) :: frag_idx integer :: fragment_size , current_log_level , iatom integer , allocatable :: fragment_indices (:) type ( calculation_result_t ), allocatable :: results (:) real ( dp ) :: mbe_total_energy real ( dp ), allocatable :: mbe_total_gradient (:, :) real ( dp ), allocatable :: mbe_total_hessian (:, :) type ( physical_fragment_t ) :: phys_frag type ( timer_type ) :: coord_timer integer ( int32 ) :: calc_type_local type ( error_t ) :: error calc_type_local = calc_type call logger % info ( \"Processing \" // to_char ( total_fragments ) // \" fragments serially...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type_local )) allocate ( results ( total_fragments )) call omp_set_num_threads ( 1 ) call coord_timer % start () do frag_idx = 1_int64 , total_fragments fragment_size = count ( polymers ( frag_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( frag_idx , 1 : fragment_size ) call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build fragment in serial processing\" end if call do_fragment_work ( frag_idx , results ( frag_idx ), method , phys_frag , calc_type = calc_type_local ) ! Debug output for gradients if ( calc_type_local == CALC_TYPE_GRADIENT . and . results ( frag_idx )% has_gradient ) then call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level ) then block character ( len = 512 ) :: debug_line integer :: iatom_local write ( debug_line , '(a,i0,a,*(i0,1x))' ) \"Fragment \" , frag_idx , \" monomers: \" , fragment_indices call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Energy: \" , results ( frag_idx )% energy % total () call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( results ( frag_idx )% gradient ** 2 )) call logger % verbose ( trim ( debug_line )) if ( size ( results ( frag_idx )% gradient , 2 ) <= 20 ) then call logger % verbose ( \"  Fragment gradient:\" ) do iatom_local = 1 , size ( results ( frag_idx )% gradient , 2 ) write ( debug_line , '(a,i3,a,3f20.12)' ) \"    Atom \" , iatom_local , \": \" , & results ( frag_idx )% gradient ( 1 , iatom_local ), & results ( frag_idx )% gradient ( 2 , iatom_local ), & results ( frag_idx )% gradient ( 3 , iatom_local ) call logger % verbose ( trim ( debug_line )) end do end if end block end if end if call phys_frag % destroy () deallocate ( fragment_indices ) if ( mod ( frag_idx , max ( 1_int64 , total_fragments / 10 )) == 0 . or . frag_idx == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( frag_idx ) // \"/\" // to_char ( total_fragments ) // & \" fragments [\" // to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call omp_set_num_threads ( omp_get_max_threads ()) call logger % info ( \"All fragments processed\" ) call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Use unified compute_mbe with optional arguments based on calc_type if ( calc_type_local == CALC_TYPE_HESSIAN ) then allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) allocate ( mbe_total_hessian ( 3 * sys_geom % total_atoms , 3 * sys_geom % total_atoms )) call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy , & sys_geom , mbe_total_gradient , mbe_total_hessian , bonds ) deallocate ( mbe_total_gradient , mbe_total_hessian ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy , & sys_geom , mbe_total_gradient , bonds = bonds ) deallocate ( mbe_total_gradient ) else call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy ) end if call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) deallocate ( results ) end subroutine serial_fragment_processor","tags":"","url":"proc/serial_fragment_processor.html"},{"title":"do_fragment_work – metalquicha","text":"module subroutine do_fragment_work(fragment_idx, result, method, phys_frag, calc_type) Interface → Uses pic_logger proc~~do_fragment_work~~UsesGraph proc~do_fragment_work do_fragment_work pic_logger pic_logger proc~do_fragment_work->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Process a single fragment for quantum chemistry calculation Performs energy and gradient calculation on a molecular fragment using\nspecified quantum chemistry method (GFN-xTB variants).\nVerbosity is controlled by the global logger level. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Fragment index for identification type( calculation_result_t ), intent(out) :: result Computation results integer(kind=int32), intent(in) :: method QC method type( physical_fragment_t ), intent(in), optional :: phys_frag Fragment geometry integer(kind=int32), intent(in) :: calc_type Calculation type Calls proc~~do_fragment_work~~CallsGraph proc~do_fragment_work do_fragment_work configuration configuration proc~do_fragment_work->configuration error error proc~do_fragment_work->error proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset info info proc~print_fragment_xyz->info proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom to_char to_char proc~print_fragment_xyz->to_char new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_energy->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~xtb_calc_hessian->info proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~xtb_calc_hessian->to_char proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~result_reset->proc~energy_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~do_fragment_work~~CalledByGraph proc~do_fragment_work do_fragment_work interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: calc_type_local Local copy of calc_type integer, private :: current_log_level Current logger verbosity level logical, private :: is_verbose Whether verbose output is enabled type( xtb_method_t ), private :: xtb_calc XTB calculator instance Source Code module subroutine do_fragment_work ( fragment_idx , result , method , phys_frag , calc_type ) !! Process a single fragment for quantum chemistry calculation !! !! Performs energy and gradient calculation on a molecular fragment using !! specified quantum chemistry method (GFN-xTB variants). !! Verbosity is controlled by the global logger level. use pic_logger , only : verbose_level integer ( int64 ), intent ( in ) :: fragment_idx !! Fragment index for identification type ( calculation_result_t ), intent ( out ) :: result !! Computation results integer ( int32 ), intent ( in ) :: method !! QC method type ( physical_fragment_t ), intent ( in ), optional :: phys_frag !! Fragment geometry integer ( int32 ), intent ( in ) :: calc_type !! Calculation type integer :: current_log_level !! Current logger verbosity level logical :: is_verbose !! Whether verbose output is enabled integer ( int32 ) :: calc_type_local !! Local copy of calc_type #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc !! XTB calculator instance #endif calc_type_local = calc_type ! Query logger to determine verbosity call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) ! Print fragment geometry if provided and verbose mode is enabled if ( present ( phys_frag )) then if ( is_verbose ) then call print_fragment_xyz ( fragment_idx , phys_frag ) end if #ifndef MQC_WITHOUT_TBLITE ! Setup XTB method xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = is_verbose ! Run the calculation using the method API select case ( calc_type_local ) case ( CALC_TYPE_ENERGY ) call xtb_calc % calc_energy ( phys_frag , result ) case ( CALC_TYPE_GRADIENT ) call xtb_calc % calc_gradient ( phys_frag , result ) case ( CALC_TYPE_HESSIAN ) call xtb_calc % calc_hessian ( phys_frag , result ) case default call logger % error ( \"Unknown calc_type: \" // calc_type_to_string ( calc_type_local )) error stop \"Invalid calc_type in do_fragment_work\" end select ! Copy fragment distance to result for JSON output result % distance = phys_frag % distance #else call logger % error ( \"XTB method requested but tblite support not compiled in\" ) call logger % error ( \"Please rebuild with -DMQC_ENABLE_TBLITE=ON\" ) error stop \"tblite support not available\" #endif else ! For empty fragments, set energy to zero call result % energy % reset () result % has_energy = . true . end if end subroutine do_fragment_work","tags":"","url":"proc/do_fragment_work.html"},{"title":"global_coordinator – metalquicha","text":"module subroutine global_coordinator(world_comm, node_comm, total_fragments, polymers, max_level, node_leader_ranks, num_nodes, sys_geom, calc_type, bonds) Interface → Global coordinator for distributing fragments to node coordinators\nwill act as a node coordinator for a single node calculation\nUses int64 for total_fragments to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~global_coordinator~~CallsGraph proc~global_coordinator global_coordinator debug debug proc~global_coordinator->debug error error proc~global_coordinator->error get_elapsed_time get_elapsed_time proc~global_coordinator->get_elapsed_time info info proc~global_coordinator->info iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~result_irecv result_irecv proc~global_coordinator->proc~result_irecv proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker start start proc~global_coordinator->start to_char to_char proc~global_coordinator->to_char verbose verbose proc~global_coordinator->verbose proc~compute_mbe->error proc~compute_mbe->info proc~compute_mbe->to_char cart_disp cart_disp proc~compute_mbe->cart_disp configuration configuration proc~compute_mbe->configuration fc_mdyne fc_mdyne proc~compute_mbe->fc_mdyne force_constants force_constants proc~compute_mbe->force_constants frequencies frequencies proc~compute_mbe->frequencies proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_mbe->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~compute_mbe->proc~energy_total proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe->proc~print_detailed_breakdown_json proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis reduced_masses reduced_masses proc~compute_mbe->reduced_masses proc~result_irecv->irecv recv recv proc~result_irecv->recv proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~build_mbe_lookup_table->debug proc~build_mbe_lookup_table->get_elapsed_time proc~build_mbe_lookup_table->start proc~build_mbe_lookup_table->to_char proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~compute_mbe_delta->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~map_fragment_to_system_gradient->debug proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->configuration proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~map_fragment_to_system_gradient->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->verbose header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->info proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->warning proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal proc~fragment_lookup_insert->fnv_1a_hash proc~fragment_lookup_insert->sort proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~global_coordinator~~CalledByGraph proc~global_coordinator global_coordinator interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: calc_type_local type(timer_type), private :: coord_timer integer(kind=int64), private :: current_fragment integer, private :: dummy_msg integer, private :: finished_nodes integer(kind=int64), private :: fragment_idx logical, private :: handling_local_workers logical, private :: has_pending integer, private :: local_dummy integer, private :: local_finished_workers type(MPI_Status), private :: local_status type(request_t), private :: req integer, private :: request_source type( calculation_result_t ), private, allocatable :: results (:) integer(kind=int64), private :: results_received type(MPI_Status), private :: status integer(kind=int64), private :: worker_fragment_map (node_comm%size()) integer, private :: worker_source Source Code module subroutine global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , calc_type , bonds ) !! Global coordinator for distributing fragments to node coordinators !! will act as a node coordinator for a single node calculation !! Uses int64 for total_fragments to handle large fragment counts that overflow int32. type ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level , num_nodes integer , intent ( in ) :: polymers (:, :), node_leader_ranks (:) type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( timer_type ) :: coord_timer integer ( int64 ) :: current_fragment , results_received integer :: finished_nodes integer :: request_source , dummy_msg integer ( int64 ) :: fragment_idx type ( MPI_Status ) :: status , local_status logical :: handling_local_workers logical :: has_pending integer ( int32 ) :: calc_type_local ! For local workers integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer ( int64 ) :: worker_fragment_map ( node_comm % size ()) integer :: worker_source ! MPI request handles for non-blocking operations type ( request_t ) :: req calc_type_local = calc_type current_fragment = total_fragments finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( node_comm % size () > 1 ) results_received = 0_int64 ! Allocate storage for results allocate ( results ( total_fragments )) worker_fragment_map = 0 call logger % verbose ( \"Global coordinator starting with \" // to_char ( total_fragments ) // & \" fragments for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers ! This MUST be checked before sending new work to avoid race conditions if ( handling_local_workers ) then ! Keep checking for results until there are none pending do call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state\" end if ! Receive result and store it using the fragment index for this worker call result_irecv ( results ( worker_fragment_map ( worker_source )), node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clear the mapping since we've received the result worker_fragment_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit ! Receive fragment index and result from node coordinator ! TODO: serialize the data for better performance call irecv ( world_comm , fragment_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( fragment_idx ), world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_fragment >= 1 ) then call send_fragment_to_node ( world_comm , current_fragment , polymers , request_source ) current_fragment = current_fragment - 1 else call isend ( world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < node_comm % size () - 1 ) then call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_fragment >= 1 ) then call send_fragment_to_worker ( node_comm , current_fragment , polymers , & local_status % MPI_SOURCE ) ! Track which fragment was sent to this worker worker_fragment_map ( local_status % MPI_SOURCE ) = current_fragment current_fragment = current_fragment - 1 else call isend ( node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if ! If worker still has pending results, skip the work request ! It will be processed on the next iteration after results are received end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= node_comm % size () - 1 & . and . results_received >= total_fragments ) then handling_local_workers = . false . if ( num_nodes == 1 ) then finished_nodes = finished_nodes + 1 call logger % debug ( \"Manually incremented finished_nodes for self\" ) else finished_nodes = finished_nodes + 1 call logger % verbose ( \"Global coordinator finished local workers\" ) end if end if end do call logger % verbose ( \"Global coordinator finished all fragments\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) block real ( dp ) :: mbe_total_energy real ( dp ), allocatable :: mbe_total_gradient (:, :) real ( dp ), allocatable :: mbe_total_hessian (:, :) ! Compute the many-body expansion call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Use combined function if computing gradients or Hessians (more efficient) if ( calc_type_local == CALC_TYPE_HESSIAN ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for Hessian calculation in global_coordinator\" ) error stop \"Missing sys_geom for Hessian calculation\" end if allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) allocate ( mbe_total_hessian ( 3 * sys_geom % total_atoms , 3 * sys_geom % total_atoms )) call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy , & sys_geom , mbe_total_gradient , mbe_total_hessian , bonds ) deallocate ( mbe_total_gradient , mbe_total_hessian ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for gradient calculation in global_coordinator\" ) error stop \"Missing sys_geom for gradient calculation\" end if allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy , & sys_geom , mbe_total_gradient , bonds = bonds ) deallocate ( mbe_total_gradient ) else call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy ) end if call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end block ! Cleanup deallocate ( results ) end subroutine global_coordinator","tags":"","url":"proc/global_coordinator.html"},{"title":"node_coordinator – metalquicha","text":"module subroutine node_coordinator(world_comm, node_comm, calc_type) Interface → Node coordinator for distributing fragments to local workers\nHandles work requests and result collection from local workers Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm integer(kind=int32), intent(in) :: calc_type Calls proc~~node_coordinator~~CallsGraph proc~node_coordinator node_coordinator error error proc~node_coordinator->error iprobe iprobe proc~node_coordinator->iprobe irecv irecv proc~node_coordinator->irecv isend isend proc~node_coordinator->isend proc~result_irecv result_irecv proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv to_char to_char proc~node_coordinator->to_char proc~result_irecv->irecv proc~result_irecv->recv proc~result_isend->isend send send proc~result_isend->send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~node_coordinator~~CalledByGraph proc~node_coordinator node_coordinator interface~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: dummy_msg integer(kind=int32), private :: finished_workers integer(kind=int64), private :: fragment_idx integer(kind=int32), private, allocatable :: fragment_indices (:) integer(kind=int32), private :: fragment_size integer(kind=int32), private :: fragment_type type(MPI_Status), private :: global_status logical, private :: has_result integer(kind=int32), private :: local_dummy logical, private :: local_message_pending logical, private :: more_fragments type(request_t), private :: req type(MPI_Status), private :: status integer(kind=int64), private :: worker_fragment_map (node_comm%size()) type( calculation_result_t ), private :: worker_result integer(kind=int32), private :: worker_source Source Code module subroutine node_coordinator ( world_comm , node_comm , calc_type ) !! Node coordinator for distributing fragments to local workers !! Handles work requests and result collection from local workers class ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int32 ), intent ( in ) :: calc_type integer ( int64 ) :: fragment_idx integer ( int32 ) :: fragment_size , fragment_type , dummy_msg integer ( int32 ) :: finished_workers integer ( int32 ), allocatable :: fragment_indices (:) type ( MPI_Status ) :: status , global_status logical :: local_message_pending , more_fragments , has_result integer ( int32 ) :: local_dummy ! For tracking worker-fragment mapping and collecting results integer ( int64 ) :: worker_fragment_map ( node_comm % size ()) integer ( int32 ) :: worker_source type ( calculation_result_t ) :: worker_result ! MPI request handles for non-blocking operations type ( request_t ) :: req finished_workers = 0 more_fragments = . true . dummy_msg = 0 worker_fragment_map = 0 do while ( finished_workers < node_comm % size () - 1 ) ! PRIORITY 1: Check for incoming results from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_result , status ) if ( has_result ) then worker_source = status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Node coordinator received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state in node coordinator\" end if ! Receive result from worker call result_irecv ( worker_result , node_comm , worker_source , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Forward results to global coordinator with fragment index call isend ( world_comm , worker_fragment_map ( worker_source ), 0 , TAG_NODE_SCALAR_RESULT , req ) ! fragment_idx call wait ( req ) call result_isend ( worker_result , world_comm , 0 , TAG_NODE_SCALAR_RESULT , req ) ! result call wait ( req ) ! Clear the mapping worker_fragment_map ( worker_source ) = 0 end if ! PRIORITY 2: Check for work requests from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , local_message_pending , status ) if ( local_message_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( more_fragments ) then call isend ( world_comm , dummy_msg , 0 , TAG_NODE_REQUEST , req ) call wait ( req ) call irecv ( world_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , global_status ) if ( global_status % MPI_TAG == TAG_NODE_FRAGMENT ) then ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( world_comm , fragment_type , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) call irecv ( world_comm , fragment_size , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( world_comm , fragment_indices , 0 , TAG_NODE_FRAGMENT , global_status ) ! Forward to worker call isend ( node_comm , fragment_idx , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_type , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_size , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_indices , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Track which fragment was sent to this worker worker_fragment_map ( status % MPI_SOURCE ) = fragment_idx deallocate ( fragment_indices ) else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 more_fragments = . false . end if else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end if end do end subroutine node_coordinator","tags":"","url":"proc/node_coordinator.html"},{"title":"node_worker – metalquicha","text":"module subroutine node_worker(world_comm, node_comm, sys_geom, method, calc_type, bonds) Interface → Uses mqc_error proc~~node_worker~~UsesGraph proc~node_worker node_worker module~mqc_error mqc_error proc~node_worker->module~mqc_error Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Node worker for processing fragments assigned by node coordinator Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~node_worker~~CallsGraph proc~node_worker node_worker error error proc~node_worker->error interface~do_fragment_work do_fragment_work proc~node_worker->interface~do_fragment_work irecv irecv proc~node_worker->irecv isend isend proc~node_worker->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_atom_list proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~node_worker->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~node_worker->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~node_worker->proc~fragment_destroy proc~result_isend result_isend proc~node_worker->proc~result_isend recv recv proc~node_worker->recv to_char to_char proc~node_worker->to_char proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~build_fragment_from_indices->proc~error_has_error proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~error_add_context proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~result_isend->isend send send proc~result_isend->send proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~do_fragment_work->error configuration configuration proc~do_fragment_work->configuration proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_fragment_xyz->proc~to_angstrom info info proc~print_fragment_xyz->info new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_energy->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~xtb_calc_hessian->info proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~node_worker~~CalledByGraph proc~node_worker node_worker interface~node_worker node_worker interface~node_worker->proc~node_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: dummy_msg type( error_t ), private :: error integer(kind=int64), private :: fragment_idx integer(kind=int32), private, allocatable :: fragment_indices (:) integer(kind=int32), private :: fragment_size integer(kind=int32), private :: fragment_type 0 = monomer (indices), 1 = intersection (atom list) type( physical_fragment_t ), private :: phys_frag type(request_t), private :: req type( calculation_result_t ), private :: result type(MPI_Status), private :: status Source Code module subroutine node_worker ( world_comm , node_comm , sys_geom , method , calc_type , bonds ) !! Node worker for processing fragments assigned by node coordinator use mqc_error , only : error_t class ( comm_t ), intent ( in ) :: world_comm , node_comm type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int64 ) :: fragment_idx integer ( int32 ) :: fragment_size , dummy_msg integer ( int32 ) :: fragment_type !! 0 = monomer (indices), 1 = intersection (atom list) integer ( int32 ), allocatable :: fragment_indices (:) type ( calculation_result_t ) :: result type ( MPI_Status ) :: status type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error ! MPI request handles for non-blocking operations type ( request_t ) :: req dummy_msg = 0 do call isend ( node_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( node_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) select case ( status % MPI_TAG ) case ( TAG_WORKER_FRAGMENT ) ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( node_comm , fragment_type , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call irecv ( node_comm , fragment_size , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( node_comm , fragment_indices , 0 , TAG_WORKER_FRAGMENT , status ) ! Build physical fragment based on type if ( present ( sys_geom )) then if ( fragment_type == 0 ) then ! Monomer: fragment_indices are monomer indices call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , error , bonds ) else ! Intersection: fragment_indices are atom indices call build_fragment_from_atom_list ( sys_geom , fragment_indices , fragment_size , phys_frag , error , bonds ) end if if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build fragment in node worker\" end if ! Process the chemistry fragment with physical geometry call do_fragment_work ( fragment_idx , result , method , phys_frag , calc_type ) call phys_frag % destroy () else ! Process without physical geometry (old behavior) call do_fragment_work ( fragment_idx , result , method , calc_type = calc_type ) end if ! Send result back to coordinator call result_isend ( result , node_comm , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clean up result call result % destroy () deallocate ( fragment_indices ) case ( TAG_WORKER_FINISH ) exit case default ! Unexpected MPI tag - this should not happen in normal operation call logger % error ( \"Worker received unexpected MPI tag: \" // to_char ( status % MPI_TAG )) call logger % error ( \"Expected TAG_WORKER_FRAGMENT or TAG_WORKER_FINISH\" ) error stop \"MPI protocol error in node_worker\" end select end do end subroutine node_worker","tags":"","url":"proc/node_worker.html"},{"title":"distributed_unfragmented_hessian – metalquicha","text":"module subroutine distributed_unfragmented_hessian(world_comm, sys_geom, method, driver_config) Interface → Uses mqc_config_adapter mqc_finite_differences mqc_method_xtb proc~~distributed_unfragmented_hessian~~UsesGraph proc~distributed_unfragmented_hessian distributed_unfragmented_hessian module~mqc_config_adapter mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_config_adapter module~mqc_finite_differences mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_finite_differences module~mqc_method_xtb mqc_method_xtb proc~distributed_unfragmented_hessian->module~mqc_method_xtb module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment pic_logger pic_logger module~mqc_config_adapter->pic_logger pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_finite_differences->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_xtb->module~mqc_result_types pic_timer pic_timer module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_calculation_keywords->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute Hessian for unfragmented system using MPI distribution Uses a dynamic work queue approach: workers request displacement indices\nfrom rank 0, compute gradients, and send results back. This provides\nbetter load balancing than static work distribution. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method type( driver_config_t ), intent(in), optional :: driver_config Driver configuration Calls proc~~distributed_unfragmented_hessian~~CallsGraph proc~distributed_unfragmented_hessian distributed_unfragmented_hessian barrier barrier proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker cart_disp cart_disp proc~hessian_coordinator->cart_disp configuration configuration proc~hessian_coordinator->configuration fc_mdyne fc_mdyne proc~hessian_coordinator->fc_mdyne force_constants force_constants proc~hessian_coordinator->force_constants get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time info info proc~hessian_coordinator->info iprobe iprobe proc~hessian_coordinator->iprobe irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~compute_vibrational_analysis compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~energy_total energy_t%energy_total proc~hessian_coordinator->proc~energy_total proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_coordinator->proc~fragment_compute_nelec proc~method_type_to_string method_type_to_string proc~hessian_coordinator->proc~method_type_to_string proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator->proc~print_unfragmented_json proc~print_vibrational_analysis print_vibrational_analysis proc~hessian_coordinator->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~hessian_coordinator->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_coordinator->proc~xtb_calc_gradient recv recv proc~hessian_coordinator->recv reduced_masses reduced_masses proc~hessian_coordinator->reduced_masses start start proc~hessian_coordinator->start to_char to_char proc~hessian_coordinator->to_char vib_freqs vib_freqs proc~hessian_coordinator->vib_freqs abort_comm abort_comm proc~hessian_worker->abort_comm error error proc~hessian_worker->error proc~hessian_worker->irecv proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~hessian_worker->proc~fragment_compute_nelec proc~hessian_worker->proc~method_type_to_string proc~hessian_worker->proc~result_destroy proc~hessian_worker->proc~xtb_calc_gradient send send proc~hessian_worker->send proc~hessian_worker->to_char proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~print_unfragmented_json->error proc~print_unfragmented_json->info proc~print_unfragmented_json->proc~energy_total proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~xtb_calc_gradient->proc~energy_total new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~mass_weight_hessian->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~distributed_unfragmented_hessian~~CalledByGraph proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: displacement integer, private :: my_rank integer, private :: n_ranks Source Code module subroutine distributed_unfragmented_hessian ( world_comm , sys_geom , method , driver_config ) !! Compute Hessian for unfragmented system using MPI distribution !! !! Uses a dynamic work queue approach: workers request displacement indices !! from rank 0, compute gradients, and send results back. This provides !! better load balancing than static work distribution. use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT , & copy_and_displace_geometry use mqc_config_adapter , only : driver_config_t #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method type ( driver_config_t ), intent ( in ), optional :: driver_config !! Driver configuration integer :: my_rank , n_ranks real ( dp ) :: displacement my_rank = world_comm % rank () n_ranks = world_comm % size () ! Use provided displacement or default if ( present ( driver_config )) then displacement = driver_config % hessian % displacement else displacement = DEFAULT_DISPLACEMENT end if if ( my_rank == 0 ) then ! Rank 0 is the coordinator call hessian_coordinator ( world_comm , sys_geom , method , displacement ) else ! Other ranks are workers call hessian_worker ( world_comm , sys_geom , method , displacement ) end if ! Synchronize all ranks before returning call world_comm % barrier () end subroutine distributed_unfragmented_hessian","tags":"","url":"proc/distributed_unfragmented_hessian.html"},{"title":"hessian_coordinator – metalquicha","text":"module subroutine hessian_coordinator(world_comm, sys_geom, method, displacement) Interface → Uses mqc_vibrational_analysis mqc_finite_differences mqc_method_xtb proc~~hessian_coordinator~~UsesGraph proc~hessian_coordinator hessian_coordinator module~mqc_finite_differences mqc_finite_differences proc~hessian_coordinator->module~mqc_finite_differences module~mqc_method_xtb mqc_method_xtb proc~hessian_coordinator->module~mqc_method_xtb module~mqc_vibrational_analysis mqc_vibrational_analysis proc~hessian_coordinator->module~mqc_vibrational_analysis module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_xtb->module~mqc_result_types pic_timer pic_timer module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_elements mqc_elements module~mqc_vibrational_analysis->module~mqc_elements pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces pic_logger pic_logger module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Coordinator for distributed Hessian calculation\nDistributes displacement work and collects gradient results Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr) Calls proc~~hessian_coordinator~~CallsGraph proc~hessian_coordinator hessian_coordinator cart_disp cart_disp proc~hessian_coordinator->cart_disp configuration configuration proc~hessian_coordinator->configuration fc_mdyne fc_mdyne proc~hessian_coordinator->fc_mdyne force_constants force_constants proc~hessian_coordinator->force_constants get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time info info proc~hessian_coordinator->info iprobe iprobe proc~hessian_coordinator->iprobe irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~compute_vibrational_analysis compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~energy_total energy_t%energy_total proc~hessian_coordinator->proc~energy_total proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_coordinator->proc~fragment_compute_nelec proc~method_type_to_string method_type_to_string proc~hessian_coordinator->proc~method_type_to_string proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator->proc~print_unfragmented_json proc~print_vibrational_analysis print_vibrational_analysis proc~hessian_coordinator->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~hessian_coordinator->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_coordinator->proc~xtb_calc_gradient recv recv proc~hessian_coordinator->recv reduced_masses reduced_masses proc~hessian_coordinator->reduced_masses start start proc~hessian_coordinator->start to_char to_char proc~hessian_coordinator->to_char vib_freqs vib_freqs proc~hessian_coordinator->vib_freqs proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses error error proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~print_unfragmented_json->info proc~print_unfragmented_json->proc~energy_total proc~print_unfragmented_json->error proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~xtb_calc_gradient->proc~energy_total new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~mass_weight_hessian->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hessian_coordinator~~CalledByGraph proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: backward_gradients (:,:,:) type(timer_type), private :: coord_timer integer, private :: current_disp integer, private :: current_log_level integer, private :: disp_idx integer, private :: dummy_msg real(kind=dp), private, allocatable :: eigenvalues (:) integer, private :: finished_workers real(kind=dp), private, allocatable :: forward_gradients (:,:,:) real(kind=dp), private, allocatable :: frequencies (:) type( physical_fragment_t ), private :: full_system real(kind=dp), private, allocatable :: grad_buffer (:,:) integer, private :: gradient_type logical, private :: has_pending real(kind=dp), private :: hess_norm real(kind=dp), private, allocatable :: hessian (:,:) integer, private :: i logical, private :: is_verbose integer, private :: j integer, private :: n_atoms integer, private :: n_displacements integer, private :: n_ranks real(kind=dp), private, allocatable :: projected_hessian (:,:) type(request_t), private :: req type( calculation_result_t ), private :: result character(len=2048), private :: result_line type(MPI_Status), private :: status integer, private :: worker_rank type( xtb_method_t ), private :: xtb_calc Source Code module subroutine hessian_coordinator ( world_comm , sys_geom , method , displacement ) !! Coordinator for distributed Hessian calculation !! Distributes displacement work and collects gradient results use mqc_finite_differences , only : finite_diff_hessian_from_gradients use mqc_vibrational_analysis , only : compute_vibrational_frequencies , & compute_vibrational_analysis , print_vibrational_analysis #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) type ( physical_fragment_t ) :: full_system type ( timer_type ) :: coord_timer real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: hessian (:, :) real ( dp ), allocatable :: grad_buffer (:, :) type ( calculation_result_t ) :: result integer :: n_atoms , n_displacements , n_ranks integer :: current_disp , finished_workers , dummy_msg , worker_rank integer :: disp_idx , gradient_type ! gradient_type: 1=forward, 2=backward type ( MPI_Status ) :: status logical :: has_pending type ( request_t ) :: req integer :: current_log_level logical :: is_verbose character ( len = 2048 ) :: result_line ! Large buffer for Hessian matrix rows real ( dp ) :: hess_norm integer :: i , j real ( dp ), allocatable :: frequencies (:) real ( dp ), allocatable :: eigenvalues (:) real ( dp ), allocatable :: projected_hessian (:, :) #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc #endif n_ranks = world_comm % size () n_atoms = sys_geom % total_atoms n_displacements = 3 * n_atoms call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) call logger % info ( \"============================================\" ) call logger % info ( \"Distributed unfragmented Hessian calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) call logger % info ( \"  Finite difference step size: \" // to_char ( displacement ) // \" Bohr\" ) call logger % info ( \"  MPI ranks: \" // to_char ( n_ranks )) call logger % info ( \"  Work distribution: Dynamic queue\" ) call logger % info ( \"============================================\" ) ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Allocate storage for all gradients allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) allocate ( grad_buffer ( 3 , n_atoms )) current_disp = 1 finished_workers = 0 ! Process work requests and collect results call coord_timer % start () do while ( finished_workers < n_ranks - 1 ) ! Check for incoming gradient results call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE ! Receive: displacement index, gradient type (1=forward, 2=backward), gradient data call irecv ( world_comm , disp_idx , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call irecv ( world_comm , gradient_type , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call recv ( world_comm , grad_buffer , worker_rank , TAG_WORKER_SCALAR_RESULT , status ) ! Store gradient in appropriate array if ( gradient_type == 1 ) then forward_gradients ( disp_idx , :, :) = grad_buffer else backward_gradients ( disp_idx , :, :) = grad_buffer end if ! Log progress every 10% or at completion (count both forward and backward) if ( gradient_type == 2 ) then ! Only log after backward gradient to count complete displacements if ( mod ( disp_idx , max ( 1 , n_displacements / 10 )) == 0 . or . disp_idx == n_displacements ) then call logger % info ( \"  Completed \" // to_char ( disp_idx ) // \"/\" // to_char ( n_displacements ) // & \" displacement pairs in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end if end if end if ! Check for work requests from workers call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE call irecv ( world_comm , dummy_msg , worker_rank , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_disp <= n_displacements ) then ! Send next displacement index to worker call isend ( world_comm , current_disp , worker_rank , TAG_WORKER_FRAGMENT , req ) call wait ( req ) current_disp = current_disp + 1 else ! No more work - tell worker to finish call isend ( world_comm , - 1 , worker_rank , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end do deallocate ( grad_buffer ) call coord_timer % stop () call logger % info ( \"All gradient calculations completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Assemble Hessian from finite differences call logger % info ( \"  Assembling Hessian matrix...\" ) call coord_timer % start () call finite_diff_hessian_from_gradients ( full_system , forward_gradients , backward_gradients , & displacement , hessian ) call coord_timer % stop () call logger % info ( \"Hessian assembly completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Compute energy and gradient at reference geometry call logger % info ( \"  Computing reference energy and gradient...\" ) #ifndef MQC_WITHOUT_TBLITE xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = is_verbose call xtb_calc % calc_gradient ( full_system , result ) #endif ! Store Hessian in result if ( allocated ( result % hessian )) deallocate ( result % hessian ) allocate ( result % hessian ( size ( hessian , 1 ), size ( hessian , 2 ))) result % hessian = hessian result % has_hessian = . true . ! Compute vibrational frequencies from the Hessian (with trans/rot projection) call logger % info ( \"  Computing vibrational frequencies (projecting trans/rot modes)...\" ) call compute_vibrational_frequencies ( result % hessian , sys_geom % element_numbers , frequencies , eigenvalues , & coordinates = sys_geom % coordinates , project_trans_rot = . true ., & projected_hessian_out = projected_hessian ) ! Print results call logger % info ( \"============================================\" ) call logger % info ( \"Distributed Hessian calculation completed\" ) write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) end if if ( result % has_hessian ) then hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) if ( is_verbose . and . n_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * n_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * n_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) ! Print projected mass-weighted Hessian if ( allocated ( projected_hessian )) then call logger % info ( \"Mass-weighted Hessian after trans/rot projection (a.u.):\" ) do i = 1 , 3 * n_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( projected_hessian ( i , j ), j = 1 , 3 * n_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if end if ! Compute and print full vibrational analysis if ( allocated ( frequencies )) then block real ( dp ), allocatable :: vib_freqs (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , vib_freqs , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( vib_freqs )) then call print_vibrational_analysis ( vib_freqs , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( vib_freqs , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if ! Output JSON call print_unfragmented_json ( result ) ! Cleanup call result % destroy () deallocate ( forward_gradients , backward_gradients ) if ( allocated ( hessian )) deallocate ( hessian ) if ( allocated ( frequencies )) deallocate ( frequencies ) if ( allocated ( eigenvalues )) deallocate ( eigenvalues ) if ( allocated ( projected_hessian )) deallocate ( projected_hessian ) end subroutine hessian_coordinator","tags":"","url":"proc/hessian_coordinator.html"},{"title":"hessian_worker – metalquicha","text":"module subroutine hessian_worker(world_comm, sys_geom, method, displacement) Interface → Uses mqc_finite_differences mqc_method_xtb proc~~hessian_worker~~UsesGraph proc~hessian_worker hessian_worker module~mqc_finite_differences mqc_finite_differences proc~hessian_worker->module~mqc_finite_differences module~mqc_method_xtb mqc_method_xtb proc~hessian_worker->module~mqc_method_xtb module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_xtb->module~mqc_result_types pic_timer pic_timer module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Worker for distributed Hessian calculation\nRequests displacement indices, computes gradients, and sends results back Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr) Calls proc~~hessian_worker~~CallsGraph proc~hessian_worker hessian_worker abort_comm abort_comm proc~hessian_worker->abort_comm error error proc~hessian_worker->error irecv irecv proc~hessian_worker->irecv isend isend proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_worker->proc~fragment_compute_nelec proc~method_type_to_string method_type_to_string proc~hessian_worker->proc~method_type_to_string proc~result_destroy calculation_result_t%result_destroy proc~hessian_worker->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_worker->proc~xtb_calc_gradient send send proc~hessian_worker->send to_char to_char proc~hessian_worker->to_char proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_gradient->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hessian_worker~~CalledByGraph proc~hessian_worker hessian_worker interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_worker interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_idx integer, private :: coord integer, private :: disp_idx type( physical_fragment_t ), private :: displaced_geom integer, private :: dummy_msg type( physical_fragment_t ), private :: full_system type( calculation_result_t ), private :: grad_result integer, private :: gradient_type integer, private :: n_atoms type(request_t), private :: req type(MPI_Status), private :: status type( xtb_method_t ), private :: xtb_calc Source Code module subroutine hessian_worker ( world_comm , sys_geom , method , displacement ) !! Worker for distributed Hessian calculation !! Requests displacement indices, computes gradients, and sends results back use mqc_finite_differences , only : copy_and_displace_geometry #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) type ( physical_fragment_t ) :: full_system , displaced_geom type ( calculation_result_t ) :: grad_result integer :: n_atoms , disp_idx , atom_idx , coord , gradient_type , dummy_msg type ( MPI_Status ) :: status type ( request_t ) :: req #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc #endif n_atoms = sys_geom % total_atoms ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () #ifndef MQC_WITHOUT_TBLITE ! Setup XTB method xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = . false . dummy_msg = 0 do ! Request work from coordinator call isend ( world_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( world_comm , disp_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) if ( status % MPI_TAG == TAG_WORKER_FINISH ) exit ! Compute displacement index to atom and coordinate atom_idx = ( disp_idx - 1 ) / 3 + 1 coord = mod ( disp_idx - 1 , 3 ) + 1 ! Compute FORWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , displacement , displaced_geom ) call xtb_calc % calc_gradient ( displaced_geom , grad_result ) if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (1=forward), gradient data gradient_type = 1 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call grad_result % destroy () call displaced_geom % destroy () ! Compute BACKWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , - displacement , displaced_geom ) call xtb_calc % calc_gradient ( displaced_geom , grad_result ) if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (2=backward), gradient data gradient_type = 2 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call grad_result % destroy () call displaced_geom % destroy () end do #else call logger % error ( \"XTB method requested but tblite support not compiled in\" ) call abort_comm ( world_comm , 1 ) #endif end subroutine hessian_worker","tags":"","url":"proc/hessian_worker.html"},{"title":"unfragmented_calculation – metalquicha","text":"module subroutine unfragmented_calculation(sys_geom, method, calc_type, bonds, result_out) Interface → Uses mqc_vibrational_analysis mqc_error proc~~unfragmented_calculation~~UsesGraph proc~unfragmented_calculation unfragmented_calculation module~mqc_error mqc_error proc~unfragmented_calculation->module~mqc_error module~mqc_vibrational_analysis mqc_vibrational_analysis proc~unfragmented_calculation->module~mqc_vibrational_analysis module~mqc_elements mqc_elements module~mqc_vibrational_analysis->module~mqc_elements pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces pic_logger pic_logger module~mqc_vibrational_analysis->pic_logger pic_types pic_types module~mqc_vibrational_analysis->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Run unfragmented calculation on the entire system (nlevel=0)\nThis is a simple single-process calculation without MPI distribution\nIf result_out is present, returns result instead of writing JSON and destroying it Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( calculation_result_t ), intent(out), optional :: result_out Calls proc~~unfragmented_calculation~~CallsGraph proc~unfragmented_calculation unfragmented_calculation cart_disp cart_disp proc~unfragmented_calculation->cart_disp configuration configuration proc~unfragmented_calculation->configuration eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues error error proc~unfragmented_calculation->error fc_mdyne fc_mdyne proc~unfragmented_calculation->fc_mdyne force_constants force_constants proc~unfragmented_calculation->force_constants frequencies frequencies proc~unfragmented_calculation->frequencies info info proc~unfragmented_calculation->info interface~do_fragment_work do_fragment_work proc~unfragmented_calculation->interface~do_fragment_work proc~check_duplicate_atoms check_duplicate_atoms proc~unfragmented_calculation->proc~check_duplicate_atoms proc~compute_vibrational_analysis compute_vibrational_analysis proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~energy_total energy_t%energy_total proc~unfragmented_calculation->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~unfragmented_calculation->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~unfragmented_calculation->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json proc~print_vibrational_analysis print_vibrational_analysis proc~unfragmented_calculation->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian reduced_masses reduced_masses proc~unfragmented_calculation->reduced_masses to_char to_char proc~unfragmented_calculation->to_char proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~print_unfragmented_json->error proc~print_unfragmented_json->info proc~print_unfragmented_json->proc~energy_total proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~do_fragment_work->configuration proc~do_fragment_work->error proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mass_weight_hessian->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->info proc~xtb_calc_hessian->proc~result_destroy proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unfragmented_calculation~~CalledByGraph proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( error_t ), private :: error type( physical_fragment_t ), private :: full_system integer, private :: i type( calculation_result_t ), private :: result integer, private :: total_atoms Source Code module subroutine unfragmented_calculation ( sys_geom , method , calc_type , bonds , result_out ) !! Run unfragmented calculation on the entire system (nlevel=0) !! This is a simple single-process calculation without MPI distribution !! If result_out is present, returns result instead of writing JSON and destroying it use mqc_error , only : error_t use mqc_vibrational_analysis , only : compute_vibrational_frequencies , & compute_vibrational_analysis , print_vibrational_analysis type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ), intent ( out ), optional :: result_out type ( calculation_result_t ) :: result integer :: total_atoms type ( physical_fragment_t ) :: full_system type ( error_t ) :: error integer :: i if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for unfragmented calculation\" ) error stop \"Missing geometry in unfragmented_calculation\" end if total_atoms = sys_geom % total_atoms call logger % info ( \"============================================\" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( total_atoms )) call logger % info ( \"============================================\" ) ! Build the full system as a single fragment ! For overlapping fragments, we use the full system directly (not concatenating fragments) full_system % n_atoms = total_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( total_atoms )) allocate ( full_system % coordinates ( 3 , total_atoms )) ! Copy all atoms from system geometry full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates ! Set charge and multiplicity from system full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Validate geometry (check for spatially overlapping atoms) call check_duplicate_atoms ( full_system , error ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Overlapping atoms in unfragmented system\" end if ! Process the full system call do_fragment_work ( 0_int64 , result , method , phys_frag = full_system , calc_type = calc_type ) call logger % info ( \"============================================\" ) call logger % info ( \"Unfragmented calculation completed\" ) block character ( len = 2048 ) :: result_line ! Large buffer for Hessian matrix rows integer :: current_log_level , iatom , i , j real ( dp ) :: hess_norm write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) ! Print full gradient if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Gradient (Hartree/Bohr):\" ) do iatom = 1 , total_atoms write ( result_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & result % gradient ( 1 , iatom ), result % gradient ( 2 , iatom ), result % gradient ( 3 , iatom ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if if ( result % has_hessian ) then ! Compute Frobenius norm of Hessian hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) ! Print full Hessian if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * total_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * total_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if ! Compute and print vibrational analysis block real ( dp ), allocatable :: frequencies (:), eigenvalues (:), projected_hessian (:, :) real ( dp ), allocatable :: reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) integer :: ii , jj ! First get projected Hessian for verbose output call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_frequencies ( result % hessian , sys_geom % element_numbers , frequencies , eigenvalues , & coordinates = sys_geom % coordinates , project_trans_rot = . true ., & projected_hessian_out = projected_hessian ) ! Print projected mass-weighted Hessian if verbose and small system if ( current_log_level >= verbose_level . and . total_atoms < 20 ) then if ( allocated ( projected_hessian )) then call logger % info ( \" \" ) call logger % info ( \"Mass-weighted Hessian after trans/rot projection (a.u.):\" ) do ii = 1 , 3 * total_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , ii , \": \" , & ( projected_hessian ( ii , jj ), jj = 1 , 3 * total_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if ! Compute full vibrational analysis and print call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if if ( allocated ( eigenvalues )) deallocate ( eigenvalues ) if ( allocated ( projected_hessian )) deallocate ( projected_hessian ) end block end if end block call logger % info ( \"============================================\" ) ! Return result to caller or write JSON if ( present ( result_out )) then ! Transfer result to output (for dynamics/optimization) result_out = result else ! Write JSON and clean up (normal mode) call print_unfragmented_json ( result ) call result % destroy () end if end subroutine unfragmented_calculation","tags":"","url":"proc/unfragmented_calculation.html"},{"title":"mqc_frag_utils – metalquicha","text":"Provides combinatorial functions and algorithms for generating molecular\nfragments, managing fragment lists, and performing many-body expansion calculations. This module re-exports functionality from specialized modules:\n- mqc_combinatorics: Pure combinatorial mathematics\n- mqc_fragment_lookup: Hash-based fragment index lookup\n- mqc_gmbe_utils: GMBE intersection and PIE enumeration Uses pic_logger mqc_gmbe_utils mqc_combinatorics pic_io mqc_physical_fragment mqc_fragment_lookup pic_types module~~mqc_frag_utils~~UsesGraph module~mqc_frag_utils mqc_frag_utils module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_physical_fragment mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment pic_io pic_io module~mqc_frag_utils->pic_io pic_logger pic_logger module~mqc_frag_utils->pic_logger pic_types pic_types module~mqc_frag_utils->pic_types module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_frag_utils~~UsedByGraph module~mqc_frag_utils mqc_frag_utils module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine apply_distance_screening (polymers, total_fragments, sys_geom, driver_config, max_level) Apply distance-based screening to filter out fragments that exceed cutoff distances\nModifies polymers array in-place and updates total_fragments count Arguments Type Intent Optional Attributes Name integer, intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: total_fragments type( system_geometry_t ), intent(in) :: sys_geom type( driver_config_t ), intent(in) :: driver_config integer, intent(in) :: max_level public  subroutine sort_fragments_by_size (polymers, total_fragments, max_level) Sort fragments by size (largest first) for better load balancing\nUses in-place sorting to reorder the polymers array\nLarger fragments (e.g., tetramers) are computed before smaller ones (e.g., dimers) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: polymers (:,:) integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: max_level","tags":"","url":"module/mqc_frag_utils.html"},{"title":"mqc_mbe_fragment_distribution_scheme – metalquicha","text":"Implements hierarchical many-body expansion for fragment-based quantum chemistry\ncalculations with MPI parallelization and energy/gradient computation. Uses mqc_mpi_tags pic_blas_interfaces pic_logger mqc_method_types mqc_config_parser mqc_result_types pic_mpi_lib pic_timer mqc_mbe mqc_method_xtb pic_io mqc_config_adapter mqc_physical_fragment mqc_mbe_io omp_lib mqc_calc_types pic_types module~~mqc_mbe_fragment_distribution_scheme~2~~UsesGraph module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_calc_types mqc_calc_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_types mqc_method_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_types module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme~2->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme~2->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme~2->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme~2->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme~2->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme~2->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_method_types->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: mqc_hessian_distribution_scheme mqc_mbe_fragment_distribution_scheme mqc_serial_fragment_processor mqc_unfragmented_workflow module~~mqc_mbe_fragment_distribution_scheme~2~~UsedByGraph module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface public module subroutine distributed_unfragmented_hessian(world_comm, sys_geom, method, driver_config) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method type( driver_config_t ), intent(in), optional :: driver_config Driver configuration interface public module subroutine do_fragment_work(fragment_idx, result, method, phys_frag, calc_type) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx type( calculation_result_t ), intent(out) :: result integer(kind=int32), intent(in) :: method type( physical_fragment_t ), intent(in), optional :: phys_frag integer(kind=int32), intent(in) :: calc_type interface public module subroutine global_coordinator(world_comm, node_comm, total_fragments, polymers, max_level, node_leader_ranks, num_nodes, sys_geom, calc_type, bonds) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) interface public module subroutine node_coordinator(world_comm, node_comm, calc_type) Implementation → Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm integer(kind=int32), intent(in) :: calc_type interface public module subroutine node_worker(world_comm, node_comm, sys_geom, method, calc_type, bonds) Implementation → Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) interface public module subroutine serial_fragment_processor(total_fragments, polymers, max_level, sys_geom, method, calc_type, bonds) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) interface public module subroutine unfragmented_calculation(sys_geom, method, calc_type, bonds, result_out) Implementation → Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( calculation_result_t ), intent(out), optional :: result_out interface private module subroutine hessian_coordinator(world_comm, sys_geom, method, displacement) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr) interface private module subroutine hessian_worker(world_comm, sys_geom, method, displacement) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr)","tags":"","url":"module/mqc_mbe_fragment_distribution_scheme~2.html"},{"title":"mqc_method_types – metalquicha","text":"Defines integer constants for quantum chemistry methods to avoid string comparisons\nthroughout the codebase. Provides conversion utilities between string\nrepresentations and integer constants. Uses pic_types module~~mqc_method_types~~UsesGraph module~mqc_method_types mqc_method_types pic_types pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_types~~UsedByGraph module~mqc_method_types mqc_method_types module~mqc_config_parser mqc_config_parser module~mqc_config_parser->module~mqc_method_types module~mqc_driver mqc_driver module~mqc_driver->module~mqc_method_types module~mqc_driver->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_config_adapter mqc_config_adapter module~mqc_driver->module~mqc_config_adapter module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_physical_fragment mqc_physical_fragment module~mqc_driver->module~mqc_physical_fragment module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_config_parser module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_physical_fragment->module~mqc_config_parser module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_config_parser proc~compute_gmbe->module~mqc_physical_fragment proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_config_parser proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_config_parser proc~process_intersection_derivatives->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_parser program~main->module~mqc_driver program~main->module~mqc_config_adapter program~main->module~mqc_physical_fragment module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~apply_distance_screening->module~mqc_physical_fragment proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: METHOD_TYPE_GFN1 = 1 integer(kind=int32), public, parameter :: METHOD_TYPE_GFN2 = 2 integer(kind=int32), public, parameter :: METHOD_TYPE_HF = 3 integer(kind=int32), public, parameter :: METHOD_TYPE_UNKNOWN = 0 Functions public pure function method_type_from_string (method_str) result(method_type) Convert method type string to integer constant Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Input string (e.g., “gfn1”, “gfn2”, “hf”) Return Value integer(kind=int32) Output integer constant public pure function method_type_to_string (method_type) result(method_str) Convert method type integer constant to string Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: method_type Input integer constant Return Value character(len=:), allocatable Output string representation","tags":"","url":"module/mqc_method_types.html"},{"title":"mqc_finite_differences – metalquicha","text":"Provides utilities for generating perturbed geometries and computing\nnumerical derivatives via finite differences (gradients, Hessians, etc.)\nGenerate forward/backward displacements\nContainer for displaced geometry\nCompute Hessian from gradient differences\nCopy and displace geometry Uses pic_types mqc_physical_fragment module~~mqc_finite_differences~~UsesGraph module~mqc_finite_differences mqc_finite_differences module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_finite_differences~~UsedByGraph module~mqc_finite_differences mqc_finite_differences proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: DEFAULT_DISPLACEMENT = 0.005_dp ~0.05 Angstrom Derived Types type, public :: displaced_geometry_t Container for a single displaced geometry Components Type Visibility Attributes Name Initial integer, public :: atom_index Which atom was displaced (1-based) integer, public :: coordinate Which coordinate was displaced (1=x, 2=y, 3=z) integer, public :: direction +1 for forward, -1 for backward real(kind=dp), public :: displacement Displacement magnitude in Bohr type( physical_fragment_t ), public :: geometry The displaced geometry Type-Bound Procedures procedure, public :: destroy => displaced_geometry_destroy Subroutines public  subroutine copy_and_displace_geometry (reference_geom, atom_idx, coord_idx, displacement, displaced_geom) Create a copy of reference geometry with one coordinate displaced Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom integer, intent(in) :: atom_idx integer, intent(in) :: coord_idx real(kind=dp), intent(in) :: displacement type( physical_fragment_t ), intent(out) :: displaced_geom public  subroutine finite_diff_hessian_from_gradients (reference_geom, forward_gradients, backward_gradients, displacement, hessian) Compute Hessian matrix from finite differences of gradients Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: forward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: backward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: displacement real(kind=dp), intent(out), allocatable :: hessian (:,:) (3 n_atoms, 3 n_atoms) public  subroutine generate_perturbed_geometries (reference_geom, displacement, forward_geoms, backward_geoms) Generate all forward and backward displaced geometries for finite difference calculations Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: displacement type( displaced_geometry_t ), intent(out), allocatable :: forward_geoms (:) type( displaced_geometry_t ), intent(out), allocatable :: backward_geoms (:) private  subroutine displaced_geometry_destroy (this) Clean up memory for displaced geometry Arguments Type Intent Optional Attributes Name class( displaced_geometry_t ), intent(inout) :: this","tags":"","url":"module/mqc_finite_differences.html"},{"title":"mqc_calculation_keywords – metalquicha","text":"Provides structured keyword types for calculation-specific settings\nThese types are embedded in driver_config_t to organize keywords by category Uses pic_types module~~mqc_calculation_keywords~~UsesGraph module~mqc_calculation_keywords mqc_calculation_keywords pic_types pic_types module~mqc_calculation_keywords->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_calculation_keywords~~UsedByGraph module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: aimd_keywords_t Ab initio molecular dynamics keywords Components Type Visibility Attributes Name Initial real(kind=dp), public :: dt = 1.0_dp Timestep (femtoseconds) real(kind=dp), public :: initial_temperature = 300.0_dp Initial temperature for velocity init (K) integer, public :: nsteps = 0 Number of MD steps (0 = no AIMD) integer, public :: output_frequency = 1 Write output every N steps type, public :: hessian_keywords_t Hessian calculation keywords Components Type Visibility Attributes Name Initial real(kind=dp), public :: displacement = 0.001_dp Finite difference displacement (Bohr) type, public :: scf_keywords_t SCF calculation keywords (placeholder for future use) Components Type Visibility Attributes Name Initial real(kind=dp), public :: convergence_threshold = 1.0e-6_dp Convergence threshold for SCF integer, public :: max_iterations = 100 Maximum SCF iterations logical, public :: use_diis = .true. Use DIIS acceleration","tags":"","url":"module/mqc_calculation_keywords.html"},{"title":"mqc_result_types – metalquicha","text":"Defines data structures for storing and managing results from\nquantum chemistry calculations including energies, gradients, and properties.\nMP2 energy components type\nCoupled cluster energy components type\nEnergy components type\nMain result container type\nSend result over MPI\nReceive result over MPI Uses pic_types pic_mpi_lib module~~mqc_result_types~~UsesGraph module~mqc_result_types mqc_result_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib pic_types pic_types module~mqc_result_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_result_types~~UsedByGraph module~mqc_result_types mqc_result_types module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_result_types module~mqc_driver mqc_driver module~mqc_driver->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_io->module~mqc_result_types module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_result_types module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->module~mqc_method_base proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_result_types proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_result_types proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_result_types proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_result_types proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~print_detailed_breakdown_json->module~mqc_result_types proc~print_gmbe_intersection_debug print_gmbe_intersection_debug proc~print_gmbe_intersection_debug->module~mqc_result_types proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_result_types module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_xtb program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: SCS_OS_SCALE = 1.2_dp SCS opposite-spin scaling factor real(kind=dp), private, parameter :: SCS_SS_SCALE = 1.0_dp/3.0_dp SCS same-spin scaling factor Derived Types type, public :: calculation_result_t Container for quantum chemistry calculation results Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dipole (:) Dipole moment vector (3) (Debye) real(kind=dp), public :: distance = 0.0_dp Minimal atomic distance between monomers (Angstrom, 0 for monomers) type( energy_t ), public :: energy Energy components (Hartree) real(kind=dp), public, allocatable :: gradient (:,:) Energy gradient (3, natoms) (Hartree/Bohr) logical, public :: has_dipole = .false. Dipole moment has been computed logical, public :: has_energy = .false. Energy has been computed logical, public :: has_gradient = .false. Gradient has been computed logical, public :: has_hessian = .false. Hessian has been computed logical, public :: has_sigma = .false. Stress tensor has been computed real(kind=dp), public, allocatable :: hessian (:,:) Energy hessian (future implementation) real(kind=dp), public, allocatable :: sigma (:,:) Stress tensor (3,3) (Hartree/Bohr&#94;3) Type-Bound Procedures procedure, public :: destroy => result_destroy Clean up allocated memory procedure, public :: reset => result_reset Reset all values and flags type, public :: cc_energy_t Container for coupled cluster energy components Components Type Visibility Attributes Name Initial real(kind=dp), public :: doubles = 0.0_dp Doubles contribution (Hartree) real(kind=dp), public :: singles = 0.0_dp Singles contribution (Hartree) real(kind=dp), public :: triples = 0.0_dp Triples contribution (Hartree) Type-Bound Procedures procedure, public :: check_stability => cc_check_stability Check for positive energies (instability) procedure, public :: reset => cc_reset Reset all components to zero procedure, public :: total => cc_total Compute total CC correlation type, public :: energy_t Container for quantum chemistry energy components Read more… Components Type Visibility Attributes Name Initial type( cc_energy_t ), public :: cc Coupled cluster correlation components type( mp2_energy_t ), public :: mp2 MP2 correlation components real(kind=dp), public :: scf = 0.0_dp SCF/HF reference energy (Hartree) Type-Bound Procedures procedure, public :: reset => energy_reset Reset all components to zero procedure, public :: total => energy_total Compute total energy from components type, public :: mp2_energy_t Container for MP2 energy components (SS/OS) Components Type Visibility Attributes Name Initial real(kind=dp), public :: os = 0.0_dp Opposite-spin correlation energy (Hartree) real(kind=dp), public :: ss = 0.0_dp Same-spin correlation energy (Hartree) Type-Bound Procedures procedure, public :: check_stability => mp2_check_stability Check for positive energies (instability) procedure, public :: reset => mp2_reset Reset both components to zero procedure, public :: scs => mp2_scs Compute SCS-MP2 correlation procedure, public :: total => mp2_total Compute total MP2 correlation Functions private pure function cc_total (this) result(total) Compute total CC correlation energy Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Return Value real(kind=dp) private pure function energy_total (this) result(total) Compute total energy from all components Arguments Type Intent Optional Attributes Name class( energy_t ), intent(in) :: this Return Value real(kind=dp) private pure function mp2_scs (this) result(scs_energy) Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy\nSCS-MP2 uses: E_SCS = (1/3) E_SS + 1.2 E_OS Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) private pure function mp2_total (this) result(total) Compute total MP2 correlation energy Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Subroutines public  subroutine result_irecv (result, comm, source, tag, req) Receive calculation result over MPI (non-blocking)\nReceives SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(request_t), intent(out) :: req public  subroutine result_isend (result, comm, dest, tag, req) Send calculation result over MPI (non-blocking)\nSends SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag type(request_t), intent(out) :: req public  subroutine result_recv (result, comm, source, tag, status) Receive calculation result over MPI (blocking)\nReceives energy components and conditionally receives gradient based on flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(MPI_Status), intent(out) :: status public  subroutine result_send (result, comm, dest, tag) Send calculation result over MPI (blocking)\nSends energy components and conditionally sends gradient based on has_gradient flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag private  subroutine cc_check_stability (this) Check for positive CC correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this private  subroutine cc_reset (this) Reset all CC components to zero Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(inout) :: this private  subroutine energy_reset (this) Reset all energy components to zero Arguments Type Intent Optional Attributes Name class( energy_t ), intent(inout) :: this private  subroutine mp2_check_stability (this) Check for positive MP2 correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this private  subroutine mp2_reset (this) Reset both MP2 components to zero Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(inout) :: this private  subroutine result_destroy (this) Clean up allocated memory in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this private  subroutine result_reset (this) Reset all values and flags in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this","tags":"","url":"module/mqc_result_types.html"},{"title":"mqc_config_adapter – metalquicha","text":"Provides conversion utilities from mqc_config_t to driver-compatible structures\nMinimal config for driver\nConvert log level string to integer\nCheck for overlapping fragments (for testing) Runtime configuration for driver (internal use only) Uses pic_logger mqc_config_parser mqc_error mqc_calculation_keywords mqc_physical_fragment mqc_elements pic_types module~~mqc_config_adapter~~UsesGraph module~mqc_config_adapter mqc_config_adapter module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment pic_logger pic_logger module~mqc_config_adapter->pic_logger pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_calculation_keywords->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_config_adapter~~UsedByGraph module~mqc_config_adapter mqc_config_adapter module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: driver_config_t Components Type Visibility Attributes Name Initial type( aimd_keywords_t ), public :: aimd AIMD calculation keywords logical, public :: allow_overlapping_fragments = .false. Enable GMBE for overlapping fragments integer(kind=int32), public :: calc_type Calculation type constant real(kind=dp), public, allocatable :: fragment_cutoffs (:) Distance cutoffs for n-mer screening (Angstrom) type( hessian_keywords_t ), public :: hessian Hessian calculation keywords integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method QC method constant integer, public :: nlevel = 0 Fragmentation level (0 = unfragmented) type( scf_keywords_t ), public :: scf SCF calculation keywords Functions public  function get_logger_level (level_string) result(level_int) Convert string log level to integer value\nThis function uses the pic_logger constants Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: level_string Return Value integer Subroutines public  subroutine check_fragment_overlap (fragments, nfrag, error) Check if any atoms appear in multiple fragments\nThis is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes Arguments Type Intent Optional Attributes Name type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: nfrag type( error_t ), intent(out) :: error public  subroutine config_to_driver (mqc_config, driver_config, molecule_index) Convert mqc_config_t to minimal driver_config_t\nExtracts only the fields needed by the driver\nIf molecule_index is provided, uses that molecule’s fragment count Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( driver_config_t ), intent(out) :: driver_config integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) public  subroutine config_to_system_geometry (mqc_config, sys_geom, error, molecule_index) Convert mqc_config_t geometry to system_geometry_t\nFor unfragmented calculations (nfrag=0), treats entire system as single unit\nFor fragmented calculations, currently assumes monomer-based fragmentation\nIf molecule_index is provided, uses that specific molecule from multi-molecule mode Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) private  subroutine geometry_to_system_fragmented (mqc_config, sys_geom, use_angstrom, error) Convert geometry to system_geometry_t for fragmented calculation\nSupports both identical and variable-sized fragments Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom type( error_t ), intent(out) :: error private  subroutine geometry_to_system_unfragmented (geom, sys_geom, use_angstrom) Convert geometry to system_geometry_t for unfragmented calculation\nTreats entire system as a single monomer Arguments Type Intent Optional Attributes Name type( geometry_type ), intent(in) :: geom type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom private  subroutine initialize_fragmented_system (nfrag, geom, fragments, charge, multiplicity, allow_overlapping, use_angstrom, sys_geom, error) Shared helper to initialize system_geometry_t for fragmented calculations\nHandles fragment allocation, size checking, and overlap validation Arguments Type Intent Optional Attributes Name integer, intent(in) :: nfrag type( geometry_type ), intent(in) :: geom type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: charge integer, intent(in) :: multiplicity logical, intent(in) :: allow_overlapping logical, intent(in) :: use_angstrom type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error private  subroutine molecule_to_system_geometry (mol, sys_geom, use_angstrom, allow_overlapping, error) Convert a molecule_t to system_geometry_t\nHandles both unfragmented (nfrag=0) and fragmented molecules Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: mol type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom logical, intent(in) :: allow_overlapping type( error_t ), intent(out) :: error","tags":"","url":"module/mqc_config_adapter.html"},{"title":"mqc_error – metalquicha","text":"Error codes Used by module~~mqc_error~~UsedByGraph module~mqc_error mqc_error module~mqc_basis_reader mqc_basis_reader module~mqc_basis_reader->module~mqc_error module~mqc_basis_utils mqc_basis_utils module~mqc_basis_utils->module~mqc_error module~mqc_cli_parser mqc_cli_parser module~mqc_cli_parser->module~mqc_error module~mqc_cli_parser->module~mqc_basis_utils module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_error module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_parser->module~mqc_error module~mqc_driver mqc_driver module~mqc_driver->module~mqc_error module~mqc_driver->module~mqc_config_adapter module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_physical_fragment module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_config_parser module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_xyz_reader->module~mqc_error proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_error proc~compute_gmbe->module~mqc_config_parser proc~compute_gmbe->module~mqc_physical_fragment proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_error proc~compute_mbe_hessian->module~mqc_config_parser proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_error proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_error proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_error proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~node_worker node_worker proc~node_worker->module~mqc_error proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_error proc~process_intersection_derivatives->module~mqc_config_parser proc~process_intersection_derivatives->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_error proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~run_multi_molecule_calculations->module~mqc_config_parser proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->module~mqc_error proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_error proc~serial_gmbe_pie_processor->module~mqc_physical_fragment proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->module~mqc_error program~main main program~main->module~mqc_error program~main->module~mqc_config_adapter program~main->module~mqc_config_parser program~main->module~mqc_driver program~main->module~mqc_physical_fragment module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_config_parser module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~apply_distance_screening->module~mqc_physical_fragment proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_config_parser proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: ERROR_GENERIC = 1 integer, public, parameter :: ERROR_IO = 2 integer, public, parameter :: ERROR_PARSE = 3 integer, public, parameter :: ERROR_VALIDATION = 4 Stack trace configuration integer, public, parameter :: SUCCESS = 0 integer, private, parameter :: MAX_LOCATION_LEN = 128 Unified error type with stack trace support integer, private, parameter :: MAX_STACK_DEPTH = 20 Derived Types type, public :: error_t Components Type Visibility Attributes Name Initial character(len=MAX_LOCATION_LEN), public :: call_stack (MAX_STACK_DEPTH) Call locations integer, public :: code = SUCCESS Error code (0 = no error) character(len=:), public, allocatable :: message Error message Read more… integer, public :: stack_depth = 0 Current stack depth Type-Bound Procedures procedure, public :: add_context => error_add_context procedure, public :: clear => error_clear procedure, public :: get_code => error_get_code procedure, public :: get_full_trace => error_get_full_trace procedure, public :: get_message => error_get_message procedure, public :: has_error => error_has_error procedure, public :: print_trace => error_print_trace procedure, public :: set => error_set Functions private pure function error_get_code (this) result(code) Get the error code Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value integer private  function error_get_full_trace (this) result(trace) Get complete error message with stack trace\nReturns a multi-line string with error and call stack Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable private pure function error_get_message (this) result(message) Get the error message (without stack trace) Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable private pure function error_has_error (this) result(has_err) Check if an error is set Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value logical Subroutines private pure subroutine error_add_context (this, location) Add a call location to the stack trace\nTypically called when propagating errors upward Read more… Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this character(len=*), intent(in) :: location private pure subroutine error_clear (this) Clear the error state and stack trace Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this private  subroutine error_print_trace (this, unit) Print error with stack trace to specified unit\nIf unit not specified, prints to stdout (unit 6) Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this integer, intent(in), optional :: unit private pure subroutine error_set (this, code, message) Set an error with code and message\nResets the stack trace Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this integer, intent(in) :: code character(len=*), intent(in) :: message","tags":"","url":"module/mqc_error.html"},{"title":"mqc_method_xtb – metalquicha","text":"Provides GFN1-xTB and GFN2-xTB methods via the tblite library,\nimplementing the abstract method interface for energy and gradient calculations.\nXTB method implementation type Uses mctc_io mqc_method_base mqc_result_types tblite_context_type tblite_xtb_singlepoint tblite_wavefunction pic_timer tblite_xtb_gfn1 mqc_physical_fragment tblite_xtb_gfn2 tblite_xtb_calculator pic_types mctc_env module~~mqc_method_xtb~~UsesGraph module~mqc_method_xtb mqc_method_xtb mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_xtb->module~mqc_result_types pic_timer pic_timer module~mqc_method_xtb->pic_timer pic_types pic_types module~mqc_method_xtb->pic_types tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_xtb~~UsedByGraph module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_xtb module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( qc_method_t ) :: xtb_method_t Extended Tight-Binding (xTB) method implementation Read more… Components Type Visibility Attributes Name Initial real(kind=wp), public :: accuracy = 0.01_wp Numerical accuracy parameter real(kind=wp), public :: kt = 300.0_wp*3.166808578545117e-06_wp Electronic temperature (300 K) character(len=:), public, allocatable :: variant XTB variant: “gfn1” or “gfn2” logical, public :: verbose = .false. Print calculation details Type-Bound Procedures procedure, public :: calc_energy => xtb_calc_energy Energy-only calculation procedure, public :: calc_gradient => xtb_calc_gradient Energy + gradient calculation procedure, public :: calc_hessian => xtb_calc_hessian Placeholder for Hessian calculation Subroutines private  subroutine xtb_calc_energy (this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine xtb_calc_gradient (this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine xtb_calc_hessian (this, fragment, result) Calculate Hessian using finite differences of gradients Read more… Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result","tags":"","url":"module/mqc_method_xtb.html"},{"title":"mqc_mpi_tags – metalquicha","text":"Module defining MPI communication tags for clarity and maintainability Uses pic_types module~~mqc_mpi_tags~~UsesGraph module~mqc_mpi_tags mqc_mpi_tags pic_types pic_types module~mqc_mpi_tags->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mpi_tags~~UsedByGraph module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_driver mqc_driver module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: TAG_NODE_FINISH = 302 Global coordinator signals node coordinator to finish integer(kind=default_int), public, parameter :: TAG_NODE_FRAGMENT = 301 Global coordinator sends fragment data to node coordinator integer(kind=default_int), public, parameter :: TAG_NODE_MATRIX_RESULT = 304 Node coordinator sends matrix results to global coordinator integer(kind=default_int), public, parameter :: TAG_NODE_REQUEST = 300 Node coordinator requests work from global coordinator integer(kind=default_int), public, parameter :: TAG_NODE_SCALAR_RESULT = 303 Node coordinator sends results (fragment_idx + scalar) to global coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_FINISH = 202 Coordinator signals worker to finish integer(kind=default_int), public, parameter :: TAG_WORKER_FRAGMENT = 201 Coordinator sends fragment data to worker integer(kind=default_int), public, parameter :: TAG_WORKER_MATRIX_RESULT = 204 Worker sends matrix results back to coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_REQUEST = 200 Worker requests work from node coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_SCALAR_RESULT = 203 Worker sends scalar results back to coordinator","tags":"","url":"module/mqc_mpi_tags.html"},{"title":"mqc_basis_file_reader – metalquicha","text":"Module for reading and parsing GAMESS formatted basis set files Uses pic_types module~~mqc_basis_file_reader~~UsesGraph module~mqc_basis_file_reader mqc_basis_file_reader pic_types pic_types module~mqc_basis_file_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_basis_file_reader~~UsedByGraph module~mqc_basis_file_reader mqc_basis_file_reader module~mqc_basis_reader mqc_basis_reader module~mqc_basis_reader->module~mqc_basis_file_reader Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: basis_file_t Container for basis set file contents Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: data_section character(len=:), public, allocatable :: full_content Functions public  function extract_element (basis_file, element) result(element_content) Extract the basis set data for a specific element from the basis file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(in) :: basis_file character(len=*), intent(in) :: element Return Value character(len=:), allocatable public pure function strings_equal (str1, str2) result(equal) Compare two strings after trimming and adjusting (removing leading/trailing whitespace)\nCompare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical private pure function is_letter (c) result(is_alpha) Check if character is a letter (A-Z or a-z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical private pure function is_uppercase_letter (c) result(is_upper) Check if character is an uppercase letter (A-Z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical private pure function uppercase (str) result(upper) Convert a string to uppercase, should use pic_ascii! Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:), allocatable Subroutines public  subroutine open_basis_file (basis_file, filename) Open and read a GAMESS formatted basis set file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(out) :: basis_file character(len=*), intent(in) :: filename","tags":"","url":"module/mqc_basis_file_reader.html"},{"title":"mqc_gmbe_utils – metalquicha","text":"Provides functions for computing fragment intersections, generating k-way\nintersections, and enumerating PIE (Principle of Inclusion-Exclusion) terms\nfor GMBE calculations with overlapping molecular fragments.\nFind shared atoms between two fragments\nGenerate all k-way intersections for GMBE\nCompute atom list for polymer (union of fragments)\nGenerate intersections for polymers\nDFS-based PIE coefficient enumeration Uses pic_io pic_logger pic_types mqc_combinatorics module~~mqc_gmbe_utils~~UsesGraph module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_combinatorics mqc_combinatorics module~mqc_gmbe_utils->module~mqc_combinatorics pic_io pic_io module~mqc_gmbe_utils->pic_io pic_logger pic_logger module~mqc_gmbe_utils->pic_logger pic_types pic_types module~mqc_gmbe_utils->pic_types module~mqc_combinatorics->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_gmbe_utils~~UsedByGraph module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils mqc_frag_utils module~mqc_frag_utils->module~mqc_gmbe_utils proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_gmbe_utils proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_gmbe_utils module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function find_fragment_intersection (frag1_atoms, n1, frag2_atoms, n2, intersection, n_intersect) result(has_intersection) Find shared atoms between two fragments (for GMBE with overlapping fragments) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag1_atoms (:) Atom indices in fragment 1 (0-indexed) integer, intent(in) :: n1 Number of atoms in fragment 1 integer, intent(in) :: frag2_atoms (:) Atom indices in fragment 2 (0-indexed) integer, intent(in) :: n2 Number of atoms in fragment 2 integer, intent(out), allocatable :: intersection (:) Shared atom indices integer, intent(out) :: n_intersect Number of shared atoms Return Value logical private pure function atom_sets_equal (set1, set2, n_atoms) result(equal) Check if two atom sets are equal (assuming sorted) Arguments Type Intent Optional Attributes Name integer, intent(in) :: set1 (:) integer, intent(in) :: set2 (:) integer, intent(in) :: n_atoms Return Value logical Subroutines public pure subroutine compute_polymer_atoms (sys_geom, polymer, polymer_size, atom_list, n_atoms) Compute the atom list for a polymer (union of atoms from base fragments)\npolymer(:) contains base fragment indices (1-based) Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymer (:) Base fragment indices in this polymer integer, intent(in) :: polymer_size Number of base fragments in polymer integer, intent(out), allocatable :: atom_list (:) Unique atoms in this polymer integer, intent(out) :: n_atoms Number of unique atoms public  subroutine generate_intersections (sys_geom, monomers, polymers, n_monomers, max_intersection_level, intersections, intersection_sets, intersection_levels, n_intersections) Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) Monomer indices integer, intent(inout) :: polymers (:,:) Output: monomers stored here integer, intent(in) :: n_monomers Number of monomers integer, intent(in) :: max_intersection_level Maximum k-way intersection depth integer, intent(out), allocatable :: intersections (:,:) Intersection atom lists integer, intent(out), allocatable :: intersection_sets (:,:) Which k-tuple created each intersection integer, intent(out), allocatable :: intersection_levels (:) Level (k) of each intersection integer, intent(out) :: n_intersections Number of intersections found public  subroutine generate_polymer_intersections (sys_geom, polymers, n_polymers, max_level, intersections, intersection_sets, intersection_levels, n_intersections) Generate all k-way intersections for polymers at any level (GMBE-N)\nThis works with dynamically generated polymers, not just base fragments Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymers (:,:) Polymer definitions (n_polymers, max_level) integer, intent(in) :: n_polymers integer, intent(in) :: max_level integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections public  subroutine gmbe_enumerate_pie_terms (sys_geom, primaries, n_primaries, polymer_level, max_k_level, pie_atom_sets, pie_coefficients, n_pie_terms, initial_max_terms) Enumerate all unique intersections via DFS and accumulate PIE coefficients\nThis implements the GMBE(N) algorithm with inclusion-exclusion principle Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: primaries (:,:) Primary polymers (n_primaries, polymer_level) integer, intent(in) :: n_primaries Number of primary polymers integer, intent(in) :: polymer_level Level of primaries (1=monomers, 2=dimers, etc.) integer, intent(in) :: max_k_level Maximum clique size (intersection depth limit) integer, intent(out), allocatable :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_terms) integer, intent(out), allocatable :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(out) :: n_pie_terms Number of unique PIE terms integer(kind=int64), intent(in), optional :: initial_max_terms Initial PIE storage capacity private recursive subroutine dfs_pie_accumulate (primary_atoms, primary_n_atoms, n_primaries, max_atoms, clique, clique_size, current_atoms, n_current_atoms, candidates, n_candidates, max_k_level, atom_sets, coefficients, n_terms, max_terms) DFS helper: accumulate PIE coefficients for intersections Arguments Type Intent Optional Attributes Name integer, intent(in) :: primary_atoms (:,:) Precomputed atom lists integer, intent(in) :: primary_n_atoms (:) Atom counts integer, intent(in) :: n_primaries integer, intent(in) :: max_atoms integer, intent(in) :: clique (:) Current clique integer, intent(in) :: clique_size Size of current clique integer, intent(in) :: current_atoms (:) Atoms in current intersection integer, intent(in) :: n_current_atoms Number of atoms in intersection integer, intent(in) :: candidates (:) Candidate primaries integer, intent(in) :: n_candidates integer, intent(in) :: max_k_level integer, intent(inout), allocatable :: atom_sets (:,:) integer, intent(inout), allocatable :: coefficients (:) integer(kind=int64), intent(inout) :: n_terms integer(kind=int64), intent(inout) :: max_terms private  subroutine generate_intersections_from_atom_lists (atom_lists, n_atoms_list, n_sets, max_k_level, intersections, intersection_sets, intersection_levels, n_intersections) Generate k-way intersections from arbitrary atom lists (not tied to sys_geom)\nmax_k_level limits the maximum intersection order to prevent combinatorial explosion Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) (max_atoms, n_sets) integer, intent(in) :: n_atoms_list (:) Number of atoms in each set integer, intent(in) :: n_sets Number of sets (polymers) integer, intent(in) :: max_k_level Maximum intersection level to compute integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections private recursive subroutine generate_k_way_intersections_for_level (sys_geom, monomers, n_monomers, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Helper to generate all k-way intersections at a specific level k Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count private  subroutine generate_k_way_intersections_from_lists (atom_lists, n_atoms_list, n_sets, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Generate all k-way intersections from atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) integer, intent(in) :: n_atoms_list (:) integer, intent(in) :: n_sets integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count private  subroutine grow_pie_storage (atom_sets, coefficients, max_terms, max_atoms) Grow PIE term storage arrays when capacity is exceeded. Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: atom_sets (:,:) integer, intent(inout), allocatable :: coefficients (:) integer(kind=int64), intent(inout) :: max_terms integer, intent(in) :: max_atoms private pure subroutine intersect_atom_lists (atoms1, n1, atoms2, n2, intersection, n_intersect) Compute intersection of two atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms1 (:) integer, intent(in) :: n1 integer, intent(in) :: atoms2 (:) integer, intent(in) :: n2 integer, intent(out) :: intersection (:) integer, intent(out) :: n_intersect","tags":"","url":"module/mqc_gmbe_utils.html"},{"title":"mqc_io_helpers – metalquicha","text":"Used by module~~mqc_io_helpers~~UsedByGraph module~mqc_io_helpers mqc_io_helpers module~mqc_driver mqc_driver module~mqc_driver->module~mqc_io_helpers module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_io->module~mqc_io_helpers proc~merge_multi_molecule_json merge_multi_molecule_json proc~merge_multi_molecule_json->module~mqc_io_helpers proc~read_json_content read_json_content proc~read_json_content->module~mqc_io_helpers proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_io_helpers program~main main program~main->module~mqc_io_helpers program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private, save :: current_basename = \"\" character(len=256), private, save :: output_json_filename = \"results.json\" Functions public  function ends_with (str, suffix) Check if string ends with suffix Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix Return Value logical public  function get_basename () result(basename) Get the base name without “output_” prefix and “.json” suffix\nExample: “output_w1.json” -> “w1” Arguments None Return Value character(len=256) public  function get_molecule_name (filename) result(name) Extract molecule name from filename\nExample: “output_multi_structure_molecule_1.json” -> “molecule_1” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value character(len=256) public  function get_output_json_filename () result(filename) Get the current JSON output filename Arguments None Return Value character(len=256) Subroutines public  subroutine set_molecule_suffix (suffix) Append a suffix to the output filename (e.g., for multi-molecule mode)\nExample: suffix=”_mol1” -> “output_multi_structure_mol1.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: suffix public  subroutine set_output_json_filename (input_filename) Set the JSON output filename based on input filename\nExample: “water.mqc” -> “output_water.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_filename","tags":"","url":"module/mqc_io_helpers.html"},{"title":"mqc_mbe – metalquicha","text":"Implements hierarchical many-body expansion for fragment-based quantum chemistry\ncalculations with MPI parallelization and energy/gradient computation.\nMBE energy with optional gradient and hessian\nGMBE energy with optional gradient and hessian Uses mqc_mpi_tags mqc_frag_utils pic_logger mqc_vibrational_analysis pic_mpi_lib pic_timer pic_io mqc_physical_fragment mqc_mbe_io pic_types module~~mqc_mbe~~UsesGraph module~mqc_mbe mqc_mbe module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe->module~mqc_physical_fragment module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis pic_io pic_io module~mqc_mbe->pic_io pic_logger pic_logger module~mqc_mbe->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe->pic_mpi_lib pic_timer pic_timer module~mqc_mbe->pic_timer pic_types pic_types module~mqc_mbe->pic_types module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_result_types mqc_result_types module~mqc_mbe_io->module~mqc_result_types module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_geometry->pic_types module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mbe~~UsedByGraph module~mqc_mbe mqc_mbe module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function compute_mbe_delta (fragment_idx, fragment, lookup, energies, delta_energies, n) result(delta_E) Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas)\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all subset deltaE values\nAll subsets must have been computed already (guaranteed by processing fragments in order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Index of this fragment (already known) integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup Pre-built hash table for lookups real(kind=dp), intent(in) :: energies (:) Pre-computed delta values real(kind=dp), intent(in) :: delta_energies (:) Pre-computed delta values integer, intent(in) :: n Return Value real(kind=dp) Subroutines public  subroutine compute_gmbe (monomers, n_monomers, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, total_energy, sys_geom, total_gradient, total_hessian, bonds) Compute generalized many-body expansion (GMBE) energy with optional gradient and/or hessian Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers type( calculation_result_t ), intent(in) :: monomer_results (:) integer, intent(in) :: n_intersections type( calculation_result_t ), intent(in), optional :: intersection_results (:) integer, intent(in), optional :: intersection_sets (:,:) integer, intent(in), optional :: intersection_levels (:) real(kind=dp), intent(out) :: total_energy type( system_geometry_t ), intent(in), optional :: sys_geom real(kind=dp), intent(out), optional :: total_gradient (:,:) real(kind=dp), intent(out), optional :: total_hessian (:,:) type( bond_t ), intent(in), optional :: bonds (:) public  subroutine compute_mbe (polymers, fragment_count, max_level, results, total_energy, sys_geom, total_gradient, total_hessian, bonds) Compute many-body expansion (MBE) energy with optional gradient and/or hessian Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(out) :: total_energy type( system_geometry_t ), intent(in), optional :: sys_geom real(kind=dp), intent(out), optional :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(out), optional :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) private  subroutine build_mbe_lookup_table (polymers, fragment_count, max_level, lookup) Build hash table for fast fragment lookups Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( fragment_lookup_t ), intent(inout) :: lookup private  subroutine compute_mbe_gradient (fragment_idx, fragment, lookup, results, delta_gradients, n, sys_geom, bonds) Bottom-up computation of n-body gradient correction\nExactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs)\nAll gradients are in system coordinates, so subtraction is simple Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_gradients (:,:,:) (3, total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps private  subroutine compute_mbe_hessian (fragment_idx, fragment, lookup, results, delta_hessians, n, sys_geom, bonds) Bottom-up computation of n-body Hessian correction\nMirrors MBE gradient logic but for second derivatives Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_hessians (:,:,:) (3 total_atoms, 3 total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) private  subroutine get_monomer_atom_list (sys_geom, monomer_idx, atom_list, n_atoms) Build 0-indexed atom list for a monomer, handling fixed or variable-sized fragments. Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_idx integer, intent(out), allocatable :: atom_list (:) integer, intent(out) :: n_atoms private  subroutine map_fragment_to_system_gradient (frag_grad, monomers, sys_geom, sys_grad, bonds) Map fragment gradient to system gradient coordinates with hydrogen cap redistribution Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_grad (:,:) (3, natoms_frag) integer, intent(in) :: monomers (:) Monomer indices in fragment type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_grad (:,:) (3, total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps private  subroutine map_fragment_to_system_hessian (frag_hess, monomers, sys_geom, sys_hess, bonds) Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_hess (:,:) (3 natoms_frag, 3 natoms_frag) integer, intent(in) :: monomers (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_hess (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) private  subroutine print_gmbe_energy_breakdown (monomer_energy, n_monomers, level_energies, level_counts, max_level, total_energy, has_intersections) Print GMBE energy breakdown using inclusion-exclusion principle Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: monomer_energy integer, intent(in) :: n_monomers real(kind=dp), intent(in), optional :: level_energies (:) integer, intent(in), optional :: level_counts (:) integer, intent(in) :: max_level real(kind=dp), intent(in) :: total_energy logical, intent(in) :: has_intersections private  subroutine print_gmbe_gradient_info (total_gradient, sys_geom, current_log_level) Print GMBE gradient information Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_gradient (:,:) type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: current_log_level private  subroutine print_gmbe_intersection_debug (n_intersections, n_monomers, intersection_sets, intersection_levels, intersection_results) Print debug information about GMBE intersections Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_intersections integer, intent(in) :: n_monomers integer, intent(in) :: intersection_sets (:,:) integer, intent(in) :: intersection_levels (:) type( calculation_result_t ), intent(in) :: intersection_results (:) private  subroutine print_mbe_energy_breakdown (sum_by_level, max_level, total_energy) Print MBE energy breakdown to logger Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sum_by_level (:) integer, intent(in) :: max_level real(kind=dp), intent(in) :: total_energy private  subroutine print_mbe_gradient_info (total_gradient, sys_geom, current_log_level) Print MBE gradient information Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_gradient (:,:) type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: current_log_level private  subroutine process_intersection_derivatives (inter_idx, k, sign_factor, intersection_results, intersection_sets, sys_geom, total_gradient, total_hessian, bonds, compute_grad, compute_hess, hess_dim) Process derivatives for a single intersection fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: inter_idx integer, intent(in) :: k real(kind=dp), intent(in) :: sign_factor type( calculation_result_t ), intent(in) :: intersection_results (:) integer, intent(in) :: intersection_sets (:,:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: total_gradient (:,:) real(kind=dp), intent(inout), optional :: total_hessian (:,:) type( bond_t ), intent(in), optional :: bonds (:) logical, intent(in) :: compute_grad logical, intent(in) :: compute_hess integer, intent(in) :: hess_dim","tags":"","url":"module/mqc_mbe.html"},{"title":"mqc_driver – metalquicha","text":"Handles both fragmented (many-body expansion) and unfragmented calculations\nwith MPI parallelization and node-based work distribution.\nMain entry point for all calculations\nMulti-molecule calculation dispatcher Uses mqc_frag_utils pic_logger mqc_method_types mqc_config_parser mqc_result_types mqc_error mqc_mbe_fragment_distribution_scheme pic_mpi_lib mqc_json mqc_mbe pic_io mqc_physical_fragment mqc_io_helpers mqc_config_adapter omp_lib mqc_calc_types pic_types mqc_gmbe_fragment_distribution_scheme module~~mqc_driver~~UsesGraph module~mqc_driver mqc_driver module~mqc_calc_types mqc_calc_types module~mqc_driver->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_driver->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_driver->module~mqc_config_parser module~mqc_error mqc_error module~mqc_driver->module~mqc_error module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_io_helpers mqc_io_helpers module~mqc_driver->module~mqc_io_helpers module~mqc_json mqc_json module~mqc_driver->module~mqc_json module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_method_types mqc_method_types module~mqc_driver->module~mqc_method_types module~mqc_physical_fragment mqc_physical_fragment module~mqc_driver->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_driver->module~mqc_result_types omp_lib omp_lib module~mqc_driver->omp_lib pic_io pic_io module~mqc_driver->pic_io pic_logger pic_logger module~mqc_driver->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_driver->pic_mpi_lib pic_types pic_types module~mqc_driver->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_error module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->pic_io module~mqc_gmbe_fragment_distribution_scheme->pic_logger module~mqc_gmbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_gmbe_fragment_distribution_scheme->pic_types module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis pic_timer pic_timer module~mqc_gmbe_fragment_distribution_scheme->pic_timer module~mqc_json->pic_io module~mqc_json->pic_logger module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe->pic_timer module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme~2->omp_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_io module~mqc_mbe_fragment_distribution_scheme~2->pic_logger module~mqc_mbe_fragment_distribution_scheme~2->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mpi_tags pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme~2->pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme~2->pic_timer module~mqc_method_types->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_geometry->pic_types module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_mbe_io->module~mqc_io_helpers module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_types module~mqc_method_xtb->pic_timer mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_driver~~UsedByGraph module~mqc_driver mqc_driver proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine run_calculation (world_comm, node_comm, config, sys_geom, bonds, result_out) Main calculation dispatcher - routes to fragmented or unfragmented calculation Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator type( driver_config_t ), intent(in) :: config Driver configuration type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( calculation_result_t ), intent(out), optional :: result_out Optional result output public  subroutine run_multi_molecule_calculations (world_comm, node_comm, mqc_config) Run calculations for multiple molecules with MPI parallelization\nEach molecule is independent, so assign one molecule per rank Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm type( mqc_config_t ), intent(in) :: mqc_config private  subroutine run_fragmented_calculation (world_comm, node_comm, method, calc_type, sys_geom, max_level, allow_overlapping_fragments, max_intersection_level, bonds, driver_config) Handle fragmented calculation (nlevel > 0) Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator integer(kind=int32), intent(in) :: method Quantum chemistry method integer(kind=int32), intent(in) :: calc_type Calculation type type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info integer, intent(in) :: max_level Maximum fragment level for MBE logical, intent(in) :: allow_overlapping_fragments Use GMBE for overlapping fragments integer, intent(in) :: max_intersection_level Maximum k-way intersection depth for GMBE type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( driver_config_t ), intent(in) :: driver_config Driver configuration with cutoffs private  subroutine run_unfragmented_calculation (world_comm, sys_geom, method, calc_type, bonds, driver_config, result_out) Handle unfragmented calculation (nlevel=0) Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type( system_geometry_t ), intent(in) :: sys_geom Complete system geometry integer(kind=int32), intent(in) :: method Quantum chemistry method integer(kind=int32), intent(in) :: calc_type Calculation type type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( driver_config_t ), intent(in), optional :: driver_config Driver configuration type( calculation_result_t ), intent(out), optional :: result_out Optional result output","tags":"","url":"module/mqc_driver.html"},{"title":"mqc_json – metalquicha","text":"Uses pic_io pic_logger module~~mqc_json~~UsesGraph module~mqc_json mqc_json pic_io pic_io module~mqc_json->pic_io pic_logger pic_logger module~mqc_json->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_json~~UsedByGraph module~mqc_json mqc_json module~mqc_driver mqc_driver module~mqc_driver->module~mqc_json proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_json proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine merge_multi_molecule_json (individual_files, nmol) Merge individual molecule JSON files into a single combined file Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: individual_files (:) integer, intent(in) :: nmol private  subroutine read_json_content (unit_in, mol_index, unit_out, filename) Read and write JSON content from an individual molecule file\nProperly handles nested structures from fragmented calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit_in integer, intent(in) :: mol_index integer, intent(in) :: unit_out character(len=*), intent(in) :: filename","tags":"","url":"module/mqc_json.html"},{"title":"mqc_gmbe_fragment_distribution_scheme – metalquicha","text":"Implements fragment distribution schemes for GMBE calculations with overlapping fragments\nHandles both serial and MPI-parallelized distribution of monomers and intersection fragments\nPIE-based serial processor\nPIE-based MPI coordinator Uses mqc_mpi_tags pic_logger mqc_vibrational_analysis mqc_config_parser mqc_result_types mqc_mbe_fragment_distribution_scheme pic_mpi_lib pic_timer pic_io mqc_physical_fragment mqc_mbe_io mqc_calc_types pic_types module~~mqc_gmbe_fragment_distribution_scheme~~UsesGraph module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_calc_types mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_config_parser mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis pic_io pic_io module~mqc_gmbe_fragment_distribution_scheme->pic_io pic_logger pic_logger module~mqc_gmbe_fragment_distribution_scheme->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_gmbe_fragment_distribution_scheme->pic_mpi_lib pic_timer pic_timer module~mqc_gmbe_fragment_distribution_scheme->pic_timer pic_types pic_types module~mqc_gmbe_fragment_distribution_scheme->pic_types module~mqc_calc_types->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->pic_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme~2->pic_io module~mqc_mbe_fragment_distribution_scheme~2->pic_logger module~mqc_mbe_fragment_distribution_scheme~2->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_timer module~mqc_mbe_fragment_distribution_scheme~2->pic_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_types module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme~2->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme~2->pic_blas_interfaces module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_cgto->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_config_adapter->module~mqc_elements module~mqc_config_adapter->module~mqc_error module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_method_types->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calculation_keywords->pic_types module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_gmbe_fragment_distribution_scheme~~UsedByGraph module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine gmbe_pie_coordinator (world_comm, node_comm, pie_atom_sets, pie_coefficients, n_pie_terms, node_leader_ranks, num_nodes, sys_geom, method, calc_type, bonds) MPI coordinator for PIE-based GMBE calculations\nDistributes PIE terms across MPI ranks and accumulates results Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(in) :: n_pie_terms integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) public  subroutine serial_gmbe_pie_processor (pie_atom_sets, pie_coefficients, n_pie_terms, sys_geom, method, calc_type, bonds) Serial GMBE processor using PIE coefficients\nEvaluates each unique atom set once and sums with PIE coefficients\nSupports energy-only, energy+gradient, and energy+gradient+Hessian calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(in) :: n_pie_terms type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) private  subroutine send_pie_term_to_node (world_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to remote node coordinator Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank private  subroutine send_pie_term_to_worker (node_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to local worker Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank","tags":"","url":"module/mqc_gmbe_fragment_distribution_scheme.html"},{"title":"mqc_basis_utils – metalquicha","text":"Provides utilities for normalizing basis set names and locating basis set files Normalization rules:\n  * -> s   (e.g., 6-31G* -> 6-31Gs)\n  + -> p   (e.g., 6-31+G -> 6-31pG)\n  (d,p) -> dp (remove parentheses and commas) Uses mqc_error module~~mqc_basis_utils~~UsesGraph module~mqc_basis_utils mqc_basis_utils module~mqc_error mqc_error module~mqc_basis_utils->module~mqc_error Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_basis_utils~~UsedByGraph module~mqc_basis_utils mqc_basis_utils module~mqc_cli_parser mqc_cli_parser module~mqc_cli_parser->module~mqc_basis_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public pure function normalize_basis_name (basis_name) result(normalized) Normalize basis set name to filename-safe format Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name Return Value character(len=:), allocatable Subroutines public  subroutine find_basis_file (basis_name, filename, error) Find basis set file using normalized name Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name character(len=:), intent(out), allocatable :: filename type( error_t ), intent(out) :: error","tags":"","url":"module/mqc_basis_utils.html"},{"title":"mqc_basis_reader – metalquicha","text":"Gaussian basis set parser and molecular basis construction Provides utilities for parsing Gaussian-type orbital basis sets\nfrom text files and building molecular basis sets for quantum calculations.\nDetermine basis file line type\nParse basis for single element\nBuild complete molecular basis\nConvert angular momentum character to integer\nConvert angular momentum integer to character Uses pic_types mqc_error mqc_basis_file_reader mqc_cgto module~~mqc_basis_reader~~UsesGraph module~mqc_basis_reader mqc_basis_reader module~mqc_basis_file_reader mqc_basis_file_reader module~mqc_basis_reader->module~mqc_basis_file_reader module~mqc_cgto mqc_cgto module~mqc_basis_reader->module~mqc_cgto module~mqc_error mqc_error module~mqc_basis_reader->module~mqc_error pic_types pic_types module~mqc_basis_reader->pic_types module~mqc_basis_file_reader->pic_types module~mqc_cgto->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: LINE_ATOM = 1 Element specification line integer, public, parameter :: LINE_FUNCTION = 3 Basis function coefficient line integer, public, parameter :: LINE_SHELL = 2 Shell definition line integer, public, parameter :: LINE_UNKNOWN = 0 Unrecognized line type Functions public pure function ang_mom_char_to_int (ang_mom_char) result(ang_mom) Convert angular momentum character to integer Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ang_mom_char Angular momentum symbol Return Value integer Corresponding integer value public pure function ang_mom_int_to_char (ang_mom) result(ang_mom_char) Convert angular momentum integer to character Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ang_mom Angular momentum quantum number Return Value character(len=1) Corresponding symbol character public pure function classify_line (line) result(line_type) Classify a line from a gamess formatted basis set file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer private pure function is_blank_or_control (line) result(res) Check if a line is blank or a control line (starts with ‘$’) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical private pure function is_function_line (line) result(res) Check if a line is a function coefficient line (starts with a number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical private pure function is_shell_header (line) result(res) Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Subroutines public  subroutine build_molecular_basis (basis_string, element_names, mol_basis, error) Build molecular basis from geometry and basis file\nOnly parses unique elements, then copies basis data to atoms Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_names (:) Element for each atom in geometry order type( molecular_basis_type ), intent(out) :: mol_basis type( error_t ), intent(out) :: error public pure subroutine parse_element_basis (basis_string, element_name, atom_basis, error) Parse basis set for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(out) :: atom_basis type( error_t ), intent(out) :: error private pure subroutine copy_atomic_basis (source, dest) Deep copy of atomic basis data from source to dest Arguments Type Intent Optional Attributes Name type( atomic_basis_type ), intent(in) :: source type( atomic_basis_type ), intent(out) :: dest private pure subroutine count_shells_for_element (basis_string, element_name, nshells, error) Count the number of shells for a specific element in a GAMESS formatted basis string, Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name integer, intent(out) :: nshells type( error_t ), intent(out) :: error private pure subroutine fill_element_basis (basis_string, element_name, atom_basis, error) Fill in the shell data for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(inout) :: atom_basis type( error_t ), intent(out) :: error private pure subroutine find_unique_strings (input_array, unique_array, nunique) Find unique strings in an array\nReturns array of unique strings and count Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_array (:) character(len=:), intent(out), allocatable :: unique_array (:) integer, intent(out) :: nunique private pure subroutine get_next_line (string, line_start, line, line_end) Extract the next line from a string starting at line_start Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: line_start character(len=*), intent(out) :: line integer, intent(out) :: line_end private pure subroutine parse_function_line (line, func_num, exponent, coeff_s, coeff_p, has_p, stat) Parse function line (e.g., “1 1.0 2.0” or “1 1.0 2.0 3.0” for L shells) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(out) :: func_num real(kind=dp), intent(out) :: exponent real(kind=dp), intent(out) :: coeff_s real(kind=dp), intent(out), optional :: coeff_p logical, intent(out) :: has_p integer, intent(out) :: stat private pure subroutine parse_shell_header (line, ang_mom, nfunc, stat) Parse shell header line (e.g., “S 2” or “L 3”) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(out) :: ang_mom integer, intent(out) :: nfunc integer, intent(out) :: stat","tags":"","url":"module/mqc_basis_reader.html"},{"title":"mqc_xyz_reader – metalquicha","text":"Provides functions to parse standard XYZ format files containing\natomic coordinates and element symbols for molecular structures.\nRead XYZ file from disk\nParse XYZ data from string\nSplit text into lines (for testing) Uses mqc_geometry pic_types mqc_error module~~mqc_xyz_reader~~UsesGraph module~mqc_xyz_reader mqc_xyz_reader module~mqc_error mqc_error module~mqc_xyz_reader->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_xyz_reader->module~mqc_geometry pic_types pic_types module~mqc_xyz_reader->pic_types module~mqc_geometry->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_xyz_reader~~UsedByGraph module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_physical_fragment proc~apply_distance_screening->module~mqc_config_adapter proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 Maximum element symbol length Functions private pure function int_to_string (i) result(str) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Subroutines public  subroutine read_xyz_file (filename, geom, error) Read molecular geometry from XYZ format file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Path to XYZ file type( geometry_type ), intent(out) :: geom Parsed molecular geometry type( error_t ), intent(out) :: error Error handling public pure subroutine read_xyz_string (xyz_string, geom, error) Parse molecular geometry from XYZ format string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xyz_string type( geometry_type ), intent(out) :: geom type( error_t ), intent(out) :: error public pure subroutine split_lines (text, lines, nlines) Split input text into lines based on CR, LF, or CRLF line endings\nTrailing newlines do not create empty lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text character(len=:), intent(out), allocatable :: lines (:) integer, intent(out) :: nlines","tags":"","url":"module/mqc_xyz_reader.html"},{"title":"mqc_config_parser – metalquicha","text":"Parses section-based input files with %section…end blocks\nThis is the new format generated by mqc_prep.py\n========================================================================\nGeneric parsing helpers to eliminate redundancy\n======================================================================== Uses mqc_method_types mqc_error mqc_calc_types mqc_geometry pic_types module~~mqc_config_parser~~UsesGraph module~mqc_config_parser mqc_config_parser module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_config_parser~~UsedByGraph module~mqc_config_parser mqc_config_parser module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_config_adapter module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_driver->module~mqc_physical_fragment module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_physical_fragment->module~mqc_config_parser proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_config_parser proc~compute_gmbe->module~mqc_physical_fragment proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_config_parser proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_config_parser proc~process_intersection_derivatives->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_parser program~main->module~mqc_config_adapter program~main->module~mqc_driver program~main->module~mqc_physical_fragment module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~apply_distance_screening->module~mqc_physical_fragment proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_LINE_LEN = 1024 Derived Types type, public :: bond_t Bond definition with atom indices, order, and broken status Components Type Visibility Attributes Name Initial integer, public :: atom_i = 0 integer, public :: atom_j = 0 logical, public :: is_broken = .false. integer, public :: order = 1 type, public :: input_fragment_t Input fragment definition with charge, multiplicity, and atom indices\nThis is the parsed representation from the input file, not the computational fragment Components Type Visibility Attributes Name Initial integer, public :: charge = 0 integer, public, allocatable :: indices (:) Atom indices in this fragment integer, public :: multiplicity = 1 Type-Bound Procedures procedure, public :: destroy => input_fragment_destroy type, public :: molecule_t Single molecule definition with structure, geometry, fragments, and connectivity Components Type Visibility Attributes Name Initial type( bond_t ), public, allocatable :: bonds (:) integer, public :: charge = 0 type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry integer, public :: multiplicity = 1 character(len=:), public, allocatable :: name Optional molecule name integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 Type-Bound Procedures procedure, public :: destroy => molecule_destroy type, public :: mqc_config_t Complete configuration from .mqc file Components Type Visibility Attributes Name Initial real(kind=dp), public :: aimd_dt = 1.0_dp Timestep (femtoseconds) real(kind=dp), public :: aimd_initial_temperature = 300.0_dp Initial temperature for velocity init (K) integer, public :: aimd_nsteps = 0 Number of MD steps (0 = no AIMD) integer, public :: aimd_output_frequency = 1 Write output every N steps logical, public :: allow_overlapping_fragments = .false. character(len=:), public, allocatable :: aux_basis character(len=:), public, allocatable :: basis type( bond_t ), public, allocatable :: bonds (:) integer(kind=int32), public :: calc_type = CALC_TYPE_ENERGY integer, public :: charge = 0 character(len=:), public, allocatable :: cutoff_method character(len=:), public, allocatable :: distance_metric character(len=:), public, allocatable :: embedding integer, public :: frag_level = 1 character(len=:), public, allocatable :: frag_method MBE, etc. real(kind=dp), public, allocatable :: fragment_cutoffs (:) Distance cutoffs indexed by n-mer level (2=dimer, 3=trimer, etc.) type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry real(kind=dp), public :: hessian_displacement = 0.001_dp Finite difference displacement (Bohr) integer, public :: index_base = 0 0-based or 1-based indexing character(len=:), public, allocatable :: log_level integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method = METHOD_TYPE_GFN2 type( molecule_t ), public, allocatable :: molecules (:) Array of molecules (if nmol > 0) integer, public :: multiplicity = 1 integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 integer, public :: nmol = 0 Number of molecules (0 = single molecule mode for backward compatibility) integer, public :: scf_maxiter = 300 real(kind=dp), public :: scf_tolerance = 1.0e-6_dp character(len=:), public, allocatable :: schema_name character(len=:), public, allocatable :: schema_version character(len=:), public, allocatable :: units angstrom or bohr Type-Bound Procedures procedure, public :: destroy => config_destroy Functions private  function parse_method_string (method_str) result(method_type) Parse method string from input file (e.g., “XTB-GFN1” -> gfn1) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Return Value integer(kind=int32) private pure function strip_comment (line) result(stripped) Remove comments (! or #) from a line and trim result Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value character(len=:), allocatable Subroutines public  subroutine read_mqc_file (filename, config, error) Read and parse a .mqc format input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( mqc_config_t ), intent(out) :: config type( error_t ), intent(out) :: error private  subroutine config_destroy (this) Clean up allocated memory in mqc_config_t Arguments Type Intent Optional Attributes Name class( mqc_config_t ), intent(inout) :: this private  subroutine input_fragment_destroy (this) Clean up allocated memory in input_fragment_t Arguments Type Intent Optional Attributes Name class( input_fragment_t ), intent(inout) :: this private  subroutine molecule_destroy (this) Clean up allocated memory in molecule_t Arguments Type Intent Optional Attributes Name class( molecule_t ), intent(inout) :: this private  subroutine parse_aimd_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_connectivity_generic (unit, nbonds, nbroken, bonds, error) Generic parser for %connectivity section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nbonds integer, intent(inout) :: nbroken type( bond_t ), intent(inout), allocatable :: bonds (:) type( error_t ), intent(out) :: error private  subroutine parse_connectivity_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_driver_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_fragment (unit, fragment, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error private  subroutine parse_fragmentation_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_fragments_generic (unit, nfrag, fragments, error) Generic parser for %fragments section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nfrag type( input_fragment_t ), intent(inout), allocatable :: fragments (:) type( error_t ), intent(out) :: error private  subroutine parse_fragments_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_geometry_generic (unit, geom, error) Generic parser for %geometry section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( geometry_type ), intent(inout) :: geom type( error_t ), intent(out) :: error private  subroutine parse_geometry_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_hessian_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_indices_line (line, fragment, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error private  subroutine parse_model_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_molecule_connectivity (unit, mol, error) Parse %connectivity section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecule_fragments (unit, mol, error) Parse %fragments section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecule_geometry (unit, mol, error) Parse %geometry section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecule_structure (unit, mol, error) Parse %structure section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecules_section (unit, config, error) Parse %molecules section containing multiple %molecule blocks Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_scf_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_schema_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_single_molecule (unit, mol, error) Parse a single %molecule block with its sections Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_structure_generic (unit, charge, multiplicity, error) Generic parser for %structure section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: charge integer, intent(inout) :: multiplicity type( error_t ), intent(out) :: error private  subroutine parse_structure_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_system_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine skip_to_end (unit, error) Skip lines until ‘end’ marker is found Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( error_t ), intent(out) :: error private  subroutine validate_cutoffs (config, error) Validate that fragment cutoffs are monotonically decreasing\nFor n-mer level N, cutoff(N) must be <= cutoff(N-1) Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: config type( error_t ), intent(out) :: error","tags":"","url":"module/mqc_config_parser.html"},{"title":"mqc_libcint_interface – metalquicha","text":"Provides Fortran interface to the Libcint library for integral calculations","tags":"","url":"module/mqc_libcint_interface.html"},{"title":"mqc_calculation_interface – metalquicha","text":"Provides a clean interface for computing energies and forces\nthat can be used by optimization algorithms, MD integrators, and MC samplers Uses pic_logger mqc_config_parser mqc_result_types pic_mpi_lib mqc_physical_fragment mqc_calc_types pic_types module~~mqc_calculation_interface~~UsesGraph module~mqc_calculation_interface mqc_calculation_interface module~mqc_calc_types mqc_calc_types module~mqc_calculation_interface->module~mqc_calc_types module~mqc_config_parser mqc_config_parser module~mqc_calculation_interface->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_calculation_interface->module~mqc_result_types pic_logger pic_logger module~mqc_calculation_interface->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_calculation_interface->pic_mpi_lib pic_types pic_types module~mqc_calculation_interface->pic_types module~mqc_calc_types->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->pic_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine compute_energy_and_forces (sys_geom, driver_config, world_comm, node_comm, energy, gradient, hessian, bonds) Compute energy and forces for current geometry\nThis is the main interface for optimization/dynamics codes Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(inout) :: sys_geom type( driver_config_t ), intent(in) :: driver_config type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm real(kind=dp), intent(out) :: energy real(kind=dp), intent(out), optional :: gradient (:,:) (3, total_atoms) real(kind=dp), intent(out), optional :: hessian (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) public  subroutine sync_geometry_to_workers (sys_geom, comm) Synchronize geometry coordinates from master rank to all worker ranks\nThis is needed when master rank updates coordinates for optimization/dynamics Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(inout) :: sys_geom type(comm_t), intent(in) :: comm","tags":"","url":"module/mqc_calculation_interface.html"},{"title":"mqc_mbe_io – metalquicha","text":"Uses pic_logger mqc_result_types pic_io mqc_physical_fragment mqc_io_helpers mqc_elements pic_types module~~mqc_mbe_io~~UsesGraph module~mqc_mbe_io mqc_mbe_io module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_mbe_io->module~mqc_result_types pic_io pic_io module~mqc_mbe_io->pic_io pic_logger pic_logger module~mqc_mbe_io->pic_logger pic_types pic_types module~mqc_mbe_io->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mbe_io~~UsedByGraph module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_driver mqc_driver module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function get_frag_level_name (frag_level) result(level_name) Map body level (n-mer) to descriptive name\nSupports up to decamers (10-mers), then falls back to “N-mers” format Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag_level Return Value character(len=32) Subroutines public  subroutine print_detailed_breakdown (polymers, fragment_count, max_level, energies, delta_energies) Print detailed energy breakdown for each fragment\nShows full energy and deltaE correction for all monomers, dimers, trimers, etc.\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) public  subroutine print_detailed_breakdown_json (polymers, fragment_count, max_level, energies, delta_energies, sum_by_level, total_energy, total_gradient, total_hessian, results) Write detailed energy breakdown to results.json file\nOutputs structured JSON with all fragment energies and deltaE corrections\nOptionally includes total gradient and Hessian if provided\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) real(kind=dp), intent(in) :: sum_by_level (:) real(kind=dp), intent(in) :: total_energy real(kind=dp), intent(in), optional :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(in), optional :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) type( calculation_result_t ), intent(in), optional :: results (:) Fragment results with distance info public  subroutine print_fragment_xyz (fragment_idx, phys_frag) Print fragment geometry in XYZ format Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx type( physical_fragment_t ), intent(in) :: phys_frag public  subroutine print_gmbe_json (n_monomers, monomer_indices, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, total_energy) Write GMBE calculation results to output JSON file\nOutputs structured JSON with monomers, intersections, and total energy\nIntersection parameters are optional and should be omitted when n_intersections=0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_monomers integer, intent(in) :: monomer_indices (:) type( calculation_result_t ), intent(in) :: monomer_results (:) integer, intent(in) :: n_intersections type( calculation_result_t ), intent(in), optional :: intersection_results (:) integer, intent(in), optional :: intersection_sets (:,:) (n_monomers, n_intersections) integer, intent(in), optional :: intersection_levels (:) real(kind=dp), intent(in) :: total_energy public  subroutine print_gmbe_pie_json (pie_atom_sets, pie_coefficients, pie_energies, n_pie_terms, total_energy, total_gradient, total_hessian) Write GMBE PIE calculation results to output JSON file\nOutputs structured JSON with PIE terms (atom sets with coefficients and energies)\nOptionally includes total gradient and Hessian norms Arguments Type Intent Optional Attributes Name integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term real(kind=dp), intent(in) :: pie_energies (:) Raw energy for each term integer(kind=int64), intent(in) :: n_pie_terms real(kind=dp), intent(in) :: total_energy real(kind=dp), intent(in), optional :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(in), optional :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) public  subroutine print_unfragmented_json (result) Write unfragmented calculation results to output JSON file\nOutputs structured JSON with energy and optionally gradient Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result","tags":"","url":"module/mqc_mbe_io.html"},{"title":"mqc_physical_fragment – metalquicha","text":"Physical molecular fragment representation and geometry handling Provides data structures and utilities for managing molecular fragments\nwith atomic coordinates, electronic properties, and geometric operations.\nSingle molecular fragment type\nComplete system geometry type\nSystem geometry initialization\nExtract fragment from system\nBuild fragment from explicit atom indices (for intersections)\nValidate fragment has no overlapping atoms Redistribute hydrogen cap gradients to original atoms\nRedistribute hydrogen cap Hessian to original atoms\nUnit conversion utilities\nCalculate minimal distance between monomers in a fragment Uses mqc_config_parser mqc_error mqc_cgto mqc_xyz_reader mqc_elements mqc_geometry pic_types module~~mqc_physical_fragment~~UsesGraph module~mqc_physical_fragment mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_physical_fragment~~UsedByGraph module~mqc_physical_fragment mqc_physical_fragment module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_physical_fragment proc~apply_distance_screening->module~mqc_config_adapter proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: bohr_radius = 0.52917721092_dp Bohr radius in Ångström Derived Types type, public :: physical_fragment_t Physical molecular fragment with atomic coordinates and properties Read more… Components Type Visibility Attributes Name Initial type( molecular_basis_type ), public, allocatable :: basis Gaussian basis functions integer, public, allocatable :: cap_replaces_atom (:) Original atom index that each cap replaces (size: n_caps) integer, public :: charge = 0 Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) Cartesian coordinates (3, n_atoms) in Bohr real(kind=dp), public :: distance = 0.0_dp Minimal atomic distance between monomers in fragment (Angstrom, 0 for monomers) integer, public, allocatable :: element_numbers (:) Atomic numbers (Z values) integer, public, allocatable :: local_to_global (:) Map fragment atom index to system atom index (size: n_atoms - n_caps) integer, public :: multiplicity = 1 Spin multiplicity (2S+1) integer, public :: n_atoms Number of atoms in this fragment integer, public :: n_caps = 0 Number of hydrogen caps added (always at end of atom list) integer, public :: nelec = 0 Total number of electrons Type-Bound Procedures procedure, public :: compute_nelec => fragment_compute_nelec Calculate electron count procedure, public :: destroy => fragment_destroy Memory cleanup procedure, public :: set_basis => fragment_set_basis Assign basis set type, public :: system_geometry_t Complete molecular system geometry for fragment-based calculations Read more… Components Type Visibility Attributes Name Initial integer, public :: atoms_per_monomer Atoms in each monomer (0 if variable-sized) integer, public :: charge Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) All coordinates (3, total_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers for all atoms integer, public, allocatable :: fragment_atoms (:,:) Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer, public, allocatable :: fragment_charges (:) Charge for each fragment (n_monomers) integer, public, allocatable :: fragment_multiplicities (:) Multiplicity for each fragment (n_monomers) integer, public, allocatable :: fragment_sizes (:) Number of atoms in each fragment (n_monomers) integer, public :: multiplicity Spin multiplicity (2S+1) integer, public :: n_monomers Number of monomer units in system integer, public :: total_atoms Total number of atoms Type-Bound Procedures procedure, public :: destroy => system_destroy Memory cleanup Functions public pure function calculate_monomer_distance (sys_geom, monomer_indices) result(min_distance) Calculate minimal atomic distance between monomers in a fragment\nFor single monomer (size 1), returns 0.0\nFor multi-monomer fragments, returns minimal distance between atoms in different monomers\nResult is in Angstrom Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) Return Value real(kind=dp) public pure elemental function to_angstrom (bohr_value) result(angstrom_value) Convert coordinate from Bohr to Angstrom Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: bohr_value Return Value real(kind=dp) public pure elemental function to_bohr (angstrom_value) result(bohr_value) Convert coordinate from Angstrom to Bohr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: angstrom_value Return Value real(kind=dp) Subroutines public  subroutine build_fragment_from_atom_list (sys_geom, atom_indices, n_atoms, fragment, error, bonds) Build a fragment from explicit atom list (for GMBE intersection fragments) Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: atom_indices (:) 0-indexed atom indices integer, intent(in) :: n_atoms Number of atoms in list type( physical_fragment_t ), intent(out) :: fragment type( error_t ), intent(out) :: error type( bond_t ), intent(in), optional :: bonds (:) Connectivity for capping public  subroutine build_fragment_from_indices (sys_geom, monomer_indices, fragment, error, bonds) Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) type( physical_fragment_t ), intent(out) :: fragment type( error_t ), intent(out) :: error type( bond_t ), intent(in), optional :: bonds (:) Connectivity information for capping public  subroutine check_duplicate_atoms (fragment, error) Validate that fragment has no spatially overlapping atoms\nChecks if any two atoms are too close together (< 0.01 Bohr)\nThis catches bugs in geometry construction or fragment building Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment type( error_t ), intent(out) :: error public  subroutine initialize_system_geometry (full_geom_file, monomer_file, sys_geom, error) Read full geometry and monomer template, initialize system_geometry_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full_geom_file character(len=*), intent(in) :: monomer_file type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error public  subroutine redistribute_cap_gradients (fragment, fragment_gradient, system_gradient) Redistribute hydrogen cap gradients to original atoms Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_gradient (:,:) (3, n_atoms_fragment) real(kind=dp), intent(inout) :: system_gradient (:,:) (3, n_atoms_system) public  subroutine redistribute_cap_hessian (fragment, fragment_hessian, system_hessian) Redistribute hydrogen cap Hessian to original atoms Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_hessian (:,:) (3 n_atoms_fragment, 3 n_atoms_fragment) real(kind=dp), intent(inout) :: system_hessian (:,:) (3 n_atoms_system, 3 n_atoms_system) private  subroutine add_hydrogen_caps (atoms_in_fragment, bonds, sys_geom, fragment, base_atom_count) Add hydrogen caps to fragment for broken bonds\nCaps are placed at the position of the atom outside the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in) :: bonds (:) type( system_geometry_t ), intent(in) :: sys_geom type( physical_fragment_t ), intent(inout) :: fragment integer, intent(in) :: base_atom_count Number of non-cap atoms private  subroutine count_hydrogen_caps (atoms_in_fragment, bonds, n_caps) Count how many hydrogen caps are needed for a fragment\nA cap is needed when exactly one atom of a broken bond is in the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in), optional :: bonds (:) integer, intent(out) :: n_caps private  subroutine fragment_compute_nelec (this) Compute number of electrons from atomic numbers and charge Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this private  subroutine fragment_destroy (this) Clean up allocated memory in physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this private  subroutine fragment_set_basis (this, basis) Set the basis set for this fragment Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis private  subroutine system_destroy (this) Clean up allocated memory in system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this","tags":"","url":"module/mqc_physical_fragment.html"},{"title":"mqc_combinatorics – metalquicha","text":"Provides pure combinatorial functions for generating molecular fragments\nincluding binomial coefficients, combinations, and fragment counting\nBinomial coefficient calculation\nCalculate total number of fragments\nGenerate sequential monomer indices\nGenerate all fragments up to max level\nGenerate all combinations of size r\nGenerate next combination in sequence\nInitialize combination to [1,2,…,k]\nGenerate next combination (alternate interface)\nDebug utility to print combinations\nCalculate minimal distances for all fragments Uses pic_types module~~mqc_combinatorics~~UsesGraph module~mqc_combinatorics mqc_combinatorics pic_types pic_types module~mqc_combinatorics->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_combinatorics~~UsedByGraph module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils mqc_frag_utils module~mqc_frag_utils->module~mqc_combinatorics module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_gmbe_utils proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_gmbe_utils module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public pure function binomial (n, r) result(c) Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) Read more… Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n Total number of items integer(kind=default_int), intent(in) :: r Number of items to choose Return Value integer(kind=int64) Binomial coefficient result public pure function get_nfrags (n_monomers, max_level) result(n_expected_fragments) Calculate total number of fragments for given system size and max level Read more… Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n_monomers Number of monomers in system integer(kind=default_int), intent(in) :: max_level Maximum fragment size Return Value integer(kind=int64) Total fragment count public  function next_combination (combination, k, n) result(has_next) Generate next combination in lexicographic order\nReturns .true. if there’s a next combination, .false. if we’ve exhausted all Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k integer, intent(in) :: n Return Value logical Subroutines public  subroutine calculate_fragment_distances (polymers, fragment_count, sys_geom, distances) Calculate minimal atomic distance for each fragment\nFor monomers (1-body), distance is 0.0\nFor n-mers (n >= 2), distance is the minimum distance between atoms\nin different constituent monomers Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: distances (:) public recursive subroutine combine (arr, n, r, out_array, count) Generate all combinations of size r from array arr of size n\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count public pure subroutine create_monomer_list (monomers) Generate a list of monomer indices from 1 to N Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(inout), allocatable :: monomers (:) public recursive subroutine generate_fragment_list (monomers, max_level, polymers, count) Generate all possible fragments (combinations of monomers) up to max_level\nUses int64 for count to handle large numbers of fragments that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: monomers (:) integer(kind=default_int), intent(in) :: max_level integer(kind=default_int), intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: count public pure subroutine get_next_combination (indices, k, n, has_next) Generate next combination (updates indices in place)\nhas_next = .true. if there’s a next combination Arguments Type Intent Optional Attributes Name integer, intent(inout) :: indices (:) integer, intent(in) :: k integer, intent(in) :: n logical, intent(out) :: has_next public  subroutine next_combination_init (combination, k) Initialize combination to [1, 2, …, k] Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k public  subroutine print_combos (out_array, count, max_len) Print combinations stored in out_array\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: out_array (:,:) integer(kind=int64), intent(in) :: count integer(kind=default_int), intent(in) :: max_len private recursive subroutine combine_util (arr, n, r, index, data, i, out_array, count) Utility for generating combinations recursively\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(in) :: index integer(kind=default_int), intent(inout) :: data (:) integer(kind=default_int), intent(in) :: i integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count","tags":"","url":"module/mqc_combinatorics.html"},{"title":"mqc_geometry – metalquicha","text":"Defines the geometry data structure for molecular systems Uses pic_types module~~mqc_geometry~~UsesGraph module~mqc_geometry mqc_geometry pic_types pic_types module~mqc_geometry->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_geometry~~UsedByGraph module~mqc_geometry mqc_geometry module~mqc_config_parser mqc_config_parser module~mqc_config_parser->module~mqc_geometry module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_fragment->module~mqc_config_parser module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_xyz_reader->module~mqc_geometry proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~geometry_to_system_unfragmented->module~mqc_geometry proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_geometry proc~initialize_fragmented_system->module~mqc_config_parser module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_config_parser module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_physical_fragment proc~apply_distance_screening->module~mqc_config_adapter proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_config_parser proc~compute_gmbe->module~mqc_physical_fragment proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_config_parser proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_config_parser proc~process_intersection_derivatives->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_config_parser program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 Derived Types type, public :: geometry_type Molecular geometry data structure Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: comment real(kind=dp), public, allocatable :: coords (:,:) character(len=:), public, allocatable :: elements (:) integer, public :: natoms Type-Bound Procedures procedure, public :: destroy => geometry_destroy Subroutines private  subroutine geometry_destroy (this) Clean up allocated memory in geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this","tags":"","url":"module/mqc_geometry.html"},{"title":"mqc_cli_parser – metalquicha","text":"Handles parsing of command line options including geometry files,\nbasis set specifications, and help/usage display.\nParsed command line arguments container\nMain argument parsing routine\nDisplay program usage information\nStandardize basis set names\nLocate basis set files Uses mqc_basis_utils mqc_error module~~mqc_cli_parser~~UsesGraph module~mqc_cli_parser mqc_cli_parser module~mqc_basis_utils mqc_basis_utils module~mqc_cli_parser->module~mqc_basis_utils module~mqc_error mqc_error module~mqc_cli_parser->module~mqc_error module~mqc_basis_utils->module~mqc_error Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: cli_args_type Container for parsed command line arguments Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: basis_name Basis set name (e.g., “6-31G”) character(len=:), public, allocatable :: xyz_file Input XYZ geometry file path Type-Bound Procedures procedure, public :: destroy => cli_args_destroy Memory cleanup Subroutines public  subroutine parse_command_line (args, error) Parse command line arguments for geometry file and basis set Read more… Arguments Type Intent Optional Attributes Name type( cli_args_type ), intent(out) :: args Parsed argument container type( error_t ), intent(out) :: error Error object public  subroutine print_usage () Print usage information Arguments None private  subroutine cli_args_destroy (this) Clean up CLI args Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this","tags":"","url":"module/mqc_cli_parser.html"},{"title":"mqc_fragment_lookup – metalquicha","text":"Provides O(1) hash table for mapping monomer combinations to fragment indices\nHash-based lookup table type Uses pic_types pic_hash_32bit pic_sorting module~~mqc_fragment_lookup~~UsesGraph module~mqc_fragment_lookup mqc_fragment_lookup pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting pic_types pic_types module~mqc_fragment_lookup->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_fragment_lookup~~UsedByGraph module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils mqc_frag_utils module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: fragment_lookup_t Hash-based lookup table for O(1) fragment index retrieval Components Type Visibility Attributes Name Initial logical, public :: initialized = .false. integer(kind=int64), public :: n_entries = 0 type( hash_entry_t ), public, allocatable :: table (:) integer, public :: table_size = 0 Type-Bound Procedures procedure, public :: destroy => fragment_lookup_destroy procedure, public :: find => fragment_lookup_find procedure, public :: init => fragment_lookup_init procedure, public :: insert => fragment_lookup_insert type, private :: hash_entry_t Single entry in hash table (private helper type) Components Type Visibility Attributes Name Initial integer, public, allocatable :: key (:) Sorted monomer indices type( hash_entry_t ), public, pointer :: next => null() Chain for collisions integer(kind=int64), public :: value Fragment index Functions private pure function arrays_equal_internal (a, b, n) result(equal) Check if two arrays are equal Arguments Type Intent Optional Attributes Name integer, intent(in) :: a (:) integer, intent(in) :: b (:) integer, intent(in) :: n Return Value logical private  function fragment_lookup_find (this, monomers, n) result(idx) Find fragment index for given monomer combination Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) private pure function next_prime_internal (n) result(p) Find next prime number >= n (simple implementation) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer Subroutines private pure subroutine fragment_lookup_destroy (this) Clean up hash table and all chains Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this private pure subroutine fragment_lookup_init (this, estimated_entries) Initialize hash table with estimated size Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries private  subroutine fragment_lookup_insert (this, monomers, n, fragment_idx) Insert a monomer combination -> fragment index mapping Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx","tags":"","url":"module/mqc_fragment_lookup.html"},{"title":"mqc_calc_types – metalquicha","text":"Defines integer constants for calculation types to avoid string comparisons\nthroughout the codebase. Provides conversion utilities between string\nrepresentations and integer constants. Uses pic_types module~~mqc_calc_types~~UsesGraph module~mqc_calc_types mqc_calc_types pic_types pic_types module~mqc_calc_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_calc_types~~UsedByGraph module~mqc_calc_types mqc_calc_types module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_calc_types module~mqc_config_parser mqc_config_parser module~mqc_calculation_interface->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_parser->module~mqc_calc_types module~mqc_driver mqc_driver module~mqc_driver->module~mqc_calc_types module~mqc_driver->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_config_adapter mqc_config_adapter module~mqc_driver->module~mqc_config_adapter module~mqc_driver->module~mqc_physical_fragment module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_calc_types proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_calc_types proc~serial_gmbe_pie_processor->module~mqc_physical_fragment module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_physical_fragment->module~mqc_config_parser module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_config_parser proc~compute_gmbe->module~mqc_physical_fragment proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_config_parser proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_config_parser proc~process_intersection_derivatives->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_parser program~main->module~mqc_driver program~main->module~mqc_config_adapter program~main->module~mqc_physical_fragment module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~apply_distance_screening->module~mqc_physical_fragment proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: CALC_TYPE_ENERGY = 1 integer(kind=int32), public, parameter :: CALC_TYPE_GRADIENT = 2 integer(kind=int32), public, parameter :: CALC_TYPE_HESSIAN = 3 integer(kind=int32), public, parameter :: CALC_TYPE_UNKNOWN = 0 Functions public pure function calc_type_from_string (calc_type_str) result(calc_type) Convert calculation type string to integer constant Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: calc_type_str Input string (e.g., “energy”, “gradient”) Return Value integer(kind=int32) Output integer constant public pure function calc_type_to_string (calc_type) result(calc_type_str) Convert calculation type integer constant to string Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: calc_type Input integer constant Return Value character(len=:), allocatable Output string representation","tags":"","url":"module/mqc_calc_types.html"},{"title":"mqc_cgto – metalquicha","text":"Defines data structures for cartesian contracted Gaussian type orbitals (CGTOs) Uses pic_types module~~mqc_cgto~~UsesGraph module~mqc_cgto mqc_cgto pic_types pic_types module~mqc_cgto->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_cgto~~UsedByGraph module~mqc_cgto mqc_cgto module~mqc_basis_reader mqc_basis_reader module~mqc_basis_reader->module~mqc_cgto module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_cgto module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_physical_fragment proc~apply_distance_screening->module~mqc_config_adapter proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: atomic_basis_type Atomic basis set data structure Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: element element symbol integer, public :: nshells number of shells in type type( cgto_type ), public, allocatable :: shells (:) array of contracted shells Type-Bound Procedures procedure, public :: allocate_shells => allocate_basis_shells procedure, public :: destroy => atomic_basis_destroy procedure, public :: num_basis_functions => atomic_basis_num_basis_functions type, public :: cgto_type Contracted Gaussian type orbital (CGTO) data structure Components Type Visibility Attributes Name Initial integer, public :: ang_mom Angular momentum quantum number (0=s, 1=p, 2=d, etc.) real(kind=dp), public, allocatable :: coefficients (:) Contraction coefficients real(kind=dp), public, allocatable :: exponents (:) Exponents (alpha values) integer, public :: nfunc Number of primitive Gaussians in the contraction Type-Bound Procedures procedure, public :: allocate_arrays => cgto_allocate_arrays procedure, public :: destroy => cgto_destroy procedure, public :: num_basis_functions => cgto_num_basis_functions type, public :: molecular_basis_type Molecular basis set data structure (assembled basis) Components Type Visibility Attributes Name Initial type( atomic_basis_type ), public, allocatable :: elements (:) array of atomic basis types integer, public :: nelements total number of atoms/elements in a molecule Type-Bound Procedures procedure, public :: allocate_elements => basis_set_allocate_elements procedure, public :: destroy => basis_set_destroy procedure, public :: num_basis_functions => molecular_basis_num_basis_functions Functions private pure function atomic_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for an atom Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer private pure function cgto_num_basis_functions (self) result(nbf) Get number of basis functions in a shell (Cartesian) Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer private pure function molecular_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for the molecule Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Subroutines private pure subroutine allocate_basis_shells (self, nshells) Allocate array of shells in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells private pure subroutine atomic_basis_destroy (self) Clean up allocated memory in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self private pure subroutine basis_set_allocate_elements (self, nelements) Allocate array of atomic basis elements in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements private pure subroutine basis_set_destroy (self) Clean up allocated memory in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self private pure subroutine cgto_allocate_arrays (self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc private pure subroutine cgto_destroy (self) Clean up allocated memory in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self","tags":"","url":"module/mqc_cgto.html"},{"title":"mqc_method_hf – metalquicha","text":"Implements the Hartree-Fock quantum chemistry method\nProvides energy and gradient calculations using a basic SCF procedure. Uses mqc_method_base pic_types mqc_result_types mqc_physical_fragment module~~mqc_method_hf~~UsesGraph module~mqc_method_hf mqc_method_hf module~mqc_method_base mqc_method_base module~mqc_method_hf->module~mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_hf->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_hf->module~mqc_result_types pic_types pic_types module~mqc_method_hf->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( qc_method_t ) :: hf_method_t Hartree-Fock method implementation Components Type Visibility Attributes Name Initial type( hf_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => hf_calc_energy procedure, public :: calc_gradient => hf_calc_gradient procedure, public :: calc_hessian => null_hessian Placeholder for Hessian calculation type, public :: hf_options_t Hartree-Fock calculation options Components Type Visibility Attributes Name Initial real(kind=dp), public :: conv_tol = 1.0e-8_dp Energy convergence threshold integer, public :: max_iter = 100 Maximum SCF iterations logical, public :: spherical = .false. Use spherical (true) or Cartesian (false) basis logical, public :: verbose = .true. Print SCF iterations Subroutines private  subroutine hf_calc_energy (this, fragment, result) Calculate electronic energy using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine hf_calc_gradient (this, fragment, result) Calculate energy gradient using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine null_hessian (this, fragment, result) Placeholder for Hessian calculation Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result","tags":"","url":"module/mqc_method_hf.html"},{"title":"mqc_vibrational_analysis – metalquicha","text":"Computes vibrational frequencies from the mass-weighted Hessian matrix.\nUses LAPACK eigenvalue decomposition via pic-blas interfaces. Uses mqc_elements pic_logger pic_types pic_lapack_interfaces module~~mqc_vibrational_analysis~~UsesGraph module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_elements mqc_elements module~mqc_vibrational_analysis->module~mqc_elements pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces pic_logger pic_logger module~mqc_vibrational_analysis->pic_logger pic_types pic_types module~mqc_vibrational_analysis->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_vibrational_analysis~~UsedByGraph module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->module~mqc_vibrational_analysis module~mqc_driver mqc_driver module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: AU_TO_CM1 = 2.642461e7_dp real(kind=dp), private, parameter :: AU_TO_MDYNE_ANG = 15.569141_dp Subroutines public  subroutine compute_cartesian_displacements (eigenvectors, element_numbers, cartesian_displacements, normalize_max) Convert mass-weighted eigenvectors to Cartesian displacements. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvectors (:,:) Mass-weighted eigenvectors (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N), columns are modes logical, intent(in), optional :: normalize_max If true, normalize so max displacement = 1 (default: true) public  subroutine compute_force_constants (eigenvalues, reduced_masses, force_constants, force_constants_mdyne) Compute force constants for each normal mode. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvalues (:) Eigenvalues from mass-weighted Hessian diagonalization (1/amu) real(kind=dp), intent(in) :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(out), allocatable :: force_constants (:) Force constants in atomic units (Hartree/Bohr²) real(kind=dp), intent(out), optional, allocatable :: force_constants_mdyne (:) Force constants in mdyne/Å (common experimental unit) public  subroutine compute_reduced_masses (eigenvectors, element_numbers, reduced_masses) Compute reduced masses for each normal mode. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvectors (:,:) Mass-weighted eigenvectors from diagonalization (3 N x 3 N)\nColumns are normal modes, assumed normalized (Σ_i L²_{i,k} = 1) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: reduced_masses (:) Reduced masses in amu (one per mode) public  subroutine compute_vibrational_analysis (hessian, element_numbers, frequencies, reduced_masses, force_constants, cartesian_displacements, eigenvalues_out, eigenvectors_out, coordinates, project_trans_rot, force_constants_mdyne) Perform complete vibrational analysis from Hessian matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Hessian matrix in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: frequencies (:) Vibrational frequencies in cm⁻¹ real(kind=dp), intent(out), allocatable :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(out), allocatable :: force_constants (:) Force constants in Hartree/Bohr² real(kind=dp), intent(out), allocatable :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N) real(kind=dp), intent(out), optional, allocatable :: eigenvalues_out (:) Raw eigenvalues from diagonalization real(kind=dp), intent(out), optional, allocatable :: eigenvectors_out (:,:) Mass-weighted eigenvectors real(kind=dp), intent(in), optional :: coordinates (:,:) Atomic coordinates in Bohr (3, N) - required for projection logical, intent(in), optional :: project_trans_rot If true, project out translation/rotation modes real(kind=dp), intent(out), optional, allocatable :: force_constants_mdyne (:) Force constants in mdyne/Å public  subroutine compute_vibrational_frequencies (hessian, element_numbers, frequencies, eigenvalues_out, eigenvectors, coordinates, project_trans_rot, projected_hessian_out) Compute vibrational frequencies from the Hessian matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Hessian matrix in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: frequencies (:) Vibrational frequencies in cm⁻¹ (3 N modes, or 3 N-6 if projected) real(kind=dp), intent(out), optional, allocatable :: eigenvalues_out (:) Raw eigenvalues from diagonalization (Hartree/Bohr²/amu) real(kind=dp), intent(out), optional, allocatable :: eigenvectors (:,:) Normal mode eigenvectors (3 N x 3 N), columns are modes real(kind=dp), intent(in), optional :: coordinates (:,:) Atomic coordinates in Bohr (3, N) - required for projection logical, intent(in), optional :: project_trans_rot If true, project out translation/rotation modes (requires coordinates) real(kind=dp), intent(out), optional, allocatable :: projected_hessian_out (:,:) Mass-weighted Hessian after trans/rot projection (before diagonalization) public  subroutine mass_weight_hessian (hessian, element_numbers, mw_hessian) Apply mass weighting to Hessian matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Input Hessian in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: mw_hessian (:,:) Mass-weighted Hessian (3 N x 3 N) public  subroutine print_vibrational_analysis (frequencies, reduced_masses, force_constants, cartesian_displacements, element_numbers, force_constants_mdyne, print_displacements, n_atoms) Print vibrational analysis results in a formatted table. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frequencies (:) Vibrational frequencies in cm⁻¹ real(kind=dp), intent(in) :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(in) :: force_constants (:) Force constants in Hartree/Bohr² (or mdyne/Å if force_constants_mdyne provided) real(kind=dp), intent(in) :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom real(kind=dp), intent(in), optional :: force_constants_mdyne (:) Force constants in mdyne/Å (if provided, these are printed instead) logical, intent(in), optional :: print_displacements If true, print Cartesian displacement vectors (default: true) integer, intent(in), optional :: n_atoms Number of atoms (if not provided, derived from size of element_numbers) public  subroutine project_translation_rotation (mw_hessian, coordinates, element_numbers) Project out translation and rotation modes from mass-weighted Hessian. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: mw_hessian (:,:) Mass-weighted Hessian (modified in place) real(kind=dp), intent(in) :: coordinates (:,:) Atomic coordinates in Bohr (3, N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms)","tags":"","url":"module/mqc_vibrational_analysis.html"},{"title":"mqc_elements – metalquicha","text":"Provides atomic numbers, element symbols, and atomic masses for the complete\nperiodic table (elements 1-118) with conversion functions between representations.\nConvert element symbol to atomic number\nConvert atomic number to element symbol\nGet atomic mass by atomic number Uses pic_types pic_ascii module~~mqc_elements~~UsesGraph module~mqc_elements mqc_elements pic_ascii pic_ascii module~mqc_elements->pic_ascii pic_types pic_types module~mqc_elements->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_elements~~UsedByGraph module~mqc_elements mqc_elements module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_elements module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_io->module~mqc_elements module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_physical_fragment->module~mqc_elements module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_vibrational_analysis->module~mqc_elements module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_adapter module~mqc_driver->module~mqc_physical_fragment module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~apply_distance_screening->module~mqc_physical_fragment proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_vibrational_analysis proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->module~mqc_vibrational_analysis program~main main program~main->module~mqc_config_adapter program~main->module~mqc_physical_fragment program~main->module~mqc_driver module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: element_masses (n_elements) = [1.008_dp, 4.0026_dp, 6.94_dp, 9.0122_dp, 10.81_dp, 12.011_dp, 14.007_dp, 15.999_dp, 18.998_dp, 20.180_dp, 22.990_dp, 24.305_dp, 26.982_dp, 28.085_dp, 30.974_dp, 32.06_dp, 35.45_dp, 39.948_dp, 39.098_dp, 40.078_dp, 44.956_dp, 47.867_dp, 50.942_dp, 51.996_dp, 54.938_dp, 55.845_dp, 58.933_dp, 58.693_dp, 63.546_dp, 65.38_dp, 69.723_dp, 72.630_dp, 74.922_dp, 78.971_dp, 79.904_dp, 83.798_dp, 85.468_dp, 87.62_dp, 88.906_dp, 91.224_dp, 92.906_dp, 95.95_dp, 98.0_dp, 101.07_dp, 102.91_dp, 106.42_dp, 107.87_dp, 112.41_dp, 114.82_dp, 118.71_dp, 121.76_dp, 127.60_dp, 126.90_dp, 131.29_dp, 132.91_dp, 137.33_dp, 138.91_dp, 140.12_dp, 140.91_dp, 144.24_dp, 145.0_dp, 150.36_dp, 151.96_dp, 157.25_dp, 158.93_dp, 162.50_dp, 164.93_dp, 167.26_dp, 168.93_dp, 173.05_dp, 174.97_dp, 178.49_dp, 180.95_dp, 183.84_dp, 186.21_dp, 190.23_dp, 192.22_dp, 195.08_dp, 196.97_dp, 200.59_dp, 204.38_dp, 207.2_dp, 208.98_dp, 209.0_dp, 210.0_dp, 222.0_dp, 223.0_dp, 226.0_dp, 227.0_dp, 232.04_dp, 231.04_dp, 238.03_dp, 237.0_dp, 244.0_dp, 243.0_dp, 247.0_dp, 247.0_dp, 251.0_dp, 252.0_dp, 257.0_dp, 258.0_dp, 259.0_dp, 262.0_dp, 267.0_dp, 268.0_dp, 271.0_dp, 272.0_dp, 270.0_dp, 276.0_dp, 281.0_dp, 280.0_dp, 285.0_dp, 284.0_dp, 289.0_dp, 288.0_dp, 293.0_dp, 294.0_dp, 294.0_dp] Standard atomic masses in atomic mass units (amu)\nBased on IUPAC standard atomic weights, ordered by atomic number character(len=2), private, parameter :: element_symbols (n_elements) = [character(len=2)::'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og'] Element symbols for the complete periodic table (H through Og)\nOrdered by atomic number from 1 to 118 integer, private, parameter :: n_elements = 118 Functions public pure function element_mass (atomic_number) result(mass) Return atomic mass in atomic mass units (amu) for a given atomic number\nUses standard atomic weights from IUPAC Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value real(kind=dp) public pure function element_number_to_symbol (atomic_number) result(symbol) Convert atomic number to element symbol\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value character(len=2) public pure function element_symbol_to_number (symbol) result(atomic_number) Convert element symbol to atomic number\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Return Value integer","tags":"","url":"module/mqc_elements.html"},{"title":"mqc_method_base – metalquicha","text":"Defines the common interface that all quantum chemistry methods must implement,\nproviding a unified API for energy and gradient calculations.\nAbstract base type for all QC methods Uses pic_types mqc_result_types mqc_physical_fragment module~~mqc_method_base~~UsesGraph module~mqc_method_base mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_base->module~mqc_result_types pic_types pic_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_base~~UsedByGraph module~mqc_method_base mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_method_base module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_xtb module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface private  subroutine calc_energy_interface(this, fragment, result) Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results abstract interface private  subroutine calc_gradient_interface(this, fragment, result) Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result abstract interface private  subroutine calc_hessian_interface(this, fragment, result) Interface for energy, gradient, and Hessian calculations Computes electronic energy, nuclear gradients, and Hessian matrix for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Derived Types type, public, abstract :: qc_method_t Abstract base type for all quantum chemistry methods Read more… Type-Bound Procedures procedure( calc_energy_interface ), public, deferred :: calc_energy Energy calculation interface procedure( calc_gradient_interface ), public, deferred :: calc_gradient Gradient calculation interface procedure( calc_hessian_interface ), public, deferred :: calc_hessian Hessian calculation interface","tags":"","url":"module/mqc_method_base.html"},{"title":"mqc_logo – metalquicha","text":"Provides the project branding sunflower logo and version information\ndisplayed at program startup.\nDisplay ASCII sunflower logo and project info Used by module~~mqc_logo~~UsedByGraph module~mqc_logo mqc_logo program~main main program~main->module~mqc_logo Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine print_logo () Print the PIC Chemistry ASCII sunflower logo Arguments None","tags":"","url":"module/mqc_logo.html"},{"title":"mqc_serial_fragment_processor – metalquicha","text":"Uses Ancestors: mqc_mbe_fragment_distribution_scheme module~~mqc_serial_fragment_processor~~UsesGraph module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_calc_types mqc_calc_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_types mqc_method_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_types module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme~2->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme~2->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme~2->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme~2->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme~2->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme~2->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_method_types->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Subroutines module subroutine serial_fragment_processor (total_fragments, polymers, max_level, sys_geom, method, calc_type, bonds) Interface → Process all fragments serially in single-rank mode\nThis is used when running with only 1 MPI rank Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:)","tags":"","url":"module/mqc_serial_fragment_processor.html"},{"title":"mqc_mbe_fragment_distribution_scheme – metalquicha","text":"Uses Ancestors: mqc_mbe_fragment_distribution_scheme module~~mqc_mbe_fragment_distribution_scheme~~UsesGraph module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_calc_types mqc_calc_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_types mqc_method_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_types module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme~2->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme~2->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme~2->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme~2->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme~2->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme~2->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_method_types->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines subroutine send_fragment_to_node (world_comm, fragment_idx, polymers, dest_rank) Send fragment data to remote node coordinator\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank subroutine send_fragment_to_worker (node_comm, fragment_idx, polymers, dest_rank) Send fragment data to local worker\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank Module Subroutines module subroutine do_fragment_work (fragment_idx, result, method, phys_frag, calc_type) Interface → Process a single fragment for quantum chemistry calculation Read more… Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Fragment index for identification type( calculation_result_t ), intent(out) :: result Computation results integer(kind=int32), intent(in) :: method QC method type( physical_fragment_t ), intent(in), optional :: phys_frag Fragment geometry integer(kind=int32), intent(in) :: calc_type Calculation type module subroutine global_coordinator (world_comm, node_comm, total_fragments, polymers, max_level, node_leader_ranks, num_nodes, sys_geom, calc_type, bonds) Interface → Global coordinator for distributing fragments to node coordinators\nwill act as a node coordinator for a single node calculation\nUses int64 for total_fragments to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) module subroutine node_coordinator (world_comm, node_comm, calc_type) Interface → Node coordinator for distributing fragments to local workers\nHandles work requests and result collection from local workers Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm integer(kind=int32), intent(in) :: calc_type module subroutine node_worker (world_comm, node_comm, sys_geom, method, calc_type, bonds) Interface → Node worker for processing fragments assigned by node coordinator Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:)","tags":"","url":"module/mqc_mbe_fragment_distribution_scheme.html"},{"title":"mqc_hessian_distribution_scheme – metalquicha","text":"Uses Ancestors: mqc_mbe_fragment_distribution_scheme module~~mqc_hessian_distribution_scheme~~UsesGraph module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_calc_types mqc_calc_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_types mqc_method_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_types module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme~2->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme~2->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme~2->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme~2->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme~2->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme~2->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_method_types->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Subroutines module subroutine distributed_unfragmented_hessian (world_comm, sys_geom, method, driver_config) Interface → Compute Hessian for unfragmented system using MPI distribution Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method type( driver_config_t ), intent(in), optional :: driver_config Driver configuration module subroutine hessian_coordinator (world_comm, sys_geom, method, displacement) Interface → Coordinator for distributed Hessian calculation\nDistributes displacement work and collects gradient results Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr) module subroutine hessian_worker (world_comm, sys_geom, method, displacement) Interface → Worker for distributed Hessian calculation\nRequests displacement indices, computes gradients, and sends results back Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr)","tags":"","url":"module/mqc_hessian_distribution_scheme.html"},{"title":"mqc_unfragmented_workflow – metalquicha","text":"Uses Ancestors: mqc_mbe_fragment_distribution_scheme module~~mqc_unfragmented_workflow~~UsesGraph module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_calc_types mqc_calc_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_types mqc_method_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_types module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme~2->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme~2->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme~2->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme~2->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme~2->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme~2->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_method_types->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Subroutines module subroutine unfragmented_calculation (sys_geom, method, calc_type, bonds, result_out) Interface → Run unfragmented calculation on the entire system (nlevel=0)\nThis is a simple single-process calculation without MPI distribution\nIf result_out is present, returns result instead of writing JSON and destroying it Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( calculation_result_t ), intent(out), optional :: result_out","tags":"","url":"module/mqc_unfragmented_workflow.html"},{"title":"main – metalquicha","text":"Uses pic_logger mqc_driver mqc_config_parser mqc_error pic_mpi_lib pic_timer pic_knowledge pic_io mqc_logo mqc_physical_fragment mqc_io_helpers mqc_config_adapter program~~main~~UsesGraph program~main main module~mqc_config_adapter mqc_config_adapter program~main->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser program~main->module~mqc_config_parser module~mqc_driver mqc_driver program~main->module~mqc_driver module~mqc_error mqc_error program~main->module~mqc_error module~mqc_io_helpers mqc_io_helpers program~main->module~mqc_io_helpers module~mqc_logo mqc_logo program~main->module~mqc_logo module~mqc_physical_fragment mqc_physical_fragment program~main->module~mqc_physical_fragment pic_io pic_io program~main->pic_io pic_knowledge pic_knowledge program~main->pic_knowledge pic_logger pic_logger program~main->pic_logger pic_mpi_lib pic_mpi_lib program~main->pic_mpi_lib pic_timer pic_timer program~main->pic_timer module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_error module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_driver->module~mqc_config_adapter module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_error module~mqc_driver->module~mqc_io_helpers module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->pic_io module~mqc_driver->pic_logger module~mqc_driver->pic_mpi_lib module~mqc_driver->module~mqc_calc_types module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_json mqc_json module~mqc_driver->module~mqc_json module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2 mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_driver->module~mqc_method_types module~mqc_result_types mqc_result_types module~mqc_driver->module~mqc_result_types omp_lib omp_lib module~mqc_driver->omp_lib module~mqc_driver->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calc_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->pic_io module~mqc_gmbe_fragment_distribution_scheme->pic_logger module~mqc_gmbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_gmbe_fragment_distribution_scheme->pic_timer module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme~2 module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->pic_types module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis module~mqc_json->pic_io module~mqc_json->pic_logger module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme~2->pic_io module~mqc_mbe_fragment_distribution_scheme~2->pic_logger module~mqc_mbe_fragment_distribution_scheme~2->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_timer module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme~2->omp_lib module~mqc_mbe_fragment_distribution_scheme~2->pic_types module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme~2->module~mqc_mpi_tags pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme~2->pic_blas_interfaces module~mqc_method_types->pic_types module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_mbe_io->module~mqc_io_helpers module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->module~mqc_elements module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->pic_timer module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->pic_types pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Orchestrates MPI initialization, input parsing, geometry loading,\nand dispatches to appropriate calculation routines (fragmented or unfragmented). Calls program~~main~~CallsGraph program~main main abort_comm abort_comm program~main->abort_comm comm_world comm_world program~main->comm_world configure configure program~main->configure error error program~main->error finalize finalize program~main->finalize get_elapsed_time get_elapsed_time program~main->get_elapsed_time get_knowledge get_knowledge program~main->get_knowledge info info program~main->info pic_mpi_finalize pic_mpi_finalize program~main->pic_mpi_finalize pic_mpi_init pic_mpi_init program~main->pic_mpi_init proc~config_to_driver config_to_driver program~main->proc~config_to_driver proc~config_to_system_geometry config_to_system_geometry program~main->proc~config_to_system_geometry proc~ends_with ends_with program~main->proc~ends_with proc~error_get_message error_t%error_get_message program~main->proc~error_get_message proc~error_has_error error_t%error_has_error program~main->proc~error_has_error proc~get_logger_level get_logger_level program~main->proc~get_logger_level proc~print_logo print_logo program~main->proc~print_logo proc~read_mqc_file read_mqc_file program~main->proc~read_mqc_file proc~run_calculation run_calculation program~main->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations program~main->proc~run_multi_molecule_calculations proc~set_output_json_filename set_output_json_filename program~main->proc~set_output_json_filename proc~system_destroy system_geometry_t%system_destroy program~main->proc~system_destroy split split program~main->split start start program~main->start to_char to_char program~main->to_char proc~config_to_system_geometry->proc~error_has_error proc~error_add_context error_t%error_add_context proc~config_to_system_geometry->proc~error_add_context proc~error_set error_t%error_set proc~config_to_system_geometry->proc~error_set proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry warning warning proc~get_logger_level->warning proc~read_mqc_file->proc~error_has_error proc~read_mqc_file->proc~error_add_context proc~read_mqc_file->proc~error_set proc~parse_aimd_section parse_aimd_section proc~read_mqc_file->proc~parse_aimd_section proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_driver_section parse_driver_section proc~read_mqc_file->proc~parse_driver_section proc~parse_fragmentation_section parse_fragmentation_section proc~read_mqc_file->proc~parse_fragmentation_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_geometry_section parse_geometry_section proc~read_mqc_file->proc~parse_geometry_section proc~parse_hessian_section parse_hessian_section proc~read_mqc_file->proc~parse_hessian_section proc~parse_model_section parse_model_section proc~read_mqc_file->proc~parse_model_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_scf_section parse_scf_section proc~read_mqc_file->proc~parse_scf_section proc~parse_schema_section parse_schema_section proc~read_mqc_file->proc~parse_schema_section proc~parse_structure_section parse_structure_section proc~read_mqc_file->proc~parse_structure_section proc~parse_system_section parse_system_section proc~read_mqc_file->proc~parse_system_section proc~skip_to_end skip_to_end proc~read_mqc_file->proc~skip_to_end proc~run_calculation->info proc~run_calculation->to_char omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_calculation->warning proc~run_multi_molecule_calculations->abort_comm proc~run_multi_molecule_calculations->error proc~run_multi_molecule_calculations->info proc~run_multi_molecule_calculations->proc~config_to_driver proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~run_multi_molecule_calculations->proc~error_has_error proc~run_multi_molecule_calculations->proc~run_calculation proc~run_multi_molecule_calculations->proc~system_destroy proc~run_multi_molecule_calculations->to_char barrier barrier proc~run_multi_molecule_calculations->barrier proc~run_multi_molecule_calculations->proc~error_add_context proc~error_get_full_trace error_t%error_get_full_trace proc~run_multi_molecule_calculations->proc~error_get_full_trace proc~get_output_json_filename get_output_json_filename proc~run_multi_molecule_calculations->proc~get_output_json_filename proc~merge_multi_molecule_json merge_multi_molecule_json proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json proc~set_molecule_suffix set_molecule_suffix proc~run_multi_molecule_calculations->proc~set_molecule_suffix verbose verbose proc~run_multi_molecule_calculations->verbose proc~error_get_full_trace->proc~error_has_error proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~merge_multi_molecule_json->error proc~merge_multi_molecule_json->info proc~merge_multi_molecule_json->to_char proc~read_json_content read_json_content proc~merge_multi_molecule_json->proc~read_json_content proc~molecule_to_system_geometry->proc~error_set proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~parse_aimd_section->proc~error_set proc~strip_comment strip_comment proc~parse_aimd_section->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_driver_section->proc~error_set proc~calc_type_from_string calc_type_from_string proc~parse_driver_section->proc~calc_type_from_string proc~parse_driver_section->proc~strip_comment proc~parse_fragmentation_section->proc~error_has_error proc~parse_fragmentation_section->proc~error_add_context proc~parse_fragmentation_section->proc~error_set proc~parse_fragmentation_section->proc~strip_comment proc~validate_cutoffs validate_cutoffs proc~parse_fragmentation_section->proc~validate_cutoffs proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_hessian_section->proc~error_set proc~parse_hessian_section->proc~strip_comment proc~parse_model_section->proc~error_set proc~parse_method_string parse_method_string proc~parse_model_section->proc~parse_method_string proc~parse_model_section->proc~strip_comment proc~parse_molecules_section->proc~error_has_error proc~parse_molecules_section->proc~error_add_context proc~parse_molecules_section->proc~error_set proc~parse_molecules_section->proc~skip_to_end proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~strip_comment proc~parse_scf_section->proc~error_set proc~parse_scf_section->proc~strip_comment proc~parse_schema_section->proc~error_set proc~parse_schema_section->proc~strip_comment proc~parse_structure_generic parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~parse_system_section->proc~error_set proc~parse_system_section->proc~strip_comment proc~run_fragmented_calculation->info proc~run_fragmented_calculation->to_char proc~run_fragmented_calculation->omp_set_num_threads proc~run_fragmented_calculation->verbose allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_coordinator node_coordinator proc~run_fragmented_calculation->interface~node_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation->proc~apply_distance_screening proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation->proc~sort_fragments_by_size proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char proc~run_unfragmented_calculation->verbose interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~node_worker node_worker interface~node_worker->proc~node_worker proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~apply_distance_screening->info proc~apply_distance_screening->to_char proc~calculate_monomer_distance calculate_monomer_distance proc~apply_distance_screening->proc~calculate_monomer_distance proc~combine_util combine_util proc~combine->proc~combine_util to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~gmbe_enumerate_pie_terms->error proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->to_char atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->get_elapsed_time proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->start proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~error_add_context proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_add_context proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string proc~parse_single_molecule->proc~error_has_error proc~parse_single_molecule->proc~error_add_context proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_single_molecule->proc~strip_comment proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name proc~serial_gmbe_pie_processor->error proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->cart_disp proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->fc_mdyne proc~serial_gmbe_pie_processor->force_constants proc~serial_gmbe_pie_processor->frequencies interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor->reduced_masses proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index proc~validate_cutoffs->proc~error_set proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~build_fragment_from_atom_list->proc~error_add_context proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_fragment_overlap->to_char proc~check_fragment_overlap->proc~error_set proc~combine_util->proc~combine_util proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~global_coordinator->error proc~global_coordinator->get_elapsed_time proc~global_coordinator->info proc~global_coordinator->start proc~global_coordinator->to_char proc~global_coordinator->verbose proc~global_coordinator->iprobe proc~global_coordinator->irecv proc~global_coordinator->isend proc~global_coordinator->proc~result_irecv debug debug proc~global_coordinator->debug mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~node_coordinator->error proc~node_coordinator->to_char proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->error proc~node_worker->proc~error_has_error proc~node_worker->to_char proc~node_worker->proc~error_get_full_trace proc~node_worker->interface~do_fragment_work proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~fragment_destroy proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~result_isend proc~node_worker->recv proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~print_gmbe_pie_json->error proc~print_gmbe_pie_json->info proc~print_gmbe_pie_json->proc~get_output_json_filename proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~print_vibrational_analysis->info proc~print_vibrational_analysis->warning proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~result_irecv->irecv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~serial_fragment_processor->error proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->info proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->start proc~serial_fragment_processor->to_char proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->proc~error_get_full_trace proc~serial_fragment_processor->verbose proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->configuration proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~unfragmented_calculation->error proc~unfragmented_calculation->info proc~unfragmented_calculation->proc~error_has_error proc~unfragmented_calculation->to_char proc~unfragmented_calculation->proc~error_get_full_trace proc~unfragmented_calculation->cart_disp proc~unfragmented_calculation->configuration proc~unfragmented_calculation->fc_mdyne proc~unfragmented_calculation->force_constants proc~unfragmented_calculation->frequencies proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~print_vibrational_analysis proc~unfragmented_calculation->reduced_masses eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( driver_config_t ) :: config Driver configuration character(len=:), allocatable :: errmsg Error messages for file I/O type( error_t ) :: error Error handling character(len=256) :: input_file Input file name type( mqc_config_t ) :: mqc_config Parsed .mqc file type(timer_type) :: my_timer Execution timing type(comm_t) :: node_comm Node-local MPI communicator integer :: stat Status code for file I/O type( system_geometry_t ) :: sys_geom Loaded molecular system type(comm_t) :: world_comm Global MPI communicator Source Code program main !! Orchestrates MPI initialization, input parsing, geometry loading, !! and dispatches to appropriate calculation routines (fragmented or unfragmented). use pic_logger , only : logger => global_logger , info_level use pic_io , only : to_char use pic_mpi_lib , only : pic_mpi_init , comm_world , comm_t , abort_comm , pic_mpi_finalize use mqc_driver , only : run_calculation , run_multi_molecule_calculations use mqc_physical_fragment , only : system_geometry_t use mqc_config_parser , only : mqc_config_t , read_mqc_file use mqc_config_adapter , only : driver_config_t , config_to_driver , config_to_system_geometry , get_logger_level use mqc_io_helpers , only : set_output_json_filename , ends_with use mqc_logo , only : print_logo use pic_timer , only : timer_type use mqc_error , only : error_t use pic_knowledge , only : get_knowledge implicit none type ( timer_type ) :: my_timer !! Execution timing type ( comm_t ) :: world_comm !! Global MPI communicator type ( comm_t ) :: node_comm !! Node-local MPI communicator type ( driver_config_t ) :: config !! Driver configuration type ( mqc_config_t ) :: mqc_config !! Parsed .mqc file type ( system_geometry_t ) :: sys_geom !! Loaded molecular system type ( error_t ) :: error !! Error handling integer :: stat !! Status code for file I/O character ( len = :), allocatable :: errmsg !! Error messages for file I/O character ( len = 256 ) :: input_file !! Input file name ! Initialize MPI ! pic-mpi will call mpi_init_thread when needed call pic_mpi_init () ! Create communicators world_comm = comm_world () node_comm = world_comm % split () if ( world_comm % rank () == 0 ) then call print_logo () call my_timer % start () end if ! Parse command line arguments if ( command_argument_count () == 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"No input file specified. Usage: mqc input_file.mqc\" ) end if call abort_comm ( world_comm , 1 ) else if ( command_argument_count () == 1 ) then call get_command_argument ( 1 , input_file , status = stat ) if ( stat /= 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error reading command line argument\" ) end if call abort_comm ( world_comm , 1 ) end if input_file = trim ( input_file ) call set_output_json_filename ( input_file ) ! Validate file extension if (. not . ends_with ( input_file , '.mqc' )) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Invalid input file extension. Expected .mqc\" ) end if call abort_comm ( world_comm , 1 ) end if else if ( world_comm % rank () == 0 ) then call logger % error ( \"Too many arguments. Usage: metalquicha [input_file.mqc]\" ) end if call abort_comm ( world_comm , 1 ) end if ! Parse .mqc input file if ( world_comm % rank () == 0 ) then call logger % info ( \"Reading input file: \" // trim ( input_file )) end if call read_mqc_file ( input_file , mqc_config , error ) if ( error % has_error ()) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error reading .mqc file: \" // error % get_message ()) end if call abort_comm ( world_comm , 1 ) end if ! Configure logger if ( allocated ( mqc_config % log_level )) then call logger % configure ( get_logger_level ( mqc_config % log_level )) if ( world_comm % rank () == 0 ) then call logger % info ( \"Logger verbosity set to: \" // trim ( mqc_config % log_level )) end if end if ! Handle single vs multiple molecules if ( mqc_config % nmol == 0 ) then ! Single molecule mode (backward compatible) call config_to_driver ( mqc_config , config ) call config_to_system_geometry ( mqc_config , sys_geom , error ) if ( error % has_error ()) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error converting geometry: \" // error % get_message ()) end if call abort_comm ( world_comm , 1 ) end if call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % bonds ) call sys_geom % destroy () else ! Multi-molecule mode: loop over all molecules call run_multi_molecule_calculations ( world_comm , node_comm , mqc_config ) end if if ( world_comm % rank () == 0 ) then call get_knowledge () call my_timer % stop () call logger % info ( \"Total processing time: \" // to_char ( my_timer % get_elapsed_time ()) // \" s\" ) end if call mqc_config % destroy () call world_comm % finalize () call node_comm % finalize () call pic_mpi_finalize () end program main","tags":"","url":"program/main.html"},{"title":"mqc_frag_utils.f90 – metalquicha","text":"Fragment generation and manipulation utilities This file depends on sourcefile~~mqc_frag_utils.f90~~EfferentGraph sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_frag_utils.f90~~AfferentGraph sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Fragment generation and manipulation utilities module mqc_frag_utils !! Provides combinatorial functions and algorithms for generating molecular !! fragments, managing fragment lists, and performing many-body expansion calculations. !! !! This module re-exports functionality from specialized modules: !! - mqc_combinatorics: Pure combinatorial mathematics !! - mqc_fragment_lookup: Hash-based fragment index lookup !! - mqc_gmbe_utils: GMBE intersection and PIE enumeration use pic_types , only : int32 , int64 , dp , int_index use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_physical_fragment , only : system_geometry_t use mqc_combinatorics , only : & binomial , & get_nfrags , & create_monomer_list , & generate_fragment_list , & combine , & get_next_combination , & next_combination_init , & next_combination , & print_combos , & calculate_fragment_distances use mqc_fragment_lookup , only : fragment_lookup_t use mqc_gmbe_utils , only : & find_fragment_intersection , & generate_intersections , & compute_polymer_atoms , & generate_polymer_intersections , & gmbe_enumerate_pie_terms implicit none private ! Re-export from mqc_combinatorics public :: binomial public :: create_monomer_list public :: generate_fragment_list public :: combine public :: get_nfrags public :: get_next_combination public :: next_combination_init public :: next_combination public :: print_combos public :: calculate_fragment_distances ! Re-export from mqc_fragment_lookup public :: fragment_lookup_t ! Re-export from mqc_gmbe_utils public :: find_fragment_intersection public :: generate_intersections public :: compute_polymer_atoms public :: generate_polymer_intersections public :: gmbe_enumerate_pie_terms ! Local utilities public :: apply_distance_screening public :: sort_fragments_by_size contains subroutine apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) !! Apply distance-based screening to filter out fragments that exceed cutoff distances !! Modifies polymers array in-place and updates total_fragments count use mqc_physical_fragment , only : calculate_monomer_distance use mqc_config_adapter , only : driver_config_t integer , intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: total_fragments type ( system_geometry_t ), intent ( in ) :: sys_geom type ( driver_config_t ), intent ( in ) :: driver_config integer , intent ( in ) :: max_level integer ( int64 ) :: i , fragments_kept integer :: fragment_size real ( dp ) :: fragment_distance , cutoff integer ( int64 ) :: fragments_screened integer :: nmer_level ! Check if we have cutoffs to apply if (. not . allocated ( driver_config % fragment_cutoffs )) then return ! No screening needed end if fragments_kept = 0_int64 fragments_screened = 0_int64 ! Loop through all fragments and filter based on distance do i = 1_int64 , total_fragments fragment_size = count ( polymers ( i , :) > 0 ) ! Monomers are always kept (distance = 0) if ( fragment_size == 1 ) then fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then ! Compact array - move this fragment to the kept position polymers ( fragments_kept , :) = polymers ( i , :) end if cycle end if ! For n-mers (n >= 2), check if we have a cutoff and apply screening nmer_level = fragment_size if ( nmer_level > size ( driver_config % fragment_cutoffs )) then ! No cutoff defined for this level - keep the fragment fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then polymers ( fragments_kept , :) = polymers ( i , :) end if cycle end if cutoff = driver_config % fragment_cutoffs ( nmer_level ) if ( cutoff <= 0.0_dp ) then ! Negative or zero cutoff means no screening for this level fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then polymers ( fragments_kept , :) = polymers ( i , :) end if cycle end if ! Calculate distance for this fragment fragment_distance = calculate_monomer_distance ( sys_geom , polymers ( i , 1 : fragment_size )) ! Apply cutoff filter if ( fragment_distance <= cutoff ) then ! Keep this fragment fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then polymers ( fragments_kept , :) = polymers ( i , :) end if else ! Screen out this fragment fragments_screened = fragments_screened + 1_int64 end if end do ! Update total fragment count if ( fragments_screened > 0 ) then call logger % info ( \"Distance-based screening applied:\" ) call logger % info ( \"  Fragments before screening: \" // to_char ( total_fragments )) call logger % info ( \"  Fragments screened out: \" // to_char ( fragments_screened )) call logger % info ( \"  Fragments kept: \" // to_char ( fragments_kept )) total_fragments = fragments_kept end if end subroutine apply_distance_screening ! cannot make this pure because sort is not pure subroutine sort_fragments_by_size ( polymers , total_fragments , max_level ) !! Sort fragments by size (largest first) for better load balancing !! Uses in-place sorting to reorder the polymers array !! Larger fragments (e.g., tetramers) are computed before smaller ones (e.g., dimers) use pic_sorting , only : sort_index integer , intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level integer ( int64 ), allocatable :: fragment_sizes (:) integer ( int_index ), allocatable :: sort_indices (:) integer , allocatable :: polymers_copy (:, :) integer ( int64 ) :: i , j , sorted_idx integer :: fragment_size ! Nothing to sort if we have 1 or fewer fragments if ( total_fragments <= 1 ) return ! Allocate arrays for sorting (0-indexed for PIC library) allocate ( fragment_sizes ( 0 : total_fragments - 1 )) allocate ( sort_indices ( 0 : total_fragments - 1 )) ! Calculate fragment sizes do i = 0 , total_fragments - 1 fragment_size = count ( polymers ( i + 1 , :) > 0 ) fragment_sizes ( i ) = int ( fragment_size , int64 ) end do ! Get sort permutation in descending order (largest first) call sort_index ( fragment_sizes , sort_indices , reverse = . true .) ! Reorder polymers array based on sort permutation allocate ( polymers_copy ( size ( polymers , 1 ), size ( polymers , 2 ))) polymers_copy = polymers ! Reorder: new position j gets data from original position sort_indices(j) ! NOTE: sort_indices already contains 1-indexed values, so don't add 1! do j = 0 , total_fragments - 1 sorted_idx = sort_indices ( j ) ! Already 1-indexed! polymers ( j + 1 , :) = polymers_copy ( sorted_idx , :) end do deallocate ( polymers_copy ) deallocate ( fragment_sizes ) deallocate ( sort_indices ) call logger % info ( \"Fragments queue sorted!\" ) end subroutine sort_fragments_by_size end module mqc_frag_utils","tags":"","url":"sourcefile/mqc_frag_utils.f90.html"},{"title":"mqc_mbe_fragment_distribution_scheme.F90 – metalquicha","text":"Many-Body Expansion (MBE) calculation module This file depends on sourcefile~~mqc_mbe_fragment_distribution_scheme.f90~~EfferentGraph sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe_fragment_distribution_scheme.f90~~AfferentGraph sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Many-Body Expansion (MBE) calculation module module mqc_mbe_fragment_distribution_scheme !! Implements hierarchical many-body expansion for fragment-based quantum chemistry !! calculations with MPI parallelization and energy/gradient computation. use pic_types , only : int32 , int64 , dp use pic_timer , only : timer_type use pic_blas_interfaces , only : pic_gemm , pic_dot use pic_mpi_lib , only : comm_t , send , recv , isend , irecv , wait , iprobe , MPI_Status , & request_t , MPI_ANY_SOURCE , MPI_ANY_TAG , abort_comm use pic_logger , only : logger => global_logger , verbose_level , info_level use pic_io , only : to_char use mqc_mbe_io , only : print_fragment_xyz , print_unfragmented_json use omp_lib , only : omp_set_num_threads , omp_get_max_threads use mqc_mbe , only : compute_mbe use mqc_mpi_tags , only : TAG_WORKER_REQUEST , TAG_WORKER_FRAGMENT , TAG_WORKER_FINISH , & TAG_WORKER_SCALAR_RESULT , & TAG_NODE_REQUEST , TAG_NODE_FRAGMENT , TAG_NODE_FINISH , & TAG_NODE_SCALAR_RESULT use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , build_fragment_from_indices , & build_fragment_from_atom_list , to_angstrom , check_duplicate_atoms use mqc_method_types , only : method_type_to_string use mqc_calc_types , only : calc_type_to_string , CALC_TYPE_ENERGY , CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_config_parser , only : bond_t use mqc_config_adapter , only : driver_config_t ! Method API imports #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif use mqc_result_types , only : calculation_result_t , result_send , result_isend , result_recv , result_irecv implicit none private ! Public interface public :: do_fragment_work , global_coordinator , node_coordinator public :: serial_fragment_processor public :: node_worker , unfragmented_calculation , distributed_unfragmented_hessian interface module subroutine do_fragment_work ( fragment_idx , result , method , phys_frag , calc_type ) implicit none integer ( int64 ), intent ( in ) :: fragment_idx type ( calculation_result_t ), intent ( out ) :: result integer ( int32 ), intent ( in ) :: method type ( physical_fragment_t ), intent ( in ), optional :: phys_frag integer ( int32 ), intent ( in ) :: calc_type end subroutine do_fragment_work module subroutine global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , calc_type , bonds ) implicit none type ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level , num_nodes integer , intent ( in ) :: polymers (:, :), node_leader_ranks (:) type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) end subroutine global_coordinator module subroutine node_coordinator ( world_comm , node_comm , calc_type ) implicit none class ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int32 ), intent ( in ) :: calc_type end subroutine node_coordinator module subroutine serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method , calc_type , bonds ) implicit none integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: polymers (:, :), max_level type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) end subroutine serial_fragment_processor module subroutine node_worker ( world_comm , node_comm , sys_geom , method , calc_type , bonds ) implicit none class ( comm_t ), intent ( in ) :: world_comm , node_comm type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) end subroutine node_worker module subroutine unfragmented_calculation ( sys_geom , method , calc_type , bonds , result_out ) implicit none type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ), intent ( out ), optional :: result_out end subroutine unfragmented_calculation module subroutine distributed_unfragmented_hessian ( world_comm , sys_geom , method , driver_config ) implicit none type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method type ( driver_config_t ), intent ( in ), optional :: driver_config !! Driver configuration end subroutine distributed_unfragmented_hessian module subroutine hessian_coordinator ( world_comm , sys_geom , method , displacement ) implicit none type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) end subroutine hessian_coordinator module subroutine hessian_worker ( world_comm , sys_geom , method , displacement ) implicit none type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) end subroutine hessian_worker end interface end module mqc_mbe_fragment_distribution_scheme","tags":"","url":"sourcefile/mqc_mbe_fragment_distribution_scheme.f90.html"},{"title":"mqc_method_types.f90 – metalquicha","text":"Method type constants for quantum chemistry methods Files dependent on this one sourcefile~~mqc_method_types.f90~~AfferentGraph sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Method type constants for quantum chemistry methods module mqc_method_types !! Defines integer constants for quantum chemistry methods to avoid string comparisons !! throughout the codebase. Provides conversion utilities between string !! representations and integer constants. use pic_types , only : int32 implicit none private ! Public constants public :: METHOD_TYPE_GFN1 , METHOD_TYPE_GFN2 , METHOD_TYPE_HF public :: METHOD_TYPE_UNKNOWN ! Public functions public :: method_type_from_string , method_type_to_string ! Method type constants integer ( int32 ), parameter :: METHOD_TYPE_UNKNOWN = 0 integer ( int32 ), parameter :: METHOD_TYPE_GFN1 = 1 integer ( int32 ), parameter :: METHOD_TYPE_GFN2 = 2 integer ( int32 ), parameter :: METHOD_TYPE_HF = 3 contains pure function method_type_from_string ( method_str ) result ( method_type ) !! Convert method type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns METHOD_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: method_str !! Input string (e.g., \"gfn1\", \"gfn2\", \"hf\") integer ( int32 ) :: method_type !! Output integer constant character ( len = len_trim ( method_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) case ( 'gfn1' ) method_type = METHOD_TYPE_GFN1 case ( 'gfn2' ) method_type = METHOD_TYPE_GFN2 case ( 'hf' ) method_type = METHOD_TYPE_HF case default method_type = METHOD_TYPE_UNKNOWN end select end function method_type_from_string pure function method_type_to_string ( method_type ) result ( method_str ) !! Convert method type integer constant to string !! !! Provides human-readable string representation of method type. integer ( int32 ), intent ( in ) :: method_type !! Input integer constant character ( len = :), allocatable :: method_str !! Output string representation select case ( method_type ) case ( METHOD_TYPE_GFN1 ) method_str = \"gfn1\" case ( METHOD_TYPE_GFN2 ) method_str = \"gfn2\" case ( METHOD_TYPE_HF ) method_str = \"hf\" case default method_str = \"unknown\" end select end function method_type_to_string end module mqc_method_types","tags":"","url":"sourcefile/mqc_method_types.f90.html"},{"title":"mqc_finite_differences.f90 – metalquicha","text":"Finite difference utilities for numerical derivatives This file depends on sourcefile~~mqc_finite_differences.f90~~EfferentGraph sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_finite_differences.f90~~AfferentGraph sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Finite difference utilities for numerical derivatives module mqc_finite_differences !! Provides utilities for generating perturbed geometries and computing !! numerical derivatives via finite differences (gradients, Hessians, etc.) use pic_types , only : dp use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: generate_perturbed_geometries !! Generate forward/backward displacements public :: displaced_geometry_t !! Container for displaced geometry public :: finite_diff_hessian_from_gradients !! Compute Hessian from gradient differences public :: copy_and_displace_geometry !! Copy and displace geometry ! Default displacement step size (Bohr) real ( dp ), parameter , public :: DEFAULT_DISPLACEMENT = 0.005_dp !! ~0.05 Angstrom type :: displaced_geometry_t !! Container for a single displaced geometry integer :: atom_index !! Which atom was displaced (1-based) integer :: coordinate !! Which coordinate was displaced (1=x, 2=y, 3=z) integer :: direction !! +1 for forward, -1 for backward real ( dp ) :: displacement !! Displacement magnitude in Bohr type ( physical_fragment_t ) :: geometry !! The displaced geometry contains procedure :: destroy => displaced_geometry_destroy end type displaced_geometry_t contains subroutine generate_perturbed_geometries ( reference_geom , displacement , forward_geoms , backward_geoms ) !! Generate all forward and backward displaced geometries for finite difference calculations !! !! For a system with N atoms, this generates: !!   - 3N forward-displaced geometries (+x, +y, +z for each atom) !!   - 3N backward-displaced geometries (-x, -y, -z for each atom) !! !! These can be used to compute: !!   - Gradient: from energies at ±displacement !!   - Hessian: from gradients at ±displacement !! !! Args: !!   reference_geom: The reference geometry to perturb !!   displacement: Step size in Bohr (typical: 0.001 Bohr) !!   forward_geoms: Output array of forward-displaced geometries (size: 3*n_atoms) !!   backward_geoms: Output array of backward-displaced geometries (size: 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: displacement type ( displaced_geometry_t ), intent ( out ), allocatable :: forward_geoms (:) type ( displaced_geometry_t ), intent ( out ), allocatable :: backward_geoms (:) integer :: n_atoms , n_displacements integer :: iatom , icoord , idx integer :: i n_atoms = reference_geom % n_atoms n_displacements = 3 * n_atoms ! x, y, z for each atom allocate ( forward_geoms ( n_displacements )) allocate ( backward_geoms ( n_displacements )) ! Generate all displaced geometries idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 ! x, y, z idx = idx + 1 ! Forward displacement (+h) forward_geoms ( idx )% atom_index = iatom forward_geoms ( idx )% coordinate = icoord forward_geoms ( idx )% direction = + 1 forward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , + displacement , & forward_geoms ( idx )% geometry ) ! Backward displacement (-h) backward_geoms ( idx )% atom_index = iatom backward_geoms ( idx )% coordinate = icoord backward_geoms ( idx )% direction = - 1 backward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , - displacement , & backward_geoms ( idx )% geometry ) end do end do end subroutine generate_perturbed_geometries subroutine copy_and_displace_geometry ( reference_geom , atom_idx , coord_idx , displacement , displaced_geom ) !! Create a copy of reference geometry with one coordinate displaced !! !! Args: !!   reference_geom: Original geometry to copy !!   atom_idx: Atom to displace (1-based) !!   coord_idx: Coordinate to displace (1=x, 2=y, 3=z) !!   displacement: Amount to displace in Bohr (positive or negative) !!   displaced_geom: Output displaced geometry type ( physical_fragment_t ), intent ( in ) :: reference_geom integer , intent ( in ) :: atom_idx , coord_idx real ( dp ), intent ( in ) :: displacement type ( physical_fragment_t ), intent ( out ) :: displaced_geom ! Copy basic properties displaced_geom % n_atoms = reference_geom % n_atoms displaced_geom % charge = reference_geom % charge displaced_geom % multiplicity = reference_geom % multiplicity displaced_geom % nelec = reference_geom % nelec displaced_geom % n_caps = reference_geom % n_caps ! Allocate and copy arrays allocate ( displaced_geom % element_numbers ( displaced_geom % n_atoms )) allocate ( displaced_geom % coordinates ( 3 , displaced_geom % n_atoms )) displaced_geom % element_numbers = reference_geom % element_numbers displaced_geom % coordinates = reference_geom % coordinates ! Copy hydrogen cap information if present if ( reference_geom % n_caps > 0 ) then allocate ( displaced_geom % cap_replaces_atom ( displaced_geom % n_caps )) displaced_geom % cap_replaces_atom = reference_geom % cap_replaces_atom end if ! Copy gradient redistribution mapping if present if ( allocated ( reference_geom % local_to_global )) then allocate ( displaced_geom % local_to_global ( size ( reference_geom % local_to_global ))) displaced_geom % local_to_global = reference_geom % local_to_global end if ! Apply displacement to specified coordinate displaced_geom % coordinates ( coord_idx , atom_idx ) = & displaced_geom % coordinates ( coord_idx , atom_idx ) + displacement ! Copy basis set if present (same basis, just different geometry) if ( allocated ( reference_geom % basis )) then ! Note: Basis set will need to be rebuilt with new coordinates ! For now, we don't copy it - it should be set up during calculation end if end subroutine copy_and_displace_geometry subroutine finite_diff_hessian_from_gradients ( reference_geom , forward_gradients , backward_gradients , & displacement , hessian ) !! Compute Hessian matrix from finite differences of gradients !! !! Uses central finite differences: H_ij = (grad_i(+h) - grad_i(-h)) / (2h) !! !! Args: !!   reference_geom: Reference geometry (for dimensioning) !!   forward_gradients: Gradients at forward-displaced geometries (3*n_atoms, 3, n_atoms) !!   backward_gradients: Gradients at backward-displaced geometries (3*n_atoms, 3, n_atoms) !!   displacement: Step size used in Bohr !!   hessian: Output Hessian matrix (3*n_atoms, 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: forward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: backward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: displacement real ( dp ), intent ( out ), allocatable :: hessian (:, :) !! (3*n_atoms, 3*n_atoms) integer :: n_atoms , n_coords integer :: iatom , jatom , icoord , jcoord integer :: i_global , j_global integer :: disp_idx n_atoms = reference_geom % n_atoms n_coords = 3 * n_atoms allocate ( hessian ( n_coords , n_coords )) hessian = 0.0_dp ! Build Hessian using central differences ! H[i,j] = d²E/(dx_i dx_j) = (dE/dx_j at x_i+h - dE/dx_j at x_i-h) / (2h) disp_idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 disp_idx = disp_idx + 1 i_global = 3 * ( iatom - 1 ) + icoord ! For each displacement, compute derivatives of all gradient components do jatom = 1 , n_atoms do jcoord = 1 , 3 j_global = 3 * ( jatom - 1 ) + jcoord ! Central difference: (grad_j(+h) - grad_j(-h)) / (2h) hessian ( i_global , j_global ) = & ( forward_gradients ( disp_idx , jcoord , jatom ) - & backward_gradients ( disp_idx , jcoord , jatom )) / ( 2.0_dp * displacement ) end do end do end do end do ! Symmetrize the Hessian: H = (H + H&#94;T) / 2 ! This reduces numerical noise from finite differences do i_global = 1 , n_coords do j_global = i_global + 1 , n_coords hessian ( i_global , j_global ) = 0.5_dp * ( hessian ( i_global , j_global ) + hessian ( j_global , i_global )) hessian ( j_global , i_global ) = hessian ( i_global , j_global ) end do end do end subroutine finite_diff_hessian_from_gradients subroutine displaced_geometry_destroy ( this ) !! Clean up memory for displaced geometry class ( displaced_geometry_t ), intent ( inout ) :: this call this % geometry % destroy () end subroutine displaced_geometry_destroy end module mqc_finite_differences","tags":"","url":"sourcefile/mqc_finite_differences.f90.html"},{"title":"mqc_calculation_keywords.f90 – metalquicha","text":"Calculation keyword types for structured configuration Files dependent on this one sourcefile~~mqc_calculation_keywords.f90~~AfferentGraph sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Calculation keyword types for structured configuration module mqc_calculation_keywords !! Provides structured keyword types for calculation-specific settings !! These types are embedded in driver_config_t to organize keywords by category use pic_types , only : dp implicit none private public :: hessian_keywords_t , aimd_keywords_t , scf_keywords_t type :: hessian_keywords_t !! Hessian calculation keywords real ( dp ) :: displacement = 0.001_dp !! Finite difference displacement (Bohr) end type hessian_keywords_t type :: aimd_keywords_t !! Ab initio molecular dynamics keywords real ( dp ) :: dt = 1.0_dp !! Timestep (femtoseconds) integer :: nsteps = 0 !! Number of MD steps (0 = no AIMD) real ( dp ) :: initial_temperature = 30 0.0_dp !! Initial temperature for velocity init (K) integer :: output_frequency = 1 !! Write output every N steps end type aimd_keywords_t type :: scf_keywords_t !! SCF calculation keywords (placeholder for future use) logical :: use_diis = . true . !! Use DIIS acceleration integer :: max_iterations = 100 !! Maximum SCF iterations real ( dp ) :: convergence_threshold = 1.0e-6_dp !! Convergence threshold for SCF end type scf_keywords_t end module mqc_calculation_keywords","tags":"","url":"sourcefile/mqc_calculation_keywords.f90.html"},{"title":"mqc_result_types.f90 – metalquicha","text":"Quantum chemistry calculation result containers Files dependent on this one sourcefile~~mqc_result_types.f90~~AfferentGraph sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Quantum chemistry calculation result containers module mqc_result_types !! Defines data structures for storing and managing results from !! quantum chemistry calculations including energies, gradients, and properties. use pic_types , only : dp use pic_mpi_lib , only : comm_t , isend , irecv , send , recv , wait , request_t , MPI_Status implicit none private public :: mp2_energy_t !! MP2 energy components type public :: cc_energy_t !! Coupled cluster energy components type public :: energy_t !! Energy components type public :: calculation_result_t !! Main result container type public :: result_send , result_isend !! Send result over MPI public :: result_recv , result_irecv !! Receive result over MPI ! SCS-MP2 scaling parameters real ( dp ), parameter :: SCS_SS_SCALE = 1.0_dp / 3.0_dp !! SCS same-spin scaling factor real ( dp ), parameter :: SCS_OS_SCALE = 1.2_dp !! SCS opposite-spin scaling factor type :: mp2_energy_t !! Container for MP2 energy components (SS/OS) real ( dp ) :: ss = 0.0_dp !! Same-spin correlation energy (Hartree) real ( dp ) :: os = 0.0_dp !! Opposite-spin correlation energy (Hartree) contains procedure :: total => mp2_total !! Compute total MP2 correlation procedure :: scs => mp2_scs !! Compute SCS-MP2 correlation procedure :: reset => mp2_reset !! Reset both components to zero procedure :: check_stability => mp2_check_stability !! Check for positive energies (instability) end type mp2_energy_t type :: cc_energy_t !! Container for coupled cluster energy components real ( dp ) :: singles = 0.0_dp !! Singles contribution (Hartree) real ( dp ) :: doubles = 0.0_dp !! Doubles contribution (Hartree) real ( dp ) :: triples = 0.0_dp !! Triples contribution (Hartree) contains procedure :: total => cc_total !! Compute total CC correlation procedure :: reset => cc_reset !! Reset all components to zero procedure :: check_stability => cc_check_stability !! Check for positive energies (instability) end type cc_energy_t type :: energy_t !! Container for quantum chemistry energy components !! !! Stores energy contributions from different levels of theory. !! Total energy is computed as: scf + mp2%total() + cc%total() real ( dp ) :: scf = 0.0_dp !! SCF/HF reference energy (Hartree) type ( mp2_energy_t ) :: mp2 !! MP2 correlation components type ( cc_energy_t ) :: cc !! Coupled cluster correlation components ! add more as needed, also need to modify the total energy function contains procedure :: total => energy_total !! Compute total energy from components procedure :: reset => energy_reset !! Reset all components to zero end type energy_t type :: calculation_result_t !! Container for quantum chemistry calculation results !! !! Stores computed quantities from QC calculations with flags !! indicating which properties have been computed. type ( energy_t ) :: energy !! Energy components (Hartree) real ( dp ), allocatable :: gradient (:, :) !! Energy gradient (3, natoms) (Hartree/Bohr) real ( dp ), allocatable :: sigma (:, :) !! Stress tensor (3,3) (Hartree/Bohr&#94;3) real ( dp ), allocatable :: hessian (:, :) !! Energy hessian (future implementation) real ( dp ), allocatable :: dipole (:) !! Dipole moment vector (3) (Debye) ! Fragment metadata real ( dp ) :: distance = 0.0_dp !! Minimal atomic distance between monomers (Angstrom, 0 for monomers) ! Computation status flags logical :: has_energy = . false . !! Energy has been computed logical :: has_gradient = . false . !! Gradient has been computed logical :: has_sigma = . false . !! Stress tensor has been computed logical :: has_hessian = . false . !! Hessian has been computed logical :: has_dipole = . false . !! Dipole moment has been computed contains procedure :: destroy => result_destroy !! Clean up allocated memory procedure :: reset => result_reset !! Reset all values and flags end type calculation_result_t contains pure function mp2_total ( this ) result ( total ) !! Compute total MP2 correlation energy class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % ss + this % os end function mp2_total pure function mp2_scs ( this ) result ( scs_energy ) !! Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy !! SCS-MP2 uses: E_SCS = (1/3)*E_SS + 1.2*E_OS class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: scs_energy scs_energy = SCS_SS_SCALE * this % ss + SCS_OS_SCALE * this % os end function mp2_scs subroutine mp2_reset ( this ) !! Reset both MP2 components to zero class ( mp2_energy_t ), intent ( inout ) :: this this % ss = 0.0_dp this % os = 0.0_dp end subroutine mp2_reset subroutine mp2_check_stability ( this ) !! Check for positive MP2 correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( mp2_energy_t ), intent ( in ) :: this if ( this % ss > 0.0_dp ) then call logger % warning ( \"MP2 same-spin correlation energy is positive - possible instability!\" ) end if if ( this % os > 0.0_dp ) then call logger % warning ( \"MP2 opposite-spin correlation energy is positive - possible instability!\" ) end if end subroutine mp2_check_stability pure function cc_total ( this ) result ( total ) !! Compute total CC correlation energy class ( cc_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % singles + this % doubles + this % triples end function cc_total subroutine cc_reset ( this ) !! Reset all CC components to zero class ( cc_energy_t ), intent ( inout ) :: this this % singles = 0.0_dp this % doubles = 0.0_dp this % triples = 0.0_dp end subroutine cc_reset subroutine cc_check_stability ( this ) !! Check for positive CC correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( cc_energy_t ), intent ( in ) :: this if ( this % singles > 0.0_dp ) then call logger % warning ( \"CC singles correlation energy is positive - possible instability!\" ) end if if ( this % doubles > 0.0_dp ) then call logger % warning ( \"CC doubles correlation energy is positive - possible instability!\" ) end if if ( this % triples > 0.0_dp ) then call logger % warning ( \"CC triples correlation energy is positive - possible instability!\" ) end if end subroutine cc_check_stability pure function energy_total ( this ) result ( total ) !! Compute total energy from all components class ( energy_t ), intent ( in ) :: this real ( dp ) :: total ! this line needs to me modified if more components are added total = this % scf + this % mp2 % total () + this % cc % total () end function energy_total subroutine energy_reset ( this ) !! Reset all energy components to zero class ( energy_t ), intent ( inout ) :: this this % scf = 0.0_dp call this % mp2 % reset () call this % cc % reset () end subroutine energy_reset subroutine result_destroy ( this ) !! Clean up allocated memory in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % sigma )) deallocate ( this % sigma ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) call this % reset () end subroutine result_destroy subroutine result_reset ( this ) !! Reset all values and flags in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this call this % energy % reset () this % has_energy = . false . this % has_gradient = . false . this % has_sigma = . false . this % has_hessian = . false . this % has_dipole = . false . end subroutine result_reset subroutine result_send ( result , comm , dest , tag ) !! Send calculation result over MPI (blocking) !! Sends energy components and conditionally sends gradient based on has_gradient flag type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag ! Send energy components call send ( comm , result % energy % scf , dest , tag ) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send fragment metadata call send ( comm , result % distance , dest , tag ) ! Send gradient flag and data if present call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if end subroutine result_send subroutine result_isend ( result , comm , dest , tag , req ) !! Send calculation result over MPI (non-blocking) !! Sends SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag type ( request_t ), intent ( out ) :: req ! Send SCF energy (non-blocking) call isend ( comm , result % energy % scf , dest , tag , req ) ! Send other energy components (blocking to avoid needing multiple request handles) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send fragment metadata call send ( comm , result % distance , dest , tag ) ! Send gradient flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if ! Send Hessian flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_hessian , dest , tag ) if ( result % has_hessian ) then call send ( comm , result % hessian , dest , tag ) end if end subroutine result_isend subroutine result_recv ( result , comm , source , tag , status ) !! Receive calculation result over MPI (blocking) !! Receives energy components and conditionally receives gradient based on flag type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( MPI_Status ), intent ( out ) :: status ! Receive energy components call recv ( comm , result % energy % scf , source , tag , status ) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive fragment metadata call recv ( comm , result % distance , source , tag , status ) ! Receive gradient flag and data if present call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data if present call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if end subroutine result_recv subroutine result_irecv ( result , comm , source , tag , req ) !! Receive calculation result over MPI (non-blocking) !! Receives SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( request_t ), intent ( out ) :: req type ( MPI_Status ) :: status ! Receive SCF energy (non-blocking) call irecv ( comm , result % energy % scf , source , tag , req ) ! Receive other energy components (blocking to avoid needing multiple request handles) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive fragment metadata call recv ( comm , result % distance , source , tag , status ) ! Receive gradient flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if end subroutine result_irecv end module mqc_result_types","tags":"","url":"sourcefile/mqc_result_types.f90.html"},{"title":"mqc_config_adapter.f90 – metalquicha","text":"Adapter module to convert mqc_config_t to internal driver structures\nThis module provides a bridge between the .mqc file format and the driver backend This file depends on sourcefile~~mqc_config_adapter.f90~~EfferentGraph sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_config_adapter.f90~~AfferentGraph sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Adapter module to convert mqc_config_t to internal driver structures !! This module provides a bridge between the .mqc file format and the driver backend module mqc_config_adapter !! Provides conversion utilities from mqc_config_t to driver-compatible structures use pic_types , only : dp , int32 use mqc_config_parser , only : mqc_config_t use mqc_physical_fragment , only : system_geometry_t , to_bohr use mqc_elements , only : element_symbol_to_number use mqc_error , only : error_t , ERROR_VALIDATION use mqc_calculation_keywords , only : hessian_keywords_t , aimd_keywords_t , scf_keywords_t use pic_logger , only : logger => global_logger implicit none private public :: driver_config_t !! Minimal config for driver public :: config_to_driver , config_to_system_geometry public :: get_logger_level !! Convert log level string to integer public :: check_fragment_overlap !! Check for overlapping fragments (for testing) !! Runtime configuration for driver (internal use only) type :: driver_config_t ! Core calculation settings integer ( int32 ) :: method !! QC method constant integer ( int32 ) :: calc_type !! Calculation type constant ! Fragmentation settings integer :: nlevel = 0 !! Fragmentation level (0 = unfragmented) logical :: allow_overlapping_fragments = . false . !! Enable GMBE for overlapping fragments integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) real ( dp ), allocatable :: fragment_cutoffs (:) !! Distance cutoffs for n-mer screening (Angstrom) ! Calculation-specific keywords (structured) type ( hessian_keywords_t ) :: hessian !! Hessian calculation keywords type ( aimd_keywords_t ) :: aimd !! AIMD calculation keywords type ( scf_keywords_t ) :: scf !! SCF calculation keywords end type driver_config_t contains subroutine config_to_driver ( mqc_config , driver_config , molecule_index ) !! Convert mqc_config_t to minimal driver_config_t !! Extracts only the fields needed by the driver !! If molecule_index is provided, uses that molecule's fragment count type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ), intent ( out ) :: driver_config integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: nfrag_to_use ! Copy method and calc_type (already integers) driver_config % method = mqc_config % method driver_config % calc_type = mqc_config % calc_type ! Determine fragment count if ( present ( molecule_index )) then ! Multi-molecule mode: use specific molecule's fragment count if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then nfrag_to_use = 0 else nfrag_to_use = mqc_config % molecules ( molecule_index )% nfrag end if else ! Single molecule mode (backward compatible) nfrag_to_use = mqc_config % nfrag end if ! Set fragmentation level ! For unfragmented calculations (nfrag=0), nlevel must be 0 if ( nfrag_to_use == 0 ) then driver_config % nlevel = 0 else driver_config % nlevel = mqc_config % frag_level end if ! Set GMBE overlapping fragments flag driver_config % allow_overlapping_fragments = mqc_config % allow_overlapping_fragments ! Set GMBE maximum intersection level driver_config % max_intersection_level = mqc_config % max_intersection_level ! Copy fragment distance cutoffs if present if ( allocated ( mqc_config % fragment_cutoffs )) then allocate ( driver_config % fragment_cutoffs ( size ( mqc_config % fragment_cutoffs ))) driver_config % fragment_cutoffs = mqc_config % fragment_cutoffs end if ! Set calculation-specific keywords driver_config % hessian % displacement = mqc_config % hessian_displacement driver_config % aimd % dt = mqc_config % aimd_dt driver_config % aimd % nsteps = mqc_config % aimd_nsteps driver_config % aimd % initial_temperature = mqc_config % aimd_initial_temperature driver_config % aimd % output_frequency = mqc_config % aimd_output_frequency driver_config % scf % max_iterations = mqc_config % scf_maxiter driver_config % scf % convergence_threshold = mqc_config % scf_tolerance end subroutine config_to_driver subroutine config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index ) !! Convert mqc_config_t geometry to system_geometry_t !! For unfragmented calculations (nfrag=0), treats entire system as single unit !! For fragmented calculations, currently assumes monomer-based fragmentation !! If molecule_index is provided, uses that specific molecule from multi-molecule mode type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: i logical :: use_angstrom ! Determine units use_angstrom = . true . if ( allocated ( mqc_config % units )) then if ( trim ( mqc_config % units ) == 'bohr' ) then use_angstrom = . false . end if end if ! Handle multi-molecule vs single molecule mode if ( present ( molecule_index )) then ! Multi-molecule mode: extract specific molecule if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then call error % set ( ERROR_VALIDATION , \"Invalid molecule_index in multi-molecule mode\" ) return end if call molecule_to_system_geometry ( mqc_config % molecules ( molecule_index ), & sys_geom , use_angstrom , mqc_config % allow_overlapping_fragments , error ) else ! Single molecule mode (backward compatible) ! Check if geometry is loaded if ( mqc_config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in mqc_config\" ) return end if if ( mqc_config % nfrag == 0 ) then ! Unfragmented calculation: entire system is one \"monomer\" call geometry_to_system_unfragmented ( mqc_config % geometry , sys_geom , use_angstrom ) sys_geom % charge = mqc_config % charge sys_geom % multiplicity = mqc_config % multiplicity else ! Fragmented calculation with explicit fragments call geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_adapter:config_to_system_geometry\" ) return end if end if end if end subroutine config_to_system_geometry subroutine geometry_to_system_unfragmented ( geom , sys_geom , use_angstrom ) !! Convert geometry to system_geometry_t for unfragmented calculation !! Treats entire system as a single monomer use mqc_geometry , only : geometry_type type ( geometry_type ), intent ( in ) :: geom type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom integer :: i ! For unfragmented: n_monomers=1, atoms_per_monomer=natoms sys_geom % n_monomers = 1 sys_geom % atoms_per_monomer = geom % natoms sys_geom % total_atoms = geom % natoms allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine geometry_to_system_unfragmented subroutine initialize_fragmented_system ( nfrag , geom , fragments , charge , multiplicity , & allow_overlapping , use_angstrom , sys_geom , error ) !! Shared helper to initialize system_geometry_t for fragmented calculations !! Handles fragment allocation, size checking, and overlap validation use mqc_geometry , only : geometry_type use mqc_config_parser , only : input_fragment_t integer , intent ( in ) :: nfrag type ( geometry_type ), intent ( in ) :: geom type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: charge , multiplicity logical , intent ( in ) :: allow_overlapping logical , intent ( in ) :: use_angstrom type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer :: i , j , atoms_in_first_frag , max_frag_size logical :: all_same_size ! Set up basic system geometry sys_geom % n_monomers = nfrag sys_geom % total_atoms = geom % natoms sys_geom % charge = charge sys_geom % multiplicity = multiplicity ! Allocate fragment info arrays allocate ( sys_geom % fragment_sizes ( nfrag )) allocate ( sys_geom % fragment_charges ( nfrag )) allocate ( sys_geom % fragment_multiplicities ( nfrag )) ! Get fragment sizes max_frag_size = 0 atoms_in_first_frag = size ( fragments ( 1 )% indices ) all_same_size = . true . do i = 1 , nfrag sys_geom % fragment_sizes ( i ) = size ( fragments ( i )% indices ) sys_geom % fragment_charges ( i ) = fragments ( i )% charge sys_geom % fragment_multiplicities ( i ) = fragments ( i )% multiplicity max_frag_size = max ( max_frag_size , sys_geom % fragment_sizes ( i )) if ( sys_geom % fragment_sizes ( i ) /= atoms_in_first_frag ) then all_same_size = . false . end if end do ! Allocate fragment_atoms array allocate ( sys_geom % fragment_atoms ( max_frag_size , nfrag )) sys_geom % fragment_atoms = - 1 ! Initialize with invalid index ! Store fragment atom indices (0-indexed from input file) do i = 1 , nfrag do j = 1 , sys_geom % fragment_sizes ( i ) sys_geom % fragment_atoms ( j , i ) = fragments ( i )% indices ( j ) end do end do ! Check for overlapping fragments if not allowed if (. not . allow_overlapping ) then call check_fragment_overlap ( fragments , nfrag , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_adapter:geometry_to_system_fragmented\" ) return end if end if ! Set atoms_per_monomer: use common size if identical, else 0 if ( all_same_size ) then sys_geom % atoms_per_monomer = atoms_in_first_frag else sys_geom % atoms_per_monomer = 0 ! Signal variable-sized fragments end if allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine initialize_fragmented_system subroutine geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) !! Convert geometry to system_geometry_t for fragmented calculation !! Supports both identical and variable-sized fragments type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error call initialize_fragmented_system ( mqc_config % nfrag , mqc_config % geometry , mqc_config % fragments , & mqc_config % charge , mqc_config % multiplicity , & mqc_config % allow_overlapping_fragments , use_angstrom , & sys_geom , error ) end subroutine geometry_to_system_fragmented subroutine molecule_to_system_geometry ( mol , sys_geom , use_angstrom , allow_overlapping , error ) !! Convert a molecule_t to system_geometry_t !! Handles both unfragmented (nfrag=0) and fragmented molecules use mqc_config_parser , only : molecule_t type ( molecule_t ), intent ( in ) :: mol type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error logical , intent ( in ) :: allow_overlapping ! Check if geometry is loaded if ( mol % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in molecule\" ) return end if if ( mol % nfrag == 0 ) then ! Unfragmented molecule call geometry_to_system_unfragmented ( mol % geometry , sys_geom , use_angstrom ) sys_geom % charge = mol % charge sys_geom % multiplicity = mol % multiplicity else ! Fragmented molecule call initialize_fragmented_system ( mol % nfrag , mol % geometry , mol % fragments , & mol % charge , mol % multiplicity , & allow_overlapping , use_angstrom , & sys_geom , error ) end if end subroutine molecule_to_system_geometry function get_logger_level ( level_string ) result ( level_int ) !! Convert string log level to integer value !! This function uses the pic_logger constants use pic_logger , only : debug_level , verbose_level , info_level , performance_level , & warning_level , error_level , knowledge_level character ( len =* ), intent ( in ) :: level_string integer :: level_int select case ( trim ( adjustl ( level_string ))) case ( 'debug' , 'Debug' , 'DEBUG' ) level_int = debug_level case ( 'verbose' , 'Verbose' , 'VERBOSE' ) level_int = verbose_level case ( 'info' , 'Info' , 'INFO' ) level_int = info_level case ( 'performance' , 'Performance' , 'PERFORMANCE' ) level_int = performance_level case ( 'warning' , 'Warning' , 'WARNING' ) level_int = warning_level case ( 'error' , 'Error' , 'ERROR' ) level_int = error_level case ( 'knowledge' , 'Knowledge' , 'KNOWLEDGE' ) level_int = knowledge_level case default ! Default to info level if unknown call logger % warning ( \"Unknown log level string: \" // level_string // \". Defaulting to INFO level.\" ) level_int = info_level end select end function get_logger_level subroutine check_fragment_overlap ( fragments , nfrag , error ) !! Check if any atoms appear in multiple fragments !! This is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes use mqc_config_parser , only : input_fragment_t use pic_io , only : to_char type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: nfrag type ( error_t ), intent ( out ) :: error integer :: i , j , k , l integer :: atom_i , atom_j ! Compare each pair of fragments do i = 1 , nfrag - 1 do j = i + 1 , nfrag ! Compare atoms in fragment i with atoms in fragment j do k = 1 , size ( fragments ( i )% indices ) atom_i = fragments ( i )% indices ( k ) do l = 1 , size ( fragments ( j )% indices ) atom_j = fragments ( j )% indices ( l ) if ( atom_i == atom_j ) then ! Found overlapping atom call error % set ( ERROR_VALIDATION , \"Overlapping fragments detected: fragments \" // to_char ( i ) // \" and \" // & to_char ( j ) // \" both contain atom \" // to_char ( atom_i ) // & \". Set allow_overlapping_fragments = true to allow this.\" ) return end if end do end do end do end do end subroutine check_fragment_overlap end module mqc_config_adapter","tags":"","url":"sourcefile/mqc_config_adapter.f90.html"},{"title":"mqc_error.f90 – metalquicha","text":"Error handling module for metalquicha\nProvides a unified error type to replace stat/errmsg pairs\nEnhanced with stack trace support for better debugging Files dependent on this one sourcefile~~mqc_error.f90~~AfferentGraph sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_basis_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cli_parser.f90 mqc_cli_parser.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_basis_utils.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_error.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_error.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Error handling module for metalquicha !! Provides a unified error type to replace stat/errmsg pairs !! Enhanced with stack trace support for better debugging module mqc_error implicit none private public :: error_t public :: SUCCESS , ERROR_GENERIC , ERROR_IO , ERROR_PARSE , ERROR_VALIDATION !! Error codes integer , parameter :: SUCCESS = 0 integer , parameter :: ERROR_GENERIC = 1 integer , parameter :: ERROR_IO = 2 integer , parameter :: ERROR_PARSE = 3 integer , parameter :: ERROR_VALIDATION = 4 !! Stack trace configuration integer , parameter :: MAX_STACK_DEPTH = 20 integer , parameter :: MAX_LOCATION_LEN = 128 !! Unified error type with stack trace support type :: error_t integer :: code = SUCCESS !! Error code (0 = no error) character ( len = :), allocatable :: message !! Error message !! Stack trace support integer :: stack_depth = 0 !! Current stack depth character ( len = MAX_LOCATION_LEN ) :: call_stack ( MAX_STACK_DEPTH ) !! Call locations contains procedure :: has_error => error_has_error procedure :: set => error_set procedure :: clear => error_clear procedure :: get_code => error_get_code procedure :: get_message => error_get_message procedure :: add_context => error_add_context procedure :: get_full_trace => error_get_full_trace procedure :: print_trace => error_print_trace end type error_t contains pure function error_has_error ( this ) result ( has_err ) !! Check if an error is set class ( error_t ), intent ( in ) :: this logical :: has_err has_err = ( this % code /= SUCCESS ) end function error_has_error pure subroutine error_set ( this , code , message ) !! Set an error with code and message !! Resets the stack trace class ( error_t ), intent ( inout ) :: this integer , intent ( in ) :: code character ( len =* ), intent ( in ) :: message this % code = code this % message = trim ( message ) this % stack_depth = 0 ! Reset stack when setting new error end subroutine error_set pure subroutine error_clear ( this ) !! Clear the error state and stack trace class ( error_t ), intent ( inout ) :: this this % code = SUCCESS this % stack_depth = 0 if ( allocated ( this % message )) deallocate ( this % message ) end subroutine error_clear pure function error_get_code ( this ) result ( code ) !! Get the error code class ( error_t ), intent ( in ) :: this integer :: code code = this % code end function error_get_code pure function error_get_message ( this ) result ( message ) !! Get the error message (without stack trace) class ( error_t ), intent ( in ) :: this character ( len = :), allocatable :: message if ( allocated ( this % message )) then message = this % message else message = \"\" end if end function error_get_message pure subroutine error_add_context ( this , location ) !! Add a call location to the stack trace !! Typically called when propagating errors upward !! !! Example: !!   call some_routine(..., error) !!   if (error%has_error()) then !!      call error%add_context(\"mqc_mbe:compute_energy\") !!      return !!   end if class ( error_t ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: location if ( this % stack_depth < MAX_STACK_DEPTH ) then this % stack_depth = this % stack_depth + 1 this % call_stack ( this % stack_depth ) = location end if ! If stack is full, silently ignore (could print warning in non-pure version) end subroutine error_add_context function error_get_full_trace ( this ) result ( trace ) !! Get complete error message with stack trace !! Returns a multi-line string with error and call stack class ( error_t ), intent ( in ) :: this character ( len = :), allocatable :: trace character ( len = 2048 ) :: buffer integer :: i , pos if (. not . this % has_error ()) then trace = \"\" return end if ! Build error message write ( buffer , '(A,I0,A)' ) \"Error \" , this % code , \": \" pos = len_trim ( buffer ) + 1 if ( allocated ( this % message )) then buffer ( pos :) = this % message pos = len_trim ( buffer ) + 1 end if ! Add stack trace if available if ( this % stack_depth > 0 ) then buffer ( pos :) = new_line ( 'a' ) // \"Call stack (most recent first):\" pos = len_trim ( buffer ) + 1 do i = this % stack_depth , 1 , - 1 write ( buffer ( pos :), '(A,I0,A)' ) new_line ( 'a' ) // \"  [\" , i , \"] \" pos = len_trim ( buffer ) + 1 buffer ( pos :) = trim ( this % call_stack ( i )) pos = len_trim ( buffer ) + 1 end do end if trace = trim ( buffer ) end function error_get_full_trace subroutine error_print_trace ( this , unit ) !! Print error with stack trace to specified unit !! If unit not specified, prints to stdout (unit 6) class ( error_t ), intent ( in ) :: this integer , intent ( in ), optional :: unit integer :: out_unit , i out_unit = 6 ! stdout if ( present ( unit )) out_unit = unit if (. not . this % has_error ()) return ! Print error message write ( out_unit , '(A,I0,A)' , advance = 'no' ) \"Error \" , this % code , \": \" if ( allocated ( this % message )) then write ( out_unit , '(A)' ) trim ( this % message ) else write ( out_unit , '(A)' ) \"(no message)\" end if ! Print stack trace if available if ( this % stack_depth > 0 ) then write ( out_unit , '(A)' ) \"Call stack (most recent first):\" do i = this % stack_depth , 1 , - 1 write ( out_unit , '(A,I0,A)' , advance = 'no' ) \"  [\" , i , \"] \" write ( out_unit , '(A)' ) trim ( this % call_stack ( i )) end do end if end subroutine error_print_trace end module mqc_error","tags":"","url":"sourcefile/mqc_error.f90.html"},{"title":"mqc_method_xtb.f90 – metalquicha","text":"Extended Tight-Binding (xTB) quantum chemistry method implementation This file depends on sourcefile~~mqc_method_xtb.f90~~EfferentGraph sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_xtb.f90~~AfferentGraph sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Extended Tight-Binding (xTB) quantum chemistry method implementation module mqc_method_xtb !! Provides GFN1-xTB and GFN2-xTB methods via the tblite library, !! implementing the abstract method interface for energy and gradient calculations. use pic_types , only : dp use mqc_method_base , only : qc_method_t use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t ! tblite imports (reuse from mqc_mbe) use mctc_env , only : wp , error_type use mctc_io , only : structure_type , new use pic_timer , only : timer_type use tblite_context_type , only : context_type use tblite_wavefunction , only : wavefunction_type , new_wavefunction use tblite_xtb_calculator , only : xtb_calculator use tblite_xtb_gfn1 , only : new_gfn1_calculator use tblite_xtb_gfn2 , only : new_gfn2_calculator use tblite_xtb_singlepoint , only : xtb_singlepoint implicit none private public :: xtb_method_t !! XTB method implementation type type , extends ( qc_method_t ) :: xtb_method_t !! Extended Tight-Binding (xTB) method implementation !! !! Concrete implementation of the abstract quantum chemistry method !! interface for GFN1-xTB and GFN2-xTB calculations via tblite. character ( len = :), allocatable :: variant !! XTB variant: \"gfn1\" or \"gfn2\" logical :: verbose = . false . !! Print calculation details real ( wp ) :: accuracy = 0.01_wp !! Numerical accuracy parameter real ( wp ) :: kt = 30 0.0_wp * 3.166808578545117e-06_wp !! Electronic temperature (300 K) contains procedure :: calc_energy => xtb_calc_energy !! Energy-only calculation procedure :: calc_gradient => xtb_calc_gradient !! Energy + gradient calculation procedure :: calc_hessian => xtb_calc_hessian !! Placeholder for Hessian calculation end type xtb_method_t contains subroutine xtb_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity if ( this % verbose ) then print * , \"XTB: Calculating energy using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure ! charge is real(wp), multiplicity converted to uhf (unpaired electrons) call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default error stop \"Unknown XTB variant: \" // this % variant end select if ( allocated ( error )) then error stop \"Failed to create XTB calculator\" end if ! Create wavefunction and run single point calculation call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt ) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , verbosity = verbosity ) ! Store result (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () end if deallocate ( num , xyz ) end subroutine xtb_calc_energy subroutine xtb_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity real ( wp ), allocatable :: gradient (:, :) real ( wp ), allocatable :: sigma (:, :) if ( this % verbose ) then print * , \"XTB: Calculating gradient using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default error stop \"Unknown XTB variant: \" // this % variant end select if ( allocated ( error )) then error stop \"Failed to create XTB calculator\" end if ! Allocate gradient and sigma arrays (initialize to zero) allocate ( gradient ( 3 , fragment % n_atoms )) allocate ( sigma ( 3 , 3 )) gradient = 0.0_wp sigma = 0.0_wp ! Create wavefunction and run single point calculation with gradient call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt , grad = . true .) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , & gradient = gradient , sigma = sigma , verbosity = verbosity ) ! Store results (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . ! Store gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = real ( gradient , dp ) result % has_gradient = . true . ! Store sigma (stress tensor) allocate ( result % sigma ( 3 , 3 )) result % sigma = real ( sigma , dp ) result % has_sigma = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () print * , \"XTB: Gradient norm =\" , sqrt ( sum ( result % gradient ** 2 )) print * , \"XTB: Gradient calculation complete\" end if deallocate ( num , xyz , gradient , sigma ) end subroutine xtb_calc_gradient subroutine xtb_calc_hessian ( this , fragment , result ) !! Calculate Hessian using finite differences of gradients !! !! Since tblite does not natively support analytic Hessians, this routine !! computes the Hessian numerically via central finite differences: !!   H[i,j] = (grad_j(x_i + h) - grad_j(x_i - h)) / (2h) !! !! This requires 6N gradient calculations (forward and backward for each coordinate) use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT use pic_logger , only : logger => global_logger use pic_io , only : to_char class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result type ( displaced_geometry_t ), allocatable :: forward_geoms (:), backward_geoms (:) real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) type ( calculation_result_t ) :: disp_result real ( dp ) :: displacement integer :: n_atoms , n_displacements , i n_atoms = fragment % n_atoms n_displacements = 3 * n_atoms displacement = DEFAULT_DISPLACEMENT if ( this % verbose ) then call logger % info ( \"XTB: Computing Hessian via finite differences\" ) call logger % info ( \"  Method: Central differences of gradients\" ) call logger % info ( \"  Atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) call logger % info ( \"  Finite difference step size: \" // to_char ( displacement ) // \" Bohr\" ) end if ! Generate all perturbed geometries call generate_perturbed_geometries ( fragment , displacement , forward_geoms , backward_geoms ) ! Allocate storage for gradients at displaced geometries allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) ! Compute gradients at all forward-displaced geometries if ( this % verbose ) then call logger % info ( \"  Computing forward-displaced gradients...\" ) end if do i = 1 , n_displacements ! Forward call this % calc_gradient ( forward_geoms ( i )% geometry , disp_result ) if (. not . disp_result % has_gradient ) then call logger % error ( \"Failed to compute gradient for forward displacement \" // to_char ( i )) error stop \"Finite difference Hessian: gradient calculation failed\" end if forward_gradients ( i , :, :) = disp_result % gradient call disp_result % destroy () ! Backward call this % calc_gradient ( backward_geoms ( i )% geometry , disp_result ) if (. not . disp_result % has_gradient ) then call logger % error ( \"Failed to compute gradient for backward displacement \" // to_char ( i )) error stop \"Finite difference Hessian: gradient calculation failed\" end if backward_gradients ( i , :, :) = disp_result % gradient call disp_result % destroy () end do if ( this % verbose ) then call logger % info ( \"  Forward and backward gradient calculations complete \" ) end if ! Compute Hessian from finite differences if ( this % verbose ) then call logger % info ( \"  Assembling Hessian matrix...\" ) end if call finite_diff_hessian_from_gradients ( fragment , forward_gradients , backward_gradients , & displacement , result % hessian ) ! Also compute energy and gradient at reference geometry for completeness call this % calc_gradient ( fragment , disp_result ) result % energy = disp_result % energy result % has_energy = disp_result % has_energy if ( disp_result % has_gradient ) then allocate ( result % gradient ( 3 , n_atoms )) result % gradient = disp_result % gradient result % has_gradient = . true . end if call disp_result % destroy () result % has_hessian = . true . if ( this % verbose ) then call logger % info ( \"  Hessian calculation complete\" ) end if ! Cleanup deallocate ( forward_gradients , backward_gradients ) do i = 1 , n_displacements call forward_geoms ( i )% destroy () call backward_geoms ( i )% destroy () end do deallocate ( forward_geoms , backward_geoms ) end subroutine xtb_calc_hessian end module mqc_method_xtb","tags":"","url":"sourcefile/mqc_method_xtb.f90.html"},{"title":"mqc_mpi_tags.f90 – metalquicha","text":"contains MPI tags used in the MQC parallel implementation Files dependent on this one sourcefile~~mqc_mpi_tags.f90~~AfferentGraph sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! contains MPI tags used in the MQC parallel implementation module mqc_mpi_tags !! Module defining MPI communication tags for clarity and maintainability use pic_types , only : default_int implicit none private ! Local worker communication tags (shared memory within a node) integer ( default_int ), parameter , public :: TAG_WORKER_REQUEST = 200 !! Worker requests work from node coordinator integer ( default_int ), parameter , public :: TAG_WORKER_FRAGMENT = 201 !! Coordinator sends fragment data to worker integer ( default_int ), parameter , public :: TAG_WORKER_FINISH = 202 !! Coordinator signals worker to finish integer ( default_int ), parameter , public :: TAG_WORKER_SCALAR_RESULT = 203 !! Worker sends scalar results back to coordinator integer ( default_int ), parameter , public :: TAG_WORKER_MATRIX_RESULT = 204 !! Worker sends matrix results back to coordinator ! Remote node communication tags (between nodes via world communicator) integer ( default_int ), parameter , public :: TAG_NODE_REQUEST = 300 !! Node coordinator requests work from global coordinator integer ( default_int ), parameter , public :: TAG_NODE_FRAGMENT = 301 !! Global coordinator sends fragment data to node coordinator integer ( default_int ), parameter , public :: TAG_NODE_FINISH = 302 !! Global coordinator signals node coordinator to finish integer ( default_int ), parameter , public :: TAG_NODE_SCALAR_RESULT = 303 !! Node coordinator sends results (fragment_idx + scalar) to global coordinator integer ( default_int ), parameter , public :: TAG_NODE_MATRIX_RESULT = 304 !! Node coordinator sends matrix results to global coordinator end module mqc_mpi_tags","tags":"","url":"sourcefile/mqc_mpi_tags.f90.html"},{"title":"mqc_basis_file_reader.f90 – metalquicha","text":"this file contains the modules and routines to open and read a GAMESS formatted basis set file Files dependent on this one sourcefile~~mqc_basis_file_reader.f90~~AfferentGraph sourcefile~mqc_basis_file_reader.f90 mqc_basis_file_reader.f90 sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_basis_file_reader.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this file contains the modules and routines to open and read a GAMESS formatted basis set file module mqc_basis_file_reader !! Module for reading and parsing GAMESS formatted basis set files use pic_types , only : int32 , dp implicit none private public :: basis_file_t , open_basis_file , extract_element , strings_equal type :: basis_file_t !! Container for basis set file contents character ( len = :), allocatable :: full_content character ( len = :), allocatable :: data_section end type basis_file_t contains subroutine open_basis_file ( basis_file , filename ) !! Open and read a GAMESS formatted basis set file type ( basis_file_t ), intent ( out ) :: basis_file character ( len =* ), intent ( in ) :: filename integer :: unit , iostat , file_size logical :: file_exists integer :: data_start , data_end ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then error stop \"Basis set file not found: \" // filename end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: basis_file % full_content ) ! Open and read entire file open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = iostat ) if ( iostat /= 0 ) error stop \"Error opening file: \" // filename read ( unit , iostat = iostat ) basis_file % full_content if ( iostat /= 0 ) error stop \"Error reading file: \" // filename close ( unit ) ! Extract the $DATA section data_start = index ( basis_file % full_content , \"$DATA\" ) if ( data_start == 0 ) then error stop \"Could not find $DATA section in basis set file\" end if data_end = index ( basis_file % full_content ( data_start :), \"$END\" ) if ( data_end == 0 ) then error stop \"Could not find $END marker in basis set file\" end if ! Store just the data section (between $DATA and $END) basis_file % data_section = basis_file % full_content ( data_start + 5 : data_start + data_end - 2 ) end subroutine open_basis_file function extract_element ( basis_file , element ) result ( element_content ) !! Extract the basis set data for a specific element from the basis file type ( basis_file_t ), intent ( in ) :: basis_file character ( len =* ), intent ( in ) :: element character ( len = :), allocatable :: element_content integer :: start_pos , end_pos , i character ( len = :), allocatable :: search_element logical :: at_line_start ! Convert element to uppercase for searching search_element = uppercase ( trim ( element )) ! Find the element name (it appears on its own line) start_pos = index ( basis_file % data_section , new_line ( 'a' ) // trim ( search_element ) // new_line ( 'a' )) if ( start_pos == 0 ) then ! Try without leading newline (might be first element after $DATA) if ( index ( basis_file % data_section , trim ( search_element ) // new_line ( 'a' )) == 1 ) then start_pos = 1 else error stop \"Element not found in basis set file: \" // element end if else start_pos = start_pos + 1 ! Skip the leading newline end if ! Find the next element by looking for a line that: ! - Starts with an uppercase letter ! - Has a second character that is also a letter (not a space or number) ! This distinguishes \"CARBON\" from \"S   3\" end_pos = len ( basis_file % data_section ) at_line_start = . false . i = start_pos + len ( search_element ) + 1 do while ( i < len ( basis_file % data_section )) if ( basis_file % data_section ( i : i ) == new_line ( 'a' )) then at_line_start = . true . i = i + 1 cycle end if if ( at_line_start ) then ! We're at the start of a new line if ( is_uppercase_letter ( basis_file % data_section ( i : i ))) then ! Check if next character is also a letter if ( i + 1 <= len ( basis_file % data_section )) then if ( is_letter ( basis_file % data_section ( i + 1 : i + 1 ))) then ! Found next element! end_pos = i - 1 exit end if end if end if at_line_start = . false . end if i = i + 1 end do ! Extract the section element_content = basis_file % data_section ( start_pos : end_pos ) end function extract_element pure function is_letter ( c ) result ( is_alpha ) !! Check if character is a letter (A-Z or a-z) character ( len = 1 ), intent ( in ) :: c logical :: is_alpha integer :: ic ic = iachar ( c ) is_alpha = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) . or . & ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) end function is_letter pure function uppercase ( str ) result ( upper ) !! Convert a string to uppercase, should use pic_ascii! character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: upper integer :: i , ic allocate ( character ( len = len ( str )) :: upper ) upper = str do i = 1 , len ( str ) ic = iachar ( str ( i : i )) if ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) then upper ( i : i ) = achar ( ic - 32 ) end if end do end function uppercase pure function is_uppercase_letter ( c ) result ( is_upper ) !! Check if character is an uppercase letter (A-Z) character ( len = 1 ), intent ( in ) :: c logical :: is_upper integer :: ic ic = iachar ( c ) is_upper = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) end function is_uppercase_letter !> Compare two strings after trimming and adjusting (removing leading/trailing whitespace) pure function strings_equal ( str1 , str2 ) result ( equal ) !! Compare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) character ( len =* ), intent ( in ) :: str1 , str2 logical :: equal equal = trim ( adjustl ( str1 )) == trim ( adjustl ( str2 )) end function strings_equal end module mqc_basis_file_reader","tags":"","url":"sourcefile/mqc_basis_file_reader.f90.html"},{"title":"mqc_gmbe_utils.f90 – metalquicha","text":"GMBE (Generalized Many-Body Expansion) utilities for overlapping fragments This file depends on sourcefile~~mqc_gmbe_utils.f90~~EfferentGraph sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_gmbe_utils.f90~~AfferentGraph sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! GMBE (Generalized Many-Body Expansion) utilities for overlapping fragments module mqc_gmbe_utils !! Provides functions for computing fragment intersections, generating k-way !! intersections, and enumerating PIE (Principle of Inclusion-Exclusion) terms !! for GMBE calculations with overlapping molecular fragments. use pic_types , only : default_int , int32 , int64 , dp use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_combinatorics , only : next_combination , next_combination_init implicit none private public :: find_fragment_intersection !! Find shared atoms between two fragments public :: generate_intersections !! Generate all k-way intersections for GMBE public :: compute_polymer_atoms !! Compute atom list for polymer (union of fragments) public :: generate_polymer_intersections !! Generate intersections for polymers public :: gmbe_enumerate_pie_terms !! DFS-based PIE coefficient enumeration contains function find_fragment_intersection ( frag1_atoms , n1 , frag2_atoms , n2 , & intersection , n_intersect ) result ( has_intersection ) !! Find shared atoms between two fragments (for GMBE with overlapping fragments) !! !! This function identifies atoms that appear in both fragments, which is essential !! for computing intersection-corrected energies in GMBE. !! !! Algorithm: O(n1 * n2) brute-force comparison !! - Loop through all atoms in fragment 1 !! - For each atom, check if it appears in fragment 2 !! - Collect all shared atoms !! !! Returns: !!   .true. if fragments share at least one atom, .false. otherwise !! !! Output: !!   intersection - allocatable array containing shared atom indices !!   n_intersect - number of shared atoms integer , intent ( in ) :: frag1_atoms (:) !! Atom indices in fragment 1 (0-indexed) integer , intent ( in ) :: n1 !! Number of atoms in fragment 1 integer , intent ( in ) :: frag2_atoms (:) !! Atom indices in fragment 2 (0-indexed) integer , intent ( in ) :: n2 !! Number of atoms in fragment 2 integer , allocatable , intent ( out ) :: intersection (:) !! Shared atom indices integer , intent ( out ) :: n_intersect !! Number of shared atoms logical :: has_intersection integer :: i , j integer , allocatable :: temp_intersection (:) integer :: temp_count ! Allocate temporary array (max possible size is min(n1, n2)) allocate ( temp_intersection ( min ( n1 , n2 ))) temp_count = 0 ! Find all shared atoms do i = 1 , n1 do j = 1 , n2 if ( frag1_atoms ( i ) == frag2_atoms ( j )) then ! Found a shared atom temp_count = temp_count + 1 temp_intersection ( temp_count ) = frag1_atoms ( i ) exit ! Move to next atom in frag1 end if end do end do ! Set output n_intersect = temp_count has_intersection = ( temp_count > 0 ) ! Allocate and copy result if intersection exists if ( has_intersection ) then allocate ( intersection ( n_intersect )) intersection = temp_intersection ( 1 : n_intersect ) end if deallocate ( temp_intersection ) end function find_fragment_intersection subroutine generate_intersections ( sys_geom , monomers , polymers , n_monomers , max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) !! !! For a system with overlapping fragments, this computes k-way intersections !! following the inclusion-exclusion principle for GMBE. !! The max_intersection_level parameter controls the maximum depth to avoid combinatorial explosion. !! !! Algorithm: !! - For each k from 2 to min(max_intersection_level, n_monomers): !!   - Generate all C(n_monomers, k) combinations !!   - For each combination, compute intersection of all k fragments !!   - Store non-empty intersections with their level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:) !! Monomer indices integer , intent ( inout ) :: polymers (:, :) !! Output: monomers stored here integer , intent ( in ) :: n_monomers !! Number of monomers integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth integer , allocatable , intent ( out ) :: intersections (:, :) !! Intersection atom lists integer , allocatable , intent ( out ) :: intersection_sets (:, :) !! Which k-tuple created each intersection integer , allocatable , intent ( out ) :: intersection_levels (:) !! Level (k) of each intersection integer , intent ( out ) :: n_intersections !! Number of intersections found ! Temporaries for storing intersections integer , allocatable :: temp_intersections (:, :) integer , allocatable :: temp_sets (:, :) integer , allocatable :: temp_levels (:) integer , allocatable :: temp_intersection (:) integer , allocatable :: current_intersection (:) integer :: temp_n_intersect , current_n_intersect logical :: has_intersection integer :: k , intersection_count , max_atoms , max_intersections , max_k_level integer :: i , idx integer , allocatable :: combination (:) ! Store monomers in polymers array polymers ( 1 : n_monomers , 1 ) = monomers ( 1 : n_monomers ) if ( n_monomers < 2 ) then n_intersections = 0 return end if ! Count maximum possible intersections: sum of C(n,k) for k=2 to n ! For small n, this is 2&#94;n - n - 1 max_intersections = 2 ** n_monomers - n_monomers - 1 ! Find maximum atoms in any fragment for allocation max_atoms = maxval ( sys_geom % fragment_sizes ( 1 : n_monomers )) ! Allocate temporary arrays allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_monomers , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 ! Determine actual maximum intersection level to use max_k_level = min ( max_intersection_level , n_monomers ) if ( max_k_level < n_monomers ) then call logger % info ( \"Generating k-way intersections up to k=\" // to_char ( max_k_level ) // & \" (limited by max_intersection_level)\" ) else call logger % info ( \"Generating all k-way intersections for GMBE (inclusion-exclusion principle)\" ) end if ! Loop over intersection levels k from 2 to max_k_level do k = 2 , max_k_level ! Generate all C(n_monomers, k) combinations allocate ( combination ( k )) call generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_monomers , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_monomers , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , max_k_level idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else call logger % info ( \"No intersections found (fragments are non-overlapping)\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections recursive subroutine generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Helper to generate all k-way intersections at a specific level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:), n_monomers , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , mono_idx , frag_size logical :: has_intersection ! Generate combinations using an iterative approach call next_combination_init ( combination , k ) do ! Compute intersection of all fragments in this combination has_intersection = . false . ! Start with the first fragment in the combination mono_idx = monomers ( combination ( 1 )) frag_size = sys_geom % fragment_sizes ( mono_idx ) allocate ( current_intersection ( frag_size )) current_intersection = sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ) current_n_intersect = frag_size ! Intersect with each subsequent fragment do i = 2 , k mono_idx = monomers ( combination ( i )) frag_size = sys_geom % fragment_sizes ( mono_idx ) has_intersection = find_fragment_intersection ( & current_intersection , current_n_intersect , & sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ), frag_size , & temp_intersection , temp_n_intersect ) if (. not . has_intersection ) then ! Intersection is empty, break early deallocate ( current_intersection ) if ( allocated ( temp_intersection )) deallocate ( temp_intersection ) exit end if ! Replace current_intersection with the new intersection deallocate ( current_intersection ) allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection current_n_intersect = temp_n_intersect deallocate ( temp_intersection ) end do ! If we have a non-empty intersection, store it if ( has_intersection . and . allocated ( current_intersection )) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection temp_sets ( 1 : k , intersection_count ) = monomers ( combination ) temp_levels ( intersection_count ) = k deallocate ( current_intersection ) end if ! Get next combination if (. not . next_combination ( combination , k , n_monomers )) exit end do end subroutine generate_k_way_intersections_for_level pure subroutine compute_polymer_atoms ( sys_geom , polymer , polymer_size , atom_list , n_atoms ) !! Compute the atom list for a polymer (union of atoms from base fragments) !! polymer(:) contains base fragment indices (1-based) use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymer (:) !! Base fragment indices in this polymer integer , intent ( in ) :: polymer_size !! Number of base fragments in polymer integer , allocatable , intent ( out ) :: atom_list (:) !! Unique atoms in this polymer integer , intent ( out ) :: n_atoms !! Number of unique atoms integer , allocatable :: temp_atoms (:) integer :: i , j , frag_idx , frag_size , temp_count logical :: already_present ! Allocate temporary array (worst case: all atoms from all fragments) allocate ( temp_atoms ( sys_geom % total_atoms )) temp_count = 0 ! Loop through each base fragment in the polymer do i = 1 , polymer_size frag_idx = polymer ( i ) if ( frag_idx == 0 ) exit ! Padding zeros frag_size = sys_geom % fragment_sizes ( frag_idx ) ! Add each atom from this fragment (avoid duplicates) do j = 1 , frag_size already_present = . false . ! Check if this atom is already in our list block integer :: k , current_atom current_atom = sys_geom % fragment_atoms ( j , frag_idx ) do k = 1 , temp_count if ( temp_atoms ( k ) == current_atom ) then already_present = . true . exit end if end do end block ! Add if not already present if (. not . already_present ) then temp_count = temp_count + 1 temp_atoms ( temp_count ) = sys_geom % fragment_atoms ( j , frag_idx ) end if end do end do ! Copy to output array n_atoms = temp_count allocate ( atom_list ( n_atoms )) atom_list = temp_atoms ( 1 : n_atoms ) deallocate ( temp_atoms ) end subroutine compute_polymer_atoms subroutine generate_polymer_intersections ( sys_geom , polymers , n_polymers , max_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for polymers at any level (GMBE-N) !! This works with dynamically generated polymers, not just base fragments use mqc_physical_fragment , only : system_geometry_t use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymers (:, :) !! Polymer definitions (n_polymers, max_level) integer , intent ( in ) :: n_polymers , max_level integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer , allocatable :: polymer_atoms (:, :) !! Atom lists for each polymer integer , allocatable :: polymer_n_atoms (:) !! Number of atoms in each polymer integer :: max_atoms_per_polymer integer :: i , polymer_size , max_intersection_level call logger % info ( \"Computing atom compositions for \" // to_char ( n_polymers ) // \" polymers...\" ) ! First, compute atom list for each polymer ! Find max atoms needed max_atoms_per_polymer = 0 do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) ! Worst case: all atoms from all fragments in this polymer max_atoms_per_polymer = max ( max_atoms_per_polymer , polymer_size * maxval ( sys_geom % fragment_sizes )) end do allocate ( polymer_atoms ( max_atoms_per_polymer , n_polymers )) allocate ( polymer_n_atoms ( n_polymers )) polymer_atoms = 0 ! Compute atoms for each polymer do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , polymers ( i , 1 : polymer_size ), polymer_size , atom_list , n_atoms ) polymer_n_atoms ( i ) = n_atoms polymer_atoms ( 1 : n_atoms , i ) = atom_list deallocate ( atom_list ) end block end do call logger % info ( \"Finding intersections between polymers...\" ) ! For GMBE(N), limit intersections to level N+1 to prevent combinatorial explosion ! GMBE(2): dimers → 3-way intersections max ! GMBE(3): trimers → 4-way intersections max max_intersection_level = max_level + 1 call logger % info ( \"Limiting intersections to level \" // to_char ( max_intersection_level ) // & \" (polymer level \" // to_char ( max_level ) // \" + 1)\" ) ! Now generate intersections between these polymer atom sets call generate_intersections_from_atom_lists ( polymer_atoms , polymer_n_atoms , n_polymers , & max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) deallocate ( polymer_atoms , polymer_n_atoms ) end subroutine generate_polymer_intersections subroutine generate_intersections_from_atom_lists ( atom_lists , n_atoms_list , n_sets , max_k_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate k-way intersections from arbitrary atom lists (not tied to sys_geom) !! max_k_level limits the maximum intersection order to prevent combinatorial explosion use pic_logger , only : logger => global_logger use pic_io , only : to_char integer , intent ( in ) :: atom_lists (:, :) !! (max_atoms, n_sets) integer , intent ( in ) :: n_atoms_list (:) !! Number of atoms in each set integer , intent ( in ) :: n_sets !! Number of sets (polymers) integer , intent ( in ) :: max_k_level !! Maximum intersection level to compute integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer :: max_intersections , max_atoms integer , allocatable :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer :: intersection_count , k , idx , actual_max_k integer , allocatable :: combination (:) if ( n_sets < 2 ) then n_intersections = 0 return end if ! Limit k-way intersections to min(max_k_level, n_sets) actual_max_k = min ( max_k_level , n_sets ) max_intersections = 2 ** n_sets - n_sets - 1 max_atoms = maxval ( n_atoms_list ) allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_sets , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 call logger % info ( \"Generating k-way intersections (k=2 to \" // to_char ( actual_max_k ) // \")\" ) ! Loop over intersection levels k from 2 to actual_max_k do k = 2 , actual_max_k allocate ( combination ( k )) call generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_sets , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_sets , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , actual_max_k idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else allocate ( intersections ( 1 , 0 )) allocate ( intersection_sets ( 1 , 0 )) allocate ( intersection_levels ( 0 )) call logger % info ( \"No intersections found\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections_from_atom_lists subroutine generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Generate all k-way intersections from atom lists integer , intent ( in ) :: atom_lists (:, :), n_atoms_list (:), n_sets , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , set_idx logical :: has_intersection call next_combination_init ( combination , k ) do ! Compute intersection of all sets in this combination has_intersection = . false . ! Start with the first set in the combination set_idx = combination ( 1 ) allocate ( current_intersection ( n_atoms_list ( set_idx ))) current_intersection = atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) current_n_intersect = n_atoms_list ( set_idx ) ! Intersect with each subsequent set do i = 2 , k set_idx = combination ( i ) allocate ( temp_intersection ( current_n_intersect )) ! Find intersection temp_n_intersect = 0 do j = 1 , current_n_intersect if ( any ( atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) == current_intersection ( j ))) then temp_n_intersect = temp_n_intersect + 1 temp_intersection ( temp_n_intersect ) = current_intersection ( j ) end if end do ! Update current intersection deallocate ( current_intersection ) if ( temp_n_intersect > 0 ) then allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection ( 1 : temp_n_intersect ) current_n_intersect = temp_n_intersect has_intersection = . true . else has_intersection = . false . end if deallocate ( temp_intersection ) if (. not . has_intersection ) exit end do ! Store if we found an intersection if ( has_intersection . and . current_n_intersect > 0 ) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection ( 1 : current_n_intersect ) temp_sets ( 1 : k , intersection_count ) = combination ( 1 : k ) temp_levels ( intersection_count ) = k end if if ( allocated ( current_intersection )) deallocate ( current_intersection ) ! Get next combination if (. not . next_combination ( combination , k , n_sets )) exit end do end subroutine generate_k_way_intersections_from_lists subroutine gmbe_enumerate_pie_terms ( sys_geom , primaries , n_primaries , polymer_level , max_k_level , & pie_atom_sets , pie_coefficients , n_pie_terms , initial_max_terms ) !! Enumerate all unique intersections via DFS and accumulate PIE coefficients !! This implements the GMBE(N) algorithm with inclusion-exclusion principle !! !! Algorithm: !! 1. For each primary i, start DFS with clique=[i] !! 2. Recursively grow cliques by adding overlapping primaries !! 3. For each clique of size k, compute intersection and add PIE coefficient: !!    coefficient = (+1) if k odd, (-1) if k even !! 4. Accumulate coefficients for each unique atom set use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: primaries (:, :) !! Primary polymers (n_primaries, polymer_level) integer , intent ( in ) :: n_primaries !! Number of primary polymers integer , intent ( in ) :: polymer_level !! Level of primaries (1=monomers, 2=dimers, etc.) integer , intent ( in ) :: max_k_level !! Maximum clique size (intersection depth limit) integer , allocatable , intent ( out ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_terms) integer , allocatable , intent ( out ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( out ) :: n_pie_terms !! Number of unique PIE terms integer ( int64 ), intent ( in ), optional :: initial_max_terms !! Initial PIE storage capacity ! Temporary storage for PIE terms (allocate generously) integer ( int64 ), parameter :: INITIAL_MAX_PIE_TERMS = 100000_int64 ! Adjust if needed integer ( int64 ) :: max_terms integer ( default_int ) :: max_terms_i integer , allocatable :: temp_atom_sets (:, :) integer , allocatable :: temp_coefficients (:) integer , allocatable :: primary_atoms (:, :) !! Precomputed atom lists for each primary integer , allocatable :: primary_n_atoms (:) !! Atom counts for each primary integer , allocatable :: clique (:) !! Current clique being built integer , allocatable :: current_atoms (:) !! Current intersection atoms integer , allocatable :: candidates (:) !! Candidate primaries to add integer :: i , j , max_atoms , n_candidates call logger % info ( \"Enumerating GMBE PIE terms via DFS...\" ) ! Find maximum atoms in any fragment max_atoms = sys_geom % total_atoms ! Allocate temporary storage if ( present ( initial_max_terms )) then max_terms = initial_max_terms else max_terms = INITIAL_MAX_PIE_TERMS end if if ( max_terms < 1_int64 ) then call logger % error ( \"Initial PIE term capacity must be positive\" ) error stop \"Invalid initial PIE term capacity\" end if if ( max_terms > int ( huge ( 0_default_int ), int64 )) then call logger % error ( \"Initial PIE term capacity exceeds default integer limit\" ) error stop \"Invalid initial PIE term capacity\" end if max_terms_i = int ( max_terms , default_int ) allocate ( temp_atom_sets ( max_atoms , max_terms_i )) allocate ( temp_coefficients ( max_terms_i )) temp_atom_sets = - 1 temp_coefficients = 0 n_pie_terms = 0_int64 ! Precompute atom lists for all primaries allocate ( primary_atoms ( max_atoms , n_primaries )) allocate ( primary_n_atoms ( n_primaries )) primary_atoms = - 1 do i = 1 , n_primaries block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , primaries ( i , :), polymer_level , atom_list , n_atoms ) primary_n_atoms ( i ) = n_atoms primary_atoms ( 1 : n_atoms , i ) = atom_list ( 1 : n_atoms ) deallocate ( atom_list ) end block end do ! Allocate work arrays allocate ( clique ( max_k_level )) allocate ( current_atoms ( max_atoms )) allocate ( candidates ( n_primaries )) ! Start DFS from each primary do i = 1 , n_primaries ! Initial clique: just primary i clique ( 1 ) = i current_atoms ( 1 : primary_n_atoms ( i )) = primary_atoms ( 1 : primary_n_atoms ( i ), i ) ! Candidates: all primaries after i (to avoid duplicates) n_candidates = n_primaries - i if ( n_candidates > 0 ) then candidates ( 1 : n_candidates ) = [( i + j , j = 1 , n_candidates )] end if ! DFS from this primary call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , 1 , current_atoms ( 1 : primary_n_atoms ( i )), primary_n_atoms ( i ), & candidates , n_candidates , max_k_level , & temp_atom_sets , temp_coefficients , n_pie_terms , max_terms ) end do ! Copy to output arrays if ( n_pie_terms > 0_int64 ) then if ( n_pie_terms > int ( huge ( 0_default_int ), int64 )) then call logger % error ( \"n_pie_terms exceeds default integer limit\" ) error stop \"PIE term count too large for allocation\" end if allocate ( pie_atom_sets ( max_atoms , int ( n_pie_terms , default_int ))) allocate ( pie_coefficients ( int ( n_pie_terms , default_int ))) pie_atom_sets = temp_atom_sets (:, 1 : n_pie_terms ) pie_coefficients = temp_coefficients ( 1 : n_pie_terms ) end if call logger % info ( \"Generated \" // to_char ( n_pie_terms ) // \" unique PIE terms\" ) ! Cleanup deallocate ( temp_atom_sets , temp_coefficients , primary_atoms , primary_n_atoms ) deallocate ( clique , current_atoms , candidates ) end subroutine gmbe_enumerate_pie_terms recursive subroutine dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , clique_size , current_atoms , n_current_atoms , & candidates , n_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms ) !! DFS helper: accumulate PIE coefficients for intersections integer , intent ( in ) :: primary_atoms (:, :) !! Precomputed atom lists integer , intent ( in ) :: primary_n_atoms (:) !! Atom counts integer , intent ( in ) :: n_primaries , max_atoms integer , intent ( in ) :: clique (:) !! Current clique integer , intent ( in ) :: clique_size !! Size of current clique integer , intent ( in ) :: current_atoms (:) !! Atoms in current intersection integer , intent ( in ) :: n_current_atoms !! Number of atoms in intersection integer , intent ( in ) :: candidates (:) !! Candidate primaries integer , intent ( in ) :: n_candidates integer , intent ( in ) :: max_k_level integer , allocatable , intent ( inout ) :: atom_sets (:, :) integer , allocatable , intent ( inout ) :: coefficients (:) integer ( int64 ), intent ( inout ) :: n_terms integer ( int64 ), intent ( inout ) :: max_terms integer :: sign , i , candidate_idx , candidate_pos integer ( int64 ) :: term_idx integer , allocatable :: new_atoms (:), new_candidates (:) integer :: n_new_atoms , n_new_candidates logical :: found ! Skip empty intersections if ( n_current_atoms == 0 ) return ! Compute PIE sign: (+1) for odd clique size, (-1) for even sign = merge ( 1 , - 1 , mod ( clique_size , 2 ) == 1 ) ! Find or create entry for this atom set found = . false . do term_idx = 1_int64 , n_terms if ( atom_sets_equal ( atom_sets (:, term_idx ), current_atoms , n_current_atoms )) then coefficients ( term_idx ) = coefficients ( term_idx ) + sign found = . true . exit end if end do if (. not . found ) then ! New atom set if ( n_terms >= max_terms ) then call grow_pie_storage ( atom_sets , coefficients , max_terms , max_atoms ) end if n_terms = n_terms + 1_int64 atom_sets ( 1 : n_current_atoms , n_terms ) = current_atoms ( 1 : n_current_atoms ) atom_sets ( n_current_atoms + 1 :, n_terms ) = - 1 coefficients ( n_terms ) = sign end if ! Stop if we've reached maximum clique size if ( clique_size >= max_k_level ) return if ( n_candidates == 0 ) return ! Try adding each candidate to the clique allocate ( new_atoms ( max_atoms )) allocate ( new_candidates ( n_primaries )) do i = 1 , n_candidates candidate_idx = candidates ( i ) ! Compute intersection with this candidate call intersect_atom_lists ( current_atoms , n_current_atoms , & primary_atoms (:, candidate_idx ), primary_n_atoms ( candidate_idx ), & new_atoms , n_new_atoms ) ! Skip if no intersection if ( n_new_atoms == 0 ) cycle ! New candidates: must come after this one and overlap with new_atoms n_new_candidates = 0 do candidate_pos = i + 1 , n_candidates block integer :: test_candidate , test_n_intersect integer , allocatable :: test_intersect (:) test_candidate = candidates ( candidate_pos ) allocate ( test_intersect ( max_atoms )) call intersect_atom_lists ( new_atoms , n_new_atoms , & primary_atoms (:, test_candidate ), primary_n_atoms ( test_candidate ), & test_intersect , test_n_intersect ) if ( test_n_intersect > 0 ) then n_new_candidates = n_new_candidates + 1 new_candidates ( n_new_candidates ) = test_candidate end if deallocate ( test_intersect ) end block end do ! Recurse block integer :: new_clique ( clique_size + 1 ) new_clique ( 1 : clique_size ) = clique ( 1 : clique_size ) new_clique ( clique_size + 1 ) = candidate_idx call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & new_clique , clique_size + 1 , new_atoms , n_new_atoms , & new_candidates , n_new_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms ) end block end do deallocate ( new_atoms , new_candidates ) end subroutine dfs_pie_accumulate subroutine grow_pie_storage ( atom_sets , coefficients , max_terms , max_atoms ) !! Grow PIE term storage arrays when capacity is exceeded. integer , allocatable , intent ( inout ) :: atom_sets (:, :) integer , allocatable , intent ( inout ) :: coefficients (:) integer ( int64 ), intent ( inout ) :: max_terms integer , intent ( in ) :: max_atoms integer ( int64 ) :: new_max_terms integer ( default_int ) :: old_terms_i , new_terms_i integer , allocatable :: new_atom_sets (:, :) integer , allocatable :: new_coefficients (:) integer ( int64 ) :: max_default_int max_default_int = int ( huge ( 0_default_int ), int64 ) new_max_terms = max_terms * 2_int64 if ( new_max_terms <= max_terms ) then call logger % error ( \"PIE term capacity overflow\" ) error stop \"PIE term capacity overflow\" end if if ( new_max_terms > max_default_int ) then new_max_terms = max_default_int end if if ( new_max_terms == max_terms ) then call logger % error ( \"Exceeded maximum PIE terms (\" // to_char ( max_terms ) // \")\" ) error stop \"Exceeded maximum PIE terms\" end if old_terms_i = int ( max_terms , default_int ) new_terms_i = int ( new_max_terms , default_int ) allocate ( new_atom_sets ( max_atoms , new_terms_i )) new_atom_sets = - 1 new_atom_sets (:, 1 : old_terms_i ) = atom_sets (:, 1 : old_terms_i ) allocate ( new_coefficients ( new_terms_i )) new_coefficients = 0 new_coefficients ( 1 : old_terms_i ) = coefficients ( 1 : old_terms_i ) call move_alloc ( new_atom_sets , atom_sets ) call move_alloc ( new_coefficients , coefficients ) max_terms = new_max_terms end subroutine grow_pie_storage pure function atom_sets_equal ( set1 , set2 , n_atoms ) result ( equal ) !! Check if two atom sets are equal (assuming sorted) integer , intent ( in ) :: set1 (:), set2 (:) integer , intent ( in ) :: n_atoms logical :: equal integer :: i equal = . true . do i = 1 , n_atoms if ( set1 ( i ) /= set2 ( i )) then equal = . false . return end if end do end function atom_sets_equal pure subroutine intersect_atom_lists ( atoms1 , n1 , atoms2 , n2 , intersection , n_intersect ) !! Compute intersection of two atom lists integer , intent ( in ) :: atoms1 (:), n1 , atoms2 (:), n2 integer , intent ( out ) :: intersection (:) integer , intent ( out ) :: n_intersect integer :: i , j n_intersect = 0 do i = 1 , n1 if ( atoms1 ( i ) < 0 ) cycle do j = 1 , n2 if ( atoms2 ( j ) < 0 ) cycle if ( atoms1 ( i ) == atoms2 ( j )) then n_intersect = n_intersect + 1 intersection ( n_intersect ) = atoms1 ( i ) exit end if end do end do end subroutine intersect_atom_lists end module mqc_gmbe_utils","tags":"","url":"sourcefile/mqc_gmbe_utils.f90.html"},{"title":"mqc_serial_fragment_processor.f90 – metalquicha","text":"This file depends on sourcefile~~mqc_serial_fragment_processor.f90~~EfferentGraph sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( mqc_mbe_fragment_distribution_scheme ) mqc_serial_fragment_processor implicit none contains module subroutine serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method , calc_type , bonds ) !! Process all fragments serially in single-rank mode !! This is used when running with only 1 MPI rank use mqc_error , only : error_t integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: polymers (:, :), max_level type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int64 ) :: frag_idx integer :: fragment_size , current_log_level , iatom integer , allocatable :: fragment_indices (:) type ( calculation_result_t ), allocatable :: results (:) real ( dp ) :: mbe_total_energy real ( dp ), allocatable :: mbe_total_gradient (:, :) real ( dp ), allocatable :: mbe_total_hessian (:, :) type ( physical_fragment_t ) :: phys_frag type ( timer_type ) :: coord_timer integer ( int32 ) :: calc_type_local type ( error_t ) :: error calc_type_local = calc_type call logger % info ( \"Processing \" // to_char ( total_fragments ) // \" fragments serially...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type_local )) allocate ( results ( total_fragments )) call omp_set_num_threads ( 1 ) call coord_timer % start () do frag_idx = 1_int64 , total_fragments fragment_size = count ( polymers ( frag_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( frag_idx , 1 : fragment_size ) call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build fragment in serial processing\" end if call do_fragment_work ( frag_idx , results ( frag_idx ), method , phys_frag , calc_type = calc_type_local ) ! Debug output for gradients if ( calc_type_local == CALC_TYPE_GRADIENT . and . results ( frag_idx )% has_gradient ) then call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level ) then block character ( len = 512 ) :: debug_line integer :: iatom_local write ( debug_line , '(a,i0,a,*(i0,1x))' ) \"Fragment \" , frag_idx , \" monomers: \" , fragment_indices call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Energy: \" , results ( frag_idx )% energy % total () call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( results ( frag_idx )% gradient ** 2 )) call logger % verbose ( trim ( debug_line )) if ( size ( results ( frag_idx )% gradient , 2 ) <= 20 ) then call logger % verbose ( \"  Fragment gradient:\" ) do iatom_local = 1 , size ( results ( frag_idx )% gradient , 2 ) write ( debug_line , '(a,i3,a,3f20.12)' ) \"    Atom \" , iatom_local , \": \" , & results ( frag_idx )% gradient ( 1 , iatom_local ), & results ( frag_idx )% gradient ( 2 , iatom_local ), & results ( frag_idx )% gradient ( 3 , iatom_local ) call logger % verbose ( trim ( debug_line )) end do end if end block end if end if call phys_frag % destroy () deallocate ( fragment_indices ) if ( mod ( frag_idx , max ( 1_int64 , total_fragments / 10 )) == 0 . or . frag_idx == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( frag_idx ) // \"/\" // to_char ( total_fragments ) // & \" fragments [\" // to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call omp_set_num_threads ( omp_get_max_threads ()) call logger % info ( \"All fragments processed\" ) call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Use unified compute_mbe with optional arguments based on calc_type if ( calc_type_local == CALC_TYPE_HESSIAN ) then allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) allocate ( mbe_total_hessian ( 3 * sys_geom % total_atoms , 3 * sys_geom % total_atoms )) call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy , & sys_geom , mbe_total_gradient , mbe_total_hessian , bonds ) deallocate ( mbe_total_gradient , mbe_total_hessian ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy , & sys_geom , mbe_total_gradient , bonds = bonds ) deallocate ( mbe_total_gradient ) else call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy ) end if call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) deallocate ( results ) end subroutine serial_fragment_processor end submodule mqc_serial_fragment_processor","tags":"","url":"sourcefile/mqc_serial_fragment_processor.f90.html"},{"title":"mqc_io_helpers.f90 – metalquicha","text":"IO helper utilities for file naming and string operations\nProvides utilities for output filename management and string parsing Files dependent on this one sourcefile~~mqc_io_helpers.f90~~AfferentGraph sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! IO helper utilities for file naming and string operations !! Provides utilities for output filename management and string parsing module mqc_io_helpers implicit none private character ( len = 256 ), save :: output_json_filename = \"results.json\" character ( len = 256 ), save :: current_basename = \"\" public :: set_output_json_filename , get_output_json_filename , get_basename public :: set_molecule_suffix public :: get_molecule_name , ends_with contains subroutine set_output_json_filename ( input_filename ) !! Set the JSON output filename based on input filename !! Example: \"water.mqc\" -> \"output_water.json\" character ( len =* ), intent ( in ) :: input_filename integer :: dot_pos , slash_pos character ( len = 256 ) :: basename ! Find last slash (if any) to extract basename slash_pos = index ( input_filename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = input_filename ( slash_pos + 1 :) else basename = input_filename end if ! Find last dot to remove extension dot_pos = index ( basename , '.' , back = . true .) if ( dot_pos > 0 ) then basename = basename ( 1 : dot_pos - 1 ) end if ! Store basename for later use current_basename = trim ( basename ) ! Construct output filename: output_<basename>.json output_json_filename = \"output_\" // trim ( basename ) // \".json\" end subroutine set_output_json_filename subroutine set_molecule_suffix ( suffix ) !! Append a suffix to the output filename (e.g., for multi-molecule mode) !! Example: suffix=\"_mol1\" -> \"output_multi_structure_mol1.json\" character ( len =* ), intent ( in ) :: suffix if ( len_trim ( current_basename ) > 0 ) then output_json_filename = \"output_\" // trim ( current_basename ) // trim ( suffix ) // \".json\" end if end subroutine set_molecule_suffix function get_output_json_filename () result ( filename ) !! Get the current JSON output filename character ( len = 256 ) :: filename filename = trim ( output_json_filename ) end function get_output_json_filename function get_basename () result ( basename ) !! Get the base name without \"output_\" prefix and \".json\" suffix !! Example: \"output_w1.json\" -> \"w1\" character ( len = 256 ) :: basename integer :: start_pos , end_pos ! Remove \"output_\" prefix (7 characters) start_pos = 8 ! Find \".json\" suffix end_pos = index ( output_json_filename , '.json' , back = . true .) - 1 if ( end_pos > start_pos ) then basename = output_json_filename ( start_pos : end_pos ) else basename = \"unknown\" end if end function get_basename function get_molecule_name ( filename ) result ( name ) !! Extract molecule name from filename !! Example: \"output_multi_structure_molecule_1.json\" -> \"molecule_1\" character ( len =* ), intent ( in ) :: filename character ( len = 256 ) :: name integer :: start_pos , end_pos ! Find \"_molecule_\" or similar pattern start_pos = index ( filename , '_molecule_' ) if ( start_pos == 0 ) start_pos = index ( filename , '_mol_' ) if ( start_pos > 0 ) then start_pos = start_pos + 1 ! Skip leading underscore end_pos = index ( filename , '.json' ) - 1 if ( end_pos > start_pos ) then name = filename ( start_pos : end_pos ) else name = \"unknown\" end if else name = \"unknown\" end if end function get_molecule_name logical function ends_with ( str , suffix ) !! Check if string ends with suffix character ( len =* ), intent ( in ) :: str , suffix integer :: str_len , suffix_len str_len = len_trim ( str ) suffix_len = len_trim ( suffix ) if ( suffix_len > str_len ) then ends_with = . false . return end if ends_with = ( str ( str_len - suffix_len + 1 : str_len ) == suffix ) end function ends_with end module mqc_io_helpers","tags":"","url":"sourcefile/mqc_io_helpers.f90.html"},{"title":"mqc_mbe.f90 – metalquicha","text":"Many-Body Expansion (MBE) calculation module This file depends on sourcefile~~mqc_mbe.f90~~EfferentGraph sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe.f90~~AfferentGraph sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Many-Body Expansion (MBE) calculation module module mqc_mbe !! Implements hierarchical many-body expansion for fragment-based quantum chemistry !! calculations with MPI parallelization and energy/gradient computation. use pic_types , only : int32 , int64 , dp use pic_timer , only : timer_type use pic_mpi_lib , only : comm_t , send , recv , iprobe , MPI_Status , MPI_ANY_SOURCE , MPI_ANY_TAG use pic_logger , only : logger => global_logger , verbose_level , debug_level , info_level use pic_io , only : to_char use mqc_mbe_io , only : print_detailed_breakdown , print_detailed_breakdown_json use mqc_mpi_tags , only : TAG_WORKER_REQUEST , TAG_WORKER_FRAGMENT , TAG_WORKER_FINISH , & TAG_WORKER_SCALAR_RESULT , & TAG_NODE_REQUEST , TAG_NODE_FRAGMENT , TAG_NODE_FINISH , & TAG_NODE_SCALAR_RESULT use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , build_fragment_from_indices , to_angstrom use mqc_frag_utils , only : get_next_combination , fragment_lookup_t use mqc_vibrational_analysis , only : compute_vibrational_analysis , print_vibrational_analysis implicit none private ! Public interface public :: compute_mbe !! MBE energy with optional gradient and hessian public :: compute_gmbe !! GMBE energy with optional gradient and hessian contains function compute_mbe_delta ( fragment_idx , fragment , lookup , energies , delta_energies , n ) result ( delta_E ) !! Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas) !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all subset deltaE values !! All subsets must have been computed already (guaranteed by processing fragments in order) integer ( int64 ), intent ( in ) :: fragment_idx !! Index of this fragment (already known) integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup !! Pre-built hash table for lookups real ( dp ), intent ( in ) :: energies (:), delta_energies (:) !! Pre-computed delta values real ( dp ) :: delta_E ! Maximum MBE level supported (decamers) integer , parameter :: MAX_MBE_LEVEL = 10 integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer energy delta_E = energies ( fragment_idx ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx < 0 ) then block use pic_io , only : to_char character ( len = 512 ) :: error_msg integer :: j write ( error_msg , '(a,i0,a,*(i0,1x))' ) \"Subset not found! Fragment idx=\" , fragment_idx , & \" seeking subset: \" , ( subset ( j ), j = 1 , subset_size ) call logger % error ( trim ( error_msg )) write ( error_msg , '(a,*(i0,1x))' ) \"  Full fragment: \" , ( fragment ( j ), j = 1 , n ) call logger % error ( trim ( error_msg )) error stop \"Subset not found in bottom-up MBE!\" end block end if ! Subtract pre-computed delta energy delta_E = delta_E - delta_energies ( subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end function compute_mbe_delta subroutine map_fragment_to_system_gradient ( frag_grad , monomers , sys_geom , sys_grad , bonds ) !! Map fragment gradient to system gradient coordinates with hydrogen cap redistribution !! !! This function rebuilds the fragment to get local→global mappings and cap information, !! then redistributes gradients including hydrogen caps to their original atoms. !! !! If bonds are not present, uses the old simple mapping (no caps possible). use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_gradients use mqc_config_parser , only : bond_t use mqc_error , only : error_t use pic_logger , only : verbose_level real ( dp ), intent ( in ) :: frag_grad (:, :) !! (3, natoms_frag) integer , intent ( in ) :: monomers (:) !! Monomer indices in fragment type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_grad (:, :) !! (3, total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps type ( physical_fragment_t ) :: fragment type ( error_t ) :: error integer :: i_mon , i_atom , frag_atom_idx , sys_atom_idx integer :: current_log_level ! Explicitly zero out the entire sys_grad array sys_grad = 0.0_dp ! Debug output call logger % configuration ( level = current_log_level ) if ( current_log_level >= debug_level ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,*(i0,1x))' ) \"  Mapping fragment with \" , size ( monomers ), \" monomers: \" , monomers call logger % debug ( trim ( debug_msg )) write ( debug_msg , '(a,i0,a)' ) \"  Fragment has \" , size ( frag_grad , 2 ), \" atoms\" call logger % debug ( trim ( debug_msg )) end block end if if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build fragment in gradient mapping\" end if ! Use new gradient redistribution with cap handling call redistribute_cap_gradients ( fragment , frag_grad , sys_grad ) ! Clean up call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment gradient to system positions (fixed-size monomers only) frag_atom_idx = 0 do i_mon = 1 , size ( monomers ) do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_idx = frag_atom_idx + 1 sys_atom_idx = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom if ( current_log_level >= debug_level . and . i_atom == 1 ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,i0,a,i0)' ) & \"    Monomer \" , monomers ( i_mon ), \": frag atoms \" , & frag_atom_idx , \" -> sys atom \" , sys_atom_idx call logger % debug ( trim ( debug_msg )) end block end if sys_grad (:, sys_atom_idx ) = frag_grad (:, frag_atom_idx ) end do end do end if end subroutine map_fragment_to_system_gradient subroutine compute_mbe_gradient ( fragment_idx , fragment , lookup , results , delta_gradients , n , sys_geom , bonds ) !! Bottom-up computation of n-body gradient correction !! Exactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs) !! All gradients are in system coordinates, so subtraction is simple use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_gradients (:, :, :) !! (3, total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps ! Maximum MBE level supported (decamers) integer , parameter :: MAX_MBE_LEVEL = 10 integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer gradient mapped to system coordinates call map_fragment_to_system_gradient ( results ( fragment_idx )% gradient , fragment , & sys_geom , delta_gradients (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) ! This is EXACTLY like the energy calculation, but for each gradient component do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx < 0 ) error stop \"Subset not found in MBE gradient!\" ! Subtract pre-computed delta gradient (simple array subtraction in system coords) delta_gradients (:, :, fragment_idx ) = delta_gradients (:, :, fragment_idx ) - & delta_gradients (:, :, subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end subroutine compute_mbe_gradient subroutine map_fragment_to_system_hessian ( frag_hess , monomers , sys_geom , sys_hess , bonds ) !! Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_hessian use mqc_config_parser , only : bond_t use mqc_error , only : error_t real ( dp ), intent ( in ) :: frag_hess (:, :) !! (3*natoms_frag, 3*natoms_frag) integer , intent ( in ) :: monomers (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_hess (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: fragment type ( error_t ) :: error ! Zero out sys_hess = 0.0_dp if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , error , bonds ) call redistribute_cap_hessian ( fragment , frag_hess , sys_hess ) call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment Hessian to system positions (fixed-size monomers only) block integer :: i_mon , j_mon , i_atom , j_atom integer :: frag_atom_i , frag_atom_j , sys_atom_i , sys_atom_j integer :: frag_row_start , frag_col_start , sys_row_start , sys_col_start integer :: n_monomers n_monomers = size ( monomers ) frag_atom_i = 0 ! Map each monomer's atoms do i_mon = 1 , n_monomers do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_i = frag_atom_i + 1 sys_atom_i = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom frag_row_start = ( frag_atom_i - 1 ) * 3 + 1 sys_row_start = ( sys_atom_i - 1 ) * 3 + 1 ! Map this atom's Hessian blocks with all other atoms in fragment frag_atom_j = 0 do j_mon = 1 , n_monomers do j_atom = 1 , sys_geom % atoms_per_monomer frag_atom_j = frag_atom_j + 1 sys_atom_j = ( monomers ( j_mon ) - 1 ) * sys_geom % atoms_per_monomer + j_atom frag_col_start = ( frag_atom_j - 1 ) * 3 + 1 sys_col_start = ( sys_atom_j - 1 ) * 3 + 1 ! Copy the 3×3 block for this atom pair sys_hess ( sys_row_start : sys_row_start + 2 , sys_col_start : sys_col_start + 2 ) = & frag_hess ( frag_row_start : frag_row_start + 2 , frag_col_start : frag_col_start + 2 ) end do end do end do end do end block end if end subroutine map_fragment_to_system_hessian subroutine compute_mbe_hessian ( fragment_idx , fragment , lookup , results , delta_hessians , n , sys_geom , bonds ) !! Bottom-up computation of n-body Hessian correction !! Mirrors MBE gradient logic but for second derivatives use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t use mqc_error , only : error_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_hessians (:, :, :) !! (3*total_atoms, 3*total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) ! Maximum MBE level supported (decamers) integer , parameter :: MAX_MBE_LEVEL = 10 integer :: subset_size , i , hess_dim integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next hess_dim = 3 * sys_geom % total_atoms ! Start with the full n-mer Hessian mapped to system coordinates call map_fragment_to_system_hessian ( results ( fragment_idx )% hessian , fragment , & sys_geom , delta_hessians (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do has_next = . true . do while ( has_next ) do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx > 0 ) then ! Subtract this subset's delta Hessian delta_hessians (:, :, fragment_idx ) = delta_hessians (:, :, fragment_idx ) - & delta_hessians (:, :, subset_idx ) end if call get_next_combination ( indices , subset_size , n , has_next ) end do end do end subroutine compute_mbe_hessian !--------------------------------------------------------------------------- ! Helper subroutines for reducing code duplication !--------------------------------------------------------------------------- subroutine build_mbe_lookup_table ( polymers , fragment_count , max_level , lookup ) !! Build hash table for fast fragment lookups integer , intent ( in ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: max_level type ( fragment_lookup_t ), intent ( inout ) :: lookup integer ( int64 ) :: i integer :: fragment_size type ( timer_type ) :: lookup_timer call lookup_timer % start () call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) call lookup % insert ( polymers ( i , :), fragment_size , i ) end do call lookup_timer % stop () call logger % debug ( \"Time to build lookup table: \" // to_char ( lookup_timer % get_elapsed_time ()) // \" s\" ) call logger % debug ( \"Hash table size: \" // to_char ( lookup % table_size ) // & \", entries: \" // to_char ( lookup % n_entries )) end subroutine build_mbe_lookup_table subroutine print_mbe_energy_breakdown ( sum_by_level , max_level , total_energy ) !! Print MBE energy breakdown to logger real ( dp ), intent ( in ) :: sum_by_level (:) integer , intent ( in ) :: max_level real ( dp ), intent ( in ) :: total_energy integer :: nlevel character ( len = 256 ) :: energy_line call logger % info ( \"MBE Energy breakdown:\" ) do nlevel = 1 , max_level if ( abs ( sum_by_level ( nlevel )) > 1e-15_dp ) then write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , nlevel , \"-body:  \" , sum_by_level ( nlevel ) call logger % info ( trim ( energy_line )) end if end do write ( energy_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( energy_line )) end subroutine print_mbe_energy_breakdown subroutine print_mbe_gradient_info ( total_gradient , sys_geom , current_log_level ) !! Print MBE gradient information real ( dp ), intent ( in ) :: total_gradient (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: current_log_level integer :: iatom character ( len = 256 ) :: grad_line call logger % info ( \"MBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total MBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end do call logger % info ( \" \" ) end if end subroutine print_mbe_gradient_info subroutine compute_mbe ( polymers , fragment_count , max_level , results , & total_energy , & sys_geom , total_gradient , total_hessian , bonds ) !! Compute many-body expansion (MBE) energy with optional gradient and/or hessian !! !! This is the core routine that handles all MBE computations. !! Optional arguments control what derivatives are computed: !!   - If sys_geom and total_gradient are present: compute gradient !!   - If total_hessian is also present: compute hessian use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t ! Required arguments integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( out ) :: total_energy ! Optional arguments for gradient computation type ( system_geometry_t ), intent ( in ), optional :: sys_geom real ( dp ), intent ( out ), optional :: total_gradient (:, :) !! (3, total_atoms) ! Optional arguments for hessian computation real ( dp ), intent ( out ), optional :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) ! Optional bond information for hydrogen cap handling type ( bond_t ), intent ( in ), optional :: bonds (:) ! Local variables integer ( int64 ) :: i integer :: fragment_size , nlevel , current_log_level , hess_dim real ( dp ), allocatable :: sum_by_level (:), delta_energies (:), energies (:) real ( dp ), allocatable :: delta_gradients (:, :, :), delta_hessians (:, :, :) real ( dp ) :: delta_E logical :: do_detailed_print , compute_grad , compute_hess type ( fragment_lookup_t ) :: lookup ! Determine what to compute based on optional arguments compute_grad = present ( sys_geom ) . and . present ( total_gradient ) compute_hess = compute_grad . and . present ( total_hessian ) ! Validate inputs for gradient computation if ( compute_grad ) then do i = 1_int64 , fragment_count if (. not . results ( i )% has_gradient ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have gradient!\" ) error stop \"Missing gradient in compute_mbe_internal\" end if end do end if ! Validate inputs for hessian computation if ( compute_hess ) then do i = 1_int64 , fragment_count if (. not . results ( i )% has_hessian ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have Hessian!\" ) error stop \"Missing Hessian in compute_mbe_internal\" end if end do hess_dim = 3 * sys_geom % total_atoms end if ! Get logger configuration call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) ! Allocate energy arrays (always needed) allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) allocate ( energies ( fragment_count )) sum_by_level = 0.0_dp delta_energies = 0.0_dp ! Extract total energies from results do i = 1_int64 , fragment_count energies ( i ) = results ( i )% energy % total () end do ! Allocate gradient arrays if needed if ( compute_grad ) then allocate ( delta_gradients ( 3 , sys_geom % total_atoms , fragment_count )) delta_gradients = 0.0_dp total_gradient = 0.0_dp end if ! Allocate hessian arrays if needed if ( compute_hess ) then allocate ( delta_hessians ( hess_dim , hess_dim , fragment_count )) delta_hessians = 0.0_dp total_hessian = 0.0_dp end if ! Build hash table for fast fragment lookups call build_mbe_lookup_table ( polymers , fragment_count , max_level , lookup ) ! Bottom-up computation: process fragments by size (1-body, then 2-body, etc.) ! This makes the algorithm independent of input fragment order ! We process by n-mer level to ensure all subsets are computed before they're needed do nlevel = 1 , max_level do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) ! Only process fragments of the current nlevel if ( fragment_size /= nlevel ) cycle if ( fragment_size == 1 ) then ! 1-body: delta = value (no subsets to subtract) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) if ( compute_grad ) then call map_fragment_to_system_gradient ( results ( i )% gradient , & polymers ( i , 1 : fragment_size ), sys_geom , delta_gradients (:, :, i ), bonds ) end if if ( compute_hess ) then call map_fragment_to_system_hessian ( results ( i )% hessian , & polymers ( i , 1 : fragment_size ), sys_geom , delta_hessians (:, :, i ), bonds ) end if else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: delta = value - sum(all subset deltas) delta_E = compute_mbe_delta ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E if ( compute_grad ) then call compute_mbe_gradient ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_gradients , fragment_size , sys_geom , bonds ) end if if ( compute_hess ) then call compute_mbe_hessian ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_hessians , fragment_size , sys_geom , bonds ) end if end if end do end do ! Clean up lookup table call lookup % destroy () ! Compute totals total_energy = sum ( sum_by_level ) if ( compute_grad ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then total_gradient = total_gradient + delta_gradients (:, :, i ) end if end do end if if ( compute_hess ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then total_hessian = total_hessian + delta_hessians (:, :, i ) end if end do end if ! Print energy breakdown (always) call print_mbe_energy_breakdown ( sum_by_level , max_level , total_energy ) ! Print gradient info if computed if ( compute_grad ) then call print_mbe_gradient_info ( total_gradient , sys_geom , current_log_level ) end if ! Print hessian info if computed if ( compute_hess ) then call logger % info ( \"MBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if ! Print detailed breakdown if requested if ( do_detailed_print ) then call print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) end if ! Write JSON output with appropriate arguments if ( compute_hess ) then call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy , total_gradient , total_hessian , results ) else if ( compute_grad ) then call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy , total_gradient , results = results ) else call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy , results = results ) end if ! Cleanup deallocate ( sum_by_level , delta_energies , energies ) if ( allocated ( delta_gradients )) deallocate ( delta_gradients ) if ( allocated ( delta_hessians )) deallocate ( delta_hessians ) end subroutine compute_mbe !--------------------------------------------------------------------------- ! GMBE Helper subroutines for reducing code duplication !--------------------------------------------------------------------------- subroutine print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & max_level , total_energy , has_intersections ) !! Print GMBE energy breakdown using inclusion-exclusion principle real ( dp ), intent ( in ) :: monomer_energy integer , intent ( in ) :: n_monomers real ( dp ), intent ( in ), optional :: level_energies (:) integer , intent ( in ), optional :: level_counts (:) integer , intent ( in ) :: max_level real ( dp ), intent ( in ) :: total_energy logical , intent ( in ) :: has_intersections integer :: k real ( dp ) :: sign_factor character ( len = 256 ) :: line if ( has_intersections ) then call logger % info ( \"GMBE Energy breakdown (Inclusion-Exclusion Principle):\" ) write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"):  \" , monomer_energy call logger % info ( trim ( line )) do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) if ( sign_factor > 0.0_dp ) then write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  +\" , level_energies ( k ) else write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  \" , level_energies ( k ) end if call logger % info ( trim ( line )) end if end do write ( line , '(a,f20.10)' ) \"  Total GMBE:      \" , total_energy call logger % info ( trim ( line )) else call logger % info ( \"GMBE Energy breakdown:\" ) write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"): \" , monomer_energy call logger % info ( trim ( line )) write ( line , '(a,f20.10)' ) \"  Total GMBE:  \" , total_energy call logger % info ( trim ( line )) end if end subroutine print_gmbe_energy_breakdown subroutine print_gmbe_gradient_info ( total_gradient , sys_geom , current_log_level ) !! Print GMBE gradient information real ( dp ), intent ( in ) :: total_gradient (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: current_log_level integer :: iatom character ( len = 256 ) :: grad_line call logger % info ( \"GMBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end do call logger % info ( \" \" ) end if end subroutine print_gmbe_gradient_info subroutine compute_gmbe ( monomers , n_monomers , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , & total_energy , & sys_geom , total_gradient , total_hessian , bonds ) !! Compute generalized many-body expansion (GMBE) energy with optional gradient and/or hessian !! !! This is the core routine that handles all GMBE computations using !! the inclusion-exclusion principle for overlapping fragments. !! Optional arguments control what derivatives are computed: !!   - If sys_geom and total_gradient are present: compute gradient !!   - If total_hessian is also present: compute hessian use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_indices , build_fragment_from_atom_list , & redistribute_cap_gradients , redistribute_cap_hessian use mqc_gmbe_utils , only : find_fragment_intersection use mqc_config_parser , only : bond_t use mqc_error , only : error_t ! Required arguments integer , intent ( in ) :: monomers (:) integer , intent ( in ) :: n_monomers type ( calculation_result_t ), intent ( in ) :: monomer_results (:) integer , intent ( in ) :: n_intersections type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) integer , intent ( in ), optional :: intersection_sets (:, :) integer , intent ( in ), optional :: intersection_levels (:) real ( dp ), intent ( out ) :: total_energy ! Optional arguments for gradient computation type ( system_geometry_t ), intent ( in ), optional :: sys_geom real ( dp ), intent ( out ), optional :: total_gradient (:, :) ! Optional arguments for hessian computation real ( dp ), intent ( out ), optional :: total_hessian (:, :) ! Optional bond information for hydrogen cap handling type ( bond_t ), intent ( in ), optional :: bonds (:) ! Local variables integer :: i , k , max_level , current_log_level , hess_dim real ( dp ) :: monomer_energy , sign_factor real ( dp ), allocatable :: level_energies (:) integer , allocatable :: level_counts (:) type ( physical_fragment_t ) :: fragment type ( error_t ) :: error integer , allocatable :: monomer_idx (:) logical :: compute_grad , compute_hess , has_intersections ! Determine what to compute based on optional arguments compute_grad = present ( sys_geom ) . and . present ( total_gradient ) compute_hess = compute_grad . and . present ( total_hessian ) has_intersections = n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels ) ! Initialize outputs if ( compute_grad ) then total_gradient = 0.0_dp end if if ( compute_hess ) then total_hessian = 0.0_dp hess_dim = 3 * sys_geom % total_atoms end if ! Sum monomer energies (and gradients/hessians if requested) monomer_energy = 0.0_dp do i = 1 , n_monomers monomer_energy = monomer_energy + monomer_results ( i )% energy % total () ! Accumulate monomer derivatives if requested if ( compute_grad . and . monomer_results ( i )% has_gradient ) then allocate ( monomer_idx ( 1 )) monomer_idx ( 1 ) = monomers ( i ) call build_fragment_from_indices ( sys_geom , monomer_idx , fragment , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build monomer fragment in GMBE\" end if call redistribute_cap_gradients ( fragment , monomer_results ( i )% gradient , total_gradient ) if ( compute_hess . and . monomer_results ( i )% has_hessian ) then call redistribute_cap_hessian ( fragment , monomer_results ( i )% hessian , total_hessian ) end if call fragment % destroy () deallocate ( monomer_idx ) end if end do ! Start with monomer contribution total_energy = monomer_energy ! Handle intersections with inclusion-exclusion if ( has_intersections ) then max_level = maxval ( intersection_levels ) allocate ( level_energies ( 2 : max_level )) allocate ( level_counts ( 2 : max_level )) level_energies = 0.0_dp level_counts = 0 ! Process intersection energies and derivatives do i = 1 , n_intersections k = intersection_levels ( i ) sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) level_energies ( k ) = level_energies ( k ) + intersection_results ( i )% energy % total () level_counts ( k ) = level_counts ( k ) + 1 ! Handle intersection derivatives if requested if ( compute_grad . and . ( intersection_results ( i )% has_gradient . or . & ( compute_hess . and . intersection_results ( i )% has_hessian ))) then call process_intersection_derivatives ( i , k , sign_factor , intersection_results , & intersection_sets , sys_geom , total_gradient , total_hessian , bonds , & compute_grad , compute_hess , hess_dim ) end if end do ! Apply inclusion-exclusion to energy do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) total_energy = total_energy + sign_factor * level_energies ( k ) end if end do ! Print energy breakdown call print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & max_level , total_energy , . true .) ! Print debug info for intersections call print_gmbe_intersection_debug ( n_intersections , n_monomers , intersection_sets , & intersection_levels , intersection_results ) deallocate ( level_energies , level_counts ) else ! No intersections - just print monomer sum call print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & 0 , total_energy , . false .) end if ! Print gradient/hessian info if ( compute_grad ) then call logger % configuration ( level = current_log_level ) call print_gmbe_gradient_info ( total_gradient , sys_geom , current_log_level ) end if if ( compute_hess ) then call logger % info ( \"GMBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if end subroutine compute_gmbe subroutine process_intersection_derivatives ( inter_idx , k , sign_factor , intersection_results , & intersection_sets , sys_geom , total_gradient , & total_hessian , bonds , compute_grad , compute_hess , hess_dim ) !! Process derivatives for a single intersection fragment use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_atom_list , & redistribute_cap_gradients , redistribute_cap_hessian use mqc_gmbe_utils , only : find_fragment_intersection use mqc_config_parser , only : bond_t use mqc_error , only : error_t integer , intent ( in ) :: inter_idx , k real ( dp ), intent ( in ) :: sign_factor type ( calculation_result_t ), intent ( in ) :: intersection_results (:) integer , intent ( in ) :: intersection_sets (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: total_gradient (:, :) real ( dp ), intent ( inout ), optional :: total_hessian (:, :) type ( bond_t ), intent ( in ), optional :: bonds (:) logical , intent ( in ) :: compute_grad , compute_hess integer , intent ( in ) :: hess_dim integer :: j , current_n , next_n , n_intersect integer , allocatable :: current_atoms (:), next_atoms (:), intersect_atoms (:) real ( dp ), allocatable :: term_gradient (:, :), term_hessian (:, :) logical :: has_intersection type ( physical_fragment_t ) :: inter_fragment type ( error_t ) :: inter_error ! Build the intersection atom list call get_monomer_atom_list ( sys_geom , intersection_sets ( 1 , inter_idx ), current_atoms , current_n ) if ( current_n > 0 ) then do j = 2 , k call get_monomer_atom_list ( sys_geom , intersection_sets ( j , inter_idx ), next_atoms , next_n ) has_intersection = find_fragment_intersection ( current_atoms , current_n , & next_atoms , next_n , & intersect_atoms , n_intersect ) deallocate ( current_atoms , next_atoms ) if (. not . has_intersection ) then current_n = 0 exit end if current_n = n_intersect allocate ( current_atoms ( current_n )) current_atoms = intersect_atoms deallocate ( intersect_atoms ) end do end if if ( current_n > 0 ) then call build_fragment_from_atom_list ( sys_geom , current_atoms , current_n , & inter_fragment , inter_error , bonds ) if ( inter_error % has_error ()) then call logger % error ( inter_error % get_full_trace ()) error stop \"Failed to build intersection fragment in GMBE\" end if if ( compute_grad . and . intersection_results ( inter_idx )% has_gradient ) then allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp call redistribute_cap_gradients ( inter_fragment , intersection_results ( inter_idx )% gradient , & term_gradient ) total_gradient = total_gradient + sign_factor * term_gradient deallocate ( term_gradient ) end if if ( compute_hess . and . intersection_results ( inter_idx )% has_hessian ) then allocate ( term_hessian ( hess_dim , hess_dim )) term_hessian = 0.0_dp call redistribute_cap_hessian ( inter_fragment , intersection_results ( inter_idx )% hessian , & term_hessian ) total_hessian = total_hessian + sign_factor * term_hessian deallocate ( term_hessian ) end if call inter_fragment % destroy () else call logger % warning ( \"GMBE intersection has no atoms; skipping derivatives\" ) end if if ( allocated ( current_atoms )) deallocate ( current_atoms ) end subroutine process_intersection_derivatives subroutine print_gmbe_intersection_debug ( n_intersections , n_monomers , intersection_sets , & intersection_levels , intersection_results ) !! Print debug information about GMBE intersections use mqc_result_types , only : calculation_result_t integer , intent ( in ) :: n_intersections , n_monomers integer , intent ( in ) :: intersection_sets (:, :) integer , intent ( in ) :: intersection_levels (:) type ( calculation_result_t ), intent ( in ) :: intersection_results (:) integer :: i , j , set_size real ( dp ) :: sign_factor character ( len = 512 ) :: detail_line character ( len = 256 ) :: set_str if ( n_intersections > 0 ) then call logger % debug ( \"GMBE intersection details:\" ) do i = 1 , n_intersections set_str = \"(\" set_size = 0 do j = 1 , n_monomers if ( intersection_sets ( j , i ) > 0 ) then if ( set_size > 0 ) set_str = trim ( set_str ) // \",\" write ( set_str , '(a,i0)' ) trim ( set_str ), intersection_sets ( j , i ) set_size = set_size + 1 end if end do set_str = trim ( set_str ) // \")\" sign_factor = real (( - 1 ) ** ( intersection_levels ( i ) + 1 ), dp ) write ( detail_line , '(a,i0,a,i0,a,a,a,f16.8)' ) & \"  Intersection \" , i , \": level=\" , intersection_levels ( i ), & \" fragments=\" , trim ( set_str ), \" energy=\" , intersection_results ( i )% energy % total () call logger % debug ( trim ( detail_line )) end do end if end subroutine print_gmbe_intersection_debug subroutine get_monomer_atom_list ( sys_geom , monomer_idx , atom_list , n_atoms ) !! Build 0-indexed atom list for a monomer, handling fixed or variable-sized fragments. type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_idx integer , allocatable , intent ( out ) :: atom_list (:) integer , intent ( out ) :: n_atoms integer :: i , base_idx if ( allocated ( sys_geom % fragment_atoms )) then n_atoms = sys_geom % fragment_sizes ( monomer_idx ) if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = sys_geom % fragment_atoms ( 1 : n_atoms , monomer_idx ) else allocate ( atom_list ( 0 )) end if else n_atoms = sys_geom % atoms_per_monomer if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) base_idx = ( monomer_idx - 1 ) * sys_geom % atoms_per_monomer do i = 1 , n_atoms atom_list ( i ) = base_idx + ( i - 1 ) end do else allocate ( atom_list ( 0 )) end if end if end subroutine get_monomer_atom_list end module mqc_mbe","tags":"","url":"sourcefile/mqc_mbe.f90.html"},{"title":"mqc_driver.f90 – metalquicha","text":"Main calculation driver module for metalquicha This file depends on sourcefile~~mqc_driver.f90~~EfferentGraph sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_driver.f90~~AfferentGraph sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Main calculation driver module for metalquicha module mqc_driver !! Handles both fragmented (many-body expansion) and unfragmented calculations !! with MPI parallelization and node-based work distribution. use pic_types , only : int32 , int64 , dp use pic_mpi_lib , only : comm_t , abort_comm , bcast , allgather use pic_logger , only : logger => global_logger use pic_io , only : to_char use omp_lib , only : omp_get_max_threads , omp_set_num_threads use mqc_mbe_fragment_distribution_scheme , only : global_coordinator , node_coordinator , node_worker , unfragmented_calculation , & serial_fragment_processor , do_fragment_work , distributed_unfragmented_hessian use mqc_gmbe_fragment_distribution_scheme , only : serial_gmbe_pie_processor , gmbe_pie_coordinator use mqc_frag_utils , only : get_nfrags , create_monomer_list , generate_fragment_list , generate_intersections , & gmbe_enumerate_pie_terms , binomial , combine , apply_distance_screening , sort_fragments_by_size use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , & build_fragment_from_indices , build_fragment_from_atom_list use mqc_config_adapter , only : driver_config_t , config_to_driver , config_to_system_geometry use mqc_method_types , only : method_type_to_string use mqc_calc_types , only : calc_type_to_string , CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_config_parser , only : bond_t , mqc_config_t use mqc_mbe , only : compute_gmbe use mqc_result_types , only : calculation_result_t use mqc_error , only : error_t use mqc_io_helpers , only : set_molecule_suffix , get_output_json_filename use mqc_json , only : merge_multi_molecule_json implicit none private public :: run_calculation !! Main entry point for all calculations public :: run_multi_molecule_calculations !! Multi-molecule calculation dispatcher contains subroutine run_calculation ( world_comm , node_comm , config , sys_geom , bonds , result_out ) !! Main calculation dispatcher - routes to fragmented or unfragmented calculation !! !! Determines calculation type based on nlevel and dispatches to appropriate !! calculation routine with proper MPI setup and validation. !! If result_out is present, returns result instead of writing JSON (for dynamics/optimization) type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator type ( driver_config_t ), intent ( in ) :: config !! Driver configuration type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( calculation_result_t ), intent ( out ), optional :: result_out !! Optional result output ! Local variables integer :: max_level !! Maximum fragment level (nlevel from config) integer :: i !! Loop counter ! Set max_level from config max_level = config % nlevel if ( world_comm % rank () == 0 ) then call logger % info ( \"============================================\" ) call logger % info ( \"Loaded geometry:\" ) call logger % info ( \"  Total monomers: \" // to_char ( sys_geom % n_monomers )) call logger % info ( \"  Atoms per monomer: \" // to_char ( sys_geom % atoms_per_monomer )) call logger % info ( \"  Total atoms: \" // to_char ( sys_geom % total_atoms )) call logger % info ( \"  Fragment level: \" // to_char ( max_level )) call logger % info ( \"============================================\" ) end if ! Warn if overlapping fragments flag is set but nlevel=0 if ( config % allow_overlapping_fragments . and . max_level == 0 ) then if ( world_comm % rank () == 0 ) then call logger % warning ( \"allow_overlapping_fragments is set to true, but nlevel=0\" ) call logger % warning ( \"Running unfragmented calculation - overlapping fragments flag will be ignored\" ) end if end if ! GMBE (overlapping fragments) with inclusion-exclusion principle ! GMBE(1): Base fragments are monomers ! GMBE(N): Base fragments are N-mers (e.g., dimers for N=2) ! Algorithm: Generate primaries, use DFS to enumerate overlapping cliques, ! accumulate PIE coefficients per unique atom set, evaluate each once if ( max_level == 0 ) then call omp_set_num_threads ( 1 ) call run_unfragmented_calculation ( world_comm , sys_geom , config % method , config % calc_type , bonds , config , result_out ) else call run_fragmented_calculation ( world_comm , node_comm , config % method , config % calc_type , sys_geom , max_level , & config % allow_overlapping_fragments , & config % max_intersection_level , bonds , config ) end if end subroutine run_calculation subroutine run_unfragmented_calculation ( world_comm , sys_geom , method , calc_type , bonds , driver_config , result_out ) !! Handle unfragmented calculation (nlevel=0) !! !! For single-molecule mode: Only rank 0 runs (validates single rank) !! For multi-molecule mode: ALL ranks can run (each with their own molecule) !! For Hessian calculations with multiple ranks: Uses distributed parallelization !! If result_out is present, returns result instead of writing JSON type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( system_geometry_t ), intent ( in ) :: sys_geom !! Complete system geometry integer ( int32 ), intent ( in ) :: method !! Quantum chemistry method integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( driver_config_t ), intent ( in ), optional :: driver_config !! Driver configuration type ( calculation_result_t ), intent ( out ), optional :: result_out !! Optional result output ! For Hessian calculations with multiple ranks, use distributed approach if ( calc_type == CALC_TYPE_HESSIAN . and . world_comm % size () > 1 ) then if ( world_comm % rank () == 0 ) then call logger % info ( \" \" ) call logger % info ( \"Running distributed unfragmented Hessian calculation\" ) call logger % info ( \"  MPI ranks: \" // to_char ( world_comm % size ())) call logger % info ( \" \" ) end if call distributed_unfragmented_hessian ( world_comm , sys_geom , method , driver_config ) return end if ! Check if this is multi-molecule mode or single-molecule mode ! In multi-molecule mode, each rank processes its own molecule ! In single-molecule mode, only rank 0 should work if ( world_comm % size () == 1 . or . world_comm % rank () == 0 ) then ! Either single-rank calculation, or rank 0 in multi-rank setup call logger % info ( \" \" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) call logger % info ( \" \" ) call unfragmented_calculation ( sys_geom , method , calc_type , bonds , result_out ) else if ( sys_geom % total_atoms > 0 ) then ! Multi-molecule mode: non-zero rank with a molecule call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Running unfragmented calculation\" ) call unfragmented_calculation ( sys_geom , method , calc_type , bonds , result_out ) end if end subroutine run_unfragmented_calculation subroutine run_fragmented_calculation ( world_comm , node_comm , method , calc_type , sys_geom , max_level , & allow_overlapping_fragments , max_intersection_level , bonds , driver_config ) !! Handle fragmented calculation (nlevel > 0) !! !! Generates fragments, distributes work across MPI processes organized in nodes, !! and coordinates many-body expansion calculation using hierarchical parallelism. !! If allow_overlapping_fragments=true, uses GMBE with intersection correction. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator integer ( int32 ), intent ( in ) :: method !! Quantum chemistry method integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info integer , intent ( in ) :: max_level !! Maximum fragment level for MBE logical , intent ( in ) :: allow_overlapping_fragments !! Use GMBE for overlapping fragments integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth for GMBE type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( driver_config_t ), intent ( in ) :: driver_config !! Driver configuration with cutoffs integer ( int64 ) :: total_fragments !! Total number of fragments generated (int64 to handle large systems) integer , allocatable :: polymers (:, :) !! Fragment composition array (fragment, monomer_indices) integer :: num_nodes !! Number of compute nodes integer :: i , j !! Loop counters integer , allocatable :: node_leader_ranks (:) !! Ranks of processes that lead each node integer , allocatable :: monomers (:) !! Temporary monomer list for fragment generation integer ( int64 ) :: n_expected_frags !! Expected number of fragments based on combinatorics (int64 to handle large systems) integer ( int64 ) :: n_rows !! Number of rows needed for polymers array (int64 to handle large systems) integer :: global_node_rank !! Global rank if this process leads a node, -1 otherwise integer , allocatable :: all_node_leader_ranks (:) !! Node leader status for all ranks ! GMBE-specific variables (old approach - kept for compatibility) integer , allocatable :: intersections (:, :) !! Intersection atom lists (max_atoms, n_intersections) integer , allocatable :: intersection_sets (:, :) !! k-tuples for each intersection (n_monomers, n_intersections) integer , allocatable :: intersection_levels (:) !! Level k of each intersection (n_intersections) integer :: n_intersections , n_monomers !! Counts for GMBE ! GMBE PIE-based variables (new approach) integer :: n_primaries !! Number of primary polymers integer ( int64 ) :: n_primaries_i64 !! For binomial calculation integer , allocatable :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , allocatable :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ) :: n_pie_terms !! Number of unique PIE terms ! Generate fragments if ( world_comm % rank () == 0 ) then if ( allow_overlapping_fragments ) then ! GMBE mode: PIE-based inclusion-exclusion ! GMBE(1): primaries are monomers ! GMBE(N): primaries are N-mers (e.g., dimers for N=2) ! Generate primaries if ( max_level == 1 ) then ! GMBE(1): primaries are base monomers n_primaries = sys_geom % n_monomers allocate ( polymers ( n_primaries , 1 )) do i = 1 , n_primaries polymers ( i , 1 ) = i end do else ! GMBE(N): primaries are all C(M, N) N-tuples n_primaries_i64 = binomial ( sys_geom % n_monomers , max_level ) n_primaries = int ( n_primaries_i64 ) allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_primaries , max_level )) polymers = 0 call create_monomer_list ( monomers ) total_fragments = 0_int64 call combine ( monomers , sys_geom % n_monomers , max_level , polymers , total_fragments ) n_primaries = int ( total_fragments ) deallocate ( monomers ) ! Apply distance-based screening to primaries if cutoffs are provided if ( max_level > 1 ) then ! Only screen if primaries are n-mers (not for GMBE(1) where primaries are monomers) total_fragments = int ( n_primaries , int64 ) call apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) n_primaries = int ( total_fragments ) end if ! Sort primaries by size (largest first) ! TODO: Currently disabled - see comment in MBE section above ! total_fragments = int(n_primaries, int64) call sort_fragments_by_size ( polymers , total_fragments , max_level ) end if call logger % info ( \"Generated \" // to_char ( n_primaries ) // \" primary \" // to_char ( max_level ) // \"-mers for GMBE(\" // & to_char ( max_level ) // \")\" ) ! Use DFS to enumerate PIE terms with coefficients call gmbe_enumerate_pie_terms ( sys_geom , polymers , n_primaries , max_level , max_intersection_level , & pie_atom_sets , pie_coefficients , n_pie_terms ) call logger % info ( \"GMBE PIE enumeration complete: \" // to_char ( n_pie_terms ) // \" unique subsystems to evaluate\" ) ! For now: total_fragments = n_pie_terms (each PIE term is a subsystem to evaluate) total_fragments = n_pie_terms else ! Standard MBE mode ! Calculate expected number of fragments n_expected_frags = get_nfrags ( sys_geom % n_monomers , max_level ) n_rows = n_expected_frags ! Allocate monomer list and polymers array allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_rows , max_level )) polymers = 0 ! Create monomer list [1, 2, 3, ..., n_monomers] call create_monomer_list ( monomers ) ! Generate all fragments (includes monomers in polymers array) total_fragments = 0_int64 ! First add monomers do i = 1 , sys_geom % n_monomers total_fragments = total_fragments + 1_int64 polymers ( total_fragments , 1 ) = i end do ! Then add n-mers for n >= 2 call generate_fragment_list ( monomers , max_level , polymers , total_fragments ) deallocate ( monomers ) ! Apply distance-based screening if cutoffs are provided call apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) ! Sort fragments by size (largest first) for better load balancing ! TODO: Currently disabled - MBE assembly is now order-independent (uses nested loops), ! but sorting still causes \"Subset not found\" errors in real validation cases. ! Unit tests pass with arbitrary order, so there may be an issue with the hash table ! or fragment generation in production code. Needs investigation. call sort_fragments_by_size ( polymers , total_fragments , max_level ) call logger % info ( \"Generated fragments:\" ) call logger % info ( \"  Total fragments: \" // to_char ( total_fragments )) call logger % info ( \"  Max level: \" // to_char ( max_level )) end if end if ! Broadcast total_fragments to all ranks call bcast ( world_comm , total_fragments , 1 , 0 ) ! Determine node leaders global_node_rank = - 1 if ( node_comm % rank () == 0 ) global_node_rank = world_comm % rank () allocate ( all_node_leader_ranks ( world_comm % size ())) call allgather ( world_comm , global_node_rank , all_node_leader_ranks ) num_nodes = count ( all_node_leader_ranks /= - 1 ) if ( world_comm % rank () == 0 ) then call logger % info ( \"Running with \" // to_char ( num_nodes ) // \" node(s)\" ) end if allocate ( node_leader_ranks ( num_nodes )) i = 0 do j = 1 , world_comm % size () if ( all_node_leader_ranks ( j ) /= - 1 ) then i = i + 1 node_leader_ranks ( i ) = all_node_leader_ranks ( j ) end if end do deallocate ( all_node_leader_ranks ) ! Execute appropriate role if ( world_comm % size () == 1 ) then ! Single rank: process fragments serially call logger % info ( \"Running in serial mode (single MPI rank)\" ) if ( allow_overlapping_fragments ) then ! GMBE serial processing with PIE coefficients call serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , sys_geom , method , calc_type , bonds ) else ! Standard MBE serial processing call serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method , calc_type , bonds ) end if else if ( world_comm % leader () . and . node_comm % leader ()) then ! Global coordinator (rank 0, node leader on node 0) call omp_set_num_threads ( omp_get_max_threads ()) call logger % verbose ( \"Rank 0: Acting as global coordinator\" ) if ( allow_overlapping_fragments ) then ! GMBE MPI processing - PIE-based approach call gmbe_pie_coordinator ( world_comm , node_comm , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method , calc_type , bonds ) else ! Standard MBE MPI processing call global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , calc_type , bonds ) end if else if ( node_comm % leader ()) then ! Node coordinator (node leader on other nodes) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as node coordinator\" ) ! Node coordinator works for both MBE and GMBE (receives fragments from global coordinator) call node_coordinator ( world_comm , node_comm , calc_type ) else ! Worker call omp_set_num_threads ( 1 ) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as worker\" ) ! Worker processes work for both MBE and GMBE (fragment_type distinguishes them) call node_worker ( world_comm , node_comm , sys_geom , method , calc_type , bonds ) end if ! Cleanup if ( world_comm % rank () == 0 ) then if ( allocated ( polymers )) deallocate ( polymers ) if ( allocated ( node_leader_ranks )) deallocate ( node_leader_ranks ) if ( allocated ( intersections )) deallocate ( intersections ) if ( allocated ( intersection_sets )) deallocate ( intersection_sets ) if ( allocated ( intersection_levels )) deallocate ( intersection_levels ) if ( allocated ( pie_atom_sets )) deallocate ( pie_atom_sets ) if ( allocated ( pie_coefficients )) deallocate ( pie_coefficients ) end if end subroutine run_fragmented_calculation subroutine run_multi_molecule_calculations ( world_comm , node_comm , mqc_config ) !! Run calculations for multiple molecules with MPI parallelization !! Each molecule is independent, so assign one molecule per rank use mqc_config_parser , only : mqc_config_t use mqc_config_adapter , only : config_to_system_geometry use mqc_error , only : error_t use mqc_io_helpers , only : set_molecule_suffix , get_output_json_filename use mqc_json , only : merge_multi_molecule_json type ( comm_t ), intent ( in ) :: world_comm type ( comm_t ), intent ( in ) :: node_comm type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ) :: config type ( system_geometry_t ) :: sys_geom type ( comm_t ) :: mol_comm , mol_node_comm type ( error_t ) :: error integer :: imol , my_rank , num_ranks , color integer :: molecules_processed character ( len = :), allocatable :: mol_name logical :: has_fragmented_molecules character ( len = 256 ), allocatable :: individual_json_files (:) my_rank = world_comm % rank () num_ranks = world_comm % size () ! Allocate array to track individual JSON files for merging allocate ( individual_json_files ( mqc_config % nmol )) ! Check if any molecules have fragments (nlevel > 0) has_fragmented_molecules = . false . do imol = 1 , mqc_config % nmol if ( mqc_config % molecules ( imol )% nfrag > 0 ) then has_fragmented_molecules = . true . exit end if end do if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"Multi-molecule mode: \" // to_char ( mqc_config % nmol ) // \" molecules\" ) call logger % info ( \"MPI ranks: \" // to_char ( num_ranks )) if ( has_fragmented_molecules ) then call logger % info ( \"Mode: Sequential execution (fragmented molecules detected)\" ) call logger % info ( \"  Each molecule will use all \" // to_char ( num_ranks ) // \" rank(s) for its calculation\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Mode: Sequential execution (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) call logger % info ( \"Note: More ranks than molecules - ranks \" // to_char ( mqc_config % nmol ) // & \" to \" // to_char ( num_ranks - 1 ) // \" will be idle\" ) else call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) end if call logger % info ( \"============================================\" ) call logger % info ( \" \" ) end if ! Determine execution mode: ! 1. Sequential: Single rank OR fragmented molecules (each molecule needs all ranks) ! 2. Parallel: Multiple ranks AND unfragmented molecules (distribute molecules across ranks) molecules_processed = 0 if ( num_ranks == 1 . or . has_fragmented_molecules ) then ! Sequential mode: process all molecules one after another ! Each molecule uses all available ranks for its calculation do imol = 1 , mqc_config % nmol ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Processing molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) end if ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then call error % add_context ( \"mqc_driver:run_multi_molecule_calculation\" ) if ( my_rank == 0 ) then call logger % error ( \"Error converting geometry for \" // mol_name // \": \" // error % get_full_trace ()) end if call abort_comm ( world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % molecules ( imol )% bonds ) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () if ( my_rank == 0 ) then call logger % info ( \"Completed molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) end if molecules_processed = molecules_processed + 1 end do else ! Multiple ranks: distribute molecules across ranks in round-robin fashion molecules_processed = 0 do imol = 1 , mqc_config % nmol ! This rank processes molecules where (imol - 1) mod num_ranks == my_rank if ( mod ( imol - 1 , num_ranks ) == my_rank ) then ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Processing molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then call error % add_context ( \"mqc_driver:run_multi_molecule_calculation\" ) call logger % error ( \"Rank \" // to_char ( my_rank ) // \": Error converting geometry for \" // mol_name // \": \" // error % get_full_trace ()) call abort_comm ( world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % molecules ( imol )% bonds ) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Completed molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) molecules_processed = molecules_processed + 1 end if end do if ( molecules_processed == 0 ) then ! Idle rank - no molecules assigned call logger % verbose ( \"Rank \" // to_char ( my_rank ) // \": No molecules assigned (idle)\" ) end if end if ! Synchronize all ranks call world_comm % barrier () ! In parallel execution, rank 0 needs to reconstruct all JSON filenames for merging ! since each rank only populated its own entry if ( my_rank == 0 . and . num_ranks > 1 . and . . not . has_fragmented_molecules ) then ! Rank 0 constructs filenames for all molecules do imol = 1 , mqc_config % nmol ! Get molecule name if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if ! Construct JSON filename pattern: output_<basename>_<molname>.json ! This mirrors what get_output_json_filename() returns after set_molecule_suffix() call set_molecule_suffix ( \"_\" // trim ( mol_name )) individual_json_files ( imol ) = get_output_json_filename () end do end if ! Merge individual JSON files into one combined file (rank 0 only) if ( my_rank == 0 ) then call merge_multi_molecule_json ( individual_json_files , mqc_config % nmol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"All \" // to_char ( mqc_config % nmol ) // \" molecules completed\" ) if ( has_fragmented_molecules ) then call logger % info ( \"Execution: Sequential (each molecule used all ranks)\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Execution: Sequential (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Execution: Parallel (active ranks: \" // to_char ( mqc_config % nmol ) // \"/\" // to_char ( num_ranks ) // \")\" ) else call logger % info ( \"Execution: Parallel (all ranks active)\" ) end if call logger % info ( \"============================================\" ) end if end subroutine run_multi_molecule_calculations end module mqc_driver","tags":"","url":"sourcefile/mqc_driver.f90.html"},{"title":"mqc_json.f90 – metalquicha","text":"JSON output utilities for multi-molecule calculations This file depends on sourcefile~~mqc_json.f90~~EfferentGraph sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_json.f90~~AfferentGraph sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! JSON output utilities for multi-molecule calculations module mqc_json use pic_logger , only : logger => global_logger use pic_io , only : to_char implicit none private public :: merge_multi_molecule_json contains subroutine merge_multi_molecule_json ( individual_files , nmol ) !! Merge individual molecule JSON files into a single combined file use mqc_io_helpers , only : get_molecule_name character ( len = 256 ), intent ( in ) :: individual_files (:) integer , intent ( in ) :: nmol integer :: imol , unit_in , unit_out , io_stat , slash_pos , dot_pos character ( len = 10000 ) :: line character ( len = 256 ) :: output_file , basename logical :: file_exists ! Determine combined output filename from first individual file ! Example: \"output_multi_structure_molecule_1.json\" -> \"output_multi_structure.json\" basename = individual_files ( 1 ) slash_pos = index ( basename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = basename ( slash_pos + 1 :) end if ! Remove \"_molecule_1\" or similar suffix dot_pos = index ( basename , '_molecule_' ) if ( dot_pos > 0 ) then output_file = basename ( 1 : dot_pos - 1 ) // \".json\" else output_file = \"output_combined.json\" end if ! Open combined output file open ( newunit = unit_out , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Merging \" // to_char ( nmol ) // \" molecule JSON files into \" // trim ( output_file )) ! Write opening brace and top-level key (basename without \"output_\" and \".json\") dot_pos = index ( output_file , '.json' ) if ( dot_pos > 0 ) then basename = output_file ( 8 : dot_pos - 1 ) ! Skip \"output_\" else basename = \"combined\" end if write ( unit_out , '(a)' ) \"{\" write ( unit_out , '(a)' ) '  \"' // trim ( basename ) // '\": {' ! Process each individual JSON file do imol = 1 , nmol inquire ( file = trim ( individual_files ( imol )), exist = file_exists ) if (. not . file_exists ) cycle open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) cycle ! Read all lines from the individual JSON file call read_json_content ( unit_in , imol , unit_out , individual_files ( imol )) close ( unit_in ) ! Delete individual file open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'readwrite' ) close ( unit_in , status = 'delete' ) end do ! Close last molecule write ( unit_out , '(a)' ) '    }' ! Close top-level key and file write ( unit_out , '(a)' ) '  }' write ( unit_out , '(a)' ) '}' close ( unit_out ) call logger % info ( \"Combined JSON written to \" // trim ( output_file )) end subroutine merge_multi_molecule_json subroutine read_json_content ( unit_in , mol_index , unit_out , filename ) !! Read and write JSON content from an individual molecule file !! Properly handles nested structures from fragmented calculations use mqc_io_helpers , only : get_molecule_name integer , intent ( in ) :: unit_in , mol_index , unit_out character ( len =* ), intent ( in ) :: filename character ( len = 10000 ), allocatable :: all_lines (:) character ( len = 10000 ) :: line integer :: io_stat , nlines , i ! Read all lines into memory allocate ( all_lines ( 1000 )) ! Reasonable size for most JSON files nlines = 0 do read ( unit_in , '(a)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit nlines = nlines + 1 if ( nlines > size ( all_lines )) then ! Reallocate if needed call logger % error ( \"JSON file too large: \" // trim ( filename )) return end if all_lines ( nlines ) = line end do ! Lines structure: ! 1: \"{\" ! 2: '  \"molecule_name\": {' ! 3..(n-2): content ! n-1: \"  }\" ! n: \"}\" if ( nlines < 3 ) then call logger % error ( \"Invalid JSON structure: \" // trim ( filename )) return end if ! Write molecule key (extracted from filename) if ( mol_index > 1 ) write ( unit_out , '(a)' ) '    },' write ( unit_out , '(a)' ) '    \"' // trim ( get_molecule_name ( filename )) // '\" : {' ! Write all content lines (from line 3 to line n-2) do i = 3 , nlines - 2 write ( unit_out , '(a)' ) '  ' // trim ( all_lines ( i )) ! Add 2 spaces for proper indentation end do deallocate ( all_lines ) end subroutine read_json_content end module mqc_json","tags":"","url":"sourcefile/mqc_json.f90.html"},{"title":"mqc_gmbe_fragment_distribution_scheme.f90 – metalquicha","text":"Generalized Many-Body Expansion (GMBE) fragment distribution module This file depends on sourcefile~~mqc_gmbe_fragment_distribution_scheme.f90~~EfferentGraph sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_gmbe_fragment_distribution_scheme.f90~~AfferentGraph sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Generalized Many-Body Expansion (GMBE) fragment distribution module module mqc_gmbe_fragment_distribution_scheme !! Implements fragment distribution schemes for GMBE calculations with overlapping fragments !! Handles both serial and MPI-parallelized distribution of monomers and intersection fragments use pic_types , only : int32 , int64 , dp use pic_timer , only : timer_type use mqc_calc_types , only : CALC_TYPE_GRADIENT use pic_mpi_lib , only : comm_t , send , recv , isend , irecv , wait , iprobe , MPI_Status , request_t , MPI_ANY_SOURCE , MPI_ANY_TAG use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_mpi_tags , only : TAG_WORKER_REQUEST , TAG_WORKER_FRAGMENT , TAG_WORKER_FINISH , & TAG_WORKER_SCALAR_RESULT , & TAG_NODE_REQUEST , TAG_NODE_FRAGMENT , TAG_NODE_FINISH , & TAG_NODE_SCALAR_RESULT use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , build_fragment_from_indices , & build_fragment_from_atom_list use mqc_config_parser , only : bond_t use mqc_result_types , only : calculation_result_t , result_send , result_isend , result_recv , result_irecv use mqc_mbe_fragment_distribution_scheme , only : do_fragment_work use mqc_mbe_io , only : print_gmbe_json , print_gmbe_pie_json use mqc_vibrational_analysis , only : compute_vibrational_analysis , print_vibrational_analysis implicit none ! Error handling imported where needed private ! Public interface public :: serial_gmbe_pie_processor !! PIE-based serial processor public :: gmbe_pie_coordinator !! PIE-based MPI coordinator contains subroutine serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , sys_geom , method , calc_type , bonds ) !! Serial GMBE processor using PIE coefficients !! Evaluates each unique atom set once and sums with PIE coefficients !! Supports energy-only, energy+gradient, and energy+gradient+Hessian calculations use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN , CALC_TYPE_ENERGY , calc_type_to_string use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian use mqc_error , only : error_t use pic_logger , only : info_level integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( in ) :: n_pie_terms type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method , calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: phys_frag type ( calculation_result_t ), allocatable :: results (:) type ( error_t ) :: error integer :: n_atoms , max_atoms , iatom , current_log_level , hess_dim integer ( int64 ) :: term_idx integer , allocatable :: atom_list (:) real ( dp ) :: total_energy , term_energy real ( dp ), allocatable :: pie_energies (:) !! Store individual energies for JSON output real ( dp ), allocatable :: total_gradient (:, :) !! Total gradient (3, total_atoms) real ( dp ), allocatable :: term_gradient (:, :) !! Temporary gradient for each term real ( dp ), allocatable :: total_hessian (:, :) !! Total Hessian (3*total_atoms, 3*total_atoms) real ( dp ), allocatable :: term_hessian (:, :) !! Temporary Hessian for each term integer :: coeff if ( int ( size ( pie_atom_sets , 2 ), int64 ) < n_pie_terms . or . & int ( size ( pie_coefficients ), int64 ) < n_pie_terms ) then call logger % error ( \"PIE term arrays are smaller than n_pie_terms\" ) error stop \"Invalid PIE term array sizes\" end if call logger % info ( \"Processing \" // to_char ( n_pie_terms ) // \" unique PIE terms...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) total_energy = 0.0_dp max_atoms = size ( pie_atom_sets , 1 ) allocate ( pie_energies ( n_pie_terms )) allocate ( results ( n_pie_terms )) ! Allocate gradient and Hessian arrays if needed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) allocate ( term_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp end if do term_idx = 1_int64 , n_pie_terms coeff = pie_coefficients ( term_idx ) ! Skip terms with zero coefficient (shouldn't happen, but safety check) if ( coeff == 0 ) then pie_energies ( term_idx ) = 0.0_dp ! Mark as skipped cycle end if ! Extract atom list for this term n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms == 0 ) then pie_energies ( term_idx ) = 0.0_dp ! Mark as skipped cycle end if allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment from atom list call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build intersection fragment\" end if ! Compute energy (and gradient if requested) call do_fragment_work ( term_idx , results ( term_idx ), method , phys_frag , calc_type ) term_energy = results ( term_idx )% energy % total () ! Store energy for JSON output pie_energies ( term_idx ) = term_energy ! Accumulate with PIE coefficient total_energy = total_energy + real ( coeff , dp ) * term_energy ! Accumulate gradient if present if (( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) . and . & results ( term_idx )% has_gradient ) then ! Map fragment gradient to system coordinates with proper cap handling term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( coeff , dp ) * term_gradient end if ! Accumulate Hessian if present if ( calc_type == CALC_TYPE_HESSIAN . and . results ( term_idx )% has_hessian ) then ! Map fragment Hessian to system coordinates with proper cap handling term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( term_idx )% hessian , term_hessian ) ! Accumulate with PIE coefficient total_hessian = total_hessian + real ( coeff , dp ) * term_hessian end if call logger % verbose ( \"PIE term \" // to_char ( term_idx ) // \"/\" // to_char ( n_pie_terms ) // & \": \" // to_char ( n_atoms ) // \" atoms, coeff=\" // to_char ( coeff ) // & \", E=\" // to_char ( term_energy )) deallocate ( atom_list ) call phys_frag % destroy () end do call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) ! Print gradient info if computed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end if ! Print Hessian info if computed if ( calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if call logger % info ( \" \" ) ! Write JSON output call print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) deallocate ( pie_energies , results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( term_gradient )) deallocate ( term_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) if ( allocated ( term_hessian )) deallocate ( term_hessian ) end subroutine serial_gmbe_pie_processor subroutine gmbe_pie_coordinator ( world_comm , node_comm , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method , calc_type , bonds ) !! MPI coordinator for PIE-based GMBE calculations !! Distributes PIE terms across MPI ranks and accumulates results use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian type ( comm_t ), intent ( in ) :: world_comm , node_comm integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( in ) :: n_pie_terms integer , intent ( in ) :: node_leader_ranks (:), num_nodes type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method , calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( timer_type ) :: coord_timer integer ( int64 ) :: current_term_idx , results_received , term_idx integer :: finished_nodes integer :: request_source , dummy_msg type ( MPI_Status ) :: status , local_status logical :: handling_local_workers , has_pending integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer ( int64 ) :: worker_term_map ( node_comm % size ()) integer :: worker_source real ( dp ) :: total_energy real ( dp ), allocatable :: total_gradient (:, :) real ( dp ), allocatable :: total_hessian (:, :) integer :: hess_dim ! MPI request handles type ( request_t ) :: req if ( int ( size ( pie_atom_sets , 2 ), int64 ) < n_pie_terms . or . & int ( size ( pie_coefficients ), int64 ) < n_pie_terms ) then call logger % error ( \"PIE term arrays are smaller than n_pie_terms\" ) error stop \"Invalid PIE term array sizes\" end if current_term_idx = n_pie_terms finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( node_comm % size () > 1 ) results_received = 0_int64 worker_term_map = 0 allocate ( results ( n_pie_terms )) call logger % verbose ( \"GMBE PIE coordinator starting with \" // to_char ( n_pie_terms ) // & \" PIE terms for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers if ( handling_local_workers ) then do call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE if ( worker_term_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no term was assigned!\" ) error stop \"Invalid worker_term_map state\" end if call result_irecv ( results ( worker_term_map ( worker_source )), node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) worker_term_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , n_pie_terms / 10_int64 )) == 0 . or . & results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit call irecv ( world_comm , term_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( term_idx ), world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , n_pie_terms / 10_int64 )) == 0 . or . & results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_term_idx >= 1 ) then call send_pie_term_to_node ( world_comm , current_term_idx , pie_atom_sets , request_source ) current_term_idx = current_term_idx - 1 else call isend ( world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < node_comm % size () - 1 ) then call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then if ( worker_term_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_term_idx >= 1 ) then call send_pie_term_to_worker ( node_comm , current_term_idx , pie_atom_sets , local_status % MPI_SOURCE ) worker_term_map ( local_status % MPI_SOURCE ) = current_term_idx current_term_idx = current_term_idx - 1 else call isend ( node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= node_comm % size () - 1 & . and . results_received >= n_pie_terms ) then handling_local_workers = . false . finished_nodes = finished_nodes + 1 end if end do call logger % verbose ( \"GMBE PIE coordinator finished all terms\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all PIE terms \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Accumulate results with PIE coefficients call logger % info ( \" \" ) call logger % info ( \"Computing GMBE PIE energy...\" ) call coord_timer % start () total_energy = 0.0_dp do term_idx = 1_int64 , n_pie_terms total_energy = total_energy + real ( pie_coefficients ( term_idx ), dp ) * results ( term_idx )% energy % total () end do ! Handle gradients if computed if ( calc_type == CALC_TYPE_GRADIENT ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp do term_idx = 1_int64 , n_pie_terms if ( results ( term_idx )% has_gradient ) then ! Map fragment gradient to system coordinates block use mqc_error , only : error_t real ( dp ), allocatable :: term_gradient (:, :) type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) call phys_frag % destroy () deallocate ( atom_list ) end if ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system block use pic_logger , only : info_level integer :: iatom , current_log_level call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end block deallocate ( total_gradient ) end if ! Handle Hessians if computed if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp ! Also allocate gradient for Hessian calculations if (. not . allocated ( total_gradient )) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if do term_idx = 1_int64 , n_pie_terms if ( results ( term_idx )% has_hessian . or . results ( term_idx )% has_gradient ) then block use mqc_error , only : error_t real ( dp ), allocatable :: term_gradient (:, :), term_hessian (:, :) type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) ! Redistribute gradient if present if ( results ( term_idx )% has_gradient ) then allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end if ! Redistribute Hessian if present if ( results ( term_idx )% has_hessian ) then allocate ( term_hessian ( hess_dim , hess_dim )) term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( term_idx )% hessian , term_hessian ) total_hessian = total_hessian + real ( pie_coefficients ( term_idx ), dp ) * term_hessian deallocate ( term_hessian ) end if call phys_frag % destroy () deallocate ( atom_list ) end if end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print Hessian information call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if call coord_timer % stop () call logger % info ( \"Time to compute GMBE PIE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) call logger % info ( \" \" ) ! Write JSON output (reuse existing function) block real ( dp ), allocatable :: pie_energies (:) allocate ( pie_energies ( n_pie_terms )) do term_idx = 1_int64 , n_pie_terms pie_energies ( term_idx ) = results ( term_idx )% energy % total () end do call print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) deallocate ( pie_energies ) end block deallocate ( results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) end subroutine gmbe_pie_coordinator subroutine send_pie_term_to_node ( world_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to remote node coordinator type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( world_comm , term_idx , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , n_atoms , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , atom_list , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_node subroutine send_pie_term_to_worker ( node_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to local worker type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( node_comm , term_idx , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , n_atoms , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , atom_list , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_worker end module mqc_gmbe_fragment_distribution_scheme","tags":"","url":"sourcefile/mqc_gmbe_fragment_distribution_scheme.f90.html"},{"title":"mqc_basis_utils.f90 – metalquicha","text":"Utilities for handling basis set names and files This file depends on sourcefile~~mqc_basis_utils.f90~~EfferentGraph sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_basis_utils.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_basis_utils.f90~~AfferentGraph sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_cli_parser.f90 mqc_cli_parser.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_basis_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Utilities for handling basis set names and files module mqc_basis_utils !! Provides utilities for normalizing basis set names and locating basis set files !! !! Normalization rules: !!   * -> s   (e.g., 6-31G* -> 6-31Gs) !!   + -> p   (e.g., 6-31+G -> 6-31pG) !!   (d,p) -> dp (remove parentheses and commas) use mqc_error , only : error_t , ERROR_IO implicit none private public :: normalize_basis_name public :: find_basis_file contains pure function normalize_basis_name ( basis_name ) result ( normalized ) !! Normalize basis set name to filename-safe format !! !! Rules: !!   * -> s !!   + -> p !!   Remove parentheses and commas !! !! Examples: !!   6-31G*      -> 6-31Gs !!   6-31+G*     -> 6-31pGs !!   6-31G(d)    -> 6-31Gd !!   6-311G(d,p) -> 6-311Gdp !!   6-311++G**  -> 6-311ppGss !!   cc-pVDZ     -> cc-pVDZ (unchanged) character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable :: normalized integer :: i , out_pos character ( len = 256 ) :: buffer logical :: in_parens buffer = \"\" out_pos = 0 in_parens = . false . do i = 1 , len_trim ( basis_name ) select case ( basis_name ( i : i )) case ( '*' ) ! Star becomes 's' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 's' case ( '+' ) ! Plus becomes 'p' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 'p' case ( '(' ) ! Start of parentheses - we'll extract contents in_parens = . true . case ( ')' ) ! End of parentheses in_parens = . false . case ( ',' , ' ' ) ! Skip commas and spaces (inside or outside parentheses) continue case default ! Copy character as-is out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = basis_name ( i : i ) end select end do normalized = trim ( buffer ( 1 : out_pos )) end function normalize_basis_name subroutine find_basis_file ( basis_name , filename , error ) !! Find basis set file using normalized name !! !! Search strategy: !!   1. Normalize the basis name (e.g., 6-31G* -> 6-31Gs) !!   2. Look for basis_sets/{normalized}.txt !!   3. If not found, return error !! !! This is a simple, straightforward approach that assumes !! the JSON/mqc input provides the correct basis set name. character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable , intent ( out ) :: filename type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: normalized logical :: file_exists character ( len = 512 ) :: filepath ! Normalize the basis name normalized = normalize_basis_name ( basis_name ) ! Construct file path: basis_sets/{normalized}.txt filepath = \"basis_sets/\" // trim ( normalized ) // \".txt\" ! Check if file exists inquire ( file = trim ( filepath ), exist = file_exists ) if ( file_exists ) then filename = trim ( filepath ) else call error % set ( ERROR_IO , \"Basis set file not found: \" // trim ( filepath ) // & \" (from basis name: \" // trim ( basis_name ) // \")\" ) end if end subroutine find_basis_file end module mqc_basis_utils","tags":"","url":"sourcefile/mqc_basis_utils.f90.html"},{"title":"mqc_basis_reader.f90 – metalquicha","text":"This file contains basis set reader routines for basis sets This file depends on sourcefile~~mqc_basis_reader.f90~~EfferentGraph sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_file_reader.f90 mqc_basis_file_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_basis_file_reader.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This file contains basis set reader routines for basis sets module mqc_basis_reader !! Gaussian basis set parser and molecular basis construction !! !! Provides utilities for parsing Gaussian-type orbital basis sets !! from text files and building molecular basis sets for quantum calculations. use mqc_cgto , only : cgto_type , atomic_basis_type , molecular_basis_type use mqc_basis_file_reader , only : strings_equal use mqc_error , only : error_t , ERROR_PARSE use pic_types , only : dp implicit none private public :: classify_line !! Determine basis file line type public :: parse_element_basis !! Parse basis for single element public :: build_molecular_basis !! Build complete molecular basis public :: ang_mom_char_to_int !! Convert angular momentum character to integer public :: ang_mom_int_to_char !! Convert angular momentum integer to character ! Basis file line classification constants integer , parameter , public :: LINE_UNKNOWN = 0 !! Unrecognized line type integer , parameter , public :: LINE_ATOM = 1 !! Element specification line integer , parameter , public :: LINE_SHELL = 2 !! Shell definition line integer , parameter , public :: LINE_FUNCTION = 3 !! Basis function coefficient line contains pure function ang_mom_char_to_int ( ang_mom_char ) result ( ang_mom ) !! Convert angular momentum character to integer !! !! Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6 !! Special case: L=-1 (combined S+P shell, requires splitting) character ( len = 1 ), intent ( in ) :: ang_mom_char !! Angular momentum symbol integer :: ang_mom !! Corresponding integer value select case ( ang_mom_char ) case ( 'S' ) ang_mom = 0 case ( 'P' ) ang_mom = 1 case ( 'D' ) ang_mom = 2 case ( 'F' ) ang_mom = 3 case ( 'G' ) ang_mom = 4 case ( 'H' ) ang_mom = 5 case ( 'I' ) ang_mom = 6 case ( 'L' ) ang_mom = - 1 ! Special case: L shells are split into S+P case default ang_mom = - 1 end select end function ang_mom_char_to_int pure function ang_mom_int_to_char ( ang_mom ) result ( ang_mom_char ) !! Convert angular momentum integer to character !! !! Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I !! Returns '?' for invalid input values. integer , intent ( in ) :: ang_mom !! Angular momentum quantum number character ( len = 1 ) :: ang_mom_char !! Corresponding symbol character select case ( ang_mom ) case ( 0 ) ang_mom_char = 'S' case ( 1 ) ang_mom_char = 'P' case ( 2 ) ang_mom_char = 'D' case ( 3 ) ang_mom_char = 'F' case ( 4 ) ang_mom_char = 'G' case ( 5 ) ang_mom_char = 'H' case ( 6 ) ang_mom_char = 'I' case default ang_mom_char = '?' end select end function ang_mom_int_to_char pure function classify_line ( line ) result ( line_type ) !! Classify a line from a gamess formatted basis set file character ( len =* ), intent ( in ) :: line integer :: line_type character ( len = :), allocatable :: line_trim line_trim = trim ( adjustl ( line )) if ( is_blank_or_control ( line_trim )) then line_type = LINE_UNKNOWN else if ( is_function_line ( line_trim )) then line_type = LINE_FUNCTION else if ( is_shell_header ( line_trim )) then line_type = LINE_SHELL else line_type = LINE_ATOM end if end function classify_line pure function is_blank_or_control ( line ) result ( res ) !! Check if a line is blank or a control line (starts with '$') character ( len =* ), intent ( in ) :: line logical :: res integer :: trimmed_len trimmed_len = len_trim ( line ) if ( trimmed_len == 0 ) then res = . true . else res = ( line ( 1 : 1 ) == '$' ) end if end function is_blank_or_control pure function is_function_line ( line ) result ( res ) !! Check if a line is a function coefficient line (starts with a number) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char if ( len_trim ( line ) == 0 ) then res = . false . return end if first_char = line ( 1 : 1 ) res = ( first_char >= '0' . and . first_char <= '9' ) end function is_function_line pure function is_shell_header ( line ) result ( res ) !! Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char integer :: ios , dummy res = . false . if ( len_trim ( line ) == 0 ) return first_char = line ( 1 : 1 ) if (. not . any ( first_char == [ 'S' , 'P' , 'D' , 'F' , 'G' , 'H' , 'I' , 'L' ])) return read ( line ( 2 :), * , iostat = ios ) dummy res = ( ios == 0 ) end function is_shell_header pure subroutine parse_element_basis ( basis_string , element_name , atom_basis , error ) !! Parse basis set for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( out ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: nshells ! Pass 1: Find the element and count its shells call count_shells_for_element ( basis_string , element_name , nshells , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_basis_reader:parse_element_basis\" ) return end if if ( nshells == 0 ) then call error % set ( ERROR_PARSE , \"Element \" // trim ( element_name ) // \" not found in basis file\" ) return end if ! ! Allocate shells atom_basis % element = trim ( element_name ) call atom_basis % allocate_shells ( nshells ) ! ! Pass 2: Parse and fill shell data call fill_element_basis ( basis_string , element_name , atom_basis , error ) end subroutine parse_element_basis pure subroutine count_shells_for_element ( basis_string , element_name , nshells , error ) !! Count the number of shells for a specific element in a GAMESS formatted basis string, character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name integer , intent ( out ) :: nshells type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_target_element , found_element character ( len = 1 ) :: ang_mom nshells = 0 in_target_element = . false . found_element = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) case ( LINE_ATOM ) ! Check if this is our target element if ( strings_equal ( line , element_name )) then in_target_element = . true . found_element = . true . else ! Different element - stop counting if we were in target if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Extract angular momentum line = adjustl ( line ) ang_mom = line ( 1 : 1 ) ! L shells become 2 shells (S + P) if ( ang_mom == 'L' ) then nshells = nshells + 2 else nshells = nshells + 1 end if end if case ( LINE_UNKNOWN ) ! Skip blank lines and comments continue case default ! Skip any other line types (e.g., LINE_FUNCTION) continue end select line_start = line_end end do ! Check if we found the element at all if (. not . found_element ) then call error % set ( ERROR_PARSE , \"Element not found in basis string: \" // trim ( element_name )) end if end subroutine count_shells_for_element pure subroutine get_next_line ( string , line_start , line , line_end ) !! Extract the next line from a string starting at line_start character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: line_start character ( len =* ), intent ( out ) :: line integer , intent ( out ) :: line_end integer :: newline_pos if ( line_start > len ( string )) then line = '' line_end = 0 return end if newline_pos = index ( string ( line_start :), new_line ( 'a' )) if ( newline_pos == 0 ) then ! Last line (no newline at end) line = string ( line_start :) line_end = len ( string ) + 1 else line = string ( line_start : line_start + newline_pos - 2 ) line_end = line_start + newline_pos end if end subroutine get_next_line pure subroutine parse_shell_header ( line , ang_mom , nfunc , stat ) !! Parse shell header line (e.g., \"S 2\" or \"L 3\") character ( len =* ), intent ( in ) :: line character ( len = 1 ), intent ( out ) :: ang_mom integer , intent ( out ) :: nfunc integer , intent ( out ) :: stat character ( len = 256 ) :: line_trim line_trim = adjustl ( line ) ang_mom = line_trim ( 1 : 1 ) ! Read the number of functions read ( line_trim ( 2 :), * , iostat = stat ) nfunc end subroutine parse_shell_header pure subroutine parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) !! Parse function line (e.g., \"1 1.0 2.0\" or \"1 1.0 2.0 3.0\" for L shells) character ( len =* ), intent ( in ) :: line integer , intent ( out ) :: func_num real ( dp ), intent ( out ) :: exponent real ( dp ), intent ( out ) :: coeff_s real ( dp ), intent ( out ), optional :: coeff_p logical , intent ( out ) :: has_p integer , intent ( out ) :: stat real ( dp ) :: temp_p has_p = . false . ! Try to read 4 values (func_num, exponent, coeff_s, coeff_p) read ( line , * , iostat = stat ) func_num , exponent , coeff_s , temp_p if ( stat == 0 ) then ! Successfully read 4 values - this is an L shell has_p = . true . if ( present ( coeff_p )) coeff_p = temp_p else ! Try reading just 3 values (func_num, exponent, coeff_s) read ( line , * , iostat = stat ) func_num , exponent , coeff_s end if end subroutine parse_function_line pure subroutine fill_element_basis ( basis_string , element_name , atom_basis , error ) !! Fill in the shell data for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( inout ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_data_block , in_target_element character ( len = 1 ) :: ang_mom integer :: nfunc , func_num , ishell , ifunc real ( dp ) :: exponent , coeff_s , coeff_p logical :: has_p ! L shell handling: we split into two shells, need to track both logical :: reading_l_shell integer :: l_shell_s_idx , l_shell_p_idx integer :: stat in_data_block = . false . in_target_element = . false . ishell = 0 reading_l_shell = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) ! case (LINE_UNKNOWN) !   if (index(line, '$DATA') > 0) then !     in_data_block = .true. !   else if (index(line, '$END') > 0) then !     exit !   end if case ( LINE_ATOM ) if ( strings_equal ( line , element_name )) then in_target_element = . true . else if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Parse shell header call parse_shell_header ( line , ang_mom , nfunc , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse shell header: \" // trim ( line )) return end if if ( ang_mom == 'L' ) then ! L shell: create two shells (S and P) reading_l_shell = . true . ishell = ishell + 1 l_shell_s_idx = ishell atom_basis % shells ( ishell )% ang_mom = 0 ! S call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ishell = ishell + 1 l_shell_p_idx = ishell atom_basis % shells ( ishell )% ang_mom = 1 ! P call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 ! Reset function counter else ! Regular shell reading_l_shell = . false . ishell = ishell + 1 ! Set angular momentum (S=0, P=1, D=2, F=3, G=4, H=5, I=6) atom_basis % shells ( ishell )% ang_mom = ang_mom_char_to_int ( ang_mom ) call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 end if end if case ( LINE_FUNCTION ) if ( in_target_element ) then call parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse function line: \" // trim ( line )) return end if ifunc = ifunc + 1 if ( reading_l_shell ) then if (. not . has_p ) then call error % set ( ERROR_PARSE , \"L shell requires both S and P coefficients\" ) return end if ! Store in both S and P shells atom_basis % shells ( l_shell_s_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_s_idx )% coefficients ( ifunc ) = coeff_s atom_basis % shells ( l_shell_p_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_p_idx )% coefficients ( ifunc ) = coeff_p else ! Store in current shell atom_basis % shells ( ishell )% exponents ( ifunc ) = exponent atom_basis % shells ( ishell )% coefficients ( ifunc ) = coeff_s end if end if case default ! Skip unknown line types (e.g., LINE_UNKNOWN, blank lines, comments) continue end select line_start = line_end end do end subroutine fill_element_basis pure subroutine find_unique_strings ( input_array , unique_array , nunique ) !! Find unique strings in an array !! Returns array of unique strings and count character ( len =* ), intent ( in ) :: input_array (:) character ( len = :), allocatable , intent ( out ) :: unique_array (:) integer , intent ( out ) :: nunique integer :: i , j , n logical :: is_unique character ( len = len ( input_array )), allocatable :: temp_unique (:) n = size ( input_array ) allocate ( temp_unique ( n )) ! Max possible size nunique = 0 do i = 1 , n is_unique = . true . ! Check if we've already seen this string do j = 1 , nunique if ( strings_equal ( input_array ( i ), temp_unique ( j ))) then is_unique = . false . exit end if end do if ( is_unique ) then nunique = nunique + 1 temp_unique ( nunique ) = input_array ( i ) end if end do ! Allocate output array with exact size and copy allocate ( character ( len = len ( input_array )) :: unique_array ( nunique )) unique_array = temp_unique ( 1 : nunique ) end subroutine find_unique_strings pure subroutine copy_atomic_basis ( source , dest ) !! Deep copy of atomic basis data from source to dest type ( atomic_basis_type ), intent ( in ) :: source type ( atomic_basis_type ), intent ( out ) :: dest integer :: ishell dest % element = source % element call dest % allocate_shells ( source % nshells ) do ishell = 1 , source % nshells dest % shells ( ishell )% ang_mom = source % shells ( ishell )% ang_mom call dest % shells ( ishell )% allocate_arrays ( source % shells ( ishell )% nfunc ) dest % shells ( ishell )% exponents = source % shells ( ishell )% exponents dest % shells ( ishell )% coefficients = source % shells ( ishell )% coefficients end do end subroutine copy_atomic_basis subroutine build_molecular_basis ( basis_string , element_names , mol_basis , error ) !! Build molecular basis from geometry and basis file !! Only parses unique elements, then copies basis data to atoms character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_names (:) !! Element for each atom in geometry order type ( molecular_basis_type ), intent ( out ) :: mol_basis type ( error_t ), intent ( out ) :: error integer :: iatom , natoms , iunique , nunique character ( len = :), allocatable :: unique_elements (:) type ( atomic_basis_type ), allocatable :: unique_bases (:) integer :: match_idx match_idx = 0 natoms = size ( element_names ) ! Find unique elements call find_unique_strings ( element_names , unique_elements , nunique ) print * , \"Found \" , nunique , \" unique elements out of \" , natoms , \" atoms\" ! Allocate for unique bases allocate ( unique_bases ( nunique )) ! Parse basis for each unique element do iunique = 1 , nunique print * , \"Parsing basis for: \" , trim ( unique_elements ( iunique )) call parse_element_basis ( basis_string , unique_elements ( iunique ), & unique_bases ( iunique ), error ) if ( error % has_error ()) then ! Prepend context to error message call error % add_context ( \"mqc_basis_reader:read_basis_from_string\" ) call error % set ( ERROR_PARSE , \"Failed to parse basis for element \" // & trim ( unique_elements ( iunique )) // \": \" // error % get_message ()) return end if end do ! Allocate molecular basis and assign to each atom call mol_basis % allocate_elements ( natoms ) do iatom = 1 , natoms ! Find which unique element this atom corresponds to do iunique = 1 , nunique if ( strings_equal ( element_names ( iatom ), unique_elements ( iunique ))) then match_idx = iunique exit end if end do ! Copy the basis data call copy_atomic_basis ( unique_bases ( match_idx ), mol_basis % elements ( iatom )) end do ! Clean up do iunique = 1 , nunique call unique_bases ( iunique )% destroy () end do end subroutine build_molecular_basis end module mqc_basis_reader","tags":"","url":"sourcefile/mqc_basis_reader.f90.html"},{"title":"mqc_xyz_reader.f90 – metalquicha","text":"XYZ molecular geometry file reader This file depends on sourcefile~~mqc_xyz_reader.f90~~EfferentGraph sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_xyz_reader.f90~~AfferentGraph sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! XYZ molecular geometry file reader module mqc_xyz_reader !! Provides functions to parse standard XYZ format files containing !! atomic coordinates and element symbols for molecular structures. use pic_types , only : dp use mqc_geometry , only : geometry_type use mqc_error , only : error_t , ERROR_IO , ERROR_PARSE implicit none private public :: read_xyz_file !! Read XYZ file from disk public :: read_xyz_string !! Parse XYZ data from string public :: split_lines !! Split text into lines (for testing) ! Constants integer , parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 !! Maximum element symbol length contains subroutine read_xyz_file ( filename , geom , error ) !! Read molecular geometry from XYZ format file !! !! Parses standard XYZ files with format: !! Line 1: Number of atoms !! Line 2: Comment/title line !! Lines 3+: Element X Y Z (coordinates in Angstrom) character ( len =* ), intent ( in ) :: filename !! Path to XYZ file type ( geometry_type ), intent ( out ) :: geom !! Parsed molecular geometry type ( error_t ), intent ( out ) :: error !! Error handling integer :: unit !! File unit number integer :: io_stat !! I/O operation status integer :: file_size !! File size in bytes logical :: file_exists !! Whether file exists on disk character ( len = :), allocatable :: file_contents !! Full file content buffer ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"XYZ file not found: \" // trim ( filename )) return end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: file_contents ) ! Open and read entire file as stream open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening file: \" // trim ( filename )) return end if read ( unit , iostat = io_stat ) file_contents close ( unit ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error reading file: \" // trim ( filename )) return end if ! Parse the contents call read_xyz_string ( file_contents , geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_xyz_reader:read_xyz_file\" ) return end if end subroutine read_xyz_file pure subroutine read_xyz_string ( xyz_string , geom , error ) !! Parse molecular geometry from XYZ format string character ( len =* ), intent ( in ) :: xyz_string type ( geometry_type ), intent ( out ) :: geom type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: lines (:) integer :: nlines , iatom , io_stat character ( len = 256 ) :: element real ( dp ) :: x , y , z ! Split into lines call split_lines ( xyz_string , lines , nlines ) if ( nlines < 2 ) then call error % set ( ERROR_PARSE , \"XYZ file must have at least 2 lines (natoms + comment)\" ) return end if ! Read number of atoms from first line read ( lines ( 1 ), * , iostat = io_stat ) geom % natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to read number of atoms from first line\" ) return end if if ( geom % natoms < 0 ) then call error % set ( ERROR_PARSE , \"Number of atoms must be non-negative\" ) return end if ! Store comment line geom % comment = trim ( adjustl ( lines ( 2 ))) ! Check we have enough lines if ( nlines < 2 + geom % natoms ) then call error % set ( ERROR_PARSE , \"XYZ file has insufficient lines: expected \" // & trim ( int_to_string ( 2 + geom % natoms )) // \", got \" // & trim ( int_to_string ( nlines ))) return end if ! Allocate arrays allocate ( character ( len = MAX_ELEMENT_SYMBOL_LEN ) :: geom % elements ( geom % natoms )) allocate ( geom % coords ( 3 , geom % natoms )) ! Read atom data do iatom = 1 , geom % natoms read ( lines ( 2 + iatom ), * , iostat = io_stat ) element , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse atom data on line \" // & trim ( int_to_string ( 2 + iatom )) // \": '\" // & trim ( lines ( 2 + iatom )) // \"'\" ) return end if geom % elements ( iatom ) = trim ( adjustl ( element )) geom % coords ( 1 , iatom ) = x geom % coords ( 2 , iatom ) = y geom % coords ( 3 , iatom ) = z end do end subroutine read_xyz_string pure function int_to_string ( i ) result ( str ) !! Convert integer to string integer , intent ( in ) :: i character ( len = :), allocatable :: str character ( len = 20 ) :: buffer write ( buffer , '(I0)' ) i str = trim ( adjustl ( buffer )) end function int_to_string pure subroutine split_lines ( text , lines , nlines ) !! Split input text into lines based on CR, LF, or CRLF line endings !! Trailing newlines do not create empty lines character ( len =* ), intent ( in ) :: text character ( len = :), allocatable , intent ( out ) :: lines (:) integer , intent ( out ) :: nlines integer :: i , line_start , line_end , max_line_len character ( len = :), allocatable :: temp_lines (:) if ( len ( text ) == 0 ) then nlines = 0 allocate ( character ( len = 1 ) :: lines ( 0 )) return end if ! Pass 1: Count lines and find maximum line length nlines = 0 max_line_len = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 ! Skip both CR and LF else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 max_line_len = max ( max_line_len , len ( text ) - line_start + 1 ) end if ! Handle empty text or ensure at least length 1 if ( max_line_len == 0 ) max_line_len = 1 ! Allocate output array allocate ( character ( len = max_line_len ) :: temp_lines ( nlines )) ! Pass 2: Extract lines nlines = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = len ( text ) - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if ! Copy to output (use explicit loop for Intel compiler compatibility) allocate ( character ( len = max_line_len ) :: lines ( nlines )) block integer :: iline do iline = 1 , nlines lines ( iline ) = temp_lines ( iline ) end do end block end subroutine split_lines end module mqc_xyz_reader","tags":"","url":"sourcefile/mqc_xyz_reader.f90.html"},{"title":"mqc_mbe_mpi_fragment_distribution_scheme.F90 – metalquicha","text":"This file depends on sourcefile~~mqc_mbe_mpi_fragment_distribution_scheme.f90~~EfferentGraph sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( mqc_mbe_fragment_distribution_scheme ) mqc_mbe_fragment_distribution_scheme implicit none contains module subroutine do_fragment_work ( fragment_idx , result , method , phys_frag , calc_type ) !! Process a single fragment for quantum chemistry calculation !! !! Performs energy and gradient calculation on a molecular fragment using !! specified quantum chemistry method (GFN-xTB variants). !! Verbosity is controlled by the global logger level. use pic_logger , only : verbose_level integer ( int64 ), intent ( in ) :: fragment_idx !! Fragment index for identification type ( calculation_result_t ), intent ( out ) :: result !! Computation results integer ( int32 ), intent ( in ) :: method !! QC method type ( physical_fragment_t ), intent ( in ), optional :: phys_frag !! Fragment geometry integer ( int32 ), intent ( in ) :: calc_type !! Calculation type integer :: current_log_level !! Current logger verbosity level logical :: is_verbose !! Whether verbose output is enabled integer ( int32 ) :: calc_type_local !! Local copy of calc_type #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc !! XTB calculator instance #endif calc_type_local = calc_type ! Query logger to determine verbosity call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) ! Print fragment geometry if provided and verbose mode is enabled if ( present ( phys_frag )) then if ( is_verbose ) then call print_fragment_xyz ( fragment_idx , phys_frag ) end if #ifndef MQC_WITHOUT_TBLITE ! Setup XTB method xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = is_verbose ! Run the calculation using the method API select case ( calc_type_local ) case ( CALC_TYPE_ENERGY ) call xtb_calc % calc_energy ( phys_frag , result ) case ( CALC_TYPE_GRADIENT ) call xtb_calc % calc_gradient ( phys_frag , result ) case ( CALC_TYPE_HESSIAN ) call xtb_calc % calc_hessian ( phys_frag , result ) case default call logger % error ( \"Unknown calc_type: \" // calc_type_to_string ( calc_type_local )) error stop \"Invalid calc_type in do_fragment_work\" end select ! Copy fragment distance to result for JSON output result % distance = phys_frag % distance #else call logger % error ( \"XTB method requested but tblite support not compiled in\" ) call logger % error ( \"Please rebuild with -DMQC_ENABLE_TBLITE=ON\" ) error stop \"tblite support not available\" #endif else ! For empty fragments, set energy to zero call result % energy % reset () result % has_energy = . true . end if end subroutine do_fragment_work module subroutine global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , calc_type , bonds ) !! Global coordinator for distributing fragments to node coordinators !! will act as a node coordinator for a single node calculation !! Uses int64 for total_fragments to handle large fragment counts that overflow int32. type ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level , num_nodes integer , intent ( in ) :: polymers (:, :), node_leader_ranks (:) type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( timer_type ) :: coord_timer integer ( int64 ) :: current_fragment , results_received integer :: finished_nodes integer :: request_source , dummy_msg integer ( int64 ) :: fragment_idx type ( MPI_Status ) :: status , local_status logical :: handling_local_workers logical :: has_pending integer ( int32 ) :: calc_type_local ! For local workers integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer ( int64 ) :: worker_fragment_map ( node_comm % size ()) integer :: worker_source ! MPI request handles for non-blocking operations type ( request_t ) :: req calc_type_local = calc_type current_fragment = total_fragments finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( node_comm % size () > 1 ) results_received = 0_int64 ! Allocate storage for results allocate ( results ( total_fragments )) worker_fragment_map = 0 call logger % verbose ( \"Global coordinator starting with \" // to_char ( total_fragments ) // & \" fragments for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers ! This MUST be checked before sending new work to avoid race conditions if ( handling_local_workers ) then ! Keep checking for results until there are none pending do call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state\" end if ! Receive result and store it using the fragment index for this worker call result_irecv ( results ( worker_fragment_map ( worker_source )), node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clear the mapping since we've received the result worker_fragment_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit ! Receive fragment index and result from node coordinator ! TODO: serialize the data for better performance call irecv ( world_comm , fragment_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( fragment_idx ), world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_fragment >= 1 ) then call send_fragment_to_node ( world_comm , current_fragment , polymers , request_source ) current_fragment = current_fragment - 1 else call isend ( world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < node_comm % size () - 1 ) then call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_fragment >= 1 ) then call send_fragment_to_worker ( node_comm , current_fragment , polymers , & local_status % MPI_SOURCE ) ! Track which fragment was sent to this worker worker_fragment_map ( local_status % MPI_SOURCE ) = current_fragment current_fragment = current_fragment - 1 else call isend ( node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if ! If worker still has pending results, skip the work request ! It will be processed on the next iteration after results are received end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= node_comm % size () - 1 & . and . results_received >= total_fragments ) then handling_local_workers = . false . if ( num_nodes == 1 ) then finished_nodes = finished_nodes + 1 call logger % debug ( \"Manually incremented finished_nodes for self\" ) else finished_nodes = finished_nodes + 1 call logger % verbose ( \"Global coordinator finished local workers\" ) end if end if end do call logger % verbose ( \"Global coordinator finished all fragments\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) block real ( dp ) :: mbe_total_energy real ( dp ), allocatable :: mbe_total_gradient (:, :) real ( dp ), allocatable :: mbe_total_hessian (:, :) ! Compute the many-body expansion call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Use combined function if computing gradients or Hessians (more efficient) if ( calc_type_local == CALC_TYPE_HESSIAN ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for Hessian calculation in global_coordinator\" ) error stop \"Missing sys_geom for Hessian calculation\" end if allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) allocate ( mbe_total_hessian ( 3 * sys_geom % total_atoms , 3 * sys_geom % total_atoms )) call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy , & sys_geom , mbe_total_gradient , mbe_total_hessian , bonds ) deallocate ( mbe_total_gradient , mbe_total_hessian ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for gradient calculation in global_coordinator\" ) error stop \"Missing sys_geom for gradient calculation\" end if allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy , & sys_geom , mbe_total_gradient , bonds = bonds ) deallocate ( mbe_total_gradient ) else call compute_mbe ( polymers , total_fragments , max_level , results , mbe_total_energy ) end if call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end block ! Cleanup deallocate ( results ) end subroutine global_coordinator subroutine send_fragment_to_node ( world_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to remote node coordinator !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int64 ) :: fragment_idx_int64 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int64 = int ( fragment_idx , kind = int64 ) call isend ( world_comm , fragment_idx_int64 , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , fragment_size , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , fragment_indices , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_node subroutine send_fragment_to_worker ( node_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to local worker !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int64 ) :: fragment_idx_int64 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int64 = int ( fragment_idx , kind = int64 ) call isend ( node_comm , fragment_idx_int64 , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , fragment_size , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , fragment_indices , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_worker module subroutine node_coordinator ( world_comm , node_comm , calc_type ) !! Node coordinator for distributing fragments to local workers !! Handles work requests and result collection from local workers class ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int32 ), intent ( in ) :: calc_type integer ( int64 ) :: fragment_idx integer ( int32 ) :: fragment_size , fragment_type , dummy_msg integer ( int32 ) :: finished_workers integer ( int32 ), allocatable :: fragment_indices (:) type ( MPI_Status ) :: status , global_status logical :: local_message_pending , more_fragments , has_result integer ( int32 ) :: local_dummy ! For tracking worker-fragment mapping and collecting results integer ( int64 ) :: worker_fragment_map ( node_comm % size ()) integer ( int32 ) :: worker_source type ( calculation_result_t ) :: worker_result ! MPI request handles for non-blocking operations type ( request_t ) :: req finished_workers = 0 more_fragments = . true . dummy_msg = 0 worker_fragment_map = 0 do while ( finished_workers < node_comm % size () - 1 ) ! PRIORITY 1: Check for incoming results from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_result , status ) if ( has_result ) then worker_source = status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Node coordinator received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state in node coordinator\" end if ! Receive result from worker call result_irecv ( worker_result , node_comm , worker_source , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Forward results to global coordinator with fragment index call isend ( world_comm , worker_fragment_map ( worker_source ), 0 , TAG_NODE_SCALAR_RESULT , req ) ! fragment_idx call wait ( req ) call result_isend ( worker_result , world_comm , 0 , TAG_NODE_SCALAR_RESULT , req ) ! result call wait ( req ) ! Clear the mapping worker_fragment_map ( worker_source ) = 0 end if ! PRIORITY 2: Check for work requests from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , local_message_pending , status ) if ( local_message_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( more_fragments ) then call isend ( world_comm , dummy_msg , 0 , TAG_NODE_REQUEST , req ) call wait ( req ) call irecv ( world_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , global_status ) if ( global_status % MPI_TAG == TAG_NODE_FRAGMENT ) then ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( world_comm , fragment_type , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) call irecv ( world_comm , fragment_size , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( world_comm , fragment_indices , 0 , TAG_NODE_FRAGMENT , global_status ) ! Forward to worker call isend ( node_comm , fragment_idx , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_type , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_size , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_indices , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Track which fragment was sent to this worker worker_fragment_map ( status % MPI_SOURCE ) = fragment_idx deallocate ( fragment_indices ) else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 more_fragments = . false . end if else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end if end do end subroutine node_coordinator module subroutine node_worker ( world_comm , node_comm , sys_geom , method , calc_type , bonds ) !! Node worker for processing fragments assigned by node coordinator use mqc_error , only : error_t class ( comm_t ), intent ( in ) :: world_comm , node_comm type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int64 ) :: fragment_idx integer ( int32 ) :: fragment_size , dummy_msg integer ( int32 ) :: fragment_type !! 0 = monomer (indices), 1 = intersection (atom list) integer ( int32 ), allocatable :: fragment_indices (:) type ( calculation_result_t ) :: result type ( MPI_Status ) :: status type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error ! MPI request handles for non-blocking operations type ( request_t ) :: req dummy_msg = 0 do call isend ( node_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( node_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) select case ( status % MPI_TAG ) case ( TAG_WORKER_FRAGMENT ) ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( node_comm , fragment_type , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call irecv ( node_comm , fragment_size , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( node_comm , fragment_indices , 0 , TAG_WORKER_FRAGMENT , status ) ! Build physical fragment based on type if ( present ( sys_geom )) then if ( fragment_type == 0 ) then ! Monomer: fragment_indices are monomer indices call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , error , bonds ) else ! Intersection: fragment_indices are atom indices call build_fragment_from_atom_list ( sys_geom , fragment_indices , fragment_size , phys_frag , error , bonds ) end if if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build fragment in node worker\" end if ! Process the chemistry fragment with physical geometry call do_fragment_work ( fragment_idx , result , method , phys_frag , calc_type ) call phys_frag % destroy () else ! Process without physical geometry (old behavior) call do_fragment_work ( fragment_idx , result , method , calc_type = calc_type ) end if ! Send result back to coordinator call result_isend ( result , node_comm , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clean up result call result % destroy () deallocate ( fragment_indices ) case ( TAG_WORKER_FINISH ) exit case default ! Unexpected MPI tag - this should not happen in normal operation call logger % error ( \"Worker received unexpected MPI tag: \" // to_char ( status % MPI_TAG )) call logger % error ( \"Expected TAG_WORKER_FRAGMENT or TAG_WORKER_FINISH\" ) error stop \"MPI protocol error in node_worker\" end select end do end subroutine node_worker end submodule mqc_mbe_fragment_distribution_scheme","tags":"","url":"sourcefile/mqc_mbe_mpi_fragment_distribution_scheme.f90.html"},{"title":"mqc_config_parser.f90 – metalquicha","text":"Parser for MQC section-based input files (.mqc format) This file depends on sourcefile~~mqc_config_parser.f90~~EfferentGraph sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_config_parser.f90~~AfferentGraph sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Parser for MQC section-based input files (.mqc format) module mqc_config_parser !! Parses section-based input files with %section...end blocks !! This is the new format generated by mqc_prep.py use pic_types , only : dp , int32 , int64 use mqc_method_types , only : method_type_from_string , METHOD_TYPE_GFN2 , METHOD_TYPE_UNKNOWN use mqc_calc_types , only : calc_type_from_string , CALC_TYPE_ENERGY , CALC_TYPE_UNKNOWN use mqc_geometry , only : geometry_type use mqc_error , only : error_t , ERROR_IO , ERROR_PARSE , ERROR_VALIDATION implicit none private public :: mqc_config_t , read_mqc_file public :: input_fragment_t , bond_t , molecule_t ! Maximum line length for reading integer , parameter :: MAX_LINE_LEN = 1024 type :: input_fragment_t !! Input fragment definition with charge, multiplicity, and atom indices !! This is the parsed representation from the input file, not the computational fragment integer :: charge = 0 integer :: multiplicity = 1 integer , allocatable :: indices (:) !! Atom indices in this fragment contains procedure :: destroy => input_fragment_destroy end type input_fragment_t type :: bond_t !! Bond definition with atom indices, order, and broken status integer :: atom_i = 0 integer :: atom_j = 0 integer :: order = 1 logical :: is_broken = . false . end type bond_t type :: molecule_t !! Single molecule definition with structure, geometry, fragments, and connectivity character ( len = :), allocatable :: name !! Optional molecule name ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) contains procedure :: destroy => molecule_destroy end type molecule_t type :: mqc_config_t !! Complete configuration from .mqc file ! Schema information character ( len = :), allocatable :: schema_name character ( len = :), allocatable :: schema_version integer :: index_base = 0 !! 0-based or 1-based indexing character ( len = :), allocatable :: units !! angstrom or bohr ! Model information integer ( int32 ) :: method = METHOD_TYPE_GFN2 character ( len = :), allocatable :: basis character ( len = :), allocatable :: aux_basis ! Driver information integer ( int32 ) :: calc_type = CALC_TYPE_ENERGY ! Multiple molecules support integer :: nmol = 0 !! Number of molecules (0 = single molecule mode for backward compatibility) type ( molecule_t ), allocatable :: molecules (:) !! Array of molecules (if nmol > 0) ! Single molecule fields (backward compatibility - used if nmol == 0) ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) ! SCF settings integer :: scf_maxiter = 300 real ( dp ) :: scf_tolerance = 1.0e-6_dp ! Hessian settings real ( dp ) :: hessian_displacement = 0.001_dp !! Finite difference displacement (Bohr) ! AIMD settings real ( dp ) :: aimd_dt = 1.0_dp !! Timestep (femtoseconds) integer :: aimd_nsteps = 0 !! Number of MD steps (0 = no AIMD) real ( dp ) :: aimd_initial_temperature = 30 0.0_dp !! Initial temperature for velocity init (K) integer :: aimd_output_frequency = 1 !! Write output every N steps ! Fragmentation settings character ( len = :), allocatable :: frag_method !! MBE, etc. integer :: frag_level = 1 logical :: allow_overlapping_fragments = . false . integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) character ( len = :), allocatable :: embedding character ( len = :), allocatable :: cutoff_method character ( len = :), allocatable :: distance_metric real ( dp ), allocatable :: fragment_cutoffs (:) !! Distance cutoffs indexed by n-mer level (2=dimer, 3=trimer, etc.) ! Logger settings (kept for compatibility) character ( len = :), allocatable :: log_level contains procedure :: destroy => config_destroy end type mqc_config_t contains pure function strip_comment ( line ) result ( stripped ) !! Remove comments (! or #) from a line and trim result character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: stripped integer :: comment_pos ! Find first occurrence of ! or # comment_pos = index ( line , '!' ) if ( comment_pos == 0 ) comment_pos = index ( line , '#' ) if ( comment_pos > 0 ) then ! Comment found - take everything before it stripped = trim ( adjustl ( line ( 1 : comment_pos - 1 ))) else ! No comment - use full line stripped = trim ( adjustl ( line )) end if end function strip_comment subroutine read_mqc_file ( filename , config , error ) !! Read and parse a .mqc format input file character ( len =* ), intent ( in ) :: filename type ( mqc_config_t ), intent ( out ) :: config type ( error_t ), intent ( out ) :: error integer :: unit , io_stat character ( len = MAX_LINE_LEN ) :: line logical :: file_exists type ( error_t ) :: parse_error inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"Input file not found: \" // trim ( filename )) return end if open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening input file: \" // trim ( filename )) return end if ! Set defaults config % log_level = \"info\" ! Read file line by line and dispatch to section parsers do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for section start if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%schema' ) call parse_schema_section ( unit , config , parse_error ) case ( '%model' ) call parse_model_section ( unit , config , parse_error ) case ( '%driver' ) call parse_driver_section ( unit , config , parse_error ) case ( '%structure' ) call parse_structure_section ( unit , config , parse_error ) case ( '%geometry' ) call parse_geometry_section ( unit , config , parse_error ) case ( '%fragments' ) call parse_fragments_section ( unit , config , parse_error ) case ( '%connectivity' ) call parse_connectivity_section ( unit , config , parse_error ) case ( '%scf' ) call parse_scf_section ( unit , config , parse_error ) case ( '%hessian' ) call parse_hessian_section ( unit , config , parse_error ) case ( '%aimd' ) call parse_aimd_section ( unit , config , parse_error ) case ( '%fragmentation' ) call parse_fragmentation_section ( unit , config , parse_error ) case ( '%system' ) call parse_system_section ( unit , config , parse_error ) case ( '%molecules' ) call parse_molecules_section ( unit , config , parse_error ) case default ! Skip unknown sections call skip_to_end ( unit , parse_error ) end select if ( parse_error % has_error ()) then error = parse_error call error % add_context ( \"mqc_config_parser:read_mqc_file\" ) close ( unit ) return end if end if end do close ( unit ) ! Validate required fields if (. not . allocated ( config % schema_name )) then call error % set ( ERROR_VALIDATION , \"Missing required section: %schema\" ) return end if ! Validate geometry: required for single-molecule mode, not for multi-molecule mode if ( config % nmol == 0 ) then ! Single molecule mode: require top-level geometry if (. not . allocated ( config % geometry % coords ) . or . config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"Missing required section: %geometry\" ) return end if else ! Multi-molecule mode: each molecule must have geometry (validated during parsing) ! No additional validation needed here end if end subroutine read_mqc_file subroutine parse_schema_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Unexpected end of file in %schema section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'name' ) config % schema_name = trim ( value ) case ( 'version' ) config % schema_version = trim ( value ) case ( 'index_base' ) read ( value , * , iostat = io_stat ) config % index_base case ( 'units' ) config % units = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %schema section: \" // trim ( key )) return end select end do end subroutine parse_schema_section subroutine parse_model_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %model section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'method' ) ! Parse method string (e.g., \"XTB-GFN1\" -> \"gfn1\") config % method = parse_method_string ( trim ( value )) if ( config % method == METHOD_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid method: \" // trim ( value )) return end if case ( 'basis' ) config % basis = trim ( value ) case ( 'aux_basis' ) config % aux_basis = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %model section: \" // trim ( key )) return end select end do end subroutine parse_model_section subroutine parse_driver_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %driver section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'type' ) config % calc_type = calc_type_from_string ( trim ( value )) if ( config % calc_type == CALC_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid calc_type: \" // trim ( value )) return end if case default call error % set ( ERROR_PARSE , \"Unknown key in %driver section: \" // trim ( key )) return end select end do end subroutine parse_driver_section subroutine parse_structure_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , config % charge , config % multiplicity , error ) end subroutine parse_structure_section subroutine parse_geometry_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , config % geometry , error ) end subroutine parse_geometry_section subroutine parse_fragments_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , config % nfrag , config % fragments , error ) end subroutine parse_fragments_section subroutine parse_fragment ( unit , fragment , error ) integer , intent ( in ) :: unit type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_indices in_indices = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragment\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_indices ) then in_indices = . false . cycle else exit end if end if if ( trim ( line ) == '%indices' ) then in_indices = . true . cycle end if if ( in_indices ) then ! Read indices call parse_indices_line ( line , fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_single_fragment_section\" ) return end if else eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) fragment % charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) fragment % multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in fragment properties: \" // trim ( key )) return end select end if end if end do end subroutine parse_fragment subroutine parse_indices_line ( line , fragment , error ) character ( len =* ), intent ( in ) :: line type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error integer :: io_stat , pos , count , i , idx character ( len = MAX_LINE_LEN ) :: temp_line integer , allocatable :: temp_indices (:), new_indices (:) temp_line = line ! Count how many integers count = 0 do read ( temp_line , * , iostat = io_stat ) idx if ( io_stat /= 0 ) exit count = count + 1 ! Remove the read integer from temp_line pos = scan ( temp_line , ' ' ) if ( pos == 0 ) exit temp_line = adjustl ( temp_line ( pos :)) end do if ( count == 0 ) return ! Allocate temporary array allocate ( temp_indices ( count )) ! Read the integers read ( line , * , iostat = io_stat ) temp_indices if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading fragment indices\" ) deallocate ( temp_indices ) return end if ! Append to existing indices if ( allocated ( fragment % indices )) then allocate ( new_indices ( size ( fragment % indices ) + count )) new_indices ( 1 : size ( fragment % indices )) = fragment % indices new_indices ( size ( fragment % indices ) + 1 :) = temp_indices call move_alloc ( new_indices , fragment % indices ) else call move_alloc ( temp_indices , fragment % indices ) end if end subroutine parse_indices_line subroutine parse_connectivity_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , config % nbonds , config % nbroken , config % bonds , error ) end subroutine parse_connectivity_section subroutine parse_scf_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %scf section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'maxiter' ) read ( value , * , iostat = io_stat ) config % scf_maxiter case ( 'tolerance' ) read ( value , * , iostat = io_stat ) config % scf_tolerance case default call error % set ( ERROR_PARSE , \"Unknown key in %scf section: \" // trim ( key )) return end select end do end subroutine parse_scf_section subroutine parse_hessian_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %hessian section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'finite_difference_displacement' , 'displacement' ) read ( value , * , iostat = io_stat ) config % hessian_displacement case default call error % set ( ERROR_PARSE , \"Unknown key in %hessian section: \" // trim ( key )) return end select end do end subroutine parse_hessian_section subroutine parse_aimd_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %aimd section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'dt' , 'timestep' ) read ( value , * , iostat = io_stat ) config % aimd_dt case ( 'nsteps' , 'steps' ) read ( value , * , iostat = io_stat ) config % aimd_nsteps case ( 'initial_temperature' , 'temperature' ) read ( value , * , iostat = io_stat ) config % aimd_initial_temperature case ( 'output_frequency' , 'output_freq' ) read ( value , * , iostat = io_stat ) config % aimd_output_frequency case default call error % set ( ERROR_PARSE , \"Unknown key in %aimd section: \" // trim ( key )) return end select end do end subroutine parse_aimd_section subroutine parse_fragmentation_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_cutoffs in_cutoffs = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragmentation section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_cutoffs ) then ! Validate cutoffs before leaving the cutoffs section call validate_cutoffs ( config , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_fragmentation_section\" ) return end if in_cutoffs = . false . cycle else exit end if end if if ( trim ( line ) == '%cutoffs' ) then in_cutoffs = . true . cycle end if eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( in_cutoffs ) then ! Parse cutoffs: numeric keys like \"2\", \"3\", \"4\", etc. ! representing n-mer level (2=dimer, 3=trimer, etc.) block integer :: nmer_level real ( dp ) :: cutoff_value ! Try to read the key as an integer (n-mer level) read ( key , * , iostat = io_stat ) nmer_level if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid n-mer level in cutoffs (expected integer): \" // trim ( key )) return end if ! Validate n-mer level if ( nmer_level < 2 ) then call error % set ( ERROR_PARSE , \"N-mer level must be >= 2 in cutoffs\" ) return end if if ( nmer_level > 10 ) then call error % set ( ERROR_PARSE , \"N-mer level too large in cutoffs (max 10 for decamer)\" ) return end if ! Read the cutoff value read ( value , * , iostat = io_stat ) cutoff_value if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid cutoff value: \" // trim ( value )) return end if ! Allocate array if not yet allocated (up to decamer = 10) if (. not . allocated ( config % fragment_cutoffs )) then allocate ( config % fragment_cutoffs ( 10 )) config % fragment_cutoffs = - 1.0_dp ! Initialize with sentinel value end if ! Store the cutoff value at the appropriate index config % fragment_cutoffs ( nmer_level ) = cutoff_value end block else select case ( trim ( key )) case ( 'method' ) config % frag_method = trim ( value ) case ( 'level' ) read ( value , * , iostat = io_stat ) config % frag_level if ( io_stat == 0 ) then if ( config % frag_level < 0 ) then call error % set ( ERROR_VALIDATION , \"Fragmentation level must be >= 0 (0 = unfragmented)\" ) return end if if ( config % frag_level > 10 ) then call error % set ( ERROR_VALIDATION , & \"Fragmentation level must be <= 10 (decamers). Higher levels not supported.\" ) return end if end if case ( 'allow_overlapping_fragments' ) config % allow_overlapping_fragments = ( trim ( value ) == 'true' ) case ( 'max_intersection_level' ) read ( value , * , iostat = io_stat ) config % max_intersection_level if ( io_stat == 0 ) then if ( config % max_intersection_level < 1 ) then call error % set ( ERROR_VALIDATION , \"max_intersection_level must be >= 1\" ) return end if if ( config % max_intersection_level > 10 ) then call error % set ( ERROR_VALIDATION , & \"max_intersection_level must be <= 10 (decamers). Higher levels not supported.\" ) return end if end if case ( 'embedding' ) config % embedding = trim ( value ) case ( 'cutoff_method' ) config % cutoff_method = trim ( value ) case ( 'distance_metric' ) config % distance_metric = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %fragmentation section: \" // trim ( key )) return end select end if end do end subroutine parse_fragmentation_section subroutine parse_system_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %system section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'log_level' ) config % log_level = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %system section: \" // trim ( key )) return end select end do end subroutine parse_system_section subroutine parse_molecules_section ( unit , config , error ) !! Parse %molecules section containing multiple %molecule blocks integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nmol , imol nmol = 0 ! First pass: read nmol do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecules section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nmol' ) then read ( value , * , iostat = io_stat ) nmol if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nmol value\" ) return end if exit end if end if end do if ( nmol == 0 ) then ! No molecules, just skip to end call skip_to_end ( unit , error ) return end if config % nmol = nmol allocate ( config % molecules ( nmol )) ! Parse individual molecules imol = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%molecule' ) then imol = imol + 1 if ( imol > nmol ) then call error % set ( ERROR_PARSE , \"More molecules than declared nmol\" ) return end if call parse_single_molecule ( unit , config % molecules ( imol ), error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_molecules_section\" ) return end if end if end do if ( imol /= nmol ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nmol , \" molecules, found \" , imol call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_molecules_section subroutine parse_single_molecule ( unit , mol , error ) !! Parse a single %molecule block with its sections integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecule\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit ! Check for key=value pairs (like name) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'name' ) then mol % name = trim ( value ) cycle end if end if ! Check for subsections if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%structure' ) call parse_molecule_structure ( unit , mol , error ) case ( '%geometry' ) call parse_molecule_geometry ( unit , mol , error ) case ( '%fragments' ) call parse_molecule_fragments ( unit , mol , error ) case ( '%connectivity' ) call parse_molecule_connectivity ( unit , mol , error ) case default ! Skip unknown subsections call skip_to_end ( unit , error ) end select if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_single_molecule\" ) return end if end if end do end subroutine parse_single_molecule subroutine parse_molecule_structure ( unit , mol , error ) !! Parse %structure section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , mol % charge , mol % multiplicity , error ) end subroutine parse_molecule_structure subroutine parse_molecule_geometry ( unit , mol , error ) !! Parse %geometry section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , mol % geometry , error ) end subroutine parse_molecule_geometry subroutine parse_molecule_fragments ( unit , mol , error ) !! Parse %fragments section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , mol % nfrag , mol % fragments , error ) end subroutine parse_molecule_fragments subroutine parse_molecule_connectivity ( unit , mol , error ) !! Parse %connectivity section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , mol % nbonds , mol % nbroken , mol % bonds , error ) end subroutine parse_molecule_connectivity subroutine skip_to_end ( unit , error ) !! Skip lines until 'end' marker is found integer , intent ( in ) :: unit type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line integer :: io_stat do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file while skipping section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) exit end do end subroutine skip_to_end function parse_method_string ( method_str ) result ( method_type ) !! Parse method string from input file (e.g., \"XTB-GFN1\" -> gfn1) character ( len =* ), intent ( in ) :: method_str integer ( int32 ) :: method_type character ( len = :), allocatable :: lower_str , method_part integer :: dash_pos , i ! Convert to lowercase allocate ( character ( len = len_trim ( method_str )) :: lower_str ) lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Handle \"XTB-GFN1\" format -> extract \"gfn1\" if ( index ( lower_str , 'xtb' ) > 0 ) then dash_pos = index ( lower_str , '-' ) if ( dash_pos > 0 ) then method_part = lower_str ( dash_pos + 1 :) else method_part = lower_str end if else method_part = lower_str end if method_type = method_type_from_string ( method_part ) end function parse_method_string subroutine molecule_destroy ( this ) !! Clean up allocated memory in molecule_t class ( molecule_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % name )) deallocate ( this % name ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) end subroutine molecule_destroy subroutine config_destroy ( this ) !! Clean up allocated memory in mqc_config_t class ( mqc_config_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % schema_name )) deallocate ( this % schema_name ) if ( allocated ( this % schema_version )) deallocate ( this % schema_version ) if ( allocated ( this % units )) deallocate ( this % units ) if ( allocated ( this % basis )) deallocate ( this % basis ) if ( allocated ( this % aux_basis )) deallocate ( this % aux_basis ) if ( allocated ( this % log_level )) deallocate ( this % log_level ) if ( allocated ( this % frag_method )) deallocate ( this % frag_method ) if ( allocated ( this % embedding )) deallocate ( this % embedding ) if ( allocated ( this % cutoff_method )) deallocate ( this % cutoff_method ) if ( allocated ( this % distance_metric )) deallocate ( this % distance_metric ) if ( allocated ( this % fragment_cutoffs )) deallocate ( this % fragment_cutoffs ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) ! Clean up molecules array (multi-molecule mode) if ( allocated ( this % molecules )) then do i = 1 , size ( this % molecules ) call this % molecules ( i )% destroy () end do deallocate ( this % molecules ) end if end subroutine config_destroy subroutine input_fragment_destroy ( this ) !! Clean up allocated memory in input_fragment_t class ( input_fragment_t ), intent ( inout ) :: this if ( allocated ( this % indices )) deallocate ( this % indices ) end subroutine input_fragment_destroy !! ======================================================================== !! Generic parsing helpers to eliminate redundancy !! ======================================================================== subroutine parse_structure_generic ( unit , charge , multiplicity , error ) !! Generic parser for %structure section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: charge , multiplicity type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %structure section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in %structure section: \" // trim ( key )) return end select end do end subroutine parse_structure_generic subroutine parse_geometry_generic ( unit , geom , error ) !! Generic parser for %geometry section (works for both config and molecule) integer , intent ( in ) :: unit type ( geometry_type ), intent ( inout ) :: geom type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , elem integer :: io_stat , natoms , i real ( dp ) :: x , y , z ! Read number of atoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading natoms in %geometry section\" ) return end if read ( line , * , iostat = io_stat ) natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid natoms in %geometry section\" ) return end if geom % natoms = natoms ! Read blank line (comment line in XYZ format) read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading comment line in %geometry section\" ) return end if geom % comment = trim ( line ) ! Allocate arrays allocate ( character ( len = 4 ) :: geom % elements ( natoms )) allocate ( geom % coords ( 3 , natoms )) ! Read coordinates do i = 1 , natoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry coordinates\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) then call error % set ( ERROR_PARSE , \"Unexpected 'end' while reading geometry\" ) return end if read ( line , * , iostat = io_stat ) elem , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid coordinate format in %geometry section\" ) return end if geom % elements ( i ) = trim ( elem ) geom % coords ( 1 , i ) = x geom % coords ( 2 , i ) = y geom % coords ( 3 , i ) = z end do ! Read 'end' marker read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_VALIDATION , \"Missing 'end' in %geometry section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) /= 'end' ) then call error % set ( ERROR_PARSE , \"Expected 'end' after geometry coordinates\" ) return end if end subroutine parse_geometry_generic subroutine parse_fragments_generic ( unit , nfrag , fragments , error ) !! Generic parser for %fragments section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nfrag type ( input_fragment_t ), allocatable , intent ( inout ) :: fragments (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nfrag_local , ifrag nfrag_local = 0 ! First pass: read nfrag do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragments section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nfrag' ) then read ( value , * , iostat = io_stat ) nfrag_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nfrag value\" ) return end if exit end if end if end do if ( nfrag_local == 0 ) then ! No fragments, just skip to end call skip_to_end ( unit , error ) return end if nfrag = nfrag_local allocate ( fragments ( nfrag )) ! Parse individual fragments ifrag = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%fragment' ) then ifrag = ifrag + 1 if ( ifrag > nfrag ) then call error % set ( ERROR_PARSE , \"More fragments than declared nfrag\" ) return end if call parse_fragment ( unit , fragments ( ifrag ), error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_molecule_fragments\" ) return end if end if end do if ( ifrag /= nfrag ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nfrag , \" fragments, found \" , ifrag call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_fragments_generic subroutine parse_connectivity_generic ( unit , nbonds , nbroken , bonds , error ) !! Generic parser for %connectivity section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nbonds , nbroken type ( bond_t ), allocatable , intent ( inout ) :: bonds (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value , status_str integer :: io_stat , eq_pos , nbonds_local , ibond integer :: atom_i , atom_j , order nbonds_local = 0 ! First pass: read nbonds do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %connectivity section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbonds' ) then read ( value , * , iostat = io_stat ) nbonds_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nbonds value\" ) return end if exit end if end if end do if ( nbonds_local == 0 ) then ! No bonds, just skip to end call skip_to_end ( unit , error ) return end if nbonds = nbonds_local allocate ( bonds ( nbonds )) ! Read bonds ibond = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for key=value pairs (like nbroken=9) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbroken' ) then read ( value , * , iostat = io_stat ) nbroken end if cycle end if if ( trim ( strip_comment ( line )) == 'end' ) exit ! Parse bond line: atom_i atom_j order broken/preserved read ( line , * , iostat = io_stat ) atom_i , atom_j , order , status_str if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid bond format in %connectivity section\" ) return end if ibond = ibond + 1 if ( ibond > nbonds ) then call error % set ( ERROR_PARSE , \"More bonds than declared nbonds\" ) return end if bonds ( ibond )% atom_i = atom_i bonds ( ibond )% atom_j = atom_j bonds ( ibond )% order = order bonds ( ibond )% is_broken = ( trim ( status_str ) == 'broken' ) end do end subroutine parse_connectivity_generic subroutine validate_cutoffs ( config , error ) !! Validate that fragment cutoffs are monotonically decreasing !! For n-mer level N, cutoff(N) must be <= cutoff(N-1) type ( mqc_config_t ), intent ( in ) :: config type ( error_t ), intent ( out ) :: error integer :: i , level_low , level_high real ( dp ) :: cutoff_low , cutoff_high character ( len = 256 ) :: msg if (. not . allocated ( config % fragment_cutoffs )) return ! Check monotonicity for consecutive levels with defined cutoffs do i = 2 , size ( config % fragment_cutoffs ) level_low = i - 1 level_high = i cutoff_low = config % fragment_cutoffs ( level_low ) cutoff_high = config % fragment_cutoffs ( level_high ) ! Skip if either cutoff is not defined (negative or zero sentinel value) if ( cutoff_low <= 0.0_dp . or . cutoff_high <= 0.0_dp ) cycle ! Validate monotonic decreasing if ( cutoff_high > cutoff_low ) then write ( msg , '(a,i0,a,f0.2,a,i0,a,f0.2,a)' ) & \"Fragment cutoffs must be monotonically decreasing: \" , & level_high , \"-mer cutoff (\" , cutoff_high , \") cannot be larger than \" , & level_low , \"-mer cutoff (\" , cutoff_low , \"). Check %cutoffs section.\" call error % set ( ERROR_PARSE , trim ( msg )) return end if end do end subroutine validate_cutoffs end module mqc_config_parser","tags":"","url":"sourcefile/mqc_config_parser.f90.html"},{"title":"mqc_libcint_interface.f90 – metalquicha","text":"Libcint Fortran interface module Source Code !! Libcint Fortran interface module module mqc_libcint_interface !! Provides Fortran interface to the Libcint library for integral calculations !use libcint_fortran implicit none private end module mqc_libcint_interface","tags":"","url":"sourcefile/mqc_libcint_interface.f90.html"},{"title":"mqc_calculation_interface.f90 – metalquicha","text":"External calculation interface for geometry optimization, AIMD, and Monte Carlo This file depends on sourcefile~~mqc_calculation_interface.f90~~EfferentGraph sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! External calculation interface for geometry optimization, AIMD, and Monte Carlo module mqc_calculation_interface !! Provides a clean interface for computing energies and forces !! that can be used by optimization algorithms, MD integrators, and MC samplers use pic_types , only : int32 , dp use pic_mpi_lib , only : comm_t , bcast use pic_logger , only : logger => global_logger use mqc_physical_fragment , only : system_geometry_t use mqc_config_parser , only : bond_t use mqc_result_types , only : calculation_result_t use mqc_calc_types , only : CALC_TYPE_ENERGY , CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN implicit none private public :: compute_energy_and_forces public :: sync_geometry_to_workers contains subroutine sync_geometry_to_workers ( sys_geom , comm ) !! Synchronize geometry coordinates from master rank to all worker ranks !! This is needed when master rank updates coordinates for optimization/dynamics !! !! TODO: Implement explicit broadcast if needed. Currently, the fragmented !! calculation infrastructure may already handle geometry distribution. !! For unfragmented calculations on master rank only, this is not needed. type ( system_geometry_t ), intent ( inout ) :: sys_geom type ( comm_t ), intent ( in ) :: comm ! NOTE: For now, we rely on the existing calculation infrastructure ! to handle geometry as needed. If explicit broadcasting is required, ! we can add MPI send/recv logic here later. end subroutine sync_geometry_to_workers subroutine compute_energy_and_forces ( sys_geom , driver_config , world_comm , node_comm , & energy , gradient , hessian , bonds ) !! Compute energy and forces for current geometry !! This is the main interface for optimization/dynamics codes !! !! Master rank provides updated geometry, all ranks compute fragments, !! results are returned on master rank only !! !! Usage: !!   1. Master rank updates sys_geom%coordinates !!   2. Call this subroutine (all ranks) !!   3. Master rank receives energy/gradient/hessian !!   4. Master rank updates geometry based on forces !!   5. Repeat from step 1 use mqc_driver , only : run_calculation use mqc_config_adapter , only : driver_config_t type ( system_geometry_t ), intent ( inout ) :: sys_geom type ( driver_config_t ), intent ( in ) :: driver_config type ( comm_t ), intent ( in ) :: world_comm , node_comm real ( dp ), intent ( out ) :: energy real ( dp ), intent ( out ), optional :: gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( out ), optional :: hessian (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ) :: result logical :: need_gradient , need_hessian ! Determine what we need based on what's requested need_gradient = present ( gradient ) need_hessian = present ( hessian ) ! Synchronize geometry from master to all ranks ! (Master may have updated coordinates for optimization/dynamics) call sync_geometry_to_workers ( sys_geom , world_comm ) ! Call the main calculation driver ! This handles both fragmented and unfragmented cases call run_calculation ( world_comm , node_comm , driver_config , sys_geom , bonds , result ) ! Extract results (only valid on master rank) if ( world_comm % rank () == 0 ) then energy = result % energy % total () if ( need_gradient . and . result % has_gradient ) then gradient = result % gradient else if ( need_gradient ) then call logger % error ( \"Gradient requested but not computed!\" ) error stop \"Missing gradient in compute_energy_and_forces\" end if if ( need_hessian . and . result % has_hessian ) then hessian = result % hessian else if ( need_hessian ) then call logger % error ( \"Hessian requested but not computed!\" ) error stop \"Missing Hessian in compute_energy_and_forces\" end if ! Clean up call result % destroy () end if end subroutine compute_energy_and_forces end module mqc_calculation_interface","tags":"","url":"sourcefile/mqc_calculation_interface.f90.html"},{"title":"mqc_mbe_io.f90 – metalquicha","text":"This file depends on sourcefile~~mqc_mbe_io.f90~~EfferentGraph sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe_io.f90~~AfferentGraph sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module mqc_mbe_io use pic_types , only : int32 , int64 , dp use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_physical_fragment , only : physical_fragment_t , to_angstrom use mqc_elements , only : element_number_to_symbol use mqc_result_types , only : calculation_result_t use mqc_io_helpers , only : get_output_json_filename , get_basename implicit none private public :: print_fragment_xyz , print_detailed_breakdown , print_detailed_breakdown_json public :: print_unfragmented_json , print_gmbe_json , print_gmbe_pie_json contains function get_frag_level_name ( frag_level ) result ( level_name ) !! Map body level (n-mer) to descriptive name !! Supports up to decamers (10-mers), then falls back to \"N-mers\" format integer , intent ( in ) :: frag_level character ( len = 32 ) :: level_name select case ( frag_level ) case ( 1 ) level_name = \"monomers\" case ( 2 ) level_name = \"dimers\" case ( 3 ) level_name = \"trimers\" case ( 4 ) level_name = \"tetramers\" case ( 5 ) level_name = \"pentamers\" case ( 6 ) level_name = \"hexamers\" case ( 7 ) level_name = \"heptamers\" case ( 8 ) level_name = \"octamers\" case ( 9 ) level_name = \"nonamers\" case ( 10 ) level_name = \"decamers\" case default ! For levels > 10, use generic format write ( level_name , '(i0,a)' ) frag_level , \"-mers\" end select end function get_frag_level_name subroutine print_fragment_xyz ( fragment_idx , phys_frag ) !! Print fragment geometry in XYZ format integer ( int64 ), intent ( in ) :: fragment_idx type ( physical_fragment_t ), intent ( in ) :: phys_frag integer :: i character ( len = 2 ) :: symbol character ( len = 256 ) :: coord_line call logger % info ( \"=========================================\" ) call logger % info ( \" Fragment \" // to_char ( fragment_idx )) call logger % info ( \" Number of atoms: \" // to_char ( phys_frag % n_atoms )) call logger % info ( \" Coordinates in Angstroms:\" ) call logger % info ( \"-----------------------------------------\" ) do i = 1 , phys_frag % n_atoms symbol = element_number_to_symbol ( phys_frag % element_numbers ( i )) ! Convert from Bohr back to Angstroms for printing write ( coord_line , '(a2,3f15.8)' ) symbol , to_angstrom ( phys_frag % coordinates ( 1 : 3 , i )) call logger % info ( trim ( coord_line )) end do call logger % info ( \"=========================================\" ) end subroutine print_fragment_xyz subroutine print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) !! Print detailed energy breakdown for each fragment !! Shows full energy and deltaE correction for all monomers, dimers, trimers, etc. !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) integer ( int64 ) :: i integer :: fragment_size , j , frag_level character ( len = 512 ) :: fragment_str , energy_line integer ( int64 ) :: count_by_level call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) call logger % verbose ( \"Detailed Energy Breakdown by Fragment\" ) call logger % verbose ( \"============================================\" ) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). Using generic N-mers notation.\" ) end if do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then call logger % verbose ( \" \" ) block character ( len = 256 ) :: header character ( len = 32 ) :: level_name level_name = get_frag_level_name ( frag_level ) write ( header , '(a,a,i0,a)' ) trim ( level_name ), \" (\" , count_by_level , \" fragments):\" ! Capitalize first letter if ( len_trim ( level_name ) > 0 ) then if ( level_name ( 1 : 1 ) >= 'a' . and . level_name ( 1 : 1 ) <= 'z' ) then header ( 1 : 1 ) = achar ( iachar ( header ( 1 : 1 )) - 32 ) end if end if call logger % verbose ( trim ( header )) end block call logger % verbose ( \"--------------------------------------------\" ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then fragment_str = \"[\" do j = 1 , fragment_size if ( j > 1 ) then write ( fragment_str , '(a,a,i0)' ) trim ( fragment_str ), \",\" , polymers ( i , j ) else write ( fragment_str , '(a,i0)' ) trim ( fragment_str ), polymers ( i , j ) end if end do write ( fragment_str , '(a,a)' ) trim ( fragment_str ), \"]\" if ( frag_level == 1 ) then write ( energy_line , '(a,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ) else write ( energy_line , '(a,a,f20.10,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ), & \"   deltaE: \" , delta_energies ( i ) end if call logger % verbose ( trim ( energy_line )) end if end do end if end do call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) end subroutine print_detailed_breakdown subroutine print_detailed_breakdown_json ( polymers , fragment_count , max_level , & energies , delta_energies , sum_by_level , total_energy , & total_gradient , total_hessian , results ) !! Write detailed energy breakdown to results.json file !! Outputs structured JSON with all fragment energies and deltaE corrections !! Optionally includes total gradient and Hessian if provided !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. use mqc_result_types , only : calculation_result_t integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) real ( dp ), intent ( in ) :: sum_by_level (:), total_energy real ( dp ), intent ( in ), optional :: total_gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( in ), optional :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) type ( calculation_result_t ), intent ( in ), optional :: results (:) !! Fragment results with distance info integer ( int64 ) :: i integer :: fragment_size , j , frag_level , unit , io_stat , iatom character ( len = 512 ) :: json_line integer ( int64 ) :: count_by_level logical :: first_level , first_fragment character ( len = 32 ) :: level_name integer :: total_atoms character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing JSON output to \" // trim ( output_file )) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). JSON will use generic N-mers notation.\" ) end if write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '    \"levels\": [' first_level = . true . do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then if (. not . first_level ) then write ( unit , '(a)' ) '      },' end if first_level = . false . write ( unit , '(a)' ) '      {' level_name = get_frag_level_name ( frag_level ) write ( json_line , '(a,i0,a)' ) '        \"frag_level\": ' , frag_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,a,a)' ) '        \"name\": \"' , trim ( level_name ), '\",' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '        \"count\": ' , count_by_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '        \"total_energy\": ' , sum_by_level ( frag_level ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '        \"fragments\": [' first_fragment = . true . do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then if (. not . first_fragment ) then write ( unit , '(a)' ) '          },' end if first_fragment = . false . write ( unit , '(a)' ) '          {' json_line = '            \"indices\": [' do j = 1 , fragment_size if ( j > 1 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , polymers ( i , j ) else write ( json_line , '(a,i0)' ) trim ( json_line ), polymers ( i , j ) end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '            \"energy\": ' , energies ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) ! Add distance field if available if ( present ( results )) then write ( json_line , '(a,f20.10)' ) '            \"distance\": ' , results ( i )% distance if ( frag_level > 1 ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '            \"delta_energy\": ' , delta_energies ( i ) end if else if ( frag_level > 1 ) then write ( json_line , '(a,f20.10)' ) '            \"delta_energy\": ' , delta_energies ( i ) end if end if write ( unit , '(a)' ) trim ( json_line ) end if end do if (. not . first_fragment ) then write ( unit , '(a)' ) '          }' end if write ( unit , '(a)' ) '        ]' end if end do if (. not . first_level ) then write ( unit , '(a)' ) '      }' end if ! Close levels array (with comma if we have more fields) if ( present ( total_gradient ) . or . present ( total_hessian )) then write ( unit , '(a)' ) '    ],' else write ( unit , '(a)' ) '    ]' end if ! Add gradient norm if present (inside basename object) if ( present ( total_gradient )) then write ( json_line , '(a,f20.10)' ) '    \"gradient_norm\": ' , sqrt ( sum ( total_gradient ** 2 )) if ( present ( total_hessian )) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian Frobenius norm if present (inside basename object) if ( present ( total_hessian )) then write ( json_line , '(a,f20.10)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( total_hessian ** 2 )) write ( unit , '(a)' ) trim ( json_line ) end if ! Close basename object write ( unit , '(a)' ) '  }' ! Close outer object write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine print_detailed_breakdown_json subroutine print_unfragmented_json ( result ) !! Write unfragmented calculation results to output JSON file !! Outputs structured JSON with energy and optionally gradient type ( calculation_result_t ), intent ( in ) :: result integer :: unit , io_stat , iatom , total_atoms character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) if ( result % has_energy ) then write ( json_line , '(a,f25.15)' ) '    \"total_energy\": ' , result % energy % total () if ( result % has_gradient . or . result % has_hessian ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add gradient norm if present if ( result % has_gradient ) then write ( json_line , '(a,f25.15)' ) '    \"gradient_norm\": ' , sqrt ( sum ( result % gradient ** 2 )) if ( result % has_hessian ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian Frobenius norm if present if ( result % has_hessian ) then write ( json_line , '(a,f25.15)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( result % hessian ** 2 )) write ( unit , '(a)' ) trim ( json_line ) end if write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine print_unfragmented_json subroutine print_gmbe_json ( n_monomers , monomer_indices , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , total_energy ) !! Write GMBE calculation results to output JSON file !! Outputs structured JSON with monomers, intersections, and total energy !! Intersection parameters are optional and should be omitted when n_intersections=0 integer , intent ( in ) :: n_monomers integer , intent ( in ) :: monomer_indices (:) type ( calculation_result_t ), intent ( in ) :: monomer_results (:) integer , intent ( in ) :: n_intersections type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) integer , intent ( in ), optional :: intersection_sets (:, :) !! (n_monomers, n_intersections) integer , intent ( in ), optional :: intersection_levels (:) real ( dp ), intent ( in ) :: total_energy integer :: i , j , k , max_level , unit , io_stat character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename logical :: first_level , first_intersection integer :: level_count output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing GMBE JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) ! Monomers section write ( unit , '(a)' ) '    \"monomers\": {' write ( json_line , '(a,i0,a)' ) '      \"count\": ' , n_monomers , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"fragments\": [' do i = 1 , n_monomers write ( unit , '(a)' ) '        {' write ( json_line , '(a,i0,a)' ) '          \"index\": ' , monomer_indices ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '          \"energy\": ' , monomer_results ( i )% energy % total () write ( unit , '(a)' ) trim ( json_line ) if ( i < n_monomers ) then write ( unit , '(a)' ) '        },' else write ( unit , '(a)' ) '        }' end if end do write ( unit , '(a)' ) '      ]' ! Add comma after monomers if we have intersections if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then write ( unit , '(a)' ) '    },' else write ( unit , '(a)' ) '    }' end if ! Intersections section if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then max_level = maxval ( intersection_levels ) write ( unit , '(a)' ) '    \"intersections\": {' write ( json_line , '(a,i0,a)' ) '      \"total_count\": ' , n_intersections , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"levels\": [' first_level = . true . do k = 2 , max_level ! Count intersections at this level level_count = 0 do i = 1 , n_intersections if ( intersection_levels ( i ) == k ) level_count = level_count + 1 end do if ( level_count > 0 ) then if (. not . first_level ) then write ( unit , '(a)' ) '        },' end if first_level = . false . write ( unit , '(a)' ) '        {' write ( json_line , '(a,i0,a)' ) '          \"level\": ' , k , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '          \"count\": ' , level_count , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '          \"fragments\": [' first_intersection = . true . do i = 1 , n_intersections if ( intersection_levels ( i ) == k ) then if (. not . first_intersection ) then write ( unit , '(a)' ) '            },' end if first_intersection = . false . write ( unit , '(a)' ) '            {' ! Write indices json_line = '              \"indices\": [' do j = 1 , n_monomers if ( intersection_sets ( j , i ) > 0 ) then if ( j > 1 . and . intersection_sets ( j - 1 , i ) > 0 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , intersection_sets ( j , i ) else write ( json_line , '(a,i0)' ) trim ( json_line ), intersection_sets ( j , i ) end if end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '              \"energy\": ' , intersection_results ( i )% energy % total () write ( unit , '(a)' ) trim ( json_line ) end if end do if (. not . first_intersection ) then write ( unit , '(a)' ) '            }' end if write ( unit , '(a)' ) '          ]' end if end do if (. not . first_level ) then write ( unit , '(a)' ) '        }' end if write ( unit , '(a)' ) '      ]' write ( unit , '(a)' ) '    }' end if write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"GMBE JSON output written successfully to \" // trim ( output_file )) end subroutine print_gmbe_json subroutine print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) !! Write GMBE PIE calculation results to output JSON file !! Outputs structured JSON with PIE terms (atom sets with coefficients and energies) !! Optionally includes total gradient and Hessian norms integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term real ( dp ), intent ( in ) :: pie_energies (:) !! Raw energy for each term integer ( int64 ), intent ( in ) :: n_pie_terms real ( dp ), intent ( in ) :: total_energy real ( dp ), intent ( in ), optional :: total_gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( in ), optional :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) integer :: j , max_atoms , n_atoms integer ( int64 ) :: i , n_nonzero_terms integer :: unit , io_stat logical :: first_term character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing GMBE PIE JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) ! Add gradient if present if ( present ( total_gradient )) then write ( json_line , '(a,f20.10,a)' ) '    \"gradient_norm\": ' , sqrt ( sum ( total_gradient ** 2 )), ',' write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian if present if ( present ( total_hessian )) then write ( json_line , '(a,f20.10,a)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( total_hessian ** 2 )), ',' write ( unit , '(a)' ) trim ( json_line ) end if ! PIE terms section ! First count non-zero coefficient terms n_nonzero_terms = 0_int64 do i = 1_int64 , n_pie_terms if ( pie_coefficients ( i ) /= 0 ) n_nonzero_terms = n_nonzero_terms + 1 end do write ( unit , '(a)' ) '    \"pie_terms\": {' write ( json_line , '(a,i0,a)' ) '      \"count\": ' , n_nonzero_terms , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"terms\": [' max_atoms = size ( pie_atom_sets , 1 ) first_term = . true . do i = 1_int64 , n_pie_terms ! Skip terms with zero coefficient if ( pie_coefficients ( i ) == 0 ) cycle if (. not . first_term ) write ( unit , '(a)' ) '        },' first_term = . false . write ( unit , '(a)' ) '        {' ! Extract atom list size n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , i ) >= 0 ) n_atoms = n_atoms + 1 end do ! Write atom indices json_line = '          \"atom_indices\": [' do j = 1 , n_atoms if ( j > 1 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , pie_atom_sets ( j , i ) else write ( json_line , '(a,i0)' ) trim ( json_line ), pie_atom_sets ( j , i ) end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '          \"coefficient\": ' , pie_coefficients ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '          \"energy\": ' , pie_energies ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '          \"weighted_energy\": ' , & real ( pie_coefficients ( i ), dp ) * pie_energies ( i ) write ( unit , '(a)' ) trim ( json_line ) end do if (. not . first_term ) write ( unit , '(a)' ) '        }' write ( unit , '(a)' ) '      ]' write ( unit , '(a)' ) '    }' write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"GMBE PIE JSON output written successfully to \" // trim ( output_file )) end subroutine print_gmbe_pie_json end module mqc_mbe_io","tags":"","url":"sourcefile/mqc_mbe_io.f90.html"},{"title":"mqc_physical_fragment.f90 – metalquicha","text":"This file contains all routines and types to represent a “physical” fragment or molecule\ni.e., with atomic coordinates, element types, electronic properties, etc. This file depends on sourcefile~~mqc_physical_fragment.f90~~EfferentGraph sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_physical_fragment.f90~~AfferentGraph sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This file contains all routines and types to represent a \"physical\" fragment or molecule !! i.e., with atomic coordinates, element types, electronic properties, etc. module mqc_physical_fragment !! Physical molecular fragment representation and geometry handling !! !! Provides data structures and utilities for managing molecular fragments !! with atomic coordinates, electronic properties, and geometric operations. use pic_types , only : dp , default_int use mqc_geometry , only : geometry_type use mqc_xyz_reader , only : read_xyz_file use mqc_elements , only : element_symbol_to_number , element_number_to_symbol , element_mass use mqc_cgto , only : molecular_basis_type use mqc_config_parser , only : bond_t use mqc_error , only : error_t , ERROR_VALIDATION implicit none private public :: physical_fragment_t !! Single molecular fragment type public :: system_geometry_t !! Complete system geometry type public :: initialize_system_geometry !! System geometry initialization public :: build_fragment_from_indices !! Extract fragment from system public :: build_fragment_from_atom_list !! Build fragment from explicit atom indices (for intersections) public :: check_duplicate_atoms !! Validate fragment has no overlapping atoms ! TODO: in theory there should be a nice way to redistribute for a general matrix of any shape, need to think about this! public :: redistribute_cap_gradients !! Redistribute hydrogen cap gradients to original atoms public :: redistribute_cap_hessian !! Redistribute hydrogen cap Hessian to original atoms public :: to_angstrom , to_bohr !! Unit conversion utilities public :: calculate_monomer_distance !! Calculate minimal distance between monomers in a fragment type :: physical_fragment_t !! Physical molecular fragment with atomic coordinates and properties !! !! Represents a molecular fragment containing atomic positions, element types, !! electronic structure information, and basis set data for quantum calculations. integer :: n_atoms !! Number of atoms in this fragment integer , allocatable :: element_numbers (:) !! Atomic numbers (Z values) real ( dp ), allocatable :: coordinates (:, :) !! Cartesian coordinates (3, n_atoms) in Bohr ! Electronic structure properties integer :: charge = 0 !! Net molecular charge (electrons) integer :: multiplicity = 1 !! Spin multiplicity (2S+1) integer :: nelec = 0 !! Total number of electrons ! Hydrogen capping for broken bonds integer :: n_caps = 0 !! Number of hydrogen caps added (always at end of atom list) integer , allocatable :: cap_replaces_atom (:) !! Original atom index that each cap replaces (size: n_caps) ! Gradient redistribution support integer , allocatable :: local_to_global (:) !! Map fragment atom index to system atom index (size: n_atoms - n_caps) ! Fragment distance (for screening) real ( dp ) :: distance = 0.0_dp !! Minimal atomic distance between monomers in fragment (Angstrom, 0 for monomers) ! Quantum chemistry basis set type ( molecular_basis_type ), allocatable :: basis !! Gaussian basis functions contains procedure :: destroy => fragment_destroy !! Memory cleanup procedure :: compute_nelec => fragment_compute_nelec !! Calculate electron count procedure :: set_basis => fragment_set_basis !! Assign basis set end type physical_fragment_t type :: system_geometry_t !! Complete molecular system geometry for fragment-based calculations !! !! Contains the full atomic structure of a molecular cluster organized !! by monomers for efficient fragment generation and MBE calculations. integer :: n_monomers !! Number of monomer units in system integer :: atoms_per_monomer !! Atoms in each monomer (0 if variable-sized) integer :: total_atoms !! Total number of atoms integer , allocatable :: element_numbers (:) !! Atomic numbers for all atoms real ( dp ), allocatable :: coordinates (:, :) !! All coordinates (3, total_atoms) in Bohr ! Electronic structure properties integer :: charge !! Net molecular charge (electrons) integer :: multiplicity !! Spin multiplicity (2S+1) ! For variable-sized fragments (explicit fragment definitions) integer , allocatable :: fragment_sizes (:) !! Number of atoms in each fragment (n_monomers) integer , allocatable :: fragment_atoms (:, :) !! Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer , allocatable :: fragment_charges (:) !! Charge for each fragment (n_monomers) integer , allocatable :: fragment_multiplicities (:) !! Multiplicity for each fragment (n_monomers) contains procedure :: destroy => system_destroy !! Memory cleanup end type system_geometry_t ! Physical constants real ( dp ), parameter :: bohr_radius = 0.52917721092_dp !! Bohr radius in Ångström contains pure elemental function to_angstrom ( bohr_value ) result ( angstrom_value ) !! Convert coordinate from Bohr to Angstrom real ( dp ), intent ( in ) :: bohr_value real ( dp ) :: angstrom_value angstrom_value = bohr_value * bohr_radius end function to_angstrom pure elemental function to_bohr ( angstrom_value ) result ( bohr_value ) !! Convert coordinate from Angstrom to Bohr real ( dp ), intent ( in ) :: angstrom_value real ( dp ) :: bohr_value bohr_value = angstrom_value / bohr_radius end function to_bohr subroutine initialize_system_geometry ( full_geom_file , monomer_file , sys_geom , error ) !! Read full geometry and monomer template, initialize system_geometry_t character ( len =* ), intent ( in ) :: full_geom_file , monomer_file type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error type ( geometry_type ) :: full_geom , monomer_geom integer :: i call read_xyz_file ( full_geom_file , full_geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:initialize_system_geometry\" ) return end if ! Read monomer template ! this will be changed once we have a proper input file parsing call read_xyz_file ( monomer_file , monomer_geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:initialize_system_geometry\" ) call full_geom % destroy () return end if ! Validate that full geometry is a multiple of monomer size sys_geom % atoms_per_monomer = monomer_geom % natoms sys_geom % total_atoms = full_geom % natoms if ( mod ( sys_geom % total_atoms , sys_geom % atoms_per_monomer ) /= 0 ) then call error % set ( ERROR_VALIDATION , \"Full geometry atoms not a multiple of monomer atoms\" ) call full_geom % destroy () call monomer_geom % destroy () return end if sys_geom % n_monomers = sys_geom % total_atoms / sys_geom % atoms_per_monomer ! TODO JORGE: this can be a sys_geom%allocate() allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( full_geom % elements ( i )) end do ! Store coordinates in Bohr (convert from Angstroms) ! TODO JORGE: need a way to handle units sys_geom % coordinates = to_bohr ( full_geom % coords ) call full_geom % destroy () call monomer_geom % destroy () end subroutine initialize_system_geometry subroutine count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) !! Count how many hydrogen caps are needed for a fragment !! A cap is needed when exactly one atom of a broken bond is in the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ), optional :: bonds (:) integer , intent ( out ) :: n_caps integer :: ibond logical :: atom_i_in_frag , atom_j_in_frag n_caps = 0 if (. not . present ( bonds )) return do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle ! Check if exactly one atom of this bond is in the fragment atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) ! Add cap only if one atom in fragment, other not (XOR condition) if (( atom_i_in_frag . and . . not . atom_j_in_frag ) . or . & (. not . atom_i_in_frag . and . atom_j_in_frag )) then n_caps = n_caps + 1 end if end do end subroutine count_hydrogen_caps subroutine add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , base_atom_count ) !! Add hydrogen caps to fragment for broken bonds !! Caps are placed at the position of the atom outside the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ) :: bonds (:) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( physical_fragment_t ), intent ( inout ) :: fragment integer , intent ( in ) :: base_atom_count !! Number of non-cap atoms integer :: ibond , cap_idx logical :: atom_i_in_frag , atom_j_in_frag if ( fragment % n_caps == 0 ) return cap_idx = 0 do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) if ( atom_i_in_frag . and . . not . atom_j_in_frag ) then ! atom_i is in fragment, atom_j is not → cap at position of atom_j cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_j (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_j + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_j else if ( atom_j_in_frag . and . . not . atom_i_in_frag ) then ! atom_j is in fragment, atom_i is not → cap at position of atom_i cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_i (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_i + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_i end if end do end subroutine add_hydrogen_caps subroutine build_fragment_from_indices ( sys_geom , monomer_indices , fragment , error , bonds ) !! Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds !! !! Extracts atoms from specified monomers and adds hydrogen caps where bonds are broken. !! Caps are always added at the end of the atom list. !! Supports both fixed-size (identical monomers) and variable-sized fragments. !! !! Example: monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5 !!          If connectivity shows broken bonds, hydrogens are capped at positions of missing atoms type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) type ( physical_fragment_t ), intent ( out ) :: fragment type ( error_t ), intent ( out ) :: error type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity information for capping integer :: n_monomers_in_frag , atoms_per_monomer , n_atoms_no_caps integer :: i , j , mono_idx , atom_start , atom_end , frag_atom_idx integer :: atom_i , atom_j , n_caps integer , allocatable :: atoms_in_fragment (:) !! List of all atom indices in this fragment integer :: iatom , atom_global_idx logical :: use_explicit_fragments n_monomers_in_frag = size ( monomer_indices ) ! Determine if we're using explicit fragment definitions or regular monomer-based use_explicit_fragments = allocated ( sys_geom % fragment_atoms ) if ( use_explicit_fragments ) then ! Variable-sized fragments: count total atoms from fragment definitions n_atoms_no_caps = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) n_atoms_no_caps = n_atoms_no_caps + sys_geom % fragment_sizes ( mono_idx ) end do ! Build list of atom indices (0-indexed) from explicit fragment definitions allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) iatom = iatom + 1 atoms_in_fragment ( iatom ) = sys_geom % fragment_atoms ( j , mono_idx ) end do end do else ! Fixed-size monomers: use atoms_per_monomer atoms_per_monomer = sys_geom % atoms_per_monomer n_atoms_no_caps = n_monomers_in_frag * atoms_per_monomer ! Build list of atom indices in this fragment (0-indexed to match bond indices) allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer do atom_i = 0 , atoms_per_monomer - 1 iatom = iatom + 1 atoms_in_fragment ( iatom ) = atom_start + atom_i end do end do end if ! Count how many caps we need call count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms_no_caps + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms_no_caps )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping frag_atom_idx = 0 if ( use_explicit_fragments ) then ! Variable-sized: copy atoms based on explicit fragment definitions do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) frag_atom_idx = frag_atom_idx + 1 ! fragment_atoms is 0-indexed, so +1 for Fortran arrays atom_global_idx = sys_geom % fragment_atoms ( j , mono_idx ) + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( frag_atom_idx ) = atom_global_idx ! Store 1-indexed global position end do end do else ! Fixed-size: use atoms_per_monomer do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer + 1 atom_end = mono_idx * atoms_per_monomer ! Copy coordinates and elements do atom_i = atom_start , atom_end frag_atom_idx = frag_atom_idx + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_i ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_i ) fragment % local_to_global ( frag_atom_idx ) = atom_i ! Store 1-indexed global position end do end do end if ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , n_atoms_no_caps ) end if ! Set electronic structure properties from system geometry if ( use_explicit_fragments . and . allocated ( sys_geom % fragment_charges ) . and . & allocated ( sys_geom % fragment_multiplicities )) then ! Explicit fragments: sum charges and multiplicities from constituent fragments fragment % charge = 0 fragment % multiplicity = 1 ! Start with singlet assumption do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) fragment % charge = fragment % charge + sys_geom % fragment_charges ( mono_idx ) end do ! For single fragment, use its specific multiplicity if ( n_monomers_in_frag == 1 ) then fragment % multiplicity = sys_geom % fragment_multiplicities ( monomer_indices ( 1 )) else ! For multi-fragment composites, multiplicity needs careful treatment ! For now, default to system multiplicity (this may need refinement) fragment % multiplicity = sys_geom % multiplicity end if else ! Fixed-size monomers: use system defaults fragment % charge = sys_geom % charge fragment % multiplicity = sys_geom % multiplicity end if call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:build_fragment_from_indices\" ) return end if ! Calculate minimal distance between monomers in this fragment fragment % distance = calculate_monomer_distance ( sys_geom , monomer_indices ) deallocate ( atoms_in_fragment ) end subroutine build_fragment_from_indices subroutine build_fragment_from_atom_list ( sys_geom , atom_indices , n_atoms , fragment , error , bonds ) !! Build a fragment from explicit atom list (for GMBE intersection fragments) !! !! Similar to build_fragment_from_indices but takes atom indices directly instead of !! monomer indices. Used for building intersection fragments in GMBE calculations. !! Intersection fragments are ALWAYS NEUTRAL (charge=0, multiplicity=1). !! !! Example: atom_indices = [3, 4, 5] builds fragment from atoms 3, 4, 5 of the system type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: atom_indices (:) !! 0-indexed atom indices integer , intent ( in ) :: n_atoms !! Number of atoms in list type ( physical_fragment_t ), intent ( out ) :: fragment type ( error_t ), intent ( out ) :: error type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity for capping integer :: i , frag_atom_idx , atom_global_idx integer :: n_caps ! Count how many caps we need call count_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping (atom_indices are 0-indexed, add 1 for Fortran arrays) do i = 1 , n_atoms atom_global_idx = atom_indices ( i ) + 1 ! Convert to 1-indexed fragment % element_numbers ( i ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, i ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( i ) = atom_global_idx ! Store 1-indexed global position end do ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , sys_geom , fragment , n_atoms ) end if ! Intersection fragments are ALWAYS NEUTRAL ! Rationale: For polypeptides, intersections are backbone atoms; ! charged side chains are in non-overlapping regions fragment % charge = 0 fragment % multiplicity = 1 call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:build_fragment_from_atom_list\" ) return end if end subroutine build_fragment_from_atom_list subroutine redistribute_cap_gradients ( fragment , fragment_gradient , system_gradient ) !! Redistribute hydrogen cap gradients to original atoms !! !! This subroutine handles gradient redistribution for fragments with hydrogen caps. !! Hydrogen caps are virtual atoms added at broken bonds - their gradients represent !! forces at the bond breakpoint and must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate gradient to system using local_to_global mapping !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap gradient to the original atom it replaces (from cap_replaces_atom) !! !! Example: !!   Fragment: [C, C, H_cap] where H_cap replaces atom 5 in system !!   Fragment gradient: [(3,1), (3,2), (3,3)] !!   - Atoms 1,2: accumulate to system using local_to_global !!   - Atom 3 (cap): add gradient to system atom 5 (cap_replaces_atom(1) + 1) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_gradient (:, :) !! (3, n_atoms_fragment) real ( dp ), intent ( inout ) :: system_gradient (:, :) !! (3, n_atoms_system) integer :: i , local_idx , global_idx integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate gradients for real atoms using local→global mapping do i = 1 , n_real_atoms global_idx = fragment % local_to_global ( i ) system_gradient (:, global_idx ) = system_gradient (:, global_idx ) + fragment_gradient (:, i ) end do ! Redistribute cap gradients to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap ! cap_replaces_atom is 0-indexed, add 1 for Fortran arrays global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Add cap gradient to the atom it replaces system_gradient (:, global_original_idx ) = system_gradient (:, global_original_idx ) + & fragment_gradient (:, local_cap_idx ) end do end if end subroutine redistribute_cap_gradients subroutine redistribute_cap_hessian ( fragment , fragment_hessian , system_hessian ) !! Redistribute hydrogen cap Hessian to original atoms !! !! This subroutine handles Hessian redistribution for fragments with hydrogen caps. !! The Hessian is a rank-2 tensor (3N × 3N) representing second derivatives of energy !! with respect to atomic coordinates. Similar to gradient redistribution, cap contributions !! must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate Hessian blocks to system using local_to_global mapping for both dimensions !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap Hessian blocks (row and column) to the original atom it replaces !! !! Note: Hessian is stored as a flattened 2D array (3*n_atoms, 3*n_atoms) !!       where rows and columns are grouped by atoms (x,y,z for atom 1, then x,y,z for atom 2, etc.) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_hessian (:, :) !! (3*n_atoms_fragment, 3*n_atoms_fragment) real ( dp ), intent ( inout ) :: system_hessian (:, :) !! (3*n_atoms_system, 3*n_atoms_system) integer :: i , j , local_i , local_j , global_i , global_j integer :: icart , jcart integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms integer :: i_cap_2 , local_cap_idx_2 , global_original_idx_2 n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate Hessian blocks for real atoms using local→global mapping ! Both row (i) and column (j) dimensions need mapping do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) ! Copy 3×3 block for atom pair (i,j) do icart = 0 , 2 ! x, y, z for atom i do jcart = 0 , 2 ! x, y, z for atom j system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do end do ! Redistribute cap Hessian blocks to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Cap rows: redistribute to original atom (cap derivatives w.r.t. all other atoms) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do ! Cap columns: redistribute to original atom (all other atoms' derivatives w.r.t. cap) do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( local_cap_idx - 1 ) + jcart + 1 ) end do end do end do ! Cap-cap blocks: redistribute to original atom diagonal block do i_cap_2 = 1 , fragment % n_caps local_cap_idx_2 = n_real_atoms + i_cap_2 global_original_idx_2 = fragment % cap_replaces_atom ( i_cap_2 ) + 1 do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( local_cap_idx_2 - 1 ) + jcart + 1 ) end do end do end do end do end if end subroutine redistribute_cap_hessian subroutine check_duplicate_atoms ( fragment , error ) !! Validate that fragment has no spatially overlapping atoms !! Checks if any two atoms are too close together (< 0.01 Bohr) !! This catches bugs in geometry construction or fragment building use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( physical_fragment_t ), intent ( in ) :: fragment type ( error_t ), intent ( out ) :: error integer :: i , j , n_atoms real ( dp ) :: distance , dx , dy , dz real ( dp ), parameter :: MIN_ATOM_DISTANCE = 0.01_dp !! Bohr - atoms closer than this are overlapping ! Only check non-cap atoms (caps can be close to replaced atoms) n_atoms = fragment % n_atoms - fragment % n_caps if ( n_atoms < 2 ) return do i = 1 , n_atoms - 1 do j = i + 1 , n_atoms dx = fragment % coordinates ( 1 , i ) - fragment % coordinates ( 1 , j ) dy = fragment % coordinates ( 2 , i ) - fragment % coordinates ( 2 , j ) dz = fragment % coordinates ( 3 , i ) - fragment % coordinates ( 3 , j ) distance = sqrt ( dx * dx + dy * dy + dz * dz ) if ( distance < MIN_ATOM_DISTANCE ) then ! Build detailed error message call error % set ( ERROR_VALIDATION , & \"Fragment contains overlapping atoms \" // to_char ( i ) // \" and \" // to_char ( j ) // & \" (distance: \" // to_char ( distance ) // \" Bohr). \" // & \"This indicates bad input geometry or a bug in fragment construction.\" ) ! Log detailed information for debugging call logger % error ( \"ERROR: Fragment contains overlapping atoms!\" ) call logger % error ( \"  Atoms \" // to_char ( i ) // \" and \" // to_char ( j ) // \" are too close together\" ) call logger % error ( \"  Distance: \" // to_char ( distance ) // \" Bohr (\" // & to_char ( distance * 0.529177_dp ) // \" Angstrom)\" ) call logger % error ( \"  Atom \" // to_char ( i ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( i )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , i )) // \", \" // & to_char ( fragment % coordinates ( 2 , i )) // \", \" // & to_char ( fragment % coordinates ( 3 , i )) // \") Bohr\" ) call logger % error ( \"  Atom \" // to_char ( j ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( j )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , j )) // \", \" // & to_char ( fragment % coordinates ( 2 , j )) // \", \" // & to_char ( fragment % coordinates ( 3 , j )) // \") Bohr\" ) return end if end do end do end subroutine check_duplicate_atoms subroutine fragment_destroy ( this ) !! Clean up allocated memory in physical_fragment_t class ( physical_fragment_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % cap_replaces_atom )) deallocate ( this % cap_replaces_atom ) if ( allocated ( this % local_to_global )) deallocate ( this % local_to_global ) if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if this % n_atoms = 0 this % charge = 0 this % multiplicity = 1 this % nelec = 0 this % n_caps = 0 end subroutine fragment_destroy subroutine fragment_compute_nelec ( this ) !! Compute number of electrons from atomic numbers and charge class ( physical_fragment_t ), intent ( inout ) :: this integer :: nuclear_charge nuclear_charge = sum ( this % element_numbers ) this % nelec = nuclear_charge - this % charge end subroutine fragment_compute_nelec subroutine fragment_set_basis ( this , basis ) !! Set the basis set for this fragment class ( physical_fragment_t ), intent ( inout ) :: this type ( molecular_basis_type ), intent ( in ) :: basis if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if allocate ( this % basis ) this % basis = basis end subroutine fragment_set_basis subroutine system_destroy ( this ) !! Clean up allocated memory in system_geometry_t class ( system_geometry_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % fragment_sizes )) deallocate ( this % fragment_sizes ) if ( allocated ( this % fragment_atoms )) deallocate ( this % fragment_atoms ) if ( allocated ( this % fragment_charges )) deallocate ( this % fragment_charges ) if ( allocated ( this % fragment_multiplicities )) deallocate ( this % fragment_multiplicities ) this % n_monomers = 0 this % atoms_per_monomer = 0 this % total_atoms = 0 end subroutine system_destroy pure function calculate_monomer_distance ( sys_geom , monomer_indices ) result ( min_distance ) !! Calculate minimal atomic distance between monomers in a fragment !! For single monomer (size 1), returns 0.0 !! For multi-monomer fragments, returns minimal distance between atoms in different monomers !! Result is in Angstrom type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) real ( dp ) :: min_distance integer :: n_monomers , i , j , iatom , jatom integer :: mon_i , mon_j integer :: atom_start_i , atom_end_i , atom_start_j , atom_end_j real ( dp ) :: dist , dx , dy , dz logical :: is_variable_size n_monomers = size ( monomer_indices ) ! Monomers have distance 0 if ( n_monomers == 1 ) then min_distance = 0.0_dp return end if ! Check if we have variable-sized fragments is_variable_size = allocated ( sys_geom % fragment_sizes ) ! Initialize with huge value min_distance = huge ( 1.0_dp ) ! Loop over all pairs of monomers do i = 1 , n_monomers - 1 mon_i = monomer_indices ( i ) do j = i + 1 , n_monomers mon_j = monomer_indices ( j ) if ( is_variable_size ) then ! Variable-sized fragments do iatom = 1 , sys_geom % fragment_sizes ( mon_i ) atom_start_i = sys_geom % fragment_atoms ( iatom , mon_i ) + 1 ! Convert to 1-indexed do jatom = 1 , sys_geom % fragment_sizes ( mon_j ) atom_start_j = sys_geom % fragment_atoms ( jatom , mon_j ) + 1 ! Convert to 1-indexed ! Calculate distance (coordinates in Bohr) dx = sys_geom % coordinates ( 1 , atom_start_i ) - sys_geom % coordinates ( 1 , atom_start_j ) dy = sys_geom % coordinates ( 2 , atom_start_i ) - sys_geom % coordinates ( 2 , atom_start_j ) dz = sys_geom % coordinates ( 3 , atom_start_i ) - sys_geom % coordinates ( 3 , atom_start_j ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_distance ) min_distance = dist end do end do else ! Fixed-sized monomers atom_start_i = ( mon_i - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_i = mon_i * sys_geom % atoms_per_monomer atom_start_j = ( mon_j - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_j = mon_j * sys_geom % atoms_per_monomer ! Loop over all atom pairs do iatom = atom_start_i , atom_end_i do jatom = atom_start_j , atom_end_j ! Calculate distance (coordinates in Bohr) dx = sys_geom % coordinates ( 1 , iatom ) - sys_geom % coordinates ( 1 , jatom ) dy = sys_geom % coordinates ( 2 , iatom ) - sys_geom % coordinates ( 2 , jatom ) dz = sys_geom % coordinates ( 3 , iatom ) - sys_geom % coordinates ( 3 , jatom ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_distance ) min_distance = dist end do end do end if end do end do ! Convert from Bohr to Angstrom min_distance = to_angstrom ( min_distance ) end function calculate_monomer_distance end module mqc_physical_fragment","tags":"","url":"sourcefile/mqc_physical_fragment.f90.html"},{"title":"mqc_combinatorics.f90 – metalquicha","text":"Combinatorial mathematics utilities for fragment generation This file depends on sourcefile~~mqc_combinatorics.f90~~EfferentGraph sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_combinatorics.f90~~AfferentGraph sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Combinatorial mathematics utilities for fragment generation module mqc_combinatorics !! Provides pure combinatorial functions for generating molecular fragments !! including binomial coefficients, combinations, and fragment counting use pic_types , only : default_int , int32 , int64 implicit none private public :: binomial !! Binomial coefficient calculation public :: get_nfrags !! Calculate total number of fragments public :: create_monomer_list !! Generate sequential monomer indices public :: generate_fragment_list !! Generate all fragments up to max level public :: combine !! Generate all combinations of size r public :: get_next_combination !! Generate next combination in sequence public :: next_combination_init !! Initialize combination to [1,2,...,k] public :: next_combination !! Generate next combination (alternate interface) public :: print_combos !! Debug utility to print combinations public :: calculate_fragment_distances !! Calculate minimal distances for all fragments contains pure function get_nfrags ( n_monomers , max_level ) result ( n_expected_fragments ) !! Calculate total number of fragments for given system size and max level !! !! Computes the sum of binomial coefficients C(n,k) for k=1 to max_level, !! representing all possible fragments from monomers to max_level-mers. !! Uses int64 to handle large fragment counts that overflow int32. integer ( default_int ), intent ( in ) :: n_monomers !! Number of monomers in system integer ( default_int ), intent ( in ) :: max_level !! Maximum fragment size integer ( int64 ) :: n_expected_fragments !! Total fragment count integer ( default_int ) :: i !! Loop counter n_expected_fragments = 0_int64 do i = 1 , max_level n_expected_fragments = n_expected_fragments + binomial ( n_monomers , i ) end do end function get_nfrags pure function binomial ( n , r ) result ( c ) !! Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) !! !! Calculates \"n choose r\" using iterative algorithm to avoid !! factorial overflow for large numbers. !! Uses int64 to handle large combinatorial values that overflow int32. integer ( default_int ), intent ( in ) :: n !! Total number of items integer ( default_int ), intent ( in ) :: r !! Number of items to choose integer ( int64 ) :: c !! Binomial coefficient result integer ( default_int ) :: i !! Loop counter if ( r == 0 . or . r == n ) then c = 1_int64 else if ( r > n ) then c = 0_int64 else c = 1_int64 do i = 1 , r c = c * int ( n - i + 1 , int64 ) / int ( i , int64 ) end do end if end function binomial pure subroutine create_monomer_list ( monomers ) !! Generate a list of monomer indices from 1 to N integer ( default_int ), allocatable , intent ( inout ) :: monomers (:) integer ( default_int ) :: i , length length = size ( monomers , 1 ) do i = 1 , length monomers ( i ) = i end do end subroutine create_monomer_list recursive subroutine generate_fragment_list ( monomers , max_level , polymers , count ) !! Generate all possible fragments (combinations of monomers) up to max_level !! Uses int64 for count to handle large numbers of fragments that overflow int32. integer ( default_int ), intent ( in ) :: monomers (:), max_level integer ( default_int ), intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: r , n n = size ( monomers , 1 ) do r = 2 , max_level call combine ( monomers , n , r , polymers , count ) end do end subroutine generate_fragment_list recursive subroutine combine ( arr , n , r , out_array , count ) !! Generate all combinations of size r from array arr of size n !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:) integer ( default_int ), intent ( in ) :: n , r integer ( default_int ), intent ( inout ) :: out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: data ( r ) call combine_util ( arr , n , r , 1 , data , 1 , out_array , count ) end subroutine combine recursive subroutine combine_util ( arr , n , r , index , data , i , out_array , count ) !! Utility for generating combinations recursively !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:), n , r , index , i integer ( default_int ), intent ( inout ) :: data (:), out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: j if ( index > r ) then count = count + 1_int64 out_array ( count , 1 : r ) = data ( 1 : r ) return end if do j = i , n data ( index ) = arr ( j ) call combine_util ( arr , n , r , index + 1 , data , j + 1 , out_array , count ) end do end subroutine combine_util subroutine print_combos ( out_array , count , max_len ) !! Print combinations stored in out_array !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: out_array (:, :), max_len integer ( int64 ), intent ( in ) :: count integer ( int64 ) :: i integer ( default_int ) :: j do i = 1_int64 , count do j = 1 , max_len if ( out_array ( i , j ) == 0 ) exit write ( * , '(I0)' , advance = 'no' ) out_array ( i , j ) if ( j < max_len . and . out_array ( i , j + 1 ) /= 0 ) then write ( * , '(A)' , advance = 'no' ) \":\" end if end do write ( * , * ) ! newline end do end subroutine print_combos pure subroutine get_next_combination ( indices , k , n , has_next ) !! Generate next combination (updates indices in place) !! has_next = .true. if there's a next combination integer , intent ( inout ) :: indices (:) integer , intent ( in ) :: k , n logical , intent ( out ) :: has_next integer :: i has_next = . true . i = k do while ( i >= 1 ) if ( indices ( i ) < n - k + i ) then indices ( i ) = indices ( i ) + 1 do while ( i < k ) i = i + 1 indices ( i ) = indices ( i - 1 ) + 1 end do return end if i = i - 1 end do has_next = . false . end subroutine get_next_combination subroutine next_combination_init ( combination , k ) !! Initialize combination to [1, 2, ..., k] integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k integer :: i do i = 1 , k combination ( i ) = i end do end subroutine next_combination_init function next_combination ( combination , k , n ) result ( has_next ) !! Generate next combination in lexicographic order !! Returns .true. if there's a next combination, .false. if we've exhausted all integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k , n logical :: has_next integer :: i has_next = . true . ! Find the rightmost element that can be incremented i = k do while ( i >= 1 ) if ( combination ( i ) < n - k + i ) then combination ( i ) = combination ( i ) + 1 ! Reset all elements to the right do while ( i < k ) i = i + 1 combination ( i ) = combination ( i - 1 ) + 1 end do return end if i = i - 1 end do ! No more combinations has_next = . false . end function next_combination subroutine calculate_fragment_distances ( polymers , fragment_count , sys_geom , distances ) !! Calculate minimal atomic distance for each fragment !! For monomers (1-body), distance is 0.0 !! For n-mers (n >= 2), distance is the minimum distance between atoms !! in different constituent monomers use pic_types , only : dp use mqc_physical_fragment , only : system_geometry_t , to_angstrom integer ( default_int ), intent ( in ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: fragment_count type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: distances (:) integer ( int64 ) :: ifrag integer :: fragment_size , i , j , iatom , jatom integer :: mon_i , mon_j integer :: atom_start_i , atom_end_i , atom_start_j , atom_end_j integer :: k real ( dp ) :: dist , min_dist real ( dp ) :: dx , dy , dz logical :: is_variable_size ! Check if we have variable-sized fragments is_variable_size = allocated ( sys_geom % fragment_sizes ) do ifrag = 1_int64 , fragment_count fragment_size = count ( polymers ( ifrag , :) > 0 ) if ( fragment_size == 1 ) then ! Monomers have distance 0 distances ( ifrag ) = 0.0_dp else ! For n-mers, calculate minimal distance between atoms in different monomers min_dist = huge ( 1.0_dp ) ! Loop over all pairs of monomers in this fragment do i = 1 , fragment_size - 1 mon_i = polymers ( ifrag , i ) do j = i + 1 , fragment_size mon_j = polymers ( ifrag , j ) if ( is_variable_size ) then ! Variable-sized fragments: use fragment_atoms to get atom indices ! Count atoms in this fragment do iatom = 1 , sys_geom % fragment_sizes ( mon_i ) atom_start_i = sys_geom % fragment_atoms ( iatom , mon_i ) + 1 ! Convert to 1-indexed do jatom = 1 , sys_geom % fragment_sizes ( mon_j ) atom_start_j = sys_geom % fragment_atoms ( jatom , mon_j ) + 1 ! Convert to 1-indexed ! Calculate distance dx = sys_geom % coordinates ( 1 , atom_start_i ) - sys_geom % coordinates ( 1 , atom_start_j ) dy = sys_geom % coordinates ( 2 , atom_start_i ) - sys_geom % coordinates ( 2 , atom_start_j ) dz = sys_geom % coordinates ( 3 , atom_start_i ) - sys_geom % coordinates ( 3 , atom_start_j ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_dist ) min_dist = dist end do end do else ! Fixed-sized monomers: calculate atom range directly atom_start_i = ( mon_i - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_i = mon_i * sys_geom % atoms_per_monomer atom_start_j = ( mon_j - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_j = mon_j * sys_geom % atoms_per_monomer ! Loop over all atoms in monomer i do iatom = atom_start_i , atom_end_i ! Loop over all atoms in monomer j do jatom = atom_start_j , atom_end_j ! Calculate distance (coordinates are in Bohr) dx = sys_geom % coordinates ( 1 , iatom ) - sys_geom % coordinates ( 1 , jatom ) dy = sys_geom % coordinates ( 2 , iatom ) - sys_geom % coordinates ( 2 , jatom ) dz = sys_geom % coordinates ( 3 , iatom ) - sys_geom % coordinates ( 3 , jatom ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_dist ) min_dist = dist end do end do end if end do end do ! Convert from Bohr to Angstrom distances ( ifrag ) = to_angstrom ( min_dist ) end if end do end subroutine calculate_fragment_distances end module mqc_combinatorics","tags":"","url":"sourcefile/mqc_combinatorics.f90.html"},{"title":"mqc_geometry.f90 – metalquicha","text":"Geometry data structure for molecular systems Files dependent on this one sourcefile~~mqc_geometry.f90~~AfferentGraph sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Geometry data structure for molecular systems module mqc_geometry !! Defines the geometry data structure for molecular systems use pic_types , only : dp implicit none private public :: geometry_type ! Parameters integer , parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 type :: geometry_type !! Molecular geometry data structure integer :: natoms character ( len = :), allocatable :: elements (:) real ( dp ), allocatable :: coords (:, :) ! coords(3, natoms) character ( len = :), allocatable :: comment contains procedure :: destroy => geometry_destroy end type geometry_type contains subroutine geometry_destroy ( this ) !! Clean up allocated memory in geometry_type class ( geometry_type ), intent ( inout ) :: this if ( allocated ( this % elements )) deallocate ( this % elements ) if ( allocated ( this % coords )) deallocate ( this % coords ) if ( allocated ( this % comment )) deallocate ( this % comment ) this % natoms = 0 end subroutine geometry_destroy end module mqc_geometry","tags":"","url":"sourcefile/mqc_geometry.f90.html"},{"title":"mqc_mbe_fragment_distribution_scheme_hessian.F90 – metalquicha","text":"This file depends on sourcefile~~mqc_mbe_fragment_distribution_scheme_hessian.f90~~EfferentGraph sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( mqc_mbe_fragment_distribution_scheme ) mqc_hessian_distribution_scheme implicit none contains module subroutine distributed_unfragmented_hessian ( world_comm , sys_geom , method , driver_config ) !! Compute Hessian for unfragmented system using MPI distribution !! !! Uses a dynamic work queue approach: workers request displacement indices !! from rank 0, compute gradients, and send results back. This provides !! better load balancing than static work distribution. use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT , & copy_and_displace_geometry use mqc_config_adapter , only : driver_config_t #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method type ( driver_config_t ), intent ( in ), optional :: driver_config !! Driver configuration integer :: my_rank , n_ranks real ( dp ) :: displacement my_rank = world_comm % rank () n_ranks = world_comm % size () ! Use provided displacement or default if ( present ( driver_config )) then displacement = driver_config % hessian % displacement else displacement = DEFAULT_DISPLACEMENT end if if ( my_rank == 0 ) then ! Rank 0 is the coordinator call hessian_coordinator ( world_comm , sys_geom , method , displacement ) else ! Other ranks are workers call hessian_worker ( world_comm , sys_geom , method , displacement ) end if ! Synchronize all ranks before returning call world_comm % barrier () end subroutine distributed_unfragmented_hessian module subroutine hessian_coordinator ( world_comm , sys_geom , method , displacement ) !! Coordinator for distributed Hessian calculation !! Distributes displacement work and collects gradient results use mqc_finite_differences , only : finite_diff_hessian_from_gradients use mqc_vibrational_analysis , only : compute_vibrational_frequencies , & compute_vibrational_analysis , print_vibrational_analysis #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) type ( physical_fragment_t ) :: full_system type ( timer_type ) :: coord_timer real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: hessian (:, :) real ( dp ), allocatable :: grad_buffer (:, :) type ( calculation_result_t ) :: result integer :: n_atoms , n_displacements , n_ranks integer :: current_disp , finished_workers , dummy_msg , worker_rank integer :: disp_idx , gradient_type ! gradient_type: 1=forward, 2=backward type ( MPI_Status ) :: status logical :: has_pending type ( request_t ) :: req integer :: current_log_level logical :: is_verbose character ( len = 2048 ) :: result_line ! Large buffer for Hessian matrix rows real ( dp ) :: hess_norm integer :: i , j real ( dp ), allocatable :: frequencies (:) real ( dp ), allocatable :: eigenvalues (:) real ( dp ), allocatable :: projected_hessian (:, :) #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc #endif n_ranks = world_comm % size () n_atoms = sys_geom % total_atoms n_displacements = 3 * n_atoms call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) call logger % info ( \"============================================\" ) call logger % info ( \"Distributed unfragmented Hessian calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) call logger % info ( \"  Finite difference step size: \" // to_char ( displacement ) // \" Bohr\" ) call logger % info ( \"  MPI ranks: \" // to_char ( n_ranks )) call logger % info ( \"  Work distribution: Dynamic queue\" ) call logger % info ( \"============================================\" ) ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Allocate storage for all gradients allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) allocate ( grad_buffer ( 3 , n_atoms )) current_disp = 1 finished_workers = 0 ! Process work requests and collect results call coord_timer % start () do while ( finished_workers < n_ranks - 1 ) ! Check for incoming gradient results call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE ! Receive: displacement index, gradient type (1=forward, 2=backward), gradient data call irecv ( world_comm , disp_idx , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call irecv ( world_comm , gradient_type , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call recv ( world_comm , grad_buffer , worker_rank , TAG_WORKER_SCALAR_RESULT , status ) ! Store gradient in appropriate array if ( gradient_type == 1 ) then forward_gradients ( disp_idx , :, :) = grad_buffer else backward_gradients ( disp_idx , :, :) = grad_buffer end if ! Log progress every 10% or at completion (count both forward and backward) if ( gradient_type == 2 ) then ! Only log after backward gradient to count complete displacements if ( mod ( disp_idx , max ( 1 , n_displacements / 10 )) == 0 . or . disp_idx == n_displacements ) then call logger % info ( \"  Completed \" // to_char ( disp_idx ) // \"/\" // to_char ( n_displacements ) // & \" displacement pairs in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end if end if end if ! Check for work requests from workers call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE call irecv ( world_comm , dummy_msg , worker_rank , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_disp <= n_displacements ) then ! Send next displacement index to worker call isend ( world_comm , current_disp , worker_rank , TAG_WORKER_FRAGMENT , req ) call wait ( req ) current_disp = current_disp + 1 else ! No more work - tell worker to finish call isend ( world_comm , - 1 , worker_rank , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end do deallocate ( grad_buffer ) call coord_timer % stop () call logger % info ( \"All gradient calculations completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Assemble Hessian from finite differences call logger % info ( \"  Assembling Hessian matrix...\" ) call coord_timer % start () call finite_diff_hessian_from_gradients ( full_system , forward_gradients , backward_gradients , & displacement , hessian ) call coord_timer % stop () call logger % info ( \"Hessian assembly completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Compute energy and gradient at reference geometry call logger % info ( \"  Computing reference energy and gradient...\" ) #ifndef MQC_WITHOUT_TBLITE xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = is_verbose call xtb_calc % calc_gradient ( full_system , result ) #endif ! Store Hessian in result if ( allocated ( result % hessian )) deallocate ( result % hessian ) allocate ( result % hessian ( size ( hessian , 1 ), size ( hessian , 2 ))) result % hessian = hessian result % has_hessian = . true . ! Compute vibrational frequencies from the Hessian (with trans/rot projection) call logger % info ( \"  Computing vibrational frequencies (projecting trans/rot modes)...\" ) call compute_vibrational_frequencies ( result % hessian , sys_geom % element_numbers , frequencies , eigenvalues , & coordinates = sys_geom % coordinates , project_trans_rot = . true ., & projected_hessian_out = projected_hessian ) ! Print results call logger % info ( \"============================================\" ) call logger % info ( \"Distributed Hessian calculation completed\" ) write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) end if if ( result % has_hessian ) then hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) if ( is_verbose . and . n_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * n_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * n_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) ! Print projected mass-weighted Hessian if ( allocated ( projected_hessian )) then call logger % info ( \"Mass-weighted Hessian after trans/rot projection (a.u.):\" ) do i = 1 , 3 * n_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( projected_hessian ( i , j ), j = 1 , 3 * n_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if end if ! Compute and print full vibrational analysis if ( allocated ( frequencies )) then block real ( dp ), allocatable :: vib_freqs (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , vib_freqs , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( vib_freqs )) then call print_vibrational_analysis ( vib_freqs , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( vib_freqs , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if ! Output JSON call print_unfragmented_json ( result ) ! Cleanup call result % destroy () deallocate ( forward_gradients , backward_gradients ) if ( allocated ( hessian )) deallocate ( hessian ) if ( allocated ( frequencies )) deallocate ( frequencies ) if ( allocated ( eigenvalues )) deallocate ( eigenvalues ) if ( allocated ( projected_hessian )) deallocate ( projected_hessian ) end subroutine hessian_coordinator module subroutine hessian_worker ( world_comm , sys_geom , method , displacement ) !! Worker for distributed Hessian calculation !! Requests displacement indices, computes gradients, and sends results back use mqc_finite_differences , only : copy_and_displace_geometry #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) type ( physical_fragment_t ) :: full_system , displaced_geom type ( calculation_result_t ) :: grad_result integer :: n_atoms , disp_idx , atom_idx , coord , gradient_type , dummy_msg type ( MPI_Status ) :: status type ( request_t ) :: req #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc #endif n_atoms = sys_geom % total_atoms ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () #ifndef MQC_WITHOUT_TBLITE ! Setup XTB method xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = . false . dummy_msg = 0 do ! Request work from coordinator call isend ( world_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( world_comm , disp_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) if ( status % MPI_TAG == TAG_WORKER_FINISH ) exit ! Compute displacement index to atom and coordinate atom_idx = ( disp_idx - 1 ) / 3 + 1 coord = mod ( disp_idx - 1 , 3 ) + 1 ! Compute FORWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , displacement , displaced_geom ) call xtb_calc % calc_gradient ( displaced_geom , grad_result ) if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (1=forward), gradient data gradient_type = 1 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call grad_result % destroy () call displaced_geom % destroy () ! Compute BACKWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , - displacement , displaced_geom ) call xtb_calc % calc_gradient ( displaced_geom , grad_result ) if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (2=backward), gradient data gradient_type = 2 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call grad_result % destroy () call displaced_geom % destroy () end do #else call logger % error ( \"XTB method requested but tblite support not compiled in\" ) call abort_comm ( world_comm , 1 ) #endif end subroutine hessian_worker end submodule mqc_hessian_distribution_scheme","tags":"","url":"sourcefile/mqc_mbe_fragment_distribution_scheme_hessian.f90.html"},{"title":"mqc_cli_parser.f90 – metalquicha","text":"Command line argument parsing for metalquicha This file depends on sourcefile~~mqc_cli_parser.f90~~EfferentGraph sourcefile~mqc_cli_parser.f90 mqc_cli_parser.f90 sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_basis_utils.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_basis_utils.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Command line argument parsing for metalquicha module mqc_cli_parser !! Handles parsing of command line options including geometry files, !! basis set specifications, and help/usage display. use mqc_basis_utils , only : normalize_basis_name , find_basis_file use mqc_error , only : error_t , ERROR_PARSE , ERROR_IO implicit none private public :: cli_args_type !! Parsed command line arguments container public :: parse_command_line !! Main argument parsing routine public :: print_usage !! Display program usage information public :: normalize_basis_name !! Standardize basis set names public :: find_basis_file !! Locate basis set files type :: cli_args_type !! Container for parsed command line arguments !! !! Stores file paths and options extracted from command line, !! with automatic memory management for string allocations. character ( len = :), allocatable :: xyz_file !! Input XYZ geometry file path character ( len = :), allocatable :: basis_name !! Basis set name (e.g., \"6-31G\") contains procedure :: destroy => cli_args_destroy !! Memory cleanup end type cli_args_type contains subroutine parse_command_line ( args , error ) !! Parse command line arguments for geometry file and basis set !! !! Extracts XYZ file path and basis set name from command line, !! validates arguments, and handles help requests. type ( cli_args_type ), intent ( out ) :: args !! Parsed argument container type ( error_t ), intent ( out ) :: error !! Error object integer :: nargs !! Number of command line arguments character ( len = 256 ) :: arg_buffer !! Temporary argument buffer integer :: arg_len !! Length of current argument integer :: stat !! Local status for intrinsic calls ! Get number of command line arguments nargs = command_argument_count () ! Check for help flag if ( nargs >= 1 ) then call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading command line argument 1\" ) return end if arg_buffer = trim ( arg_buffer ) if ( arg_buffer == \"-h\" . or . arg_buffer == \"--help\" ) then call print_usage () call error % set ( ERROR_PARSE , \"HELP_REQUESTED\" ) ! Special marker for help return end if end if ! Validate number of arguments if ( nargs < 2 ) then call error % set ( ERROR_PARSE , \"Error: Insufficient arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if if ( nargs > 2 ) then call error % set ( ERROR_PARSE , \"Error: Too many arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if ! Parse argument 1: XYZ file call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry file argument\" ) return end if args % xyz_file = trim ( arg_buffer ) ! Parse argument 2: Basis set name call get_command_argument ( 2 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading basis set name argument\" ) return end if args % basis_name = trim ( arg_buffer ) end subroutine parse_command_line !> Print usage information subroutine print_usage () character ( len = 256 ) :: prog_name integer :: stat call get_command_argument ( 0 , prog_name , status = stat ) if ( stat /= 0 ) prog_name = \"pic_basis_reader\" print * print * , \"Usage: \" , trim ( prog_name ), \" <geometry.xyz> <basis_name>\" print * print * , \"Arguments:\" print * , \"  geometry.xyz   XYZ format molecular geometry file\" print * , \"  basis_name     Name of basis set (e.g., 6-31G, 6-311G**)\" print * print * , \"Options:\" print * , \"  -h, --help     Show this help message\" print * print * , \"Example:\" print * , \"  \" , trim ( prog_name ), \" water.xyz 6-31G\" print * end subroutine print_usage !> Clean up CLI args subroutine cli_args_destroy ( this ) class ( cli_args_type ), intent ( inout ) :: this if ( allocated ( this % xyz_file )) deallocate ( this % xyz_file ) if ( allocated ( this % basis_name )) deallocate ( this % basis_name ) end subroutine cli_args_destroy end module mqc_cli_parser","tags":"","url":"sourcefile/mqc_cli_parser.f90.html"},{"title":"mqc_fragment_lookup.f90 – metalquicha","text":"Hash-based lookup table for fast fragment index retrieval Files dependent on this one sourcefile~~mqc_fragment_lookup.f90~~AfferentGraph sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Hash-based lookup table for fast fragment index retrieval module mqc_fragment_lookup !! Provides O(1) hash table for mapping monomer combinations to fragment indices use pic_types , only : int32 , int64 , dp use pic_sorting , only : sort use pic_hash_32bit , only : fnv_1a_hash implicit none private public :: fragment_lookup_t !! Hash-based lookup table type type :: hash_entry_t !! Single entry in hash table (private helper type) integer , allocatable :: key (:) !! Sorted monomer indices integer ( int64 ) :: value !! Fragment index type ( hash_entry_t ), pointer :: next => null () !! Chain for collisions end type hash_entry_t type :: fragment_lookup_t !! Hash-based lookup table for O(1) fragment index retrieval integer :: table_size = 0 type ( hash_entry_t ), allocatable :: table (:) integer ( int64 ) :: n_entries = 0 logical :: initialized = . false . contains procedure :: init => fragment_lookup_init procedure :: insert => fragment_lookup_insert procedure :: find => fragment_lookup_find procedure :: destroy => fragment_lookup_destroy end type fragment_lookup_t contains pure subroutine fragment_lookup_init ( this , estimated_entries ) !! Initialize hash table with estimated size class ( fragment_lookup_t ), intent ( inout ) :: this integer ( int64 ), intent ( in ) :: estimated_entries integer :: i ! Use prime number close to estimated size for better distribution this % table_size = next_prime_internal ( int ( estimated_entries * 1.3_dp )) allocate ( this % table ( this % table_size )) ! Initialize all entries as empty do i = 1 , this % table_size nullify ( this % table ( i )% next ) end do this % n_entries = 0 this % initialized = . true . end subroutine fragment_lookup_init subroutine fragment_lookup_insert ( this , monomers , n , fragment_idx ) !! Insert a monomer combination -> fragment index mapping class ( fragment_lookup_t ), intent ( inout ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ), intent ( in ) :: fragment_idx integer ( int32 ) :: hash_val integer :: bucket type ( hash_entry_t ), pointer :: new_entry integer , allocatable :: sorted_key (:) if (. not . this % initialized ) error stop \"Hash table not initialized\" ! Sort monomers for canonical key allocate ( sorted_key ( n )) sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Check if this is the first entry in bucket if (. not . allocated ( this % table ( bucket )% key )) then ! First entry in this bucket - use the head entry allocate ( this % table ( bucket )% key ( n )) this % table ( bucket )% key = sorted_key this % table ( bucket )% value = fragment_idx this % n_entries = this % n_entries + 1 else ! Bucket already has entries - chain new entry allocate ( new_entry ) allocate ( new_entry % key ( n )) new_entry % key = sorted_key new_entry % value = fragment_idx new_entry % next => this % table ( bucket )% next this % table ( bucket )% next => new_entry this % n_entries = this % n_entries + 1 end if deallocate ( sorted_key ) end subroutine fragment_lookup_insert function fragment_lookup_find ( this , monomers , n ) result ( idx ) !! Find fragment index for given monomer combination class ( fragment_lookup_t ), intent ( in ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ) :: idx integer ( int32 ) :: hash_val integer :: bucket , sorted_key ( n ) type ( hash_entry_t ), pointer :: entry ! Sort monomers for canonical key sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Search chain if ( allocated ( this % table ( bucket )% key )) then if ( arrays_equal_internal ( this % table ( bucket )% key , sorted_key , n )) then idx = this % table ( bucket )% value return end if entry => this % table ( bucket )% next do while ( associated ( entry )) if ( arrays_equal_internal ( entry % key , sorted_key , n )) then idx = entry % value return end if entry => entry % next end do end if ! Not found idx = - 1 end function fragment_lookup_find pure subroutine fragment_lookup_destroy ( this ) !! Clean up hash table and all chains class ( fragment_lookup_t ), intent ( inout ) :: this integer :: i type ( hash_entry_t ), pointer :: entry , next_entry if (. not . this % initialized ) return do i = 1 , this % table_size ! Free chain entry => this % table ( i )% next do while ( associated ( entry )) next_entry => entry % next if ( allocated ( entry % key )) deallocate ( entry % key ) deallocate ( entry ) entry => next_entry end do ! Free bucket head if ( allocated ( this % table ( i )% key )) deallocate ( this % table ( i )% key ) end do deallocate ( this % table ) this % initialized = . false . end subroutine fragment_lookup_destroy ! Helper functions for hash table pure function arrays_equal_internal ( a , b , n ) result ( equal ) !! Check if two arrays are equal integer , intent ( in ) :: a (:), b (:), n logical :: equal integer :: i equal = . true . if ( size ( a ) /= n . or . size ( b ) /= n ) then equal = . false . return end if do i = 1 , n if ( a ( i ) /= b ( i )) then equal = . false . return end if end do end function arrays_equal_internal pure function next_prime_internal ( n ) result ( p ) !! Find next prime number >= n (simple implementation) integer , intent ( in ) :: n integer :: p , i logical :: is_prime p = max ( n , 2 ) if ( modulo ( p , 2 ) == 0 ) p = p + 1 do is_prime = . true . do i = 3 , int ( sqrt ( real ( p ))) + 1 , 2 if ( modulo ( p , i ) == 0 ) then is_prime = . false . exit end if end do if ( is_prime ) return p = p + 2 end do end function next_prime_internal end module mqc_fragment_lookup","tags":"","url":"sourcefile/mqc_fragment_lookup.f90.html"},{"title":"mqc_calc_types.f90 – metalquicha","text":"Calculation type constants for quantum chemistry calculations Files dependent on this one sourcefile~~mqc_calc_types.f90~~AfferentGraph sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Calculation type constants for quantum chemistry calculations module mqc_calc_types !! Defines integer constants for calculation types to avoid string comparisons !! throughout the codebase. Provides conversion utilities between string !! representations and integer constants. use pic_types , only : int32 implicit none private ! Public constants public :: CALC_TYPE_ENERGY , CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN public :: CALC_TYPE_UNKNOWN ! Public functions public :: calc_type_from_string , calc_type_to_string ! Calculation type constants integer ( int32 ), parameter :: CALC_TYPE_UNKNOWN = 0 integer ( int32 ), parameter :: CALC_TYPE_ENERGY = 1 integer ( int32 ), parameter :: CALC_TYPE_GRADIENT = 2 integer ( int32 ), parameter :: CALC_TYPE_HESSIAN = 3 contains pure function calc_type_from_string ( calc_type_str ) result ( calc_type ) !! Convert calculation type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns CALC_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: calc_type_str !! Input string (e.g., \"energy\", \"gradient\") integer ( int32 ) :: calc_type !! Output integer constant character ( len = len_trim ( calc_type_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( calc_type_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) case ( 'energy' ) calc_type = CALC_TYPE_ENERGY case ( 'gradient' ) calc_type = CALC_TYPE_GRADIENT case ( 'hessian' ) calc_type = CALC_TYPE_HESSIAN case default calc_type = CALC_TYPE_UNKNOWN end select end function calc_type_from_string pure function calc_type_to_string ( calc_type ) result ( calc_type_str ) !! Convert calculation type integer constant to string !! !! Provides human-readable string representation of calculation type. integer ( int32 ), intent ( in ) :: calc_type !! Input integer constant character ( len = :), allocatable :: calc_type_str !! Output string representation select case ( calc_type ) case ( CALC_TYPE_ENERGY ) calc_type_str = \"energy\" case ( CALC_TYPE_GRADIENT ) calc_type_str = \"gradient\" case ( CALC_TYPE_HESSIAN ) calc_type_str = \"hessian\" case default calc_type_str = \"unknown\" end select end function calc_type_to_string end module mqc_calc_types","tags":"","url":"sourcefile/mqc_calc_types.f90.html"},{"title":"mqc_cgto.f90 – metalquicha","text":"Data structures for cartesian contracted Gaussian type orbitals (CGTOs) Files dependent on this one sourcefile~~mqc_cgto.f90~~AfferentGraph sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Data structures for cartesian contracted Gaussian type orbitals (CGTOs) module mqc_cgto !! Defines data structures for cartesian contracted Gaussian type orbitals (CGTOs) use pic_types , only : dp implicit none private public :: cgto_type , atomic_basis_type , molecular_basis_type type :: cgto_type !! Contracted Gaussian type orbital (CGTO) data structure integer :: ang_mom !! Angular momentum quantum number (0=s, 1=p, 2=d, etc.) integer :: nfunc !! Number of primitive Gaussians in the contraction real ( dp ), allocatable :: exponents (:) !! Exponents (alpha values) real ( dp ), allocatable :: coefficients (:) !! Contraction coefficients contains procedure :: allocate_arrays => cgto_allocate_arrays procedure :: destroy => cgto_destroy procedure :: num_basis_functions => cgto_num_basis_functions end type cgto_type type :: atomic_basis_type !! Atomic basis set data structure character ( len = :), allocatable :: element !! element symbol type ( cgto_type ), allocatable :: shells (:) !! array of contracted shells integer :: nshells !! number of shells in type contains procedure :: allocate_shells => allocate_basis_shells procedure :: destroy => atomic_basis_destroy procedure :: num_basis_functions => atomic_basis_num_basis_functions end type atomic_basis_type type :: molecular_basis_type !! Molecular basis set data structure (assembled basis) type ( atomic_basis_type ), allocatable :: elements (:) !! array of atomic basis types integer :: nelements !! total number of atoms/elements in a molecule contains procedure :: allocate_elements => basis_set_allocate_elements procedure :: destroy => basis_set_destroy procedure :: num_basis_functions => molecular_basis_num_basis_functions end type molecular_basis_type contains pure subroutine cgto_allocate_arrays ( self , nfunc ) !! Allocate arrays for exponents and coefficients in a CGTO class ( cgto_type ), intent ( inout ) :: self integer , intent ( in ) :: nfunc self % nfunc = nfunc allocate ( self % exponents ( nfunc )) allocate ( self % coefficients ( nfunc )) end subroutine cgto_allocate_arrays pure subroutine cgto_destroy ( self ) !! Clean up allocated memory in a CGTO class ( cgto_type ), intent ( inout ) :: self if ( allocated ( self % exponents )) deallocate ( self % exponents ) if ( allocated ( self % coefficients )) deallocate ( self % coefficients ) self % nfunc = 0 self % ang_mom = 0 end subroutine cgto_destroy pure subroutine allocate_basis_shells ( self , nshells ) !! Allocate array of shells in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nshells self % nshells = nshells allocate ( self % shells ( nshells )) end subroutine allocate_basis_shells pure subroutine atomic_basis_destroy ( self ) !! Clean up allocated memory in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % shells )) then do i = 1 , self % nshells call self % shells ( i )% destroy () end do deallocate ( self % shells ) end if if ( allocated ( self % element )) deallocate ( self % element ) self % nshells = 0 end subroutine atomic_basis_destroy pure subroutine basis_set_allocate_elements ( self , nelements ) !! Allocate array of atomic basis elements in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nelements self % nelements = nelements allocate ( self % elements ( nelements )) end subroutine basis_set_allocate_elements pure subroutine basis_set_destroy ( self ) !! Clean up allocated memory in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % elements )) then do i = 1 , self % nelements call self % elements ( i )% destroy () end do deallocate ( self % elements ) end if self % nelements = 0 end subroutine basis_set_destroy pure function cgto_num_basis_functions ( self ) result ( nbf ) !! Get number of basis functions in a shell (Cartesian) class ( cgto_type ), intent ( in ) :: self integer :: nbf ! Cartesian: (ang_mom+1)*(ang_mom+2)/2 nbf = ( self % ang_mom + 1 ) * ( self % ang_mom + 2 ) / 2 end function cgto_num_basis_functions pure function atomic_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for an atom class ( atomic_basis_type ), intent ( in ) :: self integer :: nbf integer :: ishell nbf = 0 do ishell = 1 , self % nshells nbf = nbf + self % shells ( ishell )% num_basis_functions () end do end function atomic_basis_num_basis_functions pure function molecular_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for the molecule class ( molecular_basis_type ), intent ( in ) :: self integer :: nbf integer :: iatom nbf = 0 do iatom = 1 , self % nelements nbf = nbf + self % elements ( iatom )% num_basis_functions () end do end function molecular_basis_num_basis_functions end module mqc_cgto","tags":"","url":"sourcefile/mqc_cgto.f90.html"},{"title":"main.f90 – metalquicha","text":"Main program for metalquicha quantum chemistry calculations Input format: .mqc (section-based format) Usage: metalquicha input_file.mqc This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~main.f90->sourcefile~mqc_error.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~main.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_logo.f90 mqc_logo.f90 sourcefile~main.f90->sourcefile~mqc_logo.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Main program for metalquicha quantum chemistry calculations !! !! Input format: .mqc (section-based format) !! !! Usage: metalquicha input_file.mqc program main !! Orchestrates MPI initialization, input parsing, geometry loading, !! and dispatches to appropriate calculation routines (fragmented or unfragmented). use pic_logger , only : logger => global_logger , info_level use pic_io , only : to_char use pic_mpi_lib , only : pic_mpi_init , comm_world , comm_t , abort_comm , pic_mpi_finalize use mqc_driver , only : run_calculation , run_multi_molecule_calculations use mqc_physical_fragment , only : system_geometry_t use mqc_config_parser , only : mqc_config_t , read_mqc_file use mqc_config_adapter , only : driver_config_t , config_to_driver , config_to_system_geometry , get_logger_level use mqc_io_helpers , only : set_output_json_filename , ends_with use mqc_logo , only : print_logo use pic_timer , only : timer_type use mqc_error , only : error_t use pic_knowledge , only : get_knowledge implicit none type ( timer_type ) :: my_timer !! Execution timing type ( comm_t ) :: world_comm !! Global MPI communicator type ( comm_t ) :: node_comm !! Node-local MPI communicator type ( driver_config_t ) :: config !! Driver configuration type ( mqc_config_t ) :: mqc_config !! Parsed .mqc file type ( system_geometry_t ) :: sys_geom !! Loaded molecular system type ( error_t ) :: error !! Error handling integer :: stat !! Status code for file I/O character ( len = :), allocatable :: errmsg !! Error messages for file I/O character ( len = 256 ) :: input_file !! Input file name ! Initialize MPI ! pic-mpi will call mpi_init_thread when needed call pic_mpi_init () ! Create communicators world_comm = comm_world () node_comm = world_comm % split () if ( world_comm % rank () == 0 ) then call print_logo () call my_timer % start () end if ! Parse command line arguments if ( command_argument_count () == 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"No input file specified. Usage: mqc input_file.mqc\" ) end if call abort_comm ( world_comm , 1 ) else if ( command_argument_count () == 1 ) then call get_command_argument ( 1 , input_file , status = stat ) if ( stat /= 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error reading command line argument\" ) end if call abort_comm ( world_comm , 1 ) end if input_file = trim ( input_file ) call set_output_json_filename ( input_file ) ! Validate file extension if (. not . ends_with ( input_file , '.mqc' )) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Invalid input file extension. Expected .mqc\" ) end if call abort_comm ( world_comm , 1 ) end if else if ( world_comm % rank () == 0 ) then call logger % error ( \"Too many arguments. Usage: metalquicha [input_file.mqc]\" ) end if call abort_comm ( world_comm , 1 ) end if ! Parse .mqc input file if ( world_comm % rank () == 0 ) then call logger % info ( \"Reading input file: \" // trim ( input_file )) end if call read_mqc_file ( input_file , mqc_config , error ) if ( error % has_error ()) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error reading .mqc file: \" // error % get_message ()) end if call abort_comm ( world_comm , 1 ) end if ! Configure logger if ( allocated ( mqc_config % log_level )) then call logger % configure ( get_logger_level ( mqc_config % log_level )) if ( world_comm % rank () == 0 ) then call logger % info ( \"Logger verbosity set to: \" // trim ( mqc_config % log_level )) end if end if ! Handle single vs multiple molecules if ( mqc_config % nmol == 0 ) then ! Single molecule mode (backward compatible) call config_to_driver ( mqc_config , config ) call config_to_system_geometry ( mqc_config , sys_geom , error ) if ( error % has_error ()) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error converting geometry: \" // error % get_message ()) end if call abort_comm ( world_comm , 1 ) end if call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % bonds ) call sys_geom % destroy () else ! Multi-molecule mode: loop over all molecules call run_multi_molecule_calculations ( world_comm , node_comm , mqc_config ) end if if ( world_comm % rank () == 0 ) then call get_knowledge () call my_timer % stop () call logger % info ( \"Total processing time: \" // to_char ( my_timer % get_elapsed_time ()) // \" s\" ) end if call mqc_config % destroy () call world_comm % finalize () call node_comm % finalize () call pic_mpi_finalize () end program main","tags":"","url":"sourcefile/main.f90.html"},{"title":"mqc_method_hf.f90 – metalquicha","text":"Hartree-Fock method implementation for metalquicha This file depends on sourcefile~~mqc_method_hf.f90~~EfferentGraph sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Hartree-Fock method implementation for metalquicha module mqc_method_hf !! Implements the Hartree-Fock quantum chemistry method !! Provides energy and gradient calculations using a basic SCF procedure. use pic_types , only : dp use mqc_method_base , only : qc_method_t use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: hf_method_t , hf_options_t type :: hf_options_t !! Hartree-Fock calculation options integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: conv_tol = 1.0e-8_dp !! Energy convergence threshold logical :: spherical = . false . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . true . !! Print SCF iterations end type hf_options_t type , extends ( qc_method_t ) :: hf_method_t !! Hartree-Fock method implementation type ( hf_options_t ) :: options contains procedure :: calc_energy => hf_calc_energy procedure :: calc_gradient => hf_calc_gradient procedure :: calc_hessian => null_hessian !! Placeholder for Hessian calculation end type hf_method_t contains subroutine hf_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement actual HF calculation ! 1. Convert fragment%basis to libcint format ! 2. Build one-electron integrals (S, T, V) ! 3. Run SCF iterations ! 4. Calculate final energy print * , \"HF: Calculating energy for fragment with\" , fragment % n_atoms , \"atoms\" print * , \"HF: nelec =\" , fragment % nelec print * , \"HF: charge =\" , fragment % charge print * , \"HF: multiplicity =\" , fragment % multiplicity ! Dummy result result % energy % scf = - 1.0_dp ! Placeholder result % has_energy = . true . print * , \"HF: Dummy energy =\" , result % energy % total () end subroutine hf_calc_energy subroutine hf_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement gradient calculation ! 1. Calculate energy (call calc_energy) ! 2. Calculate gradient using integral derivatives print * , \"HF: Calculating gradient for fragment with\" , fragment % n_atoms , \"atoms\" ! First get energy call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . print * , \"HF: Dummy gradient allocated\" end subroutine hf_calc_gradient subroutine null_hessian ( this , fragment , result ) !! Placeholder for Hessian calculation class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result print * , \"HF: Hessian calculation not implemented yet.\" result % has_hessian = . false . end subroutine null_hessian end module mqc_method_hf","tags":"","url":"sourcefile/mqc_method_hf.f90.html"},{"title":"mqc_vibrational_analysis.f90 – metalquicha","text":"Vibrational frequency analysis from Hessian matrix This file depends on sourcefile~~mqc_vibrational_analysis.f90~~EfferentGraph sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_vibrational_analysis.f90~~AfferentGraph sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Vibrational frequency analysis from Hessian matrix module mqc_vibrational_analysis !! Computes vibrational frequencies from the mass-weighted Hessian matrix. !! Uses LAPACK eigenvalue decomposition via pic-blas interfaces. use pic_types , only : dp use pic_lapack_interfaces , only : pic_syev , pic_gesvd use pic_logger , only : use mqc_elements , only : element_mass , element_number_to_symbol use pic_logger , only : logger => global_logger implicit none private public :: compute_vibrational_frequencies public :: compute_vibrational_analysis public :: mass_weight_hessian public :: project_translation_rotation public :: compute_reduced_masses public :: compute_force_constants public :: compute_cartesian_displacements public :: print_vibrational_analysis ! Conversion factor from atomic units (Hartree/Bohr²/amu) to cm⁻¹ ! Derived from fundamental constants: !   sqrt(Hartree/(Bohr²·amu)) → s⁻¹ → cm⁻¹ real ( dp ), parameter :: AU_TO_CM1 = 2.642461e7_dp ! Conversion factor from atomic units (Hartree/Bohr²) to mdyne/Å ! 1 Hartree/Bohr² = 15.569141 mdyne/Å real ( dp ), parameter :: AU_TO_MDYNE_ANG = 1 5.569141_dp contains subroutine compute_vibrational_frequencies ( hessian , element_numbers , frequencies , & eigenvalues_out , eigenvectors , & coordinates , project_trans_rot , & projected_hessian_out ) !! Compute vibrational frequencies from the Hessian matrix. !! !! Algorithm: !! 1. Mass-weight the Hessian: H_mw = M&#94;{-1/2} * H * M&#94;{-1/2} !! 2. Optionally project out translation/rotation modes !! 3. Diagonalize H_mw to get eigenvalues !! 4. Convert eigenvalues to frequencies in cm⁻¹ !! !! Negative eigenvalues produce negative frequencies (imaginary modes, !! indicating transition states or saddle points). real ( dp ), intent ( in ) :: hessian (:, :) !! Hessian matrix in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ (3*N modes, or 3*N-6 if projected) real ( dp ), allocatable , intent ( out ), optional :: eigenvalues_out (:) !! Raw eigenvalues from diagonalization (Hartree/Bohr²/amu) real ( dp ), allocatable , intent ( out ), optional :: eigenvectors (:, :) !! Normal mode eigenvectors (3*N x 3*N), columns are modes real ( dp ), intent ( in ), optional :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) - required for projection logical , intent ( in ), optional :: project_trans_rot !! If true, project out translation/rotation modes (requires coordinates) real ( dp ), allocatable , intent ( out ), optional :: projected_hessian_out (:, :) !! Mass-weighted Hessian after trans/rot projection (before diagonalization) real ( dp ), allocatable :: mw_hessian (:, :) real ( dp ), allocatable :: eigenvalues (:) integer :: n_coords , info , i logical :: do_projection n_coords = size ( hessian , 1 ) ! Check if projection is requested do_projection = . false . if ( present ( project_trans_rot )) then if ( project_trans_rot ) then if (. not . present ( coordinates )) then ! Cannot project without coordinates - fall back to no projection call logger % warning ( \"Missing coordinates, not projecting out tran/rot motions\" ) do_projection = . false . else do_projection = . true . end if end if end if ! Mass-weight the Hessian call mass_weight_hessian ( hessian , element_numbers , mw_hessian ) ! Optionally project out translation/rotation modes if ( do_projection ) then call project_translation_rotation ( mw_hessian , coordinates , element_numbers ) end if ! Return projected Hessian if requested (before diagonalization destroys it) if ( present ( projected_hessian_out )) then allocate ( projected_hessian_out ( n_coords , n_coords )) projected_hessian_out = mw_hessian end if ! Allocate eigenvalue storage allocate ( eigenvalues ( n_coords )) ! Diagonalize the mass-weighted Hessian ! pic_syev overwrites mw_hessian with eigenvectors (if jobz='V', default) call pic_syev ( mw_hessian , eigenvalues , info = info ) if ( info /= 0 ) then ! Eigenvalue decomposition failed call logger % error ( \"Eigenvalue decomposition in vibrational frequencies failed\" ) allocate ( frequencies ( n_coords )) frequencies = 0.0_dp return end if ! Convert eigenvalues to frequencies in cm⁻¹ allocate ( frequencies ( n_coords )) do i = 1 , n_coords if ( eigenvalues ( i ) >= 0.0_dp ) then ! Real frequency frequencies ( i ) = sqrt ( eigenvalues ( i ) * AU_TO_CM1 ) else ! Imaginary frequency (negative eigenvalue) - report as negative frequencies ( i ) = - sqrt ( abs ( eigenvalues ( i )) * AU_TO_CM1 ) end if end do ! Return eigenvalues if requested if ( present ( eigenvalues_out )) then allocate ( eigenvalues_out ( n_coords )) eigenvalues_out = eigenvalues end if ! Return eigenvectors if requested if ( present ( eigenvectors )) then allocate ( eigenvectors ( n_coords , n_coords )) eigenvectors = mw_hessian end if deallocate ( eigenvalues , mw_hessian ) end subroutine compute_vibrational_frequencies subroutine compute_vibrational_analysis ( hessian , element_numbers , frequencies , & reduced_masses , force_constants , & cartesian_displacements , & eigenvalues_out , eigenvectors_out , & coordinates , project_trans_rot , & force_constants_mdyne ) !! Perform complete vibrational analysis from Hessian matrix. !! !! This is a convenience wrapper that computes: !! - Vibrational frequencies in cm⁻¹ !! - Reduced masses in amu !! - Force constants in Hartree/Bohr² (and optionally mdyne/Å) !! - Cartesian displacement vectors (normalized) !! !! Optionally projects out translation/rotation modes. real ( dp ), intent ( in ) :: hessian (:, :) !! Hessian matrix in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ real ( dp ), allocatable , intent ( out ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), allocatable , intent ( out ) :: force_constants (:) !! Force constants in Hartree/Bohr² real ( dp ), allocatable , intent ( out ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N) real ( dp ), allocatable , intent ( out ), optional :: eigenvalues_out (:) !! Raw eigenvalues from diagonalization real ( dp ), allocatable , intent ( out ), optional :: eigenvectors_out (:, :) !! Mass-weighted eigenvectors real ( dp ), intent ( in ), optional :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) - required for projection logical , intent ( in ), optional :: project_trans_rot !! If true, project out translation/rotation modes real ( dp ), allocatable , intent ( out ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å real ( dp ), allocatable :: eigenvalues (:) real ( dp ), allocatable :: eigenvectors (:, :) ! First compute frequencies and eigenvectors call compute_vibrational_frequencies ( hessian , element_numbers , frequencies , & eigenvalues_out = eigenvalues , & eigenvectors = eigenvectors , & coordinates = coordinates , & project_trans_rot = project_trans_rot ) ! Compute reduced masses from eigenvectors call compute_reduced_masses ( eigenvectors , element_numbers , reduced_masses ) ! Compute force constants from eigenvalues and reduced masses call compute_force_constants ( eigenvalues , reduced_masses , force_constants , & force_constants_mdyne ) ! Compute Cartesian displacements from eigenvectors call compute_cartesian_displacements ( eigenvectors , element_numbers , & cartesian_displacements ) ! Optionally return eigenvalues and eigenvectors if ( present ( eigenvalues_out )) then allocate ( eigenvalues_out ( size ( eigenvalues ))) eigenvalues_out = eigenvalues end if if ( present ( eigenvectors_out )) then allocate ( eigenvectors_out ( size ( eigenvectors , 1 ), size ( eigenvectors , 2 ))) eigenvectors_out = eigenvectors end if deallocate ( eigenvalues , eigenvectors ) end subroutine compute_vibrational_analysis subroutine mass_weight_hessian ( hessian , element_numbers , mw_hessian ) !! Apply mass weighting to Hessian matrix. !! !! H_mw(i,j) = H(i,j) / sqrt(m_i * m_j) !! !! where m_i is the mass of the atom corresponding to coordinate i. !! Each atom contributes 3 coordinates (x, y, z). real ( dp ), intent ( in ) :: hessian (:, :) !! Input Hessian in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: mw_hessian (:, :) !! Mass-weighted Hessian (3*N x 3*N) real ( dp ), allocatable :: inv_sqrt_mass (:) integer :: n_atoms , n_coords , iatom , icoord , i , j real ( dp ) :: mass n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms ! Build inverse square root mass vector (each mass repeated 3x for x,y,z) allocate ( inv_sqrt_mass ( n_coords )) do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) do icoord = 1 , 3 inv_sqrt_mass ( 3 * ( iatom - 1 ) + icoord ) = 1.0_dp / sqrt ( mass ) end do end do ! Apply mass weighting: H_mw(i,j) = H(i,j) * inv_sqrt_mass(i) * inv_sqrt_mass(j) allocate ( mw_hessian ( n_coords , n_coords )) do j = 1 , n_coords do i = 1 , n_coords mw_hessian ( i , j ) = hessian ( i , j ) * inv_sqrt_mass ( i ) * inv_sqrt_mass ( j ) end do end do deallocate ( inv_sqrt_mass ) end subroutine mass_weight_hessian subroutine project_translation_rotation ( mw_hessian , coordinates , element_numbers ) !! Project out translation and rotation modes from mass-weighted Hessian. !! !! Builds 6 vectors (3 translation + 3 rotation) in mass-weighted coordinates, !! orthonormalizes them using SVD, then projects them out: !!   H_proj = (I - D @ D&#94;T) @ H @ (I - D @ D&#94;T) !! !! This sets the 6 translation/rotation eigenvalues to exactly zero. real ( dp ), intent ( inout ) :: mw_hessian (:, :) !! Mass-weighted Hessian (modified in place) real ( dp ), intent ( in ) :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable :: D (:, :) ! Translation/rotation vectors (3N, 6) real ( dp ), allocatable :: com (:) ! Center of mass real ( dp ), allocatable :: r (:, :) ! Coordinates relative to COM real ( dp ), allocatable :: sqrt_mass (:) ! sqrt(mass) for each atom real ( dp ), allocatable :: S (:) ! Singular values real ( dp ), allocatable :: U (:, :) ! Left singular vectors real ( dp ), allocatable :: VT (:, :) ! Right singular vectors (transposed) real ( dp ), allocatable :: D_orth (:, :) ! Orthonormalized D vectors real ( dp ), allocatable :: proj (:, :) ! Projector matrix real ( dp ), allocatable :: temp (:, :) ! Temporary matrix real ( dp ) :: total_mass , mass , norm integer :: n_atoms , n_coords , iatom , i , j , k , n_modes , info integer :: idx n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms ! Allocate arrays allocate ( D ( n_coords , 6 )) allocate ( com ( 3 )) allocate ( r ( 3 , n_atoms )) allocate ( sqrt_mass ( n_atoms )) ! Compute sqrt(mass) for each atom and total mass total_mass = 0.0_dp do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) sqrt_mass ( iatom ) = sqrt ( mass ) total_mass = total_mass + mass end do ! Compute center of mass com = 0.0_dp do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) com (:) = com (:) + mass * coordinates (:, iatom ) end do com = com / total_mass ! Compute coordinates relative to center of mass do iatom = 1 , n_atoms r (:, iatom ) = coordinates (:, iatom ) - com (:) end do ! Initialize D to zero D = 0.0_dp ! Build translation vectors (mass-weighted) ! D_trans_k: displacement along axis k, weighted by sqrt(mass) do iatom = 1 , n_atoms idx = 3 * ( iatom - 1 ) ! Translation along x D ( idx + 1 , 1 ) = sqrt_mass ( iatom ) ! Translation along y D ( idx + 2 , 2 ) = sqrt_mass ( iatom ) ! Translation along z D ( idx + 3 , 3 ) = sqrt_mass ( iatom ) end do ! Build rotation vectors (mass-weighted) ! D_rot_k: rotation around axis k, proportional to r × e_k, weighted by sqrt(mass) do iatom = 1 , n_atoms idx = 3 * ( iatom - 1 ) ! Rotation around x-axis: r × e_x = (0, r_z, -r_y) D ( idx + 2 , 4 ) = sqrt_mass ( iatom ) * r ( 3 , iatom ) D ( idx + 3 , 4 ) = - sqrt_mass ( iatom ) * r ( 2 , iatom ) ! Rotation around y-axis: r × e_y = (-r_z, 0, r_x) D ( idx + 1 , 5 ) = - sqrt_mass ( iatom ) * r ( 3 , iatom ) D ( idx + 3 , 5 ) = sqrt_mass ( iatom ) * r ( 1 , iatom ) ! Rotation around z-axis: r × e_z = (r_y, -r_x, 0) D ( idx + 1 , 6 ) = sqrt_mass ( iatom ) * r ( 2 , iatom ) D ( idx + 2 , 6 ) = - sqrt_mass ( iatom ) * r ( 1 , iatom ) end do ! Normalize each column of D do k = 1 , 6 norm = sqrt ( sum ( D (:, k ) ** 2 )) if ( norm > 1.0e-10_dp ) then D (:, k ) = D (:, k ) / norm end if end do ! Orthonormalize D using SVD: D = U @ S @ VT ! The orthonormal basis is given by the columns of U corresponding to non-zero singular values allocate ( S ( 6 )) allocate ( U ( n_coords , 6 )) allocate ( VT ( 6 , 6 )) ! pic_gesvd(A, S, U, VT, info) - A is input, U and VT are separate outputs call pic_gesvd ( D , S , U , VT , info = info ) ! Count non-zero singular values (determines number of modes to project) n_modes = 0 do k = 1 , 6 if ( S ( k ) > 1.0e-10_dp ) n_modes = n_modes + 1 end do ! Build orthonormalized D matrix from U (columns with non-zero singular values) allocate ( D_orth ( n_coords , n_modes )) j = 0 do k = 1 , 6 if ( S ( k ) > 1.0e-10_dp ) then j = j + 1 D_orth (:, j ) = U (:, k ) end if end do ! Build projector: P = I - D_orth @ D_orth&#94;T allocate ( proj ( n_coords , n_coords )) proj = 0.0_dp do i = 1 , n_coords proj ( i , i ) = 1.0_dp end do ! Subtract D_orth @ D_orth&#94;T do i = 1 , n_coords do j = 1 , n_coords do k = 1 , n_modes proj ( i , j ) = proj ( i , j ) - D_orth ( i , k ) * D_orth ( j , k ) end do end do end do ! Apply projection: H_proj = P @ H @ P allocate ( temp ( n_coords , n_coords )) ! temp = H @ P do i = 1 , n_coords do j = 1 , n_coords temp ( i , j ) = 0.0_dp do k = 1 , n_coords temp ( i , j ) = temp ( i , j ) + mw_hessian ( i , k ) * proj ( k , j ) end do end do end do ! H_proj = P @ temp do i = 1 , n_coords do j = 1 , n_coords mw_hessian ( i , j ) = 0.0_dp do k = 1 , n_coords mw_hessian ( i , j ) = mw_hessian ( i , j ) + proj ( i , k ) * temp ( k , j ) end do end do end do ! Cleanup deallocate ( D , com , r , sqrt_mass , S , U , VT , D_orth , proj , temp ) end subroutine project_translation_rotation subroutine compute_reduced_masses ( eigenvectors , element_numbers , reduced_masses ) !! Compute reduced masses for each normal mode. !! !! The reduced mass μ_k for mode k is defined as: !!   μ_k = 1 / Σ_i (L_mw_{i,k}² / m_i) !! !! where L_mw is the mass-weighted eigenvector (normalized to 1). !! This formula arises from the relationship Q_k = Σ_i √m_i * x_i * L_mw_{i,k} !! and ensures that the harmonic oscillator relation ω² = k/μ holds. real ( dp ), intent ( in ) :: eigenvectors (:, :) !! Mass-weighted eigenvectors from diagonalization (3*N x 3*N) !! Columns are normal modes, assumed normalized (Σ_i L²_{i,k} = 1) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: reduced_masses (:) !! Reduced masses in amu (one per mode) integer :: n_atoms , n_coords , iatom , icoord , k , idx real ( dp ) :: mass , sum_over_mass n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms allocate ( reduced_masses ( n_coords )) ! For each normal mode k do k = 1 , n_coords sum_over_mass = 0.0_dp ! Sum over all 3N coordinates: Σ_i (L²_{i,k} / m_i) do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) do icoord = 1 , 3 idx = 3 * ( iatom - 1 ) + icoord sum_over_mass = sum_over_mass + eigenvectors ( idx , k ) ** 2 / mass end do end do ! μ_k = 1 / Σ_i (L²_{i,k} / m_i) if ( sum_over_mass > 1.0e-14_dp ) then reduced_masses ( k ) = 1.0_dp / sum_over_mass else ! Near-zero contribution (e.g., trans/rot mode) - assign a large mass reduced_masses ( k ) = 1.0e10_dp end if end do end subroutine compute_reduced_masses subroutine compute_force_constants ( eigenvalues , reduced_masses , force_constants , & force_constants_mdyne ) !! Compute force constants for each normal mode. !! !! From the harmonic oscillator relation: !!   ω² = k/μ  →  k = ω² × μ = eigenvalue × μ !! !! Returns force constants in both atomic units (Hartree/Bohr²) and mdyne/Å. real ( dp ), intent ( in ) :: eigenvalues (:) !! Eigenvalues from mass-weighted Hessian diagonalization (1/amu) real ( dp ), intent ( in ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), allocatable , intent ( out ) :: force_constants (:) !! Force constants in atomic units (Hartree/Bohr²) real ( dp ), allocatable , intent ( out ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å (common experimental unit) integer :: n_modes , k n_modes = size ( eigenvalues ) allocate ( force_constants ( n_modes )) ! k = eigenvalue × μ (eigenvalue has units Hartree/(Bohr²·amu), μ in amu) ! So force_constant has units Hartree/Bohr² do k = 1 , n_modes if ( eigenvalues ( k ) >= 0.0_dp ) then force_constants ( k ) = eigenvalues ( k ) * reduced_masses ( k ) else ! Imaginary frequency mode - report absolute value force_constants ( k ) = - abs ( eigenvalues ( k )) * reduced_masses ( k ) end if end do ! Optionally convert to mdyne/Å if ( present ( force_constants_mdyne )) then allocate ( force_constants_mdyne ( n_modes )) force_constants_mdyne = force_constants * AU_TO_MDYNE_ANG end if end subroutine compute_force_constants subroutine compute_cartesian_displacements ( eigenvectors , element_numbers , & cartesian_displacements , normalize_max ) !! Convert mass-weighted eigenvectors to Cartesian displacements. !! !! The Cartesian displacement for coordinate i in mode k is: !!   x_{i,k} = L_mw_{i,k} / √(m_i) !! !! The output can be normalized in two ways: !! - normalize_max=.true. (default): normalize so max|x| = 1 for each mode (Gaussian convention) !! - normalize_max=.false.: normalize so Σ_i x²_{i,k} = 1 real ( dp ), intent ( in ) :: eigenvectors (:, :) !! Mass-weighted eigenvectors (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N), columns are modes logical , intent ( in ), optional :: normalize_max !! If true, normalize so max displacement = 1 (default: true) integer :: n_atoms , n_coords , iatom , icoord , k , idx real ( dp ) :: mass , inv_sqrt_mass , norm , max_disp logical :: use_max_norm n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms use_max_norm = . true . if ( present ( normalize_max )) use_max_norm = normalize_max allocate ( cartesian_displacements ( n_coords , n_coords )) ! Convert from mass-weighted to Cartesian: x = L_mw / √m do k = 1 , n_coords do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) inv_sqrt_mass = 1.0_dp / sqrt ( mass ) do icoord = 1 , 3 idx = 3 * ( iatom - 1 ) + icoord cartesian_displacements ( idx , k ) = eigenvectors ( idx , k ) * inv_sqrt_mass end do end do end do ! Normalize each mode do k = 1 , n_coords if ( use_max_norm ) then ! Gaussian convention: normalize so max |displacement| = 1 max_disp = maxval ( abs ( cartesian_displacements (:, k ))) if ( max_disp > 1.0e-14_dp ) then cartesian_displacements (:, k ) = cartesian_displacements (:, k ) / max_disp end if else ! Standard normalization: Σ_i x²_{i,k} = 1 norm = sqrt ( sum ( cartesian_displacements (:, k ) ** 2 )) if ( norm > 1.0e-14_dp ) then cartesian_displacements (:, k ) = cartesian_displacements (:, k ) / norm end if end if end do end subroutine compute_cartesian_displacements subroutine print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cartesian_displacements , element_numbers , & force_constants_mdyne , print_displacements , & n_atoms ) !! Print vibrational analysis results in a formatted table. !! !! Output format is similar to Gaussian, with frequencies grouped in columns. !! Optionally prints Cartesian displacement vectors for each mode. real ( dp ), intent ( in ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ real ( dp ), intent ( in ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), intent ( in ) :: force_constants (:) !! Force constants in Hartree/Bohr² (or mdyne/Å if force_constants_mdyne provided) real ( dp ), intent ( in ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom real ( dp ), intent ( in ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å (if provided, these are printed instead) logical , intent ( in ), optional :: print_displacements !! If true, print Cartesian displacement vectors (default: true) integer , intent ( in ), optional :: n_atoms !! Number of atoms (if not provided, derived from size of element_numbers) integer :: n_modes , n_at , n_groups , igroup , imode , iatom , icoord , k integer :: mode_start , mode_end , modes_in_group logical :: do_print_disp character ( len = 512 ) :: line character ( len = 16 ) :: freq_str , mass_str , fc_str character ( len = 2 ) :: elem_sym character ( len = 3 ) :: coord_label real ( dp ) :: fc_value n_modes = size ( frequencies ) if ( present ( n_atoms )) then n_at = n_atoms else n_at = size ( element_numbers ) end if do_print_disp = . true . if ( present ( print_displacements )) do_print_disp = print_displacements call logger % info ( \" \" ) call logger % info ( \"============================================================\" ) call logger % info ( \"                  VIBRATIONAL ANALYSIS\" ) call logger % info ( \"============================================================\" ) call logger % info ( \" \" ) ! Print in groups of 3 modes (like Gaussian) n_groups = ( n_modes + 2 ) / 3 do igroup = 1 , n_groups mode_start = ( igroup - 1 ) * 3 + 1 mode_end = min ( igroup * 3 , n_modes ) modes_in_group = mode_end - mode_start + 1 ! Mode numbers header line = \"                    \" do k = mode_start , mode_end write ( freq_str , '(i12)' ) k line = trim ( line ) // freq_str end do call logger % info ( trim ( line )) ! Frequencies (show \"i\" only for significant imaginary frequencies) line = \" Frequencies --  \" do k = mode_start , mode_end if ( frequencies ( k ) < 0.0_dp . and . abs ( frequencies ( k )) > 1 0.0_dp ) then ! Significant imaginary frequency - show with \"i\" write ( freq_str , '(f12.4,a)' ) abs ( frequencies ( k )), \"i\" else ! Real or near-zero frequency write ( freq_str , '(f12.4)' ) abs ( frequencies ( k )) end if line = trim ( line ) // freq_str end do call logger % info ( trim ( line )) ! Reduced masses line = \" Red. masses --  \" do k = mode_start , mode_end write ( mass_str , '(f12.4)' ) reduced_masses ( k ) line = trim ( line ) // mass_str end do call logger % info ( trim ( line )) ! Force constants if ( present ( force_constants_mdyne )) then line = \" Frc consts  --  \" do k = mode_start , mode_end write ( fc_str , '(f12.4)' ) force_constants_mdyne ( k ) line = trim ( line ) // fc_str end do else line = \" Frc consts  --  \" do k = mode_start , mode_end write ( fc_str , '(f12.6)' ) force_constants ( k ) line = trim ( line ) // fc_str end do end if call logger % info ( trim ( line )) ! Cartesian displacements if ( do_print_disp ) then call logger % info ( \" Atom          X         Y         Z       X         Y         Z       X         Y         Z\" ) do iatom = 1 , n_at elem_sym = element_number_to_symbol ( element_numbers ( iatom )) ! Build line with atom info and displacements for each mode write ( line , '(i4,1x,a2)' ) iatom , elem_sym do k = mode_start , mode_end do icoord = 1 , 3 write ( freq_str , '(f10.5)' ) cartesian_displacements ( 3 * ( iatom - 1 ) + icoord , k ) line = trim ( line ) // freq_str end do end do call logger % info ( trim ( line )) end do end if call logger % info ( \" \" ) end do ! Summary statistics call logger % info ( \"------------------------------------------------------------\" ) call logger % info ( \" Summary:\" ) ! Count real vs imaginary frequencies block integer :: n_real , n_imag , n_zero real ( dp ) :: zero_thresh zero_thresh = 1 0.0_dp ! frequencies below 10 cm⁻¹ considered \"zero\" n_real = 0 n_imag = 0 n_zero = 0 do k = 1 , n_modes if ( abs ( frequencies ( k )) < zero_thresh ) then n_zero = n_zero + 1 else if ( frequencies ( k ) < 0.0_dp ) then n_imag = n_imag + 1 else n_real = n_real + 1 end if end do write ( line , '(a,i5)' ) \"   Total modes:              \" , n_modes call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Real frequencies:         \" , n_real call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Imaginary frequencies:    \" , n_imag call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Near-zero (trans/rot):    \" , n_zero call logger % info ( trim ( line )) if ( n_imag > 0 ) then call logger % warning ( \"System has imaginary frequencies - may be a transition state\" ) end if end block call logger % info ( \"============================================================\" ) call logger % info ( \" \" ) end subroutine print_vibrational_analysis end module mqc_vibrational_analysis","tags":"","url":"sourcefile/mqc_vibrational_analysis.f90.html"},{"title":"mqc_elements.f90 – metalquicha","text":"Periodic table data and element utilities Files dependent on this one sourcefile~~mqc_elements.f90~~AfferentGraph sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Periodic table data and element utilities module mqc_elements !! Provides atomic numbers, element symbols, and atomic masses for the complete !! periodic table (elements 1-118) with conversion functions between representations. use pic_ascii , only : to_upper , to_lower use pic_types , only : dp implicit none private public :: element_symbol_to_number !! Convert element symbol to atomic number public :: element_number_to_symbol !! Convert atomic number to element symbol public :: element_mass !! Get atomic mass by atomic number ! TODO: refactr to use findloc ! Periodic table data as module-level parameters integer , parameter :: n_elements = 118 character ( len = 2 ), parameter :: element_symbols ( n_elements ) = [ character ( len = 2 ) :: & !! Element symbols for the complete periodic table (H through Og) !! Ordered by atomic number from 1 to 118 ! for some reason this is how the formatted formats this (????) 'H' , 'He' , & 'Li' , 'Be' , 'B' , 'C' , 'N' , 'O' , 'F' , 'Ne' , & 'Na' , 'Mg' , 'Al' , 'Si' , 'P' , 'S' , 'Cl' , 'Ar' , & 'K' , 'Ca' , 'Sc' , 'Ti' , 'V' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , & 'Rb' , 'Sr' , 'Y' , 'Zr' , 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , 'In' , 'Sn' , 'Sb' , 'Te' , 'I' , 'Xe' , & 'Cs' , 'Ba' , 'La' , 'Ce' , 'Pr' , 'Nd' , 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , 'Lu' , & 'Hf' , 'Ta' , 'W' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , & 'Fr' , 'Ra' , 'Ac' , 'Th' , 'Pa' , 'U' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' , 'Es' , 'Fm' , 'Md' , 'No' , 'Lr' , & 'Rf' , 'Db' , 'Sg' , 'Bh' , 'Hs' , 'Mt' , 'Ds' , 'Rg' , 'Cn' , 'Nh' , 'Fl' , 'Mc' , 'Lv' , 'Ts' , 'Og' ] real ( dp ), parameter :: element_masses ( n_elements ) = [ & !! Standard atomic masses in atomic mass units (amu) !! Based on IUPAC standard atomic weights, ordered by atomic number ! for some reason this is how the formatted formats this (????) 1.008_dp , 4.0026_dp , & ! H-He 6.94_dp , 9.0122_dp , 1 0.81_dp , 1 2.011_dp , 1 4.007_dp , 1 5.999_dp , 1 8.998_dp , 2 0.180_dp , & ! Li-Ne 2 2.990_dp , 2 4.305_dp , 2 6.982_dp , 2 8.085_dp , 3 0.974_dp , 3 2.06_dp , 3 5.45_dp , 3 9.948_dp , & ! Na-Ar 3 9.098_dp , 4 0.078_dp , 4 4.956_dp , 4 7.867_dp , 5 0.942_dp , 5 1.996_dp , 5 4.938_dp , 5 5.845_dp , & ! K-Fe 5 8.933_dp , 5 8.693_dp , 6 3.546_dp , 6 5.38_dp , 6 9.723_dp , 7 2.630_dp , 7 4.922_dp , 7 8.971_dp , & ! Co-Se 7 9.904_dp , 8 3.798_dp , & ! Br-Kr 8 5.468_dp , 8 7.62_dp , 8 8.906_dp , 9 1.224_dp , 9 2.906_dp , 9 5.95_dp , 9 8.0_dp , 10 1.07_dp , & ! Rb-Ru 10 2.91_dp , 10 6.42_dp , 10 7.87_dp , 11 2.41_dp , 11 4.82_dp , 11 8.71_dp , 12 1.76_dp , 12 7.60_dp , & ! Rh-Te 12 6.90_dp , 13 1.29_dp , & ! I-Xe 13 2.91_dp , 13 7.33_dp , 13 8.91_dp , 14 0.12_dp , 14 0.91_dp , 14 4.24_dp , 14 5.0_dp , 15 0.36_dp , & ! Cs-Sm 15 1.96_dp , 15 7.25_dp , 15 8.93_dp , 16 2.50_dp , 16 4.93_dp , 16 7.26_dp , 16 8.93_dp , 17 3.05_dp , & ! Eu-Yb 17 4.97_dp , 17 8.49_dp , 18 0.95_dp , 18 3.84_dp , 18 6.21_dp , 19 0.23_dp , 19 2.22_dp , 19 5.08_dp , & ! Lu-Pt 19 6.97_dp , 20 0.59_dp , 20 4.38_dp , 20 7.2_dp , 20 8.98_dp , 20 9.0_dp , 21 0.0_dp , 22 2.0_dp , & ! Au-Rn 22 3.0_dp , 22 6.0_dp , 22 7.0_dp , 23 2.04_dp , 23 1.04_dp , 23 8.03_dp , 23 7.0_dp , 24 4.0_dp , & ! Fr-Pu 24 3.0_dp , 24 7.0_dp , 24 7.0_dp , 25 1.0_dp , 25 2.0_dp , 25 7.0_dp , 25 8.0_dp , 25 9.0_dp , & ! Am-No 26 2.0_dp , 26 7.0_dp , 26 8.0_dp , 27 1.0_dp , 27 2.0_dp , 27 0.0_dp , 27 6.0_dp , 28 1.0_dp , & ! Lr-Ds 28 0.0_dp , 28 5.0_dp , 28 4.0_dp , 28 9.0_dp , 28 8.0_dp , 29 3.0_dp , 29 4.0_dp , 29 4.0_dp ] ! Rg-Og contains pure function element_symbol_to_number ( symbol ) result ( atomic_number ) !! Convert element symbol to atomic number !! Covers the complete periodic table (elements 1-118) character ( len =* ), intent ( in ) :: symbol integer :: atomic_number character ( len = 2 ) :: sym ! Normalize: uppercase first letter, lowercase second sym = adjustl ( symbol ) if ( len_trim ( sym ) >= 1 ) sym ( 1 : 1 ) = to_upper ( sym ( 1 : 1 )) if ( len_trim ( sym ) >= 2 ) sym ( 2 : 2 ) = to_lower ( sym ( 2 : 2 )) ! Search for symbol in table atomic_number = findloc ( element_symbols , sym , dim = 1 ) end function element_symbol_to_number pure function element_number_to_symbol ( atomic_number ) result ( symbol ) !! Convert atomic number to element symbol !! Covers the complete periodic table (elements 1-118) integer , intent ( in ) :: atomic_number character ( len = 2 ) :: symbol select case ( atomic_number ) case ( 1 : 118 ) symbol = element_symbols ( atomic_number ) case default symbol = 'Xx' ! Unknown end select end function element_number_to_symbol pure function element_mass ( atomic_number ) result ( mass ) !! Return atomic mass in atomic mass units (amu) for a given atomic number !! Uses standard atomic weights from IUPAC integer , intent ( in ) :: atomic_number real ( dp ) :: mass select case ( atomic_number ) case ( 1 : 118 ) mass = element_masses ( atomic_number ) case default mass = 0.0_dp ! Unknown element end select end function element_mass end module mqc_elements","tags":"","url":"sourcefile/mqc_elements.f90.html"},{"title":"mqc_unfragmented_workflow.f90 – metalquicha","text":"This file depends on sourcefile~~mqc_unfragmented_workflow.f90~~EfferentGraph sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( mqc_mbe_fragment_distribution_scheme ) mqc_unfragmented_workflow implicit none contains module subroutine unfragmented_calculation ( sys_geom , method , calc_type , bonds , result_out ) !! Run unfragmented calculation on the entire system (nlevel=0) !! This is a simple single-process calculation without MPI distribution !! If result_out is present, returns result instead of writing JSON and destroying it use mqc_error , only : error_t use mqc_vibrational_analysis , only : compute_vibrational_frequencies , & compute_vibrational_analysis , print_vibrational_analysis type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ), intent ( out ), optional :: result_out type ( calculation_result_t ) :: result integer :: total_atoms type ( physical_fragment_t ) :: full_system type ( error_t ) :: error integer :: i if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for unfragmented calculation\" ) error stop \"Missing geometry in unfragmented_calculation\" end if total_atoms = sys_geom % total_atoms call logger % info ( \"============================================\" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( total_atoms )) call logger % info ( \"============================================\" ) ! Build the full system as a single fragment ! For overlapping fragments, we use the full system directly (not concatenating fragments) full_system % n_atoms = total_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( total_atoms )) allocate ( full_system % coordinates ( 3 , total_atoms )) ! Copy all atoms from system geometry full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates ! Set charge and multiplicity from system full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Validate geometry (check for spatially overlapping atoms) call check_duplicate_atoms ( full_system , error ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Overlapping atoms in unfragmented system\" end if ! Process the full system call do_fragment_work ( 0_int64 , result , method , phys_frag = full_system , calc_type = calc_type ) call logger % info ( \"============================================\" ) call logger % info ( \"Unfragmented calculation completed\" ) block character ( len = 2048 ) :: result_line ! Large buffer for Hessian matrix rows integer :: current_log_level , iatom , i , j real ( dp ) :: hess_norm write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) ! Print full gradient if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Gradient (Hartree/Bohr):\" ) do iatom = 1 , total_atoms write ( result_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & result % gradient ( 1 , iatom ), result % gradient ( 2 , iatom ), result % gradient ( 3 , iatom ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if if ( result % has_hessian ) then ! Compute Frobenius norm of Hessian hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) ! Print full Hessian if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * total_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * total_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if ! Compute and print vibrational analysis block real ( dp ), allocatable :: frequencies (:), eigenvalues (:), projected_hessian (:, :) real ( dp ), allocatable :: reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) integer :: ii , jj ! First get projected Hessian for verbose output call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_frequencies ( result % hessian , sys_geom % element_numbers , frequencies , eigenvalues , & coordinates = sys_geom % coordinates , project_trans_rot = . true ., & projected_hessian_out = projected_hessian ) ! Print projected mass-weighted Hessian if verbose and small system if ( current_log_level >= verbose_level . and . total_atoms < 20 ) then if ( allocated ( projected_hessian )) then call logger % info ( \" \" ) call logger % info ( \"Mass-weighted Hessian after trans/rot projection (a.u.):\" ) do ii = 1 , 3 * total_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , ii , \": \" , & ( projected_hessian ( ii , jj ), jj = 1 , 3 * total_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if ! Compute full vibrational analysis and print call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if if ( allocated ( eigenvalues )) deallocate ( eigenvalues ) if ( allocated ( projected_hessian )) deallocate ( projected_hessian ) end block end if end block call logger % info ( \"============================================\" ) ! Return result to caller or write JSON if ( present ( result_out )) then ! Transfer result to output (for dynamics/optimization) result_out = result else ! Write JSON and clean up (normal mode) call print_unfragmented_json ( result ) call result % destroy () end if end subroutine unfragmented_calculation end submodule mqc_unfragmented_workflow","tags":"","url":"sourcefile/mqc_unfragmented_workflow.f90.html"},{"title":"mqc_method_base.f90 – metalquicha","text":"Abstract base module for quantum chemistry method implementations This file depends on sourcefile~~mqc_method_base.f90~~EfferentGraph sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_base.f90~~AfferentGraph sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Abstract base module for quantum chemistry method implementations module mqc_method_base !! Defines the common interface that all quantum chemistry methods must implement, !! providing a unified API for energy and gradient calculations. use pic_types , only : dp use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: qc_method_t !! Abstract base type for all QC methods type , abstract :: qc_method_t !! Abstract base type for all quantum chemistry methods !! !! Defines the required interface for energy and gradient calculations !! that must be implemented by all concrete method types (XTB, HF, etc.). contains procedure ( calc_energy_interface ), deferred :: calc_energy !! Energy calculation interface procedure ( calc_gradient_interface ), deferred :: calc_gradient !! Gradient calculation interface procedure ( calc_hessian_interface ), deferred :: calc_hessian !! Hessian calculation interface end type qc_method_t abstract interface subroutine calc_energy_interface ( this , fragment , result ) !! Interface for energy-only calculations !! !! Computes the electronic energy for a molecular fragment !! using the specified quantum chemistry method. import :: qc_method_t , calculation_result_t , physical_fragment_t implicit none class ( qc_method_t ), intent ( in ) :: this !! Method instance type ( physical_fragment_t ), intent ( in ) :: fragment !! Molecular fragment type ( calculation_result_t ), intent ( out ) :: result !! Calculation results end subroutine calc_energy_interface subroutine calc_gradient_interface ( this , fragment , result ) !! Interface for energy and gradient calculations !! !! Computes both electronic energy and nuclear gradients for a !! molecular fragment using the specified quantum chemistry method. import :: qc_method_t , calculation_result_t , physical_fragment_t implicit none class ( qc_method_t ), intent ( in ) :: this !! Method instance type ( physical_fragment_t ), intent ( in ) :: fragment !! Molecular fragment type ( calculation_result_t ), intent ( out ) :: result end subroutine calc_gradient_interface subroutine calc_hessian_interface ( this , fragment , result ) !! Interface for energy, gradient, and Hessian calculations !! !! Computes electronic energy, nuclear gradients, and Hessian matrix for a !! molecular fragment using the specified quantum chemistry method. import :: qc_method_t , calculation_result_t , physical_fragment_t implicit none class ( qc_method_t ), intent ( in ) :: this !! Method instance type ( physical_fragment_t ), intent ( in ) :: fragment !! Molecular fragment type ( calculation_result_t ), intent ( out ) :: result end subroutine calc_hessian_interface end interface end module mqc_method_base","tags":"","url":"sourcefile/mqc_method_base.f90.html"},{"title":"mqc_logo.f90 – metalquicha","text":"ASCII art logo display for metalquicha Files dependent on this one sourcefile~~mqc_logo.f90~~AfferentGraph sourcefile~mqc_logo.f90 mqc_logo.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_logo.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! ASCII art logo display for metalquicha module mqc_logo !! Provides the project branding sunflower logo and version information !! displayed at program startup. implicit none private public :: print_logo !! Display ASCII sunflower logo and project info contains subroutine print_logo () !! Print the PIC Chemistry ASCII sunflower logo write ( * , '(A)' ) ' ' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                        __   __' write ( * , '(A)' ) '                     .-(  ''.''  )-.' write ( * , '(A)' ) '                    (   \\  |  /   )' write ( * , '(A)' ) '                   ( ''`-.;;;;;.-''` )' write ( * , '(A)' ) '                  ( :-==;;;;;;;==-: )' write ( * , '(A)' ) '                   (  .-'';;;;;''-.  )' write ( * , '(A)' ) '                    (``  /  |  \\  ``)' write ( * , '(A)' ) '                     ''-(__.''.__)-''' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                      (Art by jgs)' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '    ╔═══════════════════════════════════════════════╗' write ( * , '(A)' ) '    ║              Met\"al q\"uicha                   ║' write ( * , '(A)' ) '    ║                (Sunflower)                    ║' write ( * , '(A)' ) '    ║   A hastily put together Fortran code for     ║' write ( * , '(A)' ) '    ║     Fragmented Based Quantum Chemistry        ║' write ( * , '(A)' ) '    ║                                               ║' write ( * , '(A)' ) '    ║        Coded up by Jorge as a hobby           ║' write ( * , '(A)' ) '    ╚═══════════════════════════════════════════════╝' write ( * , '(A)' ) ' ' end subroutine print_logo end module mqc_logo","tags":"","url":"sourcefile/mqc_logo.f90.html"}]}