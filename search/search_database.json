var tipuesearch = {"pages":[{"title":" metalquicha ","text":"metalquicha Metalquicha API Documentation Met’al q’uicha (metalquicha) AI Disclaimer Building Notes on Fortran compiler compatibility Building with the Fortran Package Manager (FPM) Obtaining the FPM Running a calculation Warning This API documentation is a work in progress. Metalquicha API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . Met’al q’uicha (metalquicha) Yes, this is AI generated (the image) if you know an artist, please let me know. Met’al q’uicha (the Huastec (tenek) word for sunflower), which I’ll just write as metalquicha, is a sample quantum chemistry backend\nwith focus on using the pic library and its derivatives: pic-mpi and pic-blas which are Fortran based implementations of commonly used routines such as sorting algorithms,\narray handling, strings, loggers, timers, etc. The documentation is hosted at readthedocs, here . Additionally, users can opt to try the vapaa backend for the mpi_f08 module\nto ensure cross compiler portability. Please report any issues associated here and in vapaa. Metalquicha implements a naive backend for unfragmented and fragmented quantum chemistry\ncalculations. Currently, metalquicha uses tblite as\nits chemistry engine which performs energy calculations. If you are interested in contributing, please see here . Pic is the main project here and all the contributions fall downstream. You can see Project for some information on development priorities and things being done! AI Disclaimer The development of Metalquicha has been assisted by LLMs, such as ChatGPT, and Claude. The philosophy of “vibe coding” applied to this project is as follows: The programmer (Jorge), describes the overall architecture of a subroutine to be implemented and provides pseudocode The LLM produces an implementation that compiles The programmer writes a unit test for the function and validates the subroutine The LLM is asked to optimize the code while keeping the tests passing The programmer evaluates the code and evaluates if the routine needs to be redone or just upgraded by hand Either the programmer changes the code themselves or if they are lazy or cooking dinner while developing, they ask the LLM to try again This was applied for routines such as the mqc_finite_difference module, which is pretty trivial to implement. LLMs were also extensively used to add comments and basic documentation for the code. The idea is that\nMetalquicha is a platform for development of fragmentation methods aimed to be suitable for everyone -\nfrom students with no experience in Fortran and/or Quantum Chemistry to experienced researchers with\nextensive expertise in both. Justification for LLM use I wanted to see to what extent LLMs can be used for Fortran code development. I can conclude that they are actually quite good. Building You will need an internet connection to download the dependencies. The main dependencies are: CMake A Fortran compiler An MPI installation A BLAS/LAPACK install TBLITE (will be downloaded automatically) You can then simply: mkdir build\ncd build\ncmake ../\nmake -j Notes on Fortran compiler compatibility If you enable tblite (enabled by default at the moment) you are going to be blocked by which compilers does tblite\nsupport. If you decide to not build tblite and just build the framework the code will work with most modern compilers. Supported compilers: Using TBlite: gcc, ifx, ifort Without tblite, i.e. no quantum chemistry: gcc, nvfortran, flang(new), ifx, ifort Building with the Fortran Package Manager (FPM) FPM will only work if you are building with openblas, since the linking step is hardcoded. Simply then just do: fpm install --prefix . --compiler mpifort --profile release Obtaining the FPM Install the FPM following the instructions and then simply: fpm install Running a calculation To run a calculation you need to process the JSON input into our mqc format. To do this, you can simply do: python mqc_prep.py validation/inputs/prism.json And this will generate a prism.mqc . Which can be simply run as ./build/mqc validation/inputs/prism.mqc to be run\nin serial mode. Or mpirun -np 4 ./build/mqc validation/inputs/prism.mqc . A sample mqc file is shown below: %schema name = mqc - frag version = 1.0 index_base = 0 units = angstrom end ! schema %model method = XTB - GFN1 basis = cc - pVDZ aux_basis = cc - pVDZ - RIFIT end ! model %driver type = Energy end ! driver %structure charge = 0 multiplicity = 1 end ! structure %geometry 3 O 0 0 0.119262 H 0 0.763239 -0.477047 H 0 -0.763239 -0.477047 end ! geometry %scf maxiter = 300 tolerance = 1e-06 end ! scf If you don’t want to use the python script, you can modify this file by adding an xyz formatted geometry. Supported calculations are Energy , Gradient , and Hessian . Developer Info Jorge Luis Galvez Vallejo","tags":"home","url":"index.html"},{"title":"cc_config_t – metalquicha ","text":"type, public :: cc_config_t Coupled-cluster specific settings (CCSD, CCSD(T), CC2, CC3, etc.) Inherited by type~~cc_config_t~~InheritedByGraph type~cc_config_t cc_config_t type~method_config_t method_config_t type~method_config_t->type~cc_config_t cc Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: amplitude_convergence = 1.0e-7_dp T-amplitude convergence threshold integer, public :: diis_size = 8 DIIS subspace size character(len=8), public :: eom_type = 'ee' EOM type: “ee” (excitation), “ip” (ionization), “ea” (attachment) logical, public :: include_triples = .false. Include (T) triples correction integer, public :: max_iter = 100 Maximum CC iterations integer, public :: n_roots = 0 Number of EOM-CC roots (0 = ground state only) logical, public :: perturbative_triples = .true. Use perturbative (T) vs full CCSDT logical, public :: use_diis = .true. Use DIIS for amplitude equations Source Code type :: cc_config_t !! Coupled-cluster specific settings (CCSD, CCSD(T), CC2, CC3, etc.) integer :: max_iter = 100 !! Maximum CC iterations real ( dp ) :: amplitude_convergence = 1.0e-7_dp !! T-amplitude convergence threshold ! Excitation level logical :: include_triples = . false . !! Include (T) triples correction logical :: perturbative_triples = . true . !! Use perturbative (T) vs full CCSDT ! DIIS for CC logical :: use_diis = . true . !! Use DIIS for amplitude equations integer :: diis_size = 8 !! DIIS subspace size ! EOM-CC for excited states integer :: n_roots = 0 !! Number of EOM-CC roots (0 = ground state only) character ( len = 8 ) :: eom_type = 'ee' !! EOM type: \"ee\" (excitation), \"ip\" (ionization), \"ea\" (attachment) end type cc_config_t","tags":"","url":"type/cc_config_t.html"},{"title":"correlation_config_t – metalquicha ","text":"type, public :: correlation_config_t Shared settings for all post-HF correlation methods Inherited by type~~correlation_config_t~~InheritedByGraph type~correlation_config_t correlation_config_t type~method_config_t method_config_t type~method_config_t->type~correlation_config_t corr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=32), public :: aux_basis = '' Auxiliary basis for RI (e.g., “cc-pvdz-ri”, “cc-pvtz-ri”) real(kind=dp), public :: energy_convergence = 1.0e-8_dp Correlation energy convergence threshold logical, public :: freeze_core = .true. Whether to freeze core orbitals character(len=16), public :: local_type = 'dlpno' Local correlation type: “pno”, “dlpno”, “lmp2”, “lno” integer, public :: n_frozen_core = -1 Number of frozen core orbitals (-1 = auto from elements) real(kind=dp), public :: pno_threshold = 1.0e-7_dp PNO occupation threshold for truncation real(kind=dp), public :: scs_os = 1.2_dp Opposite-spin scaling factor (default: 6/5 for SCS-MP2) real(kind=dp), public :: scs_ss = 1.0_dp/3.0_dp Same-spin scaling factor (default: 1/3 for SCS-MP2) logical, public :: use_df = .true. Use density fitting (RI) for correlation integrals logical, public :: use_local = .false. Use local correlation approximation logical, public :: use_scs = .false. Use spin-component scaled MP2 Source Code type :: correlation_config_t !! Shared settings for all post-HF correlation methods real ( dp ) :: energy_convergence = 1.0e-8_dp !! Correlation energy convergence threshold ! Frozen core integer :: n_frozen_core = - 1 !! Number of frozen core orbitals (-1 = auto from elements) logical :: freeze_core = . true . !! Whether to freeze core orbitals ! Density fitting for correlation logical :: use_df = . true . !! Use density fitting (RI) for correlation integrals character ( len = 32 ) :: aux_basis = '' !! Auxiliary basis for RI (e.g., \"cc-pvdz-ri\", \"cc-pvtz-ri\") ! Local correlation logical :: use_local = . false . !! Use local correlation approximation character ( len = 16 ) :: local_type = 'dlpno' !! Local correlation type: \"pno\", \"dlpno\", \"lmp2\", \"lno\" real ( dp ) :: pno_threshold = 1.0e-7_dp !! PNO occupation threshold for truncation ! Spin-component scaling (for MP2) logical :: use_scs = . false . !! Use spin-component scaled MP2 real ( dp ) :: scs_ss = 1.0_dp / 3.0_dp !! Same-spin scaling factor (default: 1/3 for SCS-MP2) real ( dp ) :: scs_os = 1.2_dp !! Opposite-spin scaling factor (default: 6/5 for SCS-MP2) end type correlation_config_t","tags":"","url":"type/correlation_config_t.html"},{"title":"dft_config_t – metalquicha ","text":"type, public :: dft_config_t Configuration for Kohn-Sham DFT method\nNote: SCF settings (convergence, DIIS) come from scf_config_t Inherited by type~~dft_config_t~~InheritedByGraph type~dft_config_t dft_config_t type~method_config_t method_config_t type~method_config_t->type~dft_config_t dft Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: angular_points = 302 Angular grid points (Lebedev) character(len=32), public :: aux_basis_set = '' Auxiliary basis for density fitting character(len=8), public :: dispersion_type = 'd3bj' Dispersion type: “d3”, “d3bj”, “d4” character(len=32), public :: functional = 'b3lyp' XC functional: “lda”, “pbe”, “b3lyp”, “m06-2x”, etc. character(len=16), public :: grid_type = 'medium' Grid quality: “coarse”, “medium”, “fine”, “ultrafine” integer, public :: radial_points = 75 Radial grid points per atom logical, public :: use_density_fitting = .false. Use RI-J approximation logical, public :: use_dispersion = .false. Add empirical dispersion Source Code type :: dft_config_t !! Configuration for Kohn-Sham DFT method !! Note: SCF settings (convergence, DIIS) come from scf_config_t character ( len = 32 ) :: functional = 'b3lyp' !! XC functional: \"lda\", \"pbe\", \"b3lyp\", \"m06-2x\", etc. ! Integration grid character ( len = 16 ) :: grid_type = 'medium' !! Grid quality: \"coarse\", \"medium\", \"fine\", \"ultrafine\" integer :: radial_points = 75 !! Radial grid points per atom integer :: angular_points = 302 !! Angular grid points (Lebedev) ! Density fitting logical :: use_density_fitting = . false . !! Use RI-J approximation character ( len = 32 ) :: aux_basis_set = '' !! Auxiliary basis for density fitting ! Dispersion correction logical :: use_dispersion = . false . !! Add empirical dispersion character ( len = 8 ) :: dispersion_type = 'd3bj' !! Dispersion type: \"d3\", \"d3bj\", \"d4\" end type dft_config_t","tags":"","url":"type/dft_config_t.html"},{"title":"f12_config_t – metalquicha ","text":"type, public :: f12_config_t Settings for explicitly correlated F12 methods (MP2-F12, CCSD-F12, etc.) Inherited by type~~f12_config_t~~InheritedByGraph type~f12_config_t f12_config_t type~method_config_t method_config_t type~method_config_t->type~f12_config_t f12 Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=8), public :: ansatz = '3c' F12 ansatz: “3c”, “3c(fix)”, “2b”, “2a” character(len=32), public :: cabs_basis = '' Complementary auxiliary basis (CABS) for RI real(kind=dp), public :: geminal_exponent = 1.0_dp Slater-type geminal exponent (beta) character(len=32), public :: optri_basis = '' Optional RI basis for F12 intermediates logical, public :: scale_triples = .true. Apply F12 scaling to (T) correction logical, public :: use_exponent_fit = .false. Fit geminal exponent to basis set Source Code type :: f12_config_t !! Settings for explicitly correlated F12 methods (MP2-F12, CCSD-F12, etc.) real ( dp ) :: geminal_exponent = 1.0_dp !! Slater-type geminal exponent (beta) character ( len = 8 ) :: ansatz = '3c' !! F12 ansatz: \"3c\", \"3c(fix)\", \"2b\", \"2a\" ! Auxiliary basis sets for F12 character ( len = 32 ) :: cabs_basis = '' !! Complementary auxiliary basis (CABS) for RI character ( len = 32 ) :: optri_basis = '' !! Optional RI basis for F12 intermediates ! Approximations logical :: use_exponent_fit = . false . !! Fit geminal exponent to basis set logical :: scale_triples = . true . !! Apply F12 scaling to (T) correction end type f12_config_t","tags":"","url":"type/f12_config_t.html"},{"title":"mcscf_config_t – metalquicha ","text":"type, public :: mcscf_config_t Configuration for MCSCF/CASSCF method Inherited by type~~mcscf_config_t~~InheritedByGraph type~mcscf_config_t mcscf_config_t type~method_config_t method_config_t type~method_config_t->type~mcscf_config_t mcscf Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: ci_convergence = 1.0e-8_dp CI energy threshold real(kind=dp), public :: imaginary_shift = 0.0_dp Imaginary shift for intruder states real(kind=dp), public :: ipea_shift = 0.25_dp IPEA shift for CASPT2 integer, public :: max_macro_iter = 100 Maximum orbital optimization iterations integer, public :: max_micro_iter = 50 Maximum CI iterations per macro integer, public :: n_active_electrons = 0 Number of active electrons integer, public :: n_active_orbitals = 0 Number of active orbitals integer, public :: n_inactive_orbitals = -1 Inactive orbitals (-1 = auto from nelec) integer, public :: n_states = 1 Number of states for SA-CASSCF real(kind=dp), public :: orbital_convergence = 1.0e-6_dp Orbital gradient threshold character(len=16), public :: pt2_type = 'nevpt2' PT2 flavor: “caspt2”, “nevpt2” real(kind=dp), public, allocatable :: state_weights (:) State weights (must sum to 1) logical, public :: use_pt2 = .false. Apply CASPT2/NEVPT2 after CASSCF Source Code type :: mcscf_config_t !! Configuration for MCSCF/CASSCF method ! Active space definition integer :: n_active_electrons = 0 !! Number of active electrons integer :: n_active_orbitals = 0 !! Number of active orbitals integer :: n_inactive_orbitals = - 1 !! Inactive orbitals (-1 = auto from nelec) ! State averaging integer :: n_states = 1 !! Number of states for SA-CASSCF real ( dp ), allocatable :: state_weights (:) !! State weights (must sum to 1) ! Convergence integer :: max_macro_iter = 100 !! Maximum orbital optimization iterations integer :: max_micro_iter = 50 !! Maximum CI iterations per macro real ( dp ) :: orbital_convergence = 1.0e-6_dp !! Orbital gradient threshold real ( dp ) :: ci_convergence = 1.0e-8_dp !! CI energy threshold ! Perturbative corrections logical :: use_pt2 = . false . !! Apply CASPT2/NEVPT2 after CASSCF character ( len = 16 ) :: pt2_type = 'nevpt2' !! PT2 flavor: \"caspt2\", \"nevpt2\" real ( dp ) :: ipea_shift = 0.25_dp !! IPEA shift for CASPT2 real ( dp ) :: imaginary_shift = 0.0_dp !! Imaginary shift for intruder states end type mcscf_config_t","tags":"","url":"type/mcscf_config_t.html"},{"title":"method_config_t – metalquicha ","text":"type, public :: method_config_t Master configuration containing all method-specific configs Usage:\n  config%method_type = METHOD_TYPE_DFT\n  config%basis_set = ‘cc-pvdz’\n  config%dft%functional = ‘pbe0’\n  config%dft%use_dispersion = .true. Inherits type~~method_config_t~~InheritsGraph type~method_config_t method_config_t type~cc_config_t cc_config_t type~method_config_t->type~cc_config_t cc type~correlation_config_t correlation_config_t type~method_config_t->type~correlation_config_t corr type~dft_config_t dft_config_t type~method_config_t->type~dft_config_t dft type~f12_config_t f12_config_t type~method_config_t->type~f12_config_t f12 type~mcscf_config_t mcscf_config_t type~method_config_t->type~mcscf_config_t mcscf type~scf_config_t scf_config_t type~method_config_t->type~scf_config_t scf type~xtb_config_t xtb_config_t type~method_config_t->type~xtb_config_t xtb Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=32), public :: basis_set = 'sto-3g' Basis set name (HF, DFT, MCSCF) type( cc_config_t ), public :: cc Coupled-cluster specific settings (CCSD, CCSD(T), etc.) type( correlation_config_t ), public :: corr Shared correlation settings (used by MP2, CC, etc.) type( dft_config_t ), public :: dft DFT-specific settings (functional, grid, dispersion) type( f12_config_t ), public :: f12 F12 explicitly correlated settings type( mcscf_config_t ), public :: mcscf MCSCF/CASSCF settings integer(kind=int32), public :: method_type = METHOD_TYPE_UNKNOWN Method type constant type( scf_config_t ), public :: scf Shared SCF settings (used by HF and DFT) logical, public :: use_spherical = .true. Spherical vs Cartesian basis functions logical, public :: verbose = .false. Enable verbose output type( xtb_config_t ), public :: xtb XTB settings (GFN1, GFN2) Type-Bound Procedures procedure, public :: reset => config_reset private  subroutine config_reset (this) Reset all configuration values to defaults Arguments Type Intent Optional Attributes Name class( method_config_t ), intent(inout) :: this Source Code type :: method_config_t !! Master configuration containing all method-specific configs !! !! Usage: !!   config%method_type = METHOD_TYPE_DFT !!   config%basis_set = 'cc-pvdz' !!   config%dft%functional = 'pbe0' !!   config%dft%use_dispersion = .true. !----- Common settings (all ab-initio methods) ----- integer ( int32 ) :: method_type = METHOD_TYPE_UNKNOWN !! Method type constant logical :: verbose = . false . !! Enable verbose output character ( len = 32 ) :: basis_set = 'sto-3g' !! Basis set name (HF, DFT, MCSCF) logical :: use_spherical = . true . !! Spherical vs Cartesian basis functions !----- Shared configurations ----- type ( scf_config_t ) :: scf !! Shared SCF settings (used by HF and DFT) type ( correlation_config_t ) :: corr !! Shared correlation settings (used by MP2, CC, etc.) !----- Method-specific configurations ----- type ( xtb_config_t ) :: xtb !! XTB settings (GFN1, GFN2) type ( dft_config_t ) :: dft !! DFT-specific settings (functional, grid, dispersion) type ( mcscf_config_t ) :: mcscf !! MCSCF/CASSCF settings type ( cc_config_t ) :: cc !! Coupled-cluster specific settings (CCSD, CCSD(T), etc.) type ( f12_config_t ) :: f12 !! F12 explicitly correlated settings contains procedure :: reset => config_reset end type method_config_t","tags":"","url":"type/method_config_t.html"},{"title":"scf_config_t – metalquicha ","text":"type, public :: scf_config_t Shared SCF settings for HF and DFT methods Inherited by type~~scf_config_t~~InheritedByGraph type~scf_config_t scf_config_t type~method_config_t method_config_t type~method_config_t->type~scf_config_t scf Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: density_convergence = 1.0e-6_dp Density matrix convergence threshold integer, public :: diis_size = 8 Number of Fock matrices for DIIS real(kind=dp), public :: energy_convergence = 1.0e-8_dp Energy convergence threshold (Hartree) integer, public :: max_iter = 100 Maximum SCF iterations logical, public :: use_diis = .true. Use DIIS acceleration Source Code type :: scf_config_t !! Shared SCF settings for HF and DFT methods integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: energy_convergence = 1.0e-8_dp !! Energy convergence threshold (Hartree) real ( dp ) :: density_convergence = 1.0e-6_dp !! Density matrix convergence threshold logical :: use_diis = . true . !! Use DIIS acceleration integer :: diis_size = 8 !! Number of Fock matrices for DIIS end type scf_config_t","tags":"","url":"type/scf_config_t.html"},{"title":"xtb_config_t – metalquicha ","text":"type, public :: xtb_config_t Configuration for semi-empirical xTB methods Inherited by type~~xtb_config_t~~InheritedByGraph type~xtb_config_t xtb_config_t type~method_config_t method_config_t type~method_config_t->type~xtb_config_t xtb Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: accuracy = 0.01_dp Numerical accuracy parameter integer, public :: cpcm_nang = 110 Angular grid points for CPCM real(kind=dp), public :: cpcm_rscale = 1.0_dp Radii scaling for CPCM real(kind=dp), public :: dielectric = -1.0_dp Dielectric constant (-1 = use solvent table) real(kind=dp), public :: electronic_temp = 300.0_dp Electronic temperature in Kelvin (Fermi smearing) character(len=16), public :: solvation_model = '' Solvation model: “alpb”, “gbsa”, “cpcm” character(len=32), public :: solvent = '' Solvent name: “water”, “ethanol”, etc. Empty for gas phase logical, public :: use_cds = .true. Include non-polar CDS terms logical, public :: use_shift = .true. Include solution state shift Type-Bound Procedures procedure, public :: has_solvation => xtb_has_solvation private pure function xtb_has_solvation (this) Check if solvation is configured for XTB Arguments Type Intent Optional Attributes Name class( xtb_config_t ), intent(in) :: this Return Value logical Source Code type :: xtb_config_t !! Configuration for semi-empirical xTB methods real ( dp ) :: accuracy = 0.01_dp !! Numerical accuracy parameter real ( dp ) :: electronic_temp = 30 0.0_dp !! Electronic temperature in Kelvin (Fermi smearing) ! Solvation character ( len = 32 ) :: solvent = '' !! Solvent name: \"water\", \"ethanol\", etc. Empty for gas phase character ( len = 16 ) :: solvation_model = '' !! Solvation model: \"alpb\", \"gbsa\", \"cpcm\" logical :: use_cds = . true . !! Include non-polar CDS terms logical :: use_shift = . true . !! Include solution state shift real ( dp ) :: dielectric = - 1.0_dp !! Dielectric constant (-1 = use solvent table) integer :: cpcm_nang = 110 !! Angular grid points for CPCM real ( dp ) :: cpcm_rscale = 1.0_dp !! Radii scaling for CPCM contains procedure :: has_solvation => xtb_has_solvation end type xtb_config_t","tags":"","url":"type/xtb_config_t.html"},{"title":"xtb_method_t – metalquicha ","text":"type, public, extends( qc_method_t ) :: xtb_method_t Extended Tight-Binding (xTB) method implementation Concrete implementation of the abstract quantum chemistry method\ninterface for GFN1-xTB and GFN2-xTB calculations via tblite. Inherits type~~xtb_method_t~~InheritsGraph type~xtb_method_t xtb_method_t type~qc_method_t qc_method_t type~xtb_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=wp), public :: accuracy = 0.01_wp Numerical accuracy parameter integer, public :: cpcm_nang = 110 Number of angular points for CPCM cavity real(kind=wp), public :: cpcm_rscale = 1.0_wp Radii scaling for CPCM cavity real(kind=wp), public :: dielectric = -1.0_wp Direct dielectric constant (-1 = use solvent lookup) real(kind=wp), public :: kt = 300.0_wp*3.166808578545117e-06_wp Electronic temperature (300 K) character(len=:), public, allocatable :: solvation_model “alpb” (default), “gbsa”, or “cpcm” character(len=:), public, allocatable :: solvent Solvent name: “water”, “ethanol”, etc. logical, public :: use_cds = .true. Include non-polar CDS terms (not for CPCM) logical, public :: use_shift = .true. Include solution state shift (not for CPCM) character(len=:), public, allocatable :: variant XTB variant: “gfn1” or “gfn2” logical, public :: verbose = .false. Print calculation details Type-Bound Procedures procedure, public :: calc_energy => xtb_calc_energy Energy-only calculation private  subroutine xtb_calc_energy (this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_gradient => xtb_calc_gradient Energy + gradient calculation private  subroutine xtb_calc_gradient (this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_hessian => xtb_calc_hessian Placeholder for Hessian calculation private  subroutine xtb_calc_hessian (this, fragment, result) Calculate Hessian using finite differences of gradients Read more… Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code type , extends ( qc_method_t ) :: xtb_method_t !! Extended Tight-Binding (xTB) method implementation !! !! Concrete implementation of the abstract quantum chemistry method !! interface for GFN1-xTB and GFN2-xTB calculations via tblite. character ( len = :), allocatable :: variant !! XTB variant: \"gfn1\" or \"gfn2\" logical :: verbose = . false . !! Print calculation details real ( wp ) :: accuracy = 0.01_wp !! Numerical accuracy parameter real ( wp ) :: kt = 30 0.0_wp * 3.166808578545117e-06_wp !! Electronic temperature (300 K) ! Solvation settings (leave solvent unallocated for gas phase) character ( len = :), allocatable :: solvent !! Solvent name: \"water\", \"ethanol\", etc. character ( len = :), allocatable :: solvation_model !! \"alpb\" (default), \"gbsa\", or \"cpcm\" logical :: use_cds = . true . !! Include non-polar CDS terms (not for CPCM) logical :: use_shift = . true . !! Include solution state shift (not for CPCM) ! CPCM-specific settings real ( wp ) :: dielectric = - 1.0_wp !! Direct dielectric constant (-1 = use solvent lookup) integer :: cpcm_nang = 110 !! Number of angular points for CPCM cavity real ( wp ) :: cpcm_rscale = 1.0_wp !! Radii scaling for CPCM cavity contains procedure :: calc_energy => xtb_calc_energy !! Energy-only calculation procedure :: calc_gradient => xtb_calc_gradient !! Energy + gradient calculation procedure :: calc_hessian => xtb_calc_hessian !! Placeholder for Hessian calculation end type xtb_method_t","tags":"","url":"type/xtb_method_t.html"},{"title":"method_factory_t – metalquicha ","text":"type, public :: method_factory_t Factory for creating quantum chemistry method instances Usage:\n  type(method_factory_t) :: factory\n  type(method_config_t) :: config\n  class(qc_method_t), allocatable :: method config%method_type = METHOD_TYPE_DFT\n  config%basis_set = “cc-pvdz”\n  config%dft%functional = “pbe0”\n  method = factory%create(config) Type-Bound Procedures procedure, public :: create => factory_create private  function factory_create (this, config) result(method) Create a quantum chemistry method instance from configuration Read more… Arguments Type Intent Optional Attributes Name class( method_factory_t ), intent(in) :: this type( method_config_t ), intent(in) :: config Return Value class( qc_method_t ), allocatable Source Code type :: method_factory_t !! Factory for creating quantum chemistry method instances !! !! Usage: !!   type(method_factory_t) :: factory !!   type(method_config_t) :: config !!   class(qc_method_t), allocatable :: method !! !!   config%method_type = METHOD_TYPE_DFT !!   config%basis_set = \"cc-pvdz\" !!   config%dft%functional = \"pbe0\" !!   method = factory%create(config) contains procedure :: create => factory_create end type method_factory_t","tags":"","url":"type/method_factory_t.html"},{"title":"driver_config_t – metalquicha ","text":"type, public :: driver_config_t Inherits type~~driver_config_t~~InheritsGraph type~driver_config_t driver_config_t type~aimd_keywords_t aimd_keywords_t type~driver_config_t->type~aimd_keywords_t aimd type~hessian_keywords_t hessian_keywords_t type~driver_config_t->type~hessian_keywords_t hessian type~scf_keywords_t scf_keywords_t type~driver_config_t->type~scf_keywords_t scf Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( aimd_keywords_t ), public :: aimd AIMD calculation keywords logical, public :: allow_overlapping_fragments = .false. Enable GMBE for overlapping fragments integer(kind=int32), public :: calc_type Calculation type constant integer, public :: cpcm_nang = 110 Number of angular grid points for CPCM real(kind=dp), public :: cpcm_rscale = 1.0_dp Radii scaling factor for CPCM real(kind=dp), public :: dielectric = -1.0_dp Direct dielectric constant (-1 = use solvent lookup) real(kind=dp), public, allocatable :: fragment_cutoffs (:) Distance cutoffs for n-mer screening (Angstrom) type( hessian_keywords_t ), public :: hessian Hessian calculation keywords integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method QC method constant integer, public :: nlevel = 0 Fragmentation level (0 = unfragmented) type( scf_keywords_t ), public :: scf SCF calculation keywords logical, public :: skip_json_output = .false. Skip JSON output for large calculations character(len=:), public, allocatable :: solvation_model “alpb” (default), “gbsa”, or “cpcm” character(len=:), public, allocatable :: solvent Solvent name or empty for gas phase logical, public :: use_cds = .true. Include CDS non-polar terms (not for CPCM) logical, public :: use_shift = .true. Include solution state shift (not for CPCM) Source Code type :: driver_config_t ! Core calculation settings integer ( int32 ) :: method !! QC method constant integer ( int32 ) :: calc_type !! Calculation type constant ! Fragmentation settings integer :: nlevel = 0 !! Fragmentation level (0 = unfragmented) logical :: allow_overlapping_fragments = . false . !! Enable GMBE for overlapping fragments integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) real ( dp ), allocatable :: fragment_cutoffs (:) !! Distance cutoffs for n-mer screening (Angstrom) ! XTB solvation settings character ( len = :), allocatable :: solvent !! Solvent name or empty for gas phase character ( len = :), allocatable :: solvation_model !! \"alpb\" (default), \"gbsa\", or \"cpcm\" logical :: use_cds = . true . !! Include CDS non-polar terms (not for CPCM) logical :: use_shift = . true . !! Include solution state shift (not for CPCM) ! CPCM-specific settings real ( dp ) :: dielectric = - 1.0_dp !! Direct dielectric constant (-1 = use solvent lookup) integer :: cpcm_nang = 110 !! Number of angular grid points for CPCM real ( dp ) :: cpcm_rscale = 1.0_dp !! Radii scaling factor for CPCM ! Calculation-specific keywords (structured) type ( hessian_keywords_t ) :: hessian !! Hessian calculation keywords type ( aimd_keywords_t ) :: aimd !! AIMD calculation keywords type ( scf_keywords_t ) :: scf !! SCF calculation keywords ! Output control logical :: skip_json_output = . false . !! Skip JSON output for large calculations end type driver_config_t","tags":"","url":"type/driver_config_t.html"},{"title":"json_output_data_t – metalquicha ","text":"type, public :: json_output_data_t Unified container for all JSON output data This type consolidates all data needed to write JSON output for any\ncalculation type (unfragmented, MBE, GMBE PIE). The output_mode field\ndetermines which format to use when writing JSON. Inherits type~~json_output_data_t~~InheritsGraph type~json_output_data_t json_output_data_t type~thermochemistry_result_t thermochemistry_result_t type~json_output_data_t->type~thermochemistry_result_t thermo Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: delta_energies (:) MBE delta corrections real(kind=dp), public, allocatable :: dipole (:) (3) real(kind=dp), public, allocatable :: force_constants (:) mdyne/Angstrom integer(kind=int64), public :: fragment_count = 0 real(kind=dp), public, allocatable :: fragment_distances (:) Per-fragment min distances (Angstrom) real(kind=dp), public, allocatable :: fragment_energies (:) Per-fragment total energies real(kind=dp), public, allocatable :: frequencies (:) cm&#94;-1 real(kind=dp), public, allocatable :: gradient (:,:) (3, natoms) logical, public :: has_dipole = .false. logical, public :: has_energy = .false. logical, public :: has_gradient = .false. logical, public :: has_hessian = .false. logical, public :: has_ir_intensities = .false. logical, public :: has_vibrational = .false. real(kind=dp), public, allocatable :: hessian (:,:) (3 natoms, 3 natoms) real(kind=dp), public, allocatable :: ir_intensities (:) km/mol integer, public :: max_level = 0 integer(kind=int64), public :: n_pie_terms = 0 integer, public :: output_mode = OUTPUT_MODE_NONE OUTPUT_MODE_* constant integer, public, allocatable :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_terms) integer, public, allocatable :: pie_coefficients (:) PIE coefficients real(kind=dp), public, allocatable :: pie_energies (:) Per-term energies integer, public, allocatable :: polymers (:,:) Fragment composition (n_fragments, max_level) real(kind=dp), public, allocatable :: reduced_masses (:) amu real(kind=dp), public, allocatable :: sum_by_level (:) Energy sum per level type( thermochemistry_result_t ), public :: thermo real(kind=dp), public :: total_energy = 0.0_dp Type-Bound Procedures procedure, public :: destroy => json_output_data_destroy private  subroutine json_output_data_destroy (this) Clean up all allocated memory Arguments Type Intent Optional Attributes Name class( json_output_data_t ), intent(inout) :: this procedure, public :: reset => json_output_data_reset private  subroutine json_output_data_reset (this) Reset all flags and scalar values to defaults Arguments Type Intent Optional Attributes Name class( json_output_data_t ), intent(inout) :: this Source Code type :: json_output_data_t !! Unified container for all JSON output data !! !! This type consolidates all data needed to write JSON output for any !! calculation type (unfragmented, MBE, GMBE PIE). The output_mode field !! determines which format to use when writing JSON. integer :: output_mode = OUTPUT_MODE_NONE !! OUTPUT_MODE_* constant !----- Common data ----- real ( dp ) :: total_energy = 0.0_dp real ( dp ), allocatable :: gradient (:, :) !! (3, natoms) real ( dp ), allocatable :: hessian (:, :) !! (3*natoms, 3*natoms) real ( dp ), allocatable :: dipole (:) !! (3) logical :: has_energy = . false . logical :: has_gradient = . false . logical :: has_hessian = . false . logical :: has_dipole = . false . !----- Vibrational data (optional) ----- real ( dp ), allocatable :: frequencies (:) !! cm&#94;-1 real ( dp ), allocatable :: reduced_masses (:) !! amu real ( dp ), allocatable :: force_constants (:) !! mdyne/Angstrom real ( dp ), allocatable :: ir_intensities (:) !! km/mol type ( thermochemistry_result_t ) :: thermo logical :: has_vibrational = . false . logical :: has_ir_intensities = . false . !----- MBE-specific data (store ALL fragments for detailed output) ----- integer , allocatable :: polymers (:, :) !! Fragment composition (n_fragments, max_level) real ( dp ), allocatable :: fragment_energies (:) !! Per-fragment total energies real ( dp ), allocatable :: delta_energies (:) !! MBE delta corrections real ( dp ), allocatable :: sum_by_level (:) !! Energy sum per level real ( dp ), allocatable :: fragment_distances (:) !! Per-fragment min distances (Angstrom) integer ( int64 ) :: fragment_count = 0 integer :: max_level = 0 !----- GMBE PIE-specific data ----- integer , allocatable :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_terms) integer , allocatable :: pie_coefficients (:) !! PIE coefficients real ( dp ), allocatable :: pie_energies (:) !! Per-term energies integer ( int64 ) :: n_pie_terms = 0 contains procedure :: destroy => json_output_data_destroy procedure :: reset => json_output_data_reset end type json_output_data_t","tags":"","url":"type/json_output_data_t.html"},{"title":"fragment_lookup_t – metalquicha ","text":"type, public :: fragment_lookup_t Hash-based lookup table for O(1) fragment index retrieval Inherits type~~fragment_lookup_t~~InheritsGraph type~fragment_lookup_t fragment_lookup_t type~hash_entry_t hash_entry_t type~fragment_lookup_t->type~hash_entry_t table type~hash_entry_t->type~hash_entry_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: initialized = .false. integer(kind=int64), public :: n_entries = 0 type( hash_entry_t ), public, allocatable :: table (:) integer, public :: table_size = 0 Type-Bound Procedures procedure, public :: destroy => fragment_lookup_destroy private pure subroutine fragment_lookup_destroy (this) Clean up hash table and all chains Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this procedure, public :: find => fragment_lookup_find private  function fragment_lookup_find (this, monomers, n) result(idx) Find fragment index for given monomer combination Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) procedure, public :: init => fragment_lookup_init private pure subroutine fragment_lookup_init (this, estimated_entries) Initialize hash table with estimated size Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries procedure, public :: insert => fragment_lookup_insert private  subroutine fragment_lookup_insert (this, monomers, n, fragment_idx, error) Insert a monomer combination -> fragment index mapping Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx type( error_t ), intent(out), optional :: error Source Code type :: fragment_lookup_t !! Hash-based lookup table for O(1) fragment index retrieval integer :: table_size = 0 type ( hash_entry_t ), allocatable :: table (:) integer ( int64 ) :: n_entries = 0 logical :: initialized = . false . contains procedure :: init => fragment_lookup_init procedure :: insert => fragment_lookup_insert procedure :: find => fragment_lookup_find procedure :: destroy => fragment_lookup_destroy end type fragment_lookup_t","tags":"","url":"type/fragment_lookup_t.html"},{"title":"hash_entry_t – metalquicha ","text":"type, private :: hash_entry_t Single entry in hash table (private helper type) Inherited by type~~hash_entry_t~~InheritedByGraph type~hash_entry_t hash_entry_t type~hash_entry_t->type~hash_entry_t next type~fragment_lookup_t fragment_lookup_t type~fragment_lookup_t->type~hash_entry_t table Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, allocatable :: key (:) Sorted monomer indices type( hash_entry_t ), public, pointer :: next => null() Chain for collisions integer(kind=int64), public :: value Fragment index Source Code type :: hash_entry_t !! Single entry in hash table (private helper type) integer , allocatable :: key (:) !! Sorted monomer indices integer ( int64 ) :: value !! Fragment index type ( hash_entry_t ), pointer :: next => null () !! Chain for collisions end type hash_entry_t","tags":"","url":"type/hash_entry_t.html"},{"title":"hf_method_t – metalquicha ","text":"type, public, extends( qc_method_t ) :: hf_method_t Hartree-Fock method implementation Inherits type~~hf_method_t~~InheritsGraph type~hf_method_t hf_method_t type~hf_options_t hf_options_t type~hf_method_t->type~hf_options_t options type~qc_method_t qc_method_t type~hf_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( hf_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => hf_calc_energy private  subroutine hf_calc_energy (this, fragment, result) Calculate electronic energy using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_gradient => hf_calc_gradient private  subroutine hf_calc_gradient (this, fragment, result) Calculate energy gradient using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_hessian => null_hessian Placeholder for Hessian calculation private  subroutine null_hessian (this, fragment, result) Placeholder for Hessian calculation Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code type , extends ( qc_method_t ) :: hf_method_t !! Hartree-Fock method implementation type ( hf_options_t ) :: options contains procedure :: calc_energy => hf_calc_energy procedure :: calc_gradient => hf_calc_gradient procedure :: calc_hessian => null_hessian !! Placeholder for Hessian calculation end type hf_method_t","tags":"","url":"type/hf_method_t.html"},{"title":"hf_options_t – metalquicha ","text":"type, public :: hf_options_t Hartree-Fock calculation options Inherited by type~~hf_options_t~~InheritedByGraph type~hf_options_t hf_options_t type~hf_method_t hf_method_t type~hf_method_t->type~hf_options_t options Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=32), public :: basis_set = 'sto-3g' Basis set name real(kind=dp), public :: conv_tol = 1.0e-8_dp Energy convergence threshold real(kind=dp), public :: density_tol = 1.0e-6_dp Density matrix convergence threshold integer, public :: diis_size = 8 Number of Fock matrices for DIIS integer, public :: max_iter = 100 Maximum SCF iterations logical, public :: spherical = .true. Use spherical (true) or Cartesian (false) basis logical, public :: use_diis = .true. Use DIIS acceleration logical, public :: verbose = .false. Print SCF iterations Source Code type :: hf_options_t !! Hartree-Fock calculation options character ( len = 32 ) :: basis_set = 'sto-3g' !! Basis set name logical :: spherical = . true . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . false . !! Print SCF iterations ! SCF settings (from shared scf_config_t) integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: conv_tol = 1.0e-8_dp !! Energy convergence threshold real ( dp ) :: density_tol = 1.0e-6_dp !! Density matrix convergence threshold logical :: use_diis = . true . !! Use DIIS acceleration integer :: diis_size = 8 !! Number of Fock matrices for DIIS end type hf_options_t","tags":"","url":"type/hf_options_t.html"},{"title":"geometry_type – metalquicha ","text":"type, public :: geometry_type Molecular geometry data structure Inherited by type~~geometry_type~~InheritedByGraph type~geometry_type geometry_type type~molecule_t molecule_t type~molecule_t->type~geometry_type geometry type~mqc_config_t mqc_config_t type~mqc_config_t->type~geometry_type geometry type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: comment real(kind=dp), public, allocatable :: coords (:,:) character(len=:), public, allocatable :: elements (:) integer, public :: natoms Type-Bound Procedures procedure, public :: destroy => geometry_destroy private  subroutine geometry_destroy (this) Clean up allocated memory in geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this Source Code type :: geometry_type !! Molecular geometry data structure integer :: natoms character ( len = :), allocatable :: elements (:) real ( dp ), allocatable :: coords (:, :) ! coords(3, natoms) character ( len = :), allocatable :: comment contains procedure :: destroy => geometry_destroy end type geometry_type","tags":"","url":"type/geometry_type.html"},{"title":"basis_file_t – metalquicha ","text":"type, public :: basis_file_t Container for basis set file contents Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: data_section character(len=:), public, allocatable :: full_content Source Code type :: basis_file_t !! Container for basis set file contents character ( len = :), allocatable :: full_content character ( len = :), allocatable :: data_section end type basis_file_t","tags":"","url":"type/basis_file_t.html"},{"title":"cli_args_type – metalquicha ","text":"type, public :: cli_args_type Container for parsed command line arguments Stores file paths and options extracted from command line,\nwith automatic memory management for string allocations. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: basis_name Basis set name (e.g., “6-31G”) character(len=:), public, allocatable :: xyz_file Input XYZ geometry file path Type-Bound Procedures procedure, public :: destroy => cli_args_destroy Memory cleanup private  subroutine cli_args_destroy (this) Clean up CLI args Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this Source Code type :: cli_args_type !! Container for parsed command line arguments !! !! Stores file paths and options extracted from command line, !! with automatic memory management for string allocations. character ( len = :), allocatable :: xyz_file !! Input XYZ geometry file path character ( len = :), allocatable :: basis_name !! Basis set name (e.g., \"6-31G\") contains procedure :: destroy => cli_args_destroy !! Memory cleanup end type cli_args_type","tags":"","url":"type/cli_args_type.html"},{"title":"mcscf_method_t – metalquicha ","text":"type, public, extends( qc_method_t ) :: mcscf_method_t MCSCF/CASSCF method implementation Complete Active Space SCF with optional state-averaging\nand perturbative corrections. Suitable for:\n- Near-degenerate electronic states\n- Bond breaking/formation\n- Transition metal complexes\n- Excited states Inherits type~~mcscf_method_t~~InheritsGraph type~mcscf_method_t mcscf_method_t type~mcscf_options_t mcscf_options_t type~mcscf_method_t->type~mcscf_options_t options type~qc_method_t qc_method_t type~mcscf_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( mcscf_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => mcscf_calc_energy private  subroutine mcscf_calc_energy (this, fragment, result) Calculate electronic energy using CASSCF Read more… Arguments Type Intent Optional Attributes Name class( mcscf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_gradient => mcscf_calc_gradient private  subroutine mcscf_calc_gradient (this, fragment, result) Calculate energy gradient using CASSCF Read more… Arguments Type Intent Optional Attributes Name class( mcscf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_hessian => mcscf_calc_hessian private  subroutine mcscf_calc_hessian (this, fragment, result) Calculate energy Hessian using CASSCF Read more… Arguments Type Intent Optional Attributes Name class( mcscf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code type , extends ( qc_method_t ) :: mcscf_method_t !! MCSCF/CASSCF method implementation !! !! Complete Active Space SCF with optional state-averaging !! and perturbative corrections. Suitable for: !! - Near-degenerate electronic states !! - Bond breaking/formation !! - Transition metal complexes !! - Excited states type ( mcscf_options_t ) :: options contains procedure :: calc_energy => mcscf_calc_energy procedure :: calc_gradient => mcscf_calc_gradient procedure :: calc_hessian => mcscf_calc_hessian end type mcscf_method_t","tags":"","url":"type/mcscf_method_t.html"},{"title":"mcscf_options_t – metalquicha ","text":"type, public :: mcscf_options_t MCSCF/CASSCF calculation options Inherited by type~~mcscf_options_t~~InheritedByGraph type~mcscf_options_t mcscf_options_t type~mcscf_method_t mcscf_method_t type~mcscf_method_t->type~mcscf_options_t options Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=32), public :: basis_set = 'sto-3g' Basis set name real(kind=dp), public :: ci_tol = 1.0e-8_dp CI energy convergence threshold real(kind=dp), public :: energy_tol = 1.0e-8_dp Energy convergence threshold real(kind=dp), public :: imaginary_shift = 0.0_dp Imaginary shift for intruder states real(kind=dp), public :: ipea_shift = 0.25_dp IPEA shift for CASPT2 (Hartree) integer, public :: max_macro_iter = 100 Maximum macro (orbital optimization) iterations integer, public :: max_micro_iter = 50 Maximum CI iterations per macro step integer, public :: n_active_electrons = 0 Number of active electrons (CAS) integer, public :: n_active_orbitals = 0 Number of active orbitals (CAS) integer, public :: n_inactive_orbitals = -1 Number of inactive (doubly occupied) orbitals\n-1 means auto-determine from nelec and active electrons integer, public :: n_states = 1 Number of states for state-averaged CASSCF character(len=16), public :: orbital_optimizer = 'super-ci' Orbital optimizer: “super-ci”, “newton-raphson”, “ah” (augmented Hessian) real(kind=dp), public :: orbital_tol = 1.0e-6_dp Orbital gradient convergence threshold character(len=16), public :: pt2_type = 'nevpt2' PT2 type: “caspt2”, “nevpt2” logical, public :: spherical = .true. Use spherical (true) or Cartesian (false) basis real(kind=dp), public, allocatable :: state_weights (:) Weights for state averaging (must sum to 1) logical, public :: use_pt2 = .false. Apply perturbative correction after CASSCF logical, public :: verbose = .false. Print iteration details Source Code type :: mcscf_options_t !! MCSCF/CASSCF calculation options character ( len = 32 ) :: basis_set = 'sto-3g' !! Basis set name logical :: spherical = . true . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . false . !! Print iteration details ! Active space definition integer :: n_active_electrons = 0 !! Number of active electrons (CAS) integer :: n_active_orbitals = 0 !! Number of active orbitals (CAS) integer :: n_inactive_orbitals = - 1 !! Number of inactive (doubly occupied) orbitals !! -1 means auto-determine from nelec and active electrons ! State-averaging integer :: n_states = 1 !! Number of states for state-averaged CASSCF real ( dp ), allocatable :: state_weights (:) !! Weights for state averaging (must sum to 1) ! Convergence settings integer :: max_macro_iter = 100 !! Maximum macro (orbital optimization) iterations integer :: max_micro_iter = 50 !! Maximum CI iterations per macro step real ( dp ) :: orbital_tol = 1.0e-6_dp !! Orbital gradient convergence threshold real ( dp ) :: energy_tol = 1.0e-8_dp !! Energy convergence threshold real ( dp ) :: ci_tol = 1.0e-8_dp !! CI energy convergence threshold ! Orbital optimization algorithm character ( len = 16 ) :: orbital_optimizer = 'super-ci' !! Orbital optimizer: \"super-ci\", \"newton-raphson\", \"ah\" (augmented Hessian) ! Perturbative corrections logical :: use_pt2 = . false . !! Apply perturbative correction after CASSCF character ( len = 16 ) :: pt2_type = 'nevpt2' !! PT2 type: \"caspt2\", \"nevpt2\" real ( dp ) :: ipea_shift = 0.25_dp !! IPEA shift for CASPT2 (Hartree) real ( dp ) :: imaginary_shift = 0.0_dp !! Imaginary shift for intruder states end type mcscf_options_t","tags":"","url":"type/mcscf_options_t.html"},{"title":"displaced_geometry_t – metalquicha ","text":"type, public :: displaced_geometry_t Container for a single displaced geometry Inherits type~~displaced_geometry_t~~InheritsGraph type~displaced_geometry_t displaced_geometry_t type~physical_fragment_t physical_fragment_t type~displaced_geometry_t->type~physical_fragment_t geometry type~molecular_basis_type molecular_basis_type type~physical_fragment_t->type~molecular_basis_type basis type~atomic_basis_type atomic_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: atom_index Which atom was displaced (1-based) integer, public :: coordinate Which coordinate was displaced (1=x, 2=y, 3=z) integer, public :: direction +1 for forward, -1 for backward real(kind=dp), public :: displacement Displacement magnitude in Bohr type( physical_fragment_t ), public :: geometry The displaced geometry Type-Bound Procedures procedure, public :: destroy => displaced_geometry_destroy private  subroutine displaced_geometry_destroy (this) Clean up memory for displaced geometry Arguments Type Intent Optional Attributes Name class( displaced_geometry_t ), intent(inout) :: this Source Code type :: displaced_geometry_t !! Container for a single displaced geometry integer :: atom_index !! Which atom was displaced (1-based) integer :: coordinate !! Which coordinate was displaced (1=x, 2=y, 3=z) integer :: direction !! +1 for forward, -1 for backward real ( dp ) :: displacement !! Displacement magnitude in Bohr type ( physical_fragment_t ) :: geometry !! The displaced geometry contains procedure :: destroy => displaced_geometry_destroy end type displaced_geometry_t","tags":"","url":"type/displaced_geometry_t.html"},{"title":"error_t – metalquicha ","text":"type, public :: error_t Inherited by type~~error_t~~InheritedByGraph type~error_t error_t type~calculation_result_t calculation_result_t type~calculation_result_t->type~error_t error Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=MAX_LOCATION_LEN), public :: call_stack (MAX_STACK_DEPTH) Call locations integer, public :: code = SUCCESS Error code (0 = no error) character(len=:), public, allocatable :: message Error message Stack trace support integer, public :: stack_depth = 0 Current stack depth Type-Bound Procedures procedure, public :: add_context => error_add_context private pure subroutine error_add_context (this, location) Add a call location to the stack trace\nTypically called when propagating errors upward Read more… Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this character(len=*), intent(in) :: location procedure, public :: clear => error_clear private pure subroutine error_clear (this) Clear the error state and stack trace Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this procedure, public :: get_code => error_get_code private pure function error_get_code (this) result(code) Get the error code Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value integer procedure, public :: get_full_trace => error_get_full_trace private  function error_get_full_trace (this) result(trace) Get complete error message with stack trace\nReturns a multi-line string with error and call stack Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable procedure, public :: get_message => error_get_message private pure function error_get_message (this) result(message) Get the error message (without stack trace) Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable procedure, public :: has_error => error_has_error private pure function error_has_error (this) result(has_err) Check if an error is set Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value logical procedure, public :: print_trace => error_print_trace private  subroutine error_print_trace (this, unit) Print error with stack trace to specified unit\nIf unit not specified, prints to stdout (unit 6) Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this integer, intent(in), optional :: unit procedure, public :: set => error_set private pure subroutine error_set (this, code, message) Set an error with code and message\nResets the stack trace Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this integer, intent(in) :: code character(len=*), intent(in) :: message Source Code type :: error_t integer :: code = SUCCESS !! Error code (0 = no error) character ( len = :), allocatable :: message !! Error message !! Stack trace support integer :: stack_depth = 0 !! Current stack depth character ( len = MAX_LOCATION_LEN ) :: call_stack ( MAX_STACK_DEPTH ) !! Call locations contains procedure :: has_error => error_has_error procedure :: set => error_set procedure :: clear => error_clear procedure :: get_code => error_get_code procedure :: get_message => error_get_message procedure :: add_context => error_add_context procedure :: get_full_trace => error_get_full_trace procedure :: print_trace => error_print_trace end type error_t","tags":"","url":"type/error_t.html"},{"title":"qc_method_t – metalquicha ","text":"type, public, abstract :: qc_method_t Abstract base type for all quantum chemistry methods Defines the required interface for energy and gradient calculations\nthat must be implemented by all concrete method types (XTB, HF, etc.). Inherited by type~~qc_method_t~~InheritedByGraph type~qc_method_t qc_method_t type~dft_method_t dft_method_t type~dft_method_t->type~qc_method_t type~hf_method_t hf_method_t type~hf_method_t->type~qc_method_t type~mcscf_method_t mcscf_method_t type~mcscf_method_t->type~qc_method_t type~xtb_method_t xtb_method_t type~xtb_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( calc_energy_interface ), public, deferred :: calc_energy Energy calculation interface subroutine calc_energy_interface(this, fragment, result) Prototype Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results procedure( calc_gradient_interface ), public, deferred :: calc_gradient Gradient calculation interface subroutine calc_gradient_interface(this, fragment, result) Prototype Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result procedure( calc_hessian_interface ), public, deferred :: calc_hessian Hessian calculation interface subroutine calc_hessian_interface(this, fragment, result) Prototype Interface for energy, gradient, and Hessian calculations Computes electronic energy, nuclear gradients, and Hessian matrix for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Source Code type , abstract :: qc_method_t !! Abstract base type for all quantum chemistry methods !! !! Defines the required interface for energy and gradient calculations !! that must be implemented by all concrete method types (XTB, HF, etc.). contains procedure ( calc_energy_interface ), deferred :: calc_energy !! Energy calculation interface procedure ( calc_gradient_interface ), deferred :: calc_gradient !! Gradient calculation interface procedure ( calc_hessian_interface ), deferred :: calc_hessian !! Hessian calculation interface end type qc_method_t","tags":"","url":"type/qc_method_t.html"},{"title":"mpi_comms_t – metalquicha ","text":"type, public :: mpi_comms_t Container for MPI communicators This type bundles all MPI communicators needed by the application.\nCurrently supports world and node communicators, but can be extended\nto support team-based parallelism patterns. Inherits type~~mpi_comms_t~~InheritsGraph type~mpi_comms_t mpi_comms_t comm_t comm_t type~mpi_comms_t->comm_t world_comm, node_comm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~mpi_comms_t~~InheritedByGraph type~mpi_comms_t mpi_comms_t type~resources_t resources_t type~resources_t->type~mpi_comms_t mpi_comms Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(comm_t), public :: node_comm Node-local communicator type(comm_t), public :: world_comm Global MPI communicator Source Code type :: mpi_comms_t !! Container for MPI communicators !! !! This type bundles all MPI communicators needed by the application. !! Currently supports world and node communicators, but can be extended !! to support team-based parallelism patterns. type ( comm_t ) :: world_comm !! Global MPI communicator type ( comm_t ) :: node_comm !! Node-local communicator ! Future extensions: ! type(comm_t) :: team_comm           !! Intra-team communicator ! type(comm_t) :: team_worker_comm    !! Team workers (excluding leader) ! type(comm_t) :: inter_team_comm     !! Cross-team communicator ! type(comm_t) :: team_leaders_comm   !! Team leaders only end type mpi_comms_t","tags":"","url":"type/mpi_comms_t.html"},{"title":"calculation_result_t – metalquicha ","text":"type, public :: calculation_result_t Container for quantum chemistry calculation results Stores computed quantities from QC calculations with flags\nindicating which properties have been computed. Inherits type~~calculation_result_t~~InheritsGraph type~calculation_result_t calculation_result_t type~energy_t energy_t type~calculation_result_t->type~energy_t energy type~error_t error_t type~calculation_result_t->type~error_t error type~cc_energy_t cc_energy_t type~energy_t->type~cc_energy_t cc type~mp2_energy_t mp2_energy_t type~energy_t->type~mp2_energy_t mp2 Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dipole (:) Dipole moment vector (3) (Debye) real(kind=dp), public, allocatable :: dipole_derivatives (:,:) Dipole derivatives (3, 3N) in a.u. for IR intensities real(kind=dp), public :: distance = 0.0_dp Minimal atomic distance between monomers (Angstrom, 0 for monomers) type( energy_t ), public :: energy Energy components (Hartree) type( error_t ), public :: error Calculation error (if any) real(kind=dp), public, allocatable :: gradient (:,:) Energy gradient (3, natoms) (Hartree/Bohr) logical, public :: has_dipole = .false. Dipole moment has been computed logical, public :: has_dipole_derivatives = .false. Dipole derivatives have been computed logical, public :: has_energy = .false. Energy has been computed logical, public :: has_error = .false. True if calculation failed logical, public :: has_gradient = .false. Gradient has been computed logical, public :: has_hessian = .false. Hessian has been computed logical, public :: has_sigma = .false. Stress tensor has been computed real(kind=dp), public, allocatable :: hessian (:,:) Energy hessian (future implementation) real(kind=dp), public, allocatable :: sigma (:,:) Stress tensor (3,3) (Hartree/Bohr&#94;3) Type-Bound Procedures procedure, public :: destroy => result_destroy Clean up allocated memory private  subroutine result_destroy (this) Clean up allocated memory in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this procedure, public :: reset => result_reset Reset all values and flags private  subroutine result_reset (this) Reset all values and flags in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Source Code type :: calculation_result_t !! Container for quantum chemistry calculation results !! !! Stores computed quantities from QC calculations with flags !! indicating which properties have been computed. type ( energy_t ) :: energy !! Energy components (Hartree) real ( dp ), allocatable :: gradient (:, :) !! Energy gradient (3, natoms) (Hartree/Bohr) real ( dp ), allocatable :: sigma (:, :) !! Stress tensor (3,3) (Hartree/Bohr&#94;3) real ( dp ), allocatable :: hessian (:, :) !! Energy hessian (future implementation) real ( dp ), allocatable :: dipole (:) !! Dipole moment vector (3) (Debye) real ( dp ), allocatable :: dipole_derivatives (:, :) !! Dipole derivatives (3, 3N) in a.u. for IR intensities ! Fragment metadata real ( dp ) :: distance = 0.0_dp !! Minimal atomic distance between monomers (Angstrom, 0 for monomers) ! Computation status flags logical :: has_energy = . false . !! Energy has been computed logical :: has_gradient = . false . !! Gradient has been computed logical :: has_sigma = . false . !! Stress tensor has been computed logical :: has_hessian = . false . !! Hessian has been computed logical :: has_dipole = . false . !! Dipole moment has been computed logical :: has_dipole_derivatives = . false . !! Dipole derivatives have been computed ! Error handling type ( error_t ) :: error !! Calculation error (if any) logical :: has_error = . false . !! True if calculation failed contains procedure :: destroy => result_destroy !! Clean up allocated memory procedure :: reset => result_reset !! Reset all values and flags end type calculation_result_t","tags":"","url":"type/calculation_result_t.html"},{"title":"cc_energy_t – metalquicha ","text":"type, public :: cc_energy_t Container for coupled cluster energy components Inherited by type~~cc_energy_t~~InheritedByGraph type~cc_energy_t cc_energy_t type~energy_t energy_t type~energy_t->type~cc_energy_t cc type~calculation_result_t calculation_result_t type~calculation_result_t->type~energy_t energy Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: doubles = 0.0_dp Doubles contribution (Hartree) real(kind=dp), public :: singles = 0.0_dp Singles contribution (Hartree) real(kind=dp), public :: triples = 0.0_dp Triples contribution (Hartree) Type-Bound Procedures procedure, public :: check_stability => cc_check_stability Check for positive energies (instability) private  subroutine cc_check_stability (this) Check for positive CC correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this procedure, public :: reset => cc_reset Reset all components to zero private  subroutine cc_reset (this) Reset all CC components to zero Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(inout) :: this procedure, public :: total => cc_total Compute total CC correlation private pure function cc_total (this) result(total) Compute total CC correlation energy Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code type :: cc_energy_t !! Container for coupled cluster energy components real ( dp ) :: singles = 0.0_dp !! Singles contribution (Hartree) real ( dp ) :: doubles = 0.0_dp !! Doubles contribution (Hartree) real ( dp ) :: triples = 0.0_dp !! Triples contribution (Hartree) contains procedure :: total => cc_total !! Compute total CC correlation procedure :: reset => cc_reset !! Reset all components to zero procedure :: check_stability => cc_check_stability !! Check for positive energies (instability) end type cc_energy_t","tags":"","url":"type/cc_energy_t.html"},{"title":"energy_t – metalquicha ","text":"type, public :: energy_t Container for quantum chemistry energy components Stores energy contributions from different levels of theory.\nTotal energy is computed as: scf + mp2%total() + cc%total() Inherits type~~energy_t~~InheritsGraph type~energy_t energy_t type~cc_energy_t cc_energy_t type~energy_t->type~cc_energy_t cc type~mp2_energy_t mp2_energy_t type~energy_t->type~mp2_energy_t mp2 Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~energy_t~~InheritedByGraph type~energy_t energy_t type~calculation_result_t calculation_result_t type~calculation_result_t->type~energy_t energy Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( cc_energy_t ), public :: cc Coupled cluster correlation components type( mp2_energy_t ), public :: mp2 MP2 correlation components real(kind=dp), public :: scf = 0.0_dp SCF/HF reference energy (Hartree) Type-Bound Procedures procedure, public :: reset => energy_reset Reset all components to zero private  subroutine energy_reset (this) Reset all energy components to zero Arguments Type Intent Optional Attributes Name class( energy_t ), intent(inout) :: this procedure, public :: total => energy_total Compute total energy from components private pure function energy_total (this) result(total) Compute total energy from all components Arguments Type Intent Optional Attributes Name class( energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code type :: energy_t !! Container for quantum chemistry energy components !! !! Stores energy contributions from different levels of theory. !! Total energy is computed as: scf + mp2%total() + cc%total() real ( dp ) :: scf = 0.0_dp !! SCF/HF reference energy (Hartree) type ( mp2_energy_t ) :: mp2 !! MP2 correlation components type ( cc_energy_t ) :: cc !! Coupled cluster correlation components ! add more as needed, also need to modify the total energy function contains procedure :: total => energy_total !! Compute total energy from components procedure :: reset => energy_reset !! Reset all components to zero end type energy_t","tags":"","url":"type/energy_t.html"},{"title":"mbe_result_t – metalquicha ","text":"type, public :: mbe_result_t Container for Many-Body Expansion aggregated results Stores total properties computed via MBE: energy, gradient, hessian, dipole.\nCaller allocates desired components before calling compute_mbe; the function\nuses allocated() to determine what to compute and sets has_* flags on success. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dipole (:) Total dipole moment (3) (e*Bohr) real(kind=dp), public, allocatable :: dipole_derivatives (:,:) Dipole derivatives (3, 3*natoms) for IR intensities real(kind=dp), public, allocatable :: gradient (:,:) Total gradient (3, total_atoms) (Hartree/Bohr) logical, public :: has_dipole = .false. Dipole has been computed logical, public :: has_dipole_derivatives = .false. Dipole derivatives have been computed logical, public :: has_energy = .false. Energy has been computed logical, public :: has_gradient = .false. Gradient has been computed logical, public :: has_hessian = .false. Hessian has been computed real(kind=dp), public, allocatable :: hessian (:,:) Total Hessian (3 natoms, 3 natoms) real(kind=dp), public :: total_energy = 0.0_dp Total MBE energy (Hartree) Type-Bound Procedures procedure, public :: allocate_dipole => mbe_result_allocate_dipole private  subroutine mbe_result_allocate_dipole (this) Allocate dipole array (always 3 components) Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this procedure, public :: allocate_gradient => mbe_result_allocate_gradient private  subroutine mbe_result_allocate_gradient (this, total_atoms) Allocate gradient array for total_atoms Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this integer, intent(in) :: total_atoms procedure, public :: allocate_hessian => mbe_result_allocate_hessian private  subroutine mbe_result_allocate_hessian (this, total_atoms) Allocate hessian array for total_atoms Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this integer, intent(in) :: total_atoms procedure, public :: destroy => mbe_result_destroy Clean up allocated memory private  subroutine mbe_result_destroy (this) Clean up allocated memory in mbe_result_t Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this procedure, public :: reset => mbe_result_reset Reset all values and flags private  subroutine mbe_result_reset (this) Reset all values and flags in mbe_result_t Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this Source Code type :: mbe_result_t !! Container for Many-Body Expansion aggregated results !! !! Stores total properties computed via MBE: energy, gradient, hessian, dipole. !! Caller allocates desired components before calling compute_mbe; the function !! uses allocated() to determine what to compute and sets has_* flags on success. real ( dp ) :: total_energy = 0.0_dp !! Total MBE energy (Hartree) real ( dp ), allocatable :: gradient (:, :) !! Total gradient (3, total_atoms) (Hartree/Bohr) real ( dp ), allocatable :: hessian (:, :) !! Total Hessian (3*natoms, 3*natoms) real ( dp ), allocatable :: dipole (:) !! Total dipole moment (3) (e*Bohr) real ( dp ), allocatable :: dipole_derivatives (:, :) !! Dipole derivatives (3, 3*natoms) for IR intensities ! Computation status flags logical :: has_energy = . false . !! Energy has been computed logical :: has_gradient = . false . !! Gradient has been computed logical :: has_hessian = . false . !! Hessian has been computed logical :: has_dipole = . false . !! Dipole has been computed logical :: has_dipole_derivatives = . false . !! Dipole derivatives have been computed contains procedure :: destroy => mbe_result_destroy !! Clean up allocated memory procedure :: reset => mbe_result_reset !! Reset all values and flags procedure :: allocate_gradient => mbe_result_allocate_gradient procedure :: allocate_hessian => mbe_result_allocate_hessian procedure :: allocate_dipole => mbe_result_allocate_dipole end type mbe_result_t","tags":"","url":"type/mbe_result_t.html"},{"title":"mp2_energy_t – metalquicha ","text":"type, public :: mp2_energy_t Container for MP2 energy components (SS/OS) Inherited by type~~mp2_energy_t~~InheritedByGraph type~mp2_energy_t mp2_energy_t type~energy_t energy_t type~energy_t->type~mp2_energy_t mp2 type~calculation_result_t calculation_result_t type~calculation_result_t->type~energy_t energy Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: os = 0.0_dp Opposite-spin correlation energy (Hartree) real(kind=dp), public :: ss = 0.0_dp Same-spin correlation energy (Hartree) Type-Bound Procedures procedure, public :: check_stability => mp2_check_stability Check for positive energies (instability) private  subroutine mp2_check_stability (this) Check for positive MP2 correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this procedure, public :: reset => mp2_reset Reset both components to zero private  subroutine mp2_reset (this) Reset both MP2 components to zero Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(inout) :: this procedure, public :: scs => mp2_scs Compute SCS-MP2 correlation private pure function mp2_scs (this) result(scs_energy) Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy\nSCS-MP2 uses: E_SCS = (1/3) E_SS + 1.2 E_OS Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) procedure, public :: total => mp2_total Compute total MP2 correlation private pure function mp2_total (this) result(total) Compute total MP2 correlation energy Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code type :: mp2_energy_t !! Container for MP2 energy components (SS/OS) real ( dp ) :: ss = 0.0_dp !! Same-spin correlation energy (Hartree) real ( dp ) :: os = 0.0_dp !! Opposite-spin correlation energy (Hartree) contains procedure :: total => mp2_total !! Compute total MP2 correlation procedure :: scs => mp2_scs !! Compute SCS-MP2 correlation procedure :: reset => mp2_reset !! Reset both components to zero procedure :: check_stability => mp2_check_stability !! Check for positive energies (instability) end type mp2_energy_t","tags":"","url":"type/mp2_energy_t.html"},{"title":"bond_t – metalquicha ","text":"type, public :: bond_t Bond definition with atom indices, order, and broken status Inherited by type~~bond_t~~InheritedByGraph type~bond_t bond_t type~molecule_t molecule_t type~molecule_t->type~bond_t bonds type~mqc_config_t mqc_config_t type~mqc_config_t->type~bond_t bonds type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: atom_i = 0 integer, public :: atom_j = 0 logical, public :: is_broken = .false. integer, public :: order = 1 Source Code type :: bond_t !! Bond definition with atom indices, order, and broken status integer :: atom_i = 0 integer :: atom_j = 0 integer :: order = 1 logical :: is_broken = . false . end type bond_t","tags":"","url":"type/bond_t.html"},{"title":"input_fragment_t – metalquicha ","text":"type, public :: input_fragment_t Input fragment definition with charge, multiplicity, and atom indices\nThis is the parsed representation from the input file, not the computational fragment Inherited by type~~input_fragment_t~~InheritedByGraph type~input_fragment_t input_fragment_t type~molecule_t molecule_t type~molecule_t->type~input_fragment_t fragments type~mqc_config_t mqc_config_t type~mqc_config_t->type~input_fragment_t fragments type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: charge = 0 integer, public, allocatable :: indices (:) Atom indices in this fragment integer, public :: multiplicity = 1 Type-Bound Procedures procedure, public :: destroy => input_fragment_destroy private  subroutine input_fragment_destroy (this) Clean up allocated memory in input_fragment_t Arguments Type Intent Optional Attributes Name class( input_fragment_t ), intent(inout) :: this Source Code type :: input_fragment_t !! Input fragment definition with charge, multiplicity, and atom indices !! This is the parsed representation from the input file, not the computational fragment integer :: charge = 0 integer :: multiplicity = 1 integer , allocatable :: indices (:) !! Atom indices in this fragment contains procedure :: destroy => input_fragment_destroy end type input_fragment_t","tags":"","url":"type/input_fragment_t.html"},{"title":"molecule_t – metalquicha ","text":"type, public :: molecule_t Single molecule definition with structure, geometry, fragments, and connectivity Inherits type~~molecule_t~~InheritsGraph type~molecule_t molecule_t type~bond_t bond_t type~molecule_t->type~bond_t bonds type~geometry_type geometry_type type~molecule_t->type~geometry_type geometry type~input_fragment_t input_fragment_t type~molecule_t->type~input_fragment_t fragments Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~molecule_t~~InheritedByGraph type~molecule_t molecule_t type~mqc_config_t mqc_config_t type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( bond_t ), public, allocatable :: bonds (:) integer, public :: charge = 0 type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry integer, public :: multiplicity = 1 character(len=:), public, allocatable :: name Optional molecule name integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 Type-Bound Procedures procedure, public :: destroy => molecule_destroy private  subroutine molecule_destroy (this) Clean up allocated memory in molecule_t Arguments Type Intent Optional Attributes Name class( molecule_t ), intent(inout) :: this Source Code type :: molecule_t !! Single molecule definition with structure, geometry, fragments, and connectivity character ( len = :), allocatable :: name !! Optional molecule name ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) contains procedure :: destroy => molecule_destroy end type molecule_t","tags":"","url":"type/molecule_t.html"},{"title":"mqc_config_t – metalquicha ","text":"type, public :: mqc_config_t Complete configuration from .mqc file Inherits type~~mqc_config_t~~InheritsGraph type~mqc_config_t mqc_config_t type~bond_t bond_t type~mqc_config_t->type~bond_t bonds type~geometry_type geometry_type type~mqc_config_t->type~geometry_type geometry type~input_fragment_t input_fragment_t type~mqc_config_t->type~input_fragment_t fragments type~molecule_t molecule_t type~mqc_config_t->type~molecule_t molecules type~molecule_t->type~bond_t bonds type~molecule_t->type~geometry_type geometry type~molecule_t->type~input_fragment_t fragments Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: aimd_dt = 1.0_dp Timestep (femtoseconds) real(kind=dp), public :: aimd_initial_temperature = 300.0_dp Initial temperature for velocity init (K) integer, public :: aimd_nsteps = 0 Number of MD steps (0 = no AIMD) integer, public :: aimd_output_frequency = 1 Write output every N steps logical, public :: allow_overlapping_fragments = .false. character(len=:), public, allocatable :: aux_basis character(len=:), public, allocatable :: basis type( bond_t ), public, allocatable :: bonds (:) integer(kind=int32), public :: calc_type = CALC_TYPE_ENERGY integer, public :: charge = 0 integer, public :: cpcm_nang = 110 Number of angular grid points for CPCM cavity real(kind=dp), public :: cpcm_rscale = 1.0_dp Radii scaling factor for CPCM cavity character(len=:), public, allocatable :: cutoff_method real(kind=dp), public :: dielectric = -1.0_dp Direct dielectric constant (-1 = use solvent lookup) character(len=:), public, allocatable :: distance_metric character(len=:), public, allocatable :: embedding integer, public :: frag_level = 1 character(len=:), public, allocatable :: frag_method MBE, etc. real(kind=dp), public, allocatable :: fragment_cutoffs (:) Distance cutoffs indexed by n-mer level (2=dimer, 3=trimer, etc.) type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry real(kind=dp), public :: hessian_displacement = 0.001_dp Finite difference displacement (Bohr) real(kind=dp), public :: hessian_pressure = 1.0_dp Pressure for thermochemistry (atm) real(kind=dp), public :: hessian_temperature = 298.15_dp Temperature for thermochemistry (K) integer, public :: index_base = 0 0-based or 1-based indexing character(len=:), public, allocatable :: log_level integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method = METHOD_TYPE_GFN2 type( molecule_t ), public, allocatable :: molecules (:) Array of molecules (if nmol > 0) integer, public :: multiplicity = 1 integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 integer, public :: nmol = 0 Number of molecules (0 = single molecule mode for backward compatibility) integer, public :: scf_maxiter = 300 real(kind=dp), public :: scf_tolerance = 1.0e-6_dp character(len=:), public, allocatable :: schema_name character(len=:), public, allocatable :: schema_version logical, public :: skip_json_output = .false. Skip JSON output for large calculations character(len=:), public, allocatable :: solvation_model Solvation model: “alpb” (default), “gbsa”, or “cpcm” character(len=:), public, allocatable :: solvent Solvent name (e.g., “water”, “ethanol”) or empty for gas phase character(len=:), public, allocatable :: units angstrom or bohr logical, public :: use_cds = .true. Include non-polar CDS terms in solvation (not for CPCM) logical, public :: use_shift = .true. Include solution state shift in solvation (not for CPCM) Type-Bound Procedures procedure, public :: destroy => config_destroy private  subroutine config_destroy (this) Clean up allocated memory in mqc_config_t Arguments Type Intent Optional Attributes Name class( mqc_config_t ), intent(inout) :: this Source Code type :: mqc_config_t !! Complete configuration from .mqc file ! Schema information character ( len = :), allocatable :: schema_name character ( len = :), allocatable :: schema_version integer :: index_base = 0 !! 0-based or 1-based indexing character ( len = :), allocatable :: units !! angstrom or bohr ! Model information integer ( int32 ) :: method = METHOD_TYPE_GFN2 character ( len = :), allocatable :: basis character ( len = :), allocatable :: aux_basis ! XTB solvation settings character ( len = :), allocatable :: solvent !! Solvent name (e.g., \"water\", \"ethanol\") or empty for gas phase character ( len = :), allocatable :: solvation_model !! Solvation model: \"alpb\" (default), \"gbsa\", or \"cpcm\" logical :: use_cds = . true . !! Include non-polar CDS terms in solvation (not for CPCM) logical :: use_shift = . true . !! Include solution state shift in solvation (not for CPCM) ! CPCM-specific settings real ( dp ) :: dielectric = - 1.0_dp !! Direct dielectric constant (-1 = use solvent lookup) integer :: cpcm_nang = 110 !! Number of angular grid points for CPCM cavity real ( dp ) :: cpcm_rscale = 1.0_dp !! Radii scaling factor for CPCM cavity ! Driver information integer ( int32 ) :: calc_type = CALC_TYPE_ENERGY ! Multiple molecules support integer :: nmol = 0 !! Number of molecules (0 = single molecule mode for backward compatibility) type ( molecule_t ), allocatable :: molecules (:) !! Array of molecules (if nmol > 0) ! Single molecule fields (backward compatibility - used if nmol == 0) ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) ! SCF settings integer :: scf_maxiter = 300 real ( dp ) :: scf_tolerance = 1.0e-6_dp ! Hessian settings real ( dp ) :: hessian_displacement = 0.001_dp !! Finite difference displacement (Bohr) real ( dp ) :: hessian_temperature = 29 8.15_dp !! Temperature for thermochemistry (K) real ( dp ) :: hessian_pressure = 1.0_dp !! Pressure for thermochemistry (atm) ! AIMD settings real ( dp ) :: aimd_dt = 1.0_dp !! Timestep (femtoseconds) integer :: aimd_nsteps = 0 !! Number of MD steps (0 = no AIMD) real ( dp ) :: aimd_initial_temperature = 30 0.0_dp !! Initial temperature for velocity init (K) integer :: aimd_output_frequency = 1 !! Write output every N steps ! Fragmentation settings character ( len = :), allocatable :: frag_method !! MBE, etc. integer :: frag_level = 1 logical :: allow_overlapping_fragments = . false . integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) character ( len = :), allocatable :: embedding character ( len = :), allocatable :: cutoff_method character ( len = :), allocatable :: distance_metric real ( dp ), allocatable :: fragment_cutoffs (:) !! Distance cutoffs indexed by n-mer level (2=dimer, 3=trimer, etc.) ! Logger settings (kept for compatibility) character ( len = :), allocatable :: log_level ! Output control logical :: skip_json_output = . false . !! Skip JSON output for large calculations contains procedure :: destroy => config_destroy end type mqc_config_t","tags":"","url":"type/mqc_config_t.html"},{"title":"thermochemistry_result_t – metalquicha ","text":"type, public :: thermochemistry_result_t Container for thermochemistry calculation results Inherited by type~~thermochemistry_result_t~~InheritedByGraph type~thermochemistry_result_t thermochemistry_result_t type~json_output_data_t json_output_data_t type~json_output_data_t->type~thermochemistry_result_t thermo Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: Cv_rot = 0.0_dp Rotational heat capacity real(kind=dp), public :: Cv_trans = 0.0_dp Translational heat capacity real(kind=dp), public :: Cv_vib = 0.0_dp Vibrational heat capacity real(kind=dp), public :: E_elec = 0.0_dp Electronic thermal energy (always 0) real(kind=dp), public :: E_rot = 0.0_dp Rotational thermal energy real(kind=dp), public :: E_trans = 0.0_dp Translational thermal energy real(kind=dp), public :: E_vib = 0.0_dp Vibrational thermal energy (excluding ZPE) real(kind=dp), public :: S_elec = 0.0_dp Electronic entropy real(kind=dp), public :: S_rot = 0.0_dp Rotational entropy real(kind=dp), public :: S_trans = 0.0_dp Translational entropy real(kind=dp), public :: S_vib = 0.0_dp Vibrational entropy logical, public :: is_linear = .false. True if molecule is linear real(kind=dp), public :: moments (3) = 0.0_dp Principal moments of inertia in amu*Angstrom&#94;2 integer, public :: n_imag_freqs = 0 Number of imaginary frequencies (skipped) integer, public :: n_real_freqs = 0 Number of real vibrational frequencies real(kind=dp), public :: pressure = DEFAULT_PRESSURE Pressure in atm real(kind=dp), public :: q_rot = 0.0_dp Rotational partition function real(kind=dp), public :: q_trans = 0.0_dp Translational partition function real(kind=dp), public :: q_vib = 1.0_dp Vibrational partition function real(kind=dp), public :: rot_const (3) = 0.0_dp Rotational constants in GHz integer, public :: spin_multiplicity = DEFAULT_SPIN_MULTIPLICITY Electronic spin multiplicity integer, public :: symmetry_number = DEFAULT_SYMMETRY_NUMBER Rotational symmetry number real(kind=dp), public :: temperature = DEFAULT_TEMPERATURE Temperature in K real(kind=dp), public :: thermal_correction_energy = 0.0_dp E_tot = ZPE + E_trans + E_rot + E_vib real(kind=dp), public :: thermal_correction_enthalpy = 0.0_dp H = E_tot + RT real(kind=dp), public :: thermal_correction_gibbs = 0.0_dp G = H - TS real(kind=dp), public :: total_mass = 0.0_dp Total mass in amu real(kind=dp), public :: zpe_hartree = 0.0_dp ZPE in Hartree real(kind=dp), public :: zpe_kcalmol = 0.0_dp ZPE in kcal/mol Source Code type :: thermochemistry_result_t !! Container for thermochemistry calculation results real ( dp ) :: temperature = DEFAULT_TEMPERATURE !! Temperature in K real ( dp ) :: pressure = DEFAULT_PRESSURE !! Pressure in atm integer :: symmetry_number = DEFAULT_SYMMETRY_NUMBER !! Rotational symmetry number integer :: spin_multiplicity = DEFAULT_SPIN_MULTIPLICITY !! Electronic spin multiplicity logical :: is_linear = . false . !! True if molecule is linear ! Molecular properties real ( dp ) :: total_mass = 0.0_dp !! Total mass in amu real ( dp ) :: moments ( 3 ) = 0.0_dp !! Principal moments of inertia in amu*Angstrom&#94;2 real ( dp ) :: rot_const ( 3 ) = 0.0_dp !! Rotational constants in GHz ! Zero-point energy real ( dp ) :: zpe_hartree = 0.0_dp !! ZPE in Hartree real ( dp ) :: zpe_kcalmol = 0.0_dp !! ZPE in kcal/mol ! Thermal energy contributions (Hartree) real ( dp ) :: E_trans = 0.0_dp !! Translational thermal energy real ( dp ) :: E_rot = 0.0_dp !! Rotational thermal energy real ( dp ) :: E_vib = 0.0_dp !! Vibrational thermal energy (excluding ZPE) real ( dp ) :: E_elec = 0.0_dp !! Electronic thermal energy (always 0) ! Entropy contributions (cal/(mol*K)) real ( dp ) :: S_trans = 0.0_dp !! Translational entropy real ( dp ) :: S_rot = 0.0_dp !! Rotational entropy real ( dp ) :: S_vib = 0.0_dp !! Vibrational entropy real ( dp ) :: S_elec = 0.0_dp !! Electronic entropy ! Heat capacity contributions (cal/(mol*K)) real ( dp ) :: Cv_trans = 0.0_dp !! Translational heat capacity real ( dp ) :: Cv_rot = 0.0_dp !! Rotational heat capacity real ( dp ) :: Cv_vib = 0.0_dp !! Vibrational heat capacity ! Summary quantities (Hartree) real ( dp ) :: thermal_correction_energy = 0.0_dp !! E_tot = ZPE + E_trans + E_rot + E_vib real ( dp ) :: thermal_correction_enthalpy = 0.0_dp !! H = E_tot + RT real ( dp ) :: thermal_correction_gibbs = 0.0_dp !! G = H - TS ! Partition functions real ( dp ) :: q_trans = 0.0_dp !! Translational partition function real ( dp ) :: q_rot = 0.0_dp !! Rotational partition function real ( dp ) :: q_vib = 1.0_dp !! Vibrational partition function ! Counts integer :: n_real_freqs = 0 !! Number of real vibrational frequencies integer :: n_imag_freqs = 0 !! Number of imaginary frequencies (skipped) end type thermochemistry_result_t","tags":"","url":"type/thermochemistry_result_t.html"},{"title":"aimd_keywords_t – metalquicha ","text":"type, public :: aimd_keywords_t Ab initio molecular dynamics keywords Inherited by type~~aimd_keywords_t~~InheritedByGraph type~aimd_keywords_t aimd_keywords_t type~driver_config_t driver_config_t type~driver_config_t->type~aimd_keywords_t aimd Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: dt = 1.0_dp Timestep (femtoseconds) real(kind=dp), public :: initial_temperature = 300.0_dp Initial temperature for velocity init (K) integer, public :: nsteps = 0 Number of MD steps (0 = no AIMD) integer, public :: output_frequency = 1 Write output every N steps Source Code type :: aimd_keywords_t !! Ab initio molecular dynamics keywords real ( dp ) :: dt = 1.0_dp !! Timestep (femtoseconds) integer :: nsteps = 0 !! Number of MD steps (0 = no AIMD) real ( dp ) :: initial_temperature = 30 0.0_dp !! Initial temperature for velocity init (K) integer :: output_frequency = 1 !! Write output every N steps end type aimd_keywords_t","tags":"","url":"type/aimd_keywords_t.html"},{"title":"hessian_keywords_t – metalquicha ","text":"type, public :: hessian_keywords_t Hessian calculation keywords Inherited by type~~hessian_keywords_t~~InheritedByGraph type~hessian_keywords_t hessian_keywords_t type~driver_config_t driver_config_t type~driver_config_t->type~hessian_keywords_t hessian Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: displacement = 0.001_dp Finite difference displacement (Bohr) real(kind=dp), public :: pressure = 1.0_dp Pressure for thermochemistry (atm) real(kind=dp), public :: temperature = 298.15_dp Temperature for thermochemistry (K) Source Code type :: hessian_keywords_t !! Hessian calculation keywords real ( dp ) :: displacement = 0.001_dp !! Finite difference displacement (Bohr) real ( dp ) :: temperature = 29 8.15_dp !! Temperature for thermochemistry (K) real ( dp ) :: pressure = 1.0_dp !! Pressure for thermochemistry (atm) end type hessian_keywords_t","tags":"","url":"type/hessian_keywords_t.html"},{"title":"scf_keywords_t – metalquicha ","text":"type, public :: scf_keywords_t SCF calculation keywords (placeholder for future use) Inherited by type~~scf_keywords_t~~InheritedByGraph type~scf_keywords_t scf_keywords_t type~driver_config_t driver_config_t type~driver_config_t->type~scf_keywords_t scf Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: convergence_threshold = 1.0e-6_dp Convergence threshold for SCF integer, public :: max_iterations = 100 Maximum SCF iterations logical, public :: use_diis = .true. Use DIIS acceleration Source Code type :: scf_keywords_t !! SCF calculation keywords (placeholder for future use) logical :: use_diis = . true . !! Use DIIS acceleration integer :: max_iterations = 100 !! Maximum SCF iterations real ( dp ) :: convergence_threshold = 1.0e-6_dp !! Convergence threshold for SCF end type scf_keywords_t","tags":"","url":"type/scf_keywords_t.html"},{"title":"atomic_basis_type – metalquicha ","text":"type, public :: atomic_basis_type Atomic basis set data structure Inherits type~~atomic_basis_type~~InheritsGraph type~atomic_basis_type atomic_basis_type type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~atomic_basis_type~~InheritedByGraph type~atomic_basis_type atomic_basis_type type~molecular_basis_type molecular_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: element element symbol integer, public :: nshells number of shells in type type( cgto_type ), public, allocatable :: shells (:) array of contracted shells Type-Bound Procedures procedure, public :: allocate_shells => allocate_basis_shells private pure subroutine allocate_basis_shells (self, nshells) Allocate array of shells in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells procedure, public :: destroy => atomic_basis_destroy private pure subroutine atomic_basis_destroy (self) Clean up allocated memory in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self procedure, public :: num_basis_functions => atomic_basis_num_basis_functions private pure function atomic_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for an atom Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer Source Code type :: atomic_basis_type !! Atomic basis set data structure character ( len = :), allocatable :: element !! element symbol type ( cgto_type ), allocatable :: shells (:) !! array of contracted shells integer :: nshells !! number of shells in type contains procedure :: allocate_shells => allocate_basis_shells procedure :: destroy => atomic_basis_destroy procedure :: num_basis_functions => atomic_basis_num_basis_functions end type atomic_basis_type","tags":"","url":"type/atomic_basis_type.html"},{"title":"cgto_type – metalquicha ","text":"type, public :: cgto_type Contracted Gaussian type orbital (CGTO) data structure Inherited by type~~cgto_type~~InheritedByGraph type~cgto_type cgto_type type~atomic_basis_type atomic_basis_type type~atomic_basis_type->type~cgto_type shells type~molecular_basis_type molecular_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: ang_mom Angular momentum quantum number (0=s, 1=p, 2=d, etc.) real(kind=dp), public, allocatable :: coefficients (:) Contraction coefficients real(kind=dp), public, allocatable :: exponents (:) Exponents (alpha values) integer, public :: nfunc Number of primitive Gaussians in the contraction Type-Bound Procedures procedure, public :: allocate_arrays => cgto_allocate_arrays private pure subroutine cgto_allocate_arrays (self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc procedure, public :: destroy => cgto_destroy private pure subroutine cgto_destroy (self) Clean up allocated memory in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self procedure, public :: num_basis_functions => cgto_num_basis_functions private pure function cgto_num_basis_functions (self) result(nbf) Get number of basis functions in a shell (Cartesian) Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer Source Code type :: cgto_type !! Contracted Gaussian type orbital (CGTO) data structure integer :: ang_mom !! Angular momentum quantum number (0=s, 1=p, 2=d, etc.) integer :: nfunc !! Number of primitive Gaussians in the contraction real ( dp ), allocatable :: exponents (:) !! Exponents (alpha values) real ( dp ), allocatable :: coefficients (:) !! Contraction coefficients contains procedure :: allocate_arrays => cgto_allocate_arrays procedure :: destroy => cgto_destroy procedure :: num_basis_functions => cgto_num_basis_functions end type cgto_type","tags":"","url":"type/cgto_type.html"},{"title":"molecular_basis_type – metalquicha ","text":"type, public :: molecular_basis_type Molecular basis set data structure (assembled basis) Inherits type~~molecular_basis_type~~InheritsGraph type~molecular_basis_type molecular_basis_type type~atomic_basis_type atomic_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~molecular_basis_type~~InheritedByGraph type~molecular_basis_type molecular_basis_type type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( atomic_basis_type ), public, allocatable :: elements (:) array of atomic basis types integer, public :: nelements total number of atoms/elements in a molecule Type-Bound Procedures procedure, public :: allocate_elements => basis_set_allocate_elements private pure subroutine basis_set_allocate_elements (self, nelements) Allocate array of atomic basis elements in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements procedure, public :: destroy => basis_set_destroy private pure subroutine basis_set_destroy (self) Clean up allocated memory in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self procedure, public :: num_basis_functions => molecular_basis_num_basis_functions private pure function molecular_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for the molecule Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Source Code type :: molecular_basis_type !! Molecular basis set data structure (assembled basis) type ( atomic_basis_type ), allocatable :: elements (:) !! array of atomic basis types integer :: nelements !! total number of atoms/elements in a molecule contains procedure :: allocate_elements => basis_set_allocate_elements procedure :: destroy => basis_set_destroy procedure :: num_basis_functions => molecular_basis_num_basis_functions end type molecular_basis_type","tags":"","url":"type/molecular_basis_type.html"},{"title":"physical_fragment_t – metalquicha ","text":"type, public :: physical_fragment_t Physical molecular fragment with atomic coordinates and properties Represents a molecular fragment containing atomic positions, element types,\nelectronic structure information, and basis set data for quantum calculations. Inherits type~~physical_fragment_t~~InheritsGraph type~physical_fragment_t physical_fragment_t type~molecular_basis_type molecular_basis_type type~physical_fragment_t->type~molecular_basis_type basis type~atomic_basis_type atomic_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~physical_fragment_t~~InheritedByGraph type~physical_fragment_t physical_fragment_t type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( molecular_basis_type ), public, allocatable :: basis Gaussian basis functions integer, public, allocatable :: cap_replaces_atom (:) Original atom index that each cap replaces (size: n_caps) integer, public :: charge = 0 Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) Cartesian coordinates (3, n_atoms) in Bohr real(kind=dp), public :: distance = 0.0_dp Minimal atomic distance between monomers in fragment (Angstrom, 0 for monomers) integer, public, allocatable :: element_numbers (:) Atomic numbers (Z values) integer, public, allocatable :: local_to_global (:) Map fragment atom index to system atom index (size: n_atoms - n_caps) integer, public :: multiplicity = 1 Spin multiplicity (2S+1) integer, public :: n_atoms Number of atoms in this fragment integer, public :: n_caps = 0 Number of hydrogen caps added (always at end of atom list) integer, public :: nelec = 0 Total number of electrons Type-Bound Procedures procedure, public :: compute_nelec => fragment_compute_nelec Calculate electron count private  subroutine fragment_compute_nelec (this) Compute number of electrons from atomic numbers and charge Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this procedure, public :: destroy => fragment_destroy Memory cleanup private  subroutine fragment_destroy (this) Clean up allocated memory in physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this procedure, public :: set_basis => fragment_set_basis Assign basis set private  subroutine fragment_set_basis (this, basis) Set the basis set for this fragment Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis Source Code type :: physical_fragment_t !! Physical molecular fragment with atomic coordinates and properties !! !! Represents a molecular fragment containing atomic positions, element types, !! electronic structure information, and basis set data for quantum calculations. integer :: n_atoms !! Number of atoms in this fragment integer , allocatable :: element_numbers (:) !! Atomic numbers (Z values) real ( dp ), allocatable :: coordinates (:, :) !! Cartesian coordinates (3, n_atoms) in Bohr ! Electronic structure properties integer :: charge = 0 !! Net molecular charge (electrons) integer :: multiplicity = 1 !! Spin multiplicity (2S+1) integer :: nelec = 0 !! Total number of electrons ! Hydrogen capping for broken bonds integer :: n_caps = 0 !! Number of hydrogen caps added (always at end of atom list) integer , allocatable :: cap_replaces_atom (:) !! Original atom index that each cap replaces (size: n_caps) ! Gradient redistribution support integer , allocatable :: local_to_global (:) !! Map fragment atom index to system atom index (size: n_atoms - n_caps) ! Fragment distance (for screening) real ( dp ) :: distance = 0.0_dp !! Minimal atomic distance between monomers in fragment (Angstrom, 0 for monomers) ! Quantum chemistry basis set type ( molecular_basis_type ), allocatable :: basis !! Gaussian basis functions contains procedure :: destroy => fragment_destroy !! Memory cleanup procedure :: compute_nelec => fragment_compute_nelec !! Calculate electron count procedure :: set_basis => fragment_set_basis !! Assign basis set end type physical_fragment_t","tags":"","url":"type/physical_fragment_t.html"},{"title":"system_geometry_t – metalquicha ","text":"type, public :: system_geometry_t Complete molecular system geometry for fragment-based calculations Contains the full atomic structure of a molecular cluster organized\nby monomers for efficient fragment generation and MBE calculations. Components Type Visibility Attributes Name Initial integer, public :: atoms_per_monomer Atoms in each monomer (0 if variable-sized) integer, public :: charge Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) All coordinates (3, total_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers for all atoms integer, public, allocatable :: fragment_atoms (:,:) Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer, public, allocatable :: fragment_charges (:) Charge for each fragment (n_monomers) integer, public, allocatable :: fragment_multiplicities (:) Multiplicity for each fragment (n_monomers) integer, public, allocatable :: fragment_sizes (:) Number of atoms in each fragment (n_monomers) integer, public :: multiplicity Spin multiplicity (2S+1) integer, public :: n_monomers Number of monomer units in system integer, public :: total_atoms Total number of atoms Type-Bound Procedures procedure, public :: destroy => system_destroy Memory cleanup private  subroutine system_destroy (this) Clean up allocated memory in system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this Source Code type :: system_geometry_t !! Complete molecular system geometry for fragment-based calculations !! !! Contains the full atomic structure of a molecular cluster organized !! by monomers for efficient fragment generation and MBE calculations. integer :: n_monomers !! Number of monomer units in system integer :: atoms_per_monomer !! Atoms in each monomer (0 if variable-sized) integer :: total_atoms !! Total number of atoms integer , allocatable :: element_numbers (:) !! Atomic numbers for all atoms real ( dp ), allocatable :: coordinates (:, :) !! All coordinates (3, total_atoms) in Bohr ! Electronic structure properties integer :: charge !! Net molecular charge (electrons) integer :: multiplicity !! Spin multiplicity (2S+1) ! For variable-sized fragments (explicit fragment definitions) integer , allocatable :: fragment_sizes (:) !! Number of atoms in each fragment (n_monomers) integer , allocatable :: fragment_atoms (:, :) !! Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer , allocatable :: fragment_charges (:) !! Charge for each fragment (n_monomers) integer , allocatable :: fragment_multiplicities (:) !! Multiplicity for each fragment (n_monomers) contains procedure :: destroy => system_destroy !! Memory cleanup end type system_geometry_t","tags":"","url":"type/system_geometry_t.html"},{"title":"dft_method_t – metalquicha ","text":"type, public, extends( qc_method_t ) :: dft_method_t DFT method implementation Kohn-Sham DFT with configurable exchange-correlation functional,\nintegration grid, and optional density fitting. Inherits type~~dft_method_t~~InheritsGraph type~dft_method_t dft_method_t type~dft_options_t dft_options_t type~dft_method_t->type~dft_options_t options type~qc_method_t qc_method_t type~dft_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( dft_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => dft_calc_energy private  subroutine dft_calc_energy (this, fragment, result) Calculate electronic energy using Kohn-Sham DFT Read more… Arguments Type Intent Optional Attributes Name class( dft_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_gradient => dft_calc_gradient private  subroutine dft_calc_gradient (this, fragment, result) Calculate energy gradient using Kohn-Sham DFT Read more… Arguments Type Intent Optional Attributes Name class( dft_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_hessian => dft_calc_hessian private  subroutine dft_calc_hessian (this, fragment, result) Calculate energy Hessian using Kohn-Sham DFT Read more… Arguments Type Intent Optional Attributes Name class( dft_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code type , extends ( qc_method_t ) :: dft_method_t !! DFT method implementation !! !! Kohn-Sham DFT with configurable exchange-correlation functional, !! integration grid, and optional density fitting. type ( dft_options_t ) :: options contains procedure :: calc_energy => dft_calc_energy procedure :: calc_gradient => dft_calc_gradient procedure :: calc_hessian => dft_calc_hessian end type dft_method_t","tags":"","url":"type/dft_method_t.html"},{"title":"dft_options_t – metalquicha ","text":"type, public :: dft_options_t DFT calculation options Inherited by type~~dft_options_t~~InheritedByGraph type~dft_options_t dft_options_t type~dft_method_t dft_method_t type~dft_method_t->type~dft_options_t options Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: angular_points = 302 Number of angular grid points (Lebedev) character(len=32), public :: aux_basis_set = '' Auxiliary basis set for density fitting character(len=32), public :: basis_set = 'sto-3g' Basis set name real(kind=dp), public :: density_tol = 1.0e-6_dp Density matrix convergence threshold integer, public :: diis_size = 8 Number of Fock matrices in DIIS character(len=8), public :: dispersion_type = 'd3bj' Dispersion type: “d3”, “d3bj”, “d4” real(kind=dp), public :: energy_tol = 1.0e-8_dp Energy convergence threshold character(len=32), public :: functional = 'b3lyp' Exchange-correlation functional character(len=16), public :: grid_type = 'medium' Integration grid quality integer, public :: max_iter = 100 Maximum SCF iterations integer, public :: radial_points = 75 Number of radial grid points per atom logical, public :: spherical = .true. Use spherical (true) or Cartesian (false) basis logical, public :: use_density_fitting = .false. Use RI-J approximation logical, public :: use_diis = .true. Use DIIS for SCF convergence logical, public :: use_dispersion = .false. Add empirical dispersion correction logical, public :: verbose = .false. Print SCF iterations Source Code type :: dft_options_t !! DFT calculation options character ( len = 32 ) :: basis_set = 'sto-3g' !! Basis set name character ( len = 32 ) :: functional = 'b3lyp' !! Exchange-correlation functional integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: energy_tol = 1.0e-8_dp !! Energy convergence threshold real ( dp ) :: density_tol = 1.0e-6_dp !! Density matrix convergence threshold logical :: spherical = . true . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . false . !! Print SCF iterations ! Grid settings character ( len = 16 ) :: grid_type = 'medium' !! Integration grid quality integer :: radial_points = 75 !! Number of radial grid points per atom integer :: angular_points = 302 !! Number of angular grid points (Lebedev) ! Density fitting logical :: use_density_fitting = . false . !! Use RI-J approximation character ( len = 32 ) :: aux_basis_set = '' !! Auxiliary basis set for density fitting ! Dispersion correction logical :: use_dispersion = . false . !! Add empirical dispersion correction character ( len = 8 ) :: dispersion_type = 'd3bj' !! Dispersion type: \"d3\", \"d3bj\", \"d4\" ! DIIS acceleration logical :: use_diis = . true . !! Use DIIS for SCF convergence integer :: diis_size = 8 !! Number of Fock matrices in DIIS end type dft_options_t","tags":"","url":"type/dft_options_t.html"},{"title":"resources_t – metalquicha ","text":"type, public :: resources_t Container for calculation resources This type bundles all resources needed by calculation methods.\nCurrently holds MPI communicators, but can be extended to include\nBLAS providers, basis readers, and other shared resources. Inherits type~~resources_t~~InheritsGraph type~resources_t resources_t type~mpi_comms_t mpi_comms_t type~resources_t->type~mpi_comms_t mpi_comms comm_t comm_t type~mpi_comms_t->comm_t world_comm, node_comm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( mpi_comms_t ), public :: mpi_comms MPI communicators Source Code type :: resources_t !! Container for calculation resources !! !! This type bundles all resources needed by calculation methods. !! Currently holds MPI communicators, but can be extended to include !! BLAS providers, basis readers, and other shared resources. type ( mpi_comms_t ) :: mpi_comms !! MPI communicators ! Future extensions: ! type(blas_provider_t), pointer :: blas => null() ! type(basis_reader_t), pointer :: basis_reader => null() ! type(memory_pool_t), pointer :: memory => null() end type resources_t","tags":"","url":"type/resources_t.html"},{"title":"calc_energy_interface – metalquicha","text":"interface private  subroutine calc_energy_interface(this, fragment, result) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results Description Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method.","tags":"","url":"interface/calc_energy_interface.html"},{"title":"calc_gradient_interface – metalquicha","text":"interface private  subroutine calc_gradient_interface(this, fragment, result) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Description Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method.","tags":"","url":"interface/calc_gradient_interface.html"},{"title":"calc_hessian_interface – metalquicha","text":"interface private  subroutine calc_hessian_interface(this, fragment, result) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Description Interface for energy, gradient, and Hessian calculations Computes electronic energy, nuclear gradients, and Hessian matrix for a\nmolecular fragment using the specified quantum chemistry method.","tags":"","url":"interface/calc_hessian_interface.html"},{"title":"xtb_has_solvation – metalquicha","text":"private pure function xtb_has_solvation(this) Check if solvation is configured for XTB Type Bound xtb_config_t Arguments Type Intent Optional Attributes Name class( xtb_config_t ), intent(in) :: this Return Value logical Called by proc~~xtb_has_solvation~~CalledByGraph proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~configure_xtb configure_xtb proc~configure_xtb->proc~xtb_has_solvation proc~run_calculation run_calculation proc~run_calculation->proc~xtb_has_solvation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~factory_create method_factory_t%factory_create proc~factory_create->proc~configure_xtb proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations proc~create_method create_method proc~create_method->proc~factory_create proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~create_method proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~create_method proc~hessian_worker hessian_worker proc~hessian_worker->proc~create_method interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure logical function xtb_has_solvation ( this ) !! Check if solvation is configured for XTB class ( xtb_config_t ), intent ( in ) :: this xtb_has_solvation = len_trim ( this % solvent ) > 0 . or . this % dielectric > 0.0_dp end function xtb_has_solvation","tags":"","url":"proc/xtb_has_solvation.html"},{"title":"config_reset – metalquicha","text":"private  subroutine config_reset(this) Reset all configuration values to defaults Type Bound method_config_t Arguments Type Intent Optional Attributes Name class( method_config_t ), intent(inout) :: this Source Code subroutine config_reset ( this ) !! Reset all configuration values to defaults class ( method_config_t ), intent ( inout ) :: this ! Common settings this % method_type = METHOD_TYPE_UNKNOWN this % verbose = . false . this % basis_set = 'sto-3g' this % use_spherical = . true . ! XTB defaults this % xtb % accuracy = 0.01_dp this % xtb % electronic_temp = 30 0.0_dp this % xtb % solvent = '' this % xtb % solvation_model = '' this % xtb % use_cds = . true . this % xtb % use_shift = . true . this % xtb % dielectric = - 1.0_dp this % xtb % cpcm_nang = 110 this % xtb % cpcm_rscale = 1.0_dp ! SCF defaults (shared by HF and DFT) this % scf % max_iter = 100 this % scf % energy_convergence = 1.0e-8_dp this % scf % density_convergence = 1.0e-6_dp this % scf % use_diis = . true . this % scf % diis_size = 8 ! DFT-specific defaults this % dft % functional = 'b3lyp' this % dft % grid_type = 'medium' this % dft % radial_points = 75 this % dft % angular_points = 302 this % dft % use_density_fitting = . false . this % dft % aux_basis_set = '' this % dft % use_dispersion = . false . this % dft % dispersion_type = 'd3bj' ! MCSCF defaults this % mcscf % n_active_electrons = 0 this % mcscf % n_active_orbitals = 0 this % mcscf % n_inactive_orbitals = - 1 this % mcscf % n_states = 1 if ( allocated ( this % mcscf % state_weights )) deallocate ( this % mcscf % state_weights ) this % mcscf % max_macro_iter = 100 this % mcscf % max_micro_iter = 50 this % mcscf % orbital_convergence = 1.0e-6_dp this % mcscf % ci_convergence = 1.0e-8_dp this % mcscf % use_pt2 = . false . this % mcscf % pt2_type = 'nevpt2' this % mcscf % ipea_shift = 0.25_dp this % mcscf % imaginary_shift = 0.0_dp ! Correlation defaults (shared by MP2, CC, etc.) this % corr % energy_convergence = 1.0e-8_dp this % corr % n_frozen_core = - 1 this % corr % freeze_core = . true . this % corr % use_df = . true . this % corr % aux_basis = '' this % corr % use_local = . false . this % corr % local_type = 'dlpno' this % corr % pno_threshold = 1.0e-7_dp this % corr % use_scs = . false . this % corr % scs_ss = 1.0_dp / 3.0_dp this % corr % scs_os = 1.2_dp ! Coupled-cluster defaults this % cc % max_iter = 100 this % cc % amplitude_convergence = 1.0e-7_dp this % cc % include_triples = . false . this % cc % perturbative_triples = . true . this % cc % use_diis = . true . this % cc % diis_size = 8 this % cc % n_roots = 0 this % cc % eom_type = 'ee' ! F12 defaults this % f12 % geminal_exponent = 1.0_dp this % f12 % ansatz = '3c' this % f12 % cabs_basis = '' this % f12 % optri_basis = '' this % f12 % use_exponent_fit = . false . this % f12 % scale_triples = . true . end subroutine config_reset","tags":"","url":"proc/config_reset.html"},{"title":"compute_mbe_delta – metalquicha","text":"private  function compute_mbe_delta(fragment_idx, fragment, lookup, energies, delta_energies, n, world_comm) result(delta_E) Uses pic_io proc~~compute_mbe_delta~~UsesGraph proc~compute_mbe_delta compute_mbe_delta pic_io pic_io proc~compute_mbe_delta->pic_io Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas)\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all subset deltaE values\nAll subsets must have been computed already (guaranteed by processing fragments in order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Index of this fragment (already known) integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup Pre-built hash table for lookups real(kind=dp), intent(in) :: energies (:) Pre-computed delta values real(kind=dp), intent(in) :: delta_energies (:) Pre-computed delta values integer, intent(in) :: n type(comm_t), intent(in), optional :: world_comm MPI communicator for abort Return Value real(kind=dp) Calls proc~~compute_mbe_delta~~CallsGraph proc~compute_mbe_delta compute_mbe_delta abort_comm abort_comm proc~compute_mbe_delta->abort_comm error error proc~compute_mbe_delta->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_delta~~CalledByGraph proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_delta proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: has_next integer, private :: i integer, private :: indices (MAX_MBE_LEVEL) integer, private :: subset (MAX_MBE_LEVEL) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code function compute_mbe_delta ( fragment_idx , fragment , lookup , energies , delta_energies , n , world_comm ) result ( delta_E ) !! Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas) !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all subset deltaE values !! All subsets must have been computed already (guaranteed by processing fragments in order) integer ( int64 ), intent ( in ) :: fragment_idx !! Index of this fragment (already known) integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup !! Pre-built hash table for lookups real ( dp ), intent ( in ) :: energies (:), delta_energies (:) !! Pre-computed delta values type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort real ( dp ) :: delta_E integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer energy delta_E = energies ( fragment_idx ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx < 0 ) then block use pic_io , only : to_char character ( len = 512 ) :: error_msg integer :: j write ( error_msg , '(a,i0,a,*(i0,1x))' ) \"Subset not found! Fragment idx=\" , fragment_idx , & \" seeking subset: \" , ( subset ( j ), j = 1 , subset_size ) call logger % error ( trim ( error_msg )) write ( error_msg , '(a,*(i0,1x))' ) \"  Full fragment: \" , ( fragment ( j ), j = 1 , n ) call logger % error ( trim ( error_msg )) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Subset not found in bottom-up MBE!\" end if end block end if ! Subtract pre-computed delta energy delta_E = delta_E - delta_energies ( subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end function compute_mbe_delta","tags":"","url":"proc/compute_mbe_delta.html"},{"title":"compute_gmbe – metalquicha","text":"public  subroutine compute_gmbe(monomers, n_monomers, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, total_energy, sys_geom, total_gradient, total_hessian, bonds, world_comm) Uses mqc_gmbe_utils mqc_error mqc_result_types mqc_config_parser mqc_physical_fragment proc~~compute_gmbe~~UsesGraph proc~compute_gmbe compute_gmbe module~mqc_config_parser mqc_config_parser proc~compute_gmbe->module~mqc_config_parser module~mqc_error mqc_error proc~compute_gmbe->module~mqc_error module~mqc_gmbe_utils mqc_gmbe_utils proc~compute_gmbe->module~mqc_gmbe_utils module~mqc_physical_fragment mqc_physical_fragment proc~compute_gmbe->module~mqc_physical_fragment module~mqc_result_types mqc_result_types proc~compute_gmbe->module~mqc_result_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_gmbe_utils->module~mqc_error module~mqc_combinatorics mqc_combinatorics module~mqc_gmbe_utils->module~mqc_combinatorics pic_io pic_io module~mqc_gmbe_utils->pic_io pic_logger pic_logger module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute generalized many-body expansion (GMBE) energy with optional gradient and/or hessian This is the core routine that handles all GMBE computations using\nthe inclusion-exclusion principle for overlapping fragments.\nOptional arguments control what derivatives are computed:\n  - If sys_geom and total_gradient are present: compute gradient\n  - If total_hessian is also present: compute hessian Arguments Type Intent Optional Attributes Name integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers type( calculation_result_t ), intent(in) :: monomer_results (:) integer, intent(in) :: n_intersections type( calculation_result_t ), intent(in), optional :: intersection_results (:) integer, intent(in), optional :: intersection_sets (:,:) integer, intent(in), optional :: intersection_levels (:) real(kind=dp), intent(out) :: total_energy type( system_geometry_t ), intent(in), optional :: sys_geom real(kind=dp), intent(out), optional :: total_gradient (:,:) real(kind=dp), intent(out), optional :: total_hessian (:,:) type( bond_t ), intent(in), optional :: bonds (:) type(comm_t), intent(in), optional :: world_comm Calls proc~~compute_gmbe~~CallsGraph proc~compute_gmbe compute_gmbe abort_comm abort_comm proc~compute_gmbe->abort_comm cart_disp cart_disp proc~compute_gmbe->cart_disp configuration configuration proc~compute_gmbe->configuration error error proc~compute_gmbe->error fc_mdyne fc_mdyne proc~compute_gmbe->fc_mdyne force_constants force_constants proc~compute_gmbe->force_constants frequencies frequencies proc~compute_gmbe->frequencies info info proc~compute_gmbe->info proc~build_fragment_from_indices build_fragment_from_indices proc~compute_gmbe->proc~build_fragment_from_indices proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_gmbe->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~compute_gmbe->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~compute_gmbe->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~compute_gmbe->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~compute_gmbe->proc~fragment_destroy proc~print_gmbe_energy_breakdown print_gmbe_energy_breakdown proc~compute_gmbe->proc~print_gmbe_energy_breakdown proc~print_gmbe_gradient_info print_gmbe_gradient_info proc~compute_gmbe->proc~print_gmbe_gradient_info proc~print_gmbe_intersection_debug print_gmbe_intersection_debug proc~compute_gmbe->proc~print_gmbe_intersection_debug proc~print_vibrational_analysis print_vibrational_analysis proc~compute_gmbe->proc~print_vibrational_analysis proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~redistribute_cap_gradients redistribute_cap_gradients proc~compute_gmbe->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~compute_gmbe->proc~redistribute_cap_hessian reduced_masses reduced_masses proc~compute_gmbe->reduced_masses to_char to_char proc~compute_gmbe->to_char proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~print_gmbe_energy_breakdown->info proc~print_gmbe_gradient_info->info proc~print_gmbe_gradient_info->to_char proc~print_gmbe_intersection_debug->proc~energy_total debug debug proc~print_gmbe_intersection_debug->debug proc~print_vibrational_analysis->info proc~compute_thermochemistry compute_thermochemistry proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry warning warning proc~print_vibrational_analysis->warning proc~process_intersection_derivatives->abort_comm proc~process_intersection_derivatives->error proc~process_intersection_derivatives->proc~error_get_full_trace proc~process_intersection_derivatives->proc~error_has_error proc~process_intersection_derivatives->proc~fragment_destroy proc~process_intersection_derivatives->proc~redistribute_cap_gradients proc~process_intersection_derivatives->proc~redistribute_cap_hessian proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~find_fragment_intersection find_fragment_intersection proc~process_intersection_derivatives->proc~find_fragment_intersection proc~get_monomer_atom_list get_monomer_atom_list proc~process_intersection_derivatives->proc~get_monomer_atom_list proc~process_intersection_derivatives->warning proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_fragment_from_atom_list->proc~error_has_error proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~build_fragment_from_atom_list->proc~error_add_context proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~print_thermochemistry->info proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->warning proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->proc~element_mass proc~compute_zpe->to_char proc~compute_zpe->warning proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: compute_grad logical, private :: compute_hess integer, private :: current_log_level type( error_t ), private :: error type( physical_fragment_t ), private :: fragment logical, private :: has_intersections integer, private :: hess_dim integer, private :: i integer, private :: k integer, private, allocatable :: level_counts (:) real(kind=dp), private, allocatable :: level_energies (:) integer, private :: max_level real(kind=dp), private :: monomer_energy integer, private, allocatable :: monomer_idx (:) real(kind=dp), private :: sign_factor Source Code subroutine compute_gmbe ( monomers , n_monomers , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , & total_energy , & sys_geom , total_gradient , total_hessian , bonds , world_comm ) !! Compute generalized many-body expansion (GMBE) energy with optional gradient and/or hessian !! !! This is the core routine that handles all GMBE computations using !! the inclusion-exclusion principle for overlapping fragments. !! Optional arguments control what derivatives are computed: !!   - If sys_geom and total_gradient are present: compute gradient !!   - If total_hessian is also present: compute hessian use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_indices , build_fragment_from_atom_list , & redistribute_cap_gradients , redistribute_cap_hessian use mqc_gmbe_utils , only : find_fragment_intersection use mqc_config_parser , only : bond_t use mqc_error , only : error_t ! Required arguments integer , intent ( in ) :: monomers (:) integer , intent ( in ) :: n_monomers type ( calculation_result_t ), intent ( in ) :: monomer_results (:) integer , intent ( in ) :: n_intersections type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) integer , intent ( in ), optional :: intersection_sets (:, :) integer , intent ( in ), optional :: intersection_levels (:) real ( dp ), intent ( out ) :: total_energy ! Optional arguments for gradient computation type ( system_geometry_t ), intent ( in ), optional :: sys_geom real ( dp ), intent ( out ), optional :: total_gradient (:, :) ! Optional arguments for hessian computation real ( dp ), intent ( out ), optional :: total_hessian (:, :) ! Optional bond information for hydrogen cap handling type ( bond_t ), intent ( in ), optional :: bonds (:) ! Optional MPI communicator for abort type ( comm_t ), intent ( in ), optional :: world_comm ! Local variables integer :: i , k , max_level , current_log_level , hess_dim real ( dp ) :: monomer_energy , sign_factor real ( dp ), allocatable :: level_energies (:) integer , allocatable :: level_counts (:) type ( physical_fragment_t ) :: fragment type ( error_t ) :: error integer , allocatable :: monomer_idx (:) logical :: compute_grad , compute_hess , has_intersections ! Determine what to compute based on optional arguments compute_grad = present ( sys_geom ) . and . present ( total_gradient ) compute_hess = compute_grad . and . present ( total_hessian ) has_intersections = n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels ) ! Initialize outputs if ( compute_grad ) then total_gradient = 0.0_dp end if if ( compute_hess ) then total_hessian = 0.0_dp hess_dim = 3 * sys_geom % total_atoms end if ! Sum monomer energies (and gradients/hessians if requested) monomer_energy = 0.0_dp do i = 1 , n_monomers monomer_energy = monomer_energy + monomer_results ( i )% energy % total () ! Accumulate monomer derivatives if requested if ( compute_grad . and . monomer_results ( i )% has_gradient ) then allocate ( monomer_idx ( 1 )) monomer_idx ( 1 ) = monomers ( i ) call build_fragment_from_indices ( sys_geom , monomer_idx , fragment , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Failed to build monomer fragment in GMBE\" end if end if call redistribute_cap_gradients ( fragment , monomer_results ( i )% gradient , total_gradient ) if ( compute_hess . and . monomer_results ( i )% has_hessian ) then call redistribute_cap_hessian ( fragment , monomer_results ( i )% hessian , total_hessian ) end if call fragment % destroy () deallocate ( monomer_idx ) end if end do ! Start with monomer contribution total_energy = monomer_energy ! Handle intersections with inclusion-exclusion if ( has_intersections ) then max_level = maxval ( intersection_levels ) allocate ( level_energies ( 2 : max_level )) allocate ( level_counts ( 2 : max_level )) level_energies = 0.0_dp level_counts = 0 ! Process intersection energies and derivatives do i = 1 , n_intersections k = intersection_levels ( i ) sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) level_energies ( k ) = level_energies ( k ) + intersection_results ( i )% energy % total () level_counts ( k ) = level_counts ( k ) + 1 ! Handle intersection derivatives if requested if ( compute_grad . and . ( intersection_results ( i )% has_gradient . or . & ( compute_hess . and . intersection_results ( i )% has_hessian ))) then call process_intersection_derivatives ( i , k , sign_factor , intersection_results , & intersection_sets , sys_geom , total_gradient , total_hessian , bonds , & compute_grad , compute_hess , hess_dim , world_comm ) end if end do ! Apply inclusion-exclusion to energy do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) total_energy = total_energy + sign_factor * level_energies ( k ) end if end do ! Print energy breakdown call print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & max_level , total_energy , . true .) ! Print debug info for intersections call print_gmbe_intersection_debug ( n_intersections , n_monomers , intersection_sets , & intersection_levels , intersection_results ) deallocate ( level_energies , level_counts ) else ! No intersections - just print monomer sum call print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & 0 , total_energy , . false .) end if ! Print gradient/hessian info if ( compute_grad ) then call logger % configuration ( level = current_log_level ) call print_gmbe_gradient_info ( total_gradient , sys_geom , current_log_level ) end if if ( compute_hess ) then call logger % info ( \"GMBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & coordinates = sys_geom % coordinates , & electronic_energy = total_energy ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if end subroutine compute_gmbe","tags":"","url":"proc/compute_gmbe.html"},{"title":"compute_mbe – metalquicha","text":"public  subroutine compute_mbe(polymers, fragment_count, max_level, results, mbe_result, sys_geom, bonds, world_comm, json_data) Uses mqc_config_parser mqc_result_types mqc_error proc~~compute_mbe~~UsesGraph proc~compute_mbe compute_mbe module~mqc_config_parser mqc_config_parser proc~compute_mbe->module~mqc_config_parser module~mqc_error mqc_error proc~compute_mbe->module~mqc_error module~mqc_result_types mqc_result_types proc~compute_mbe->module~mqc_result_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute many-body expansion (MBE) energy with optional gradient, hessian, and dipole This is the core routine that handles all MBE computations.\nThe caller pre-allocates desired components in mbe_result before calling:\n  - mbe_result%gradient allocated: compute gradient (requires sys_geom)\n  - mbe_result%hessian allocated: compute hessian (requires sys_geom)\n  - mbe_result%dipole allocated: compute total dipole moment\nIf json_data is present, populates it for centralized JSON output Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( calculation_result_t ), intent(in) :: results (:) type( mbe_result_t ), intent(inout) :: mbe_result Pre-allocated by caller type( system_geometry_t ), intent(in), optional :: sys_geom Required for gradient/hessian type( bond_t ), intent(in), optional :: bonds (:) Bond info for H-cap handling type(comm_t), intent(in), optional :: world_comm MPI communicator for abort type( json_output_data_t ), intent(out), optional :: json_data JSON output data Calls proc~~compute_mbe~~CallsGraph proc~compute_mbe compute_mbe abort_comm abort_comm proc~compute_mbe->abort_comm cart_disp cart_disp proc~compute_mbe->cart_disp configuration configuration proc~compute_mbe->configuration error error proc~compute_mbe->error fc_mdyne fc_mdyne proc~compute_mbe->fc_mdyne force_constants force_constants proc~compute_mbe->force_constants frequencies frequencies proc~compute_mbe->frequencies get_message get_message proc~compute_mbe->get_message has_error has_error proc~compute_mbe->has_error info info proc~compute_mbe->info proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe->proc~compute_mbe_dipole proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_thermochemistry compute_thermochemistry proc~compute_mbe->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_mbe->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~compute_mbe->proc~energy_total proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis reduced_masses reduced_masses proc~compute_mbe->reduced_masses to_char to_char proc~compute_mbe->to_char warning warning proc~compute_mbe->warning proc~build_mbe_lookup_table->to_char debug debug proc~build_mbe_lookup_table->debug get_elapsed_time get_elapsed_time proc~build_mbe_lookup_table->get_elapsed_time proc~error_add_context error_t%error_add_context proc~build_mbe_lookup_table->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_mbe_lookup_table->proc~error_has_error proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert start start proc~build_mbe_lookup_table->start proc~compute_mbe_delta->abort_comm proc~compute_mbe_delta->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_dipole->abort_comm proc~compute_mbe_dipole->error proc~compute_mbe_dipole->proc~fragment_lookup_find proc~compute_mbe_dipole->proc~get_next_combination proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~fragment_lookup_find proc~compute_mbe_dipole_derivatives->proc~get_next_combination proc~compute_mbe_gradient->abort_comm proc~compute_mbe_gradient->error proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~redistribute_cap_dipole_derivatives proc~map_fragment_to_system_gradient->abort_comm proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->debug proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_has_error proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->warning header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name verbose verbose proc~print_detailed_breakdown->verbose proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~print_vibrational_analysis->warning proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~build_fragment_from_indices->proc~error_add_context proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->warning pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_zpe->to_char proc~compute_zpe->warning proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal proc~fragment_lookup_insert->fnv_1a_hash proc~error_set error_t%error_set proc~fragment_lookup_insert->proc~error_set proc~fragment_lookup_insert->sort proc~print_thermochemistry->info proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->proc~element_number_to_symbol proc~check_duplicate_atoms->proc~error_set proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe~~CalledByGraph proc~compute_mbe compute_mbe proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: compute_dipole logical, private :: compute_dipole_derivs logical, private :: compute_grad logical, private :: compute_hess integer, private :: current_log_level real(kind=dp), private :: delta_E real(kind=dp), private, allocatable :: delta_dipole_derivs (:,:,:) (3, 3*total_atoms, fragment_count) real(kind=dp), private, allocatable :: delta_dipoles (:,:) (3, fragment_count) real(kind=dp), private, allocatable :: delta_energies (:) real(kind=dp), private, allocatable :: delta_gradients (:,:,:) real(kind=dp), private, allocatable :: delta_hessians (:,:,:) logical, private :: do_detailed_print real(kind=dp), private, allocatable :: energies (:) integer, private :: fragment_size integer, private :: hess_dim integer(kind=int64), private :: i real(kind=dp), private, allocatable :: ir_intensities (:) IR intensities in km/mol type( fragment_lookup_t ), private :: lookup integer, private :: nlevel real(kind=dp), private, allocatable :: sum_by_level (:) Source Code subroutine compute_mbe ( polymers , fragment_count , max_level , results , & mbe_result , sys_geom , bonds , world_comm , json_data ) !! Compute many-body expansion (MBE) energy with optional gradient, hessian, and dipole !! !! This is the core routine that handles all MBE computations. !! The caller pre-allocates desired components in mbe_result before calling: !!   - mbe_result%gradient allocated: compute gradient (requires sys_geom) !!   - mbe_result%hessian allocated: compute hessian (requires sys_geom) !!   - mbe_result%dipole allocated: compute total dipole moment !! If json_data is present, populates it for centralized JSON output use mqc_result_types , only : calculation_result_t , mbe_result_t use mqc_config_parser , only : bond_t ! Required arguments integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level type ( calculation_result_t ), intent ( in ) :: results (:) type ( mbe_result_t ), intent ( inout ) :: mbe_result !! Pre-allocated by caller ! Optional arguments type ( system_geometry_t ), intent ( in ), optional :: sys_geom !! Required for gradient/hessian type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond info for H-cap handling type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data ! Local variables integer ( int64 ) :: i integer :: fragment_size , nlevel , current_log_level , hess_dim real ( dp ), allocatable :: sum_by_level (:), delta_energies (:), energies (:) real ( dp ), allocatable :: delta_gradients (:, :, :), delta_hessians (:, :, :) real ( dp ), allocatable :: delta_dipoles (:, :) !! (3, fragment_count) real ( dp ), allocatable :: delta_dipole_derivs (:, :, :) !! (3, 3*total_atoms, fragment_count) real ( dp ), allocatable :: ir_intensities (:) !! IR intensities in km/mol real ( dp ) :: delta_E logical :: do_detailed_print , compute_grad , compute_hess , compute_dipole , compute_dipole_derivs type ( fragment_lookup_t ) :: lookup ! Determine what to compute based on allocated components in mbe_result compute_grad = allocated ( mbe_result % gradient ) compute_hess = allocated ( mbe_result % hessian ) compute_dipole = allocated ( mbe_result % dipole ) compute_dipole_derivs = . false . ! Will be set true if all fragments have dipole_derivatives ! Validate inputs for gradient computation if ( compute_grad ) then do i = 1_int64 , fragment_count if (. not . results ( i )% has_gradient ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have gradient!\" ) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Missing gradient in compute_mbe_internal\" end if end if end do end if ! Validate inputs for hessian computation if ( compute_hess ) then do i = 1_int64 , fragment_count if (. not . results ( i )% has_hessian ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have Hessian!\" ) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Missing Hessian in compute_mbe_internal\" end if end if end do hess_dim = 3 * sys_geom % total_atoms end if ! Validate inputs for dipole computation if ( compute_dipole ) then do i = 1_int64 , fragment_count if (. not . results ( i )% has_dipole ) then call logger % warning ( \"Fragment \" // to_char ( i ) // \" does not have dipole - skipping dipole MBE\" ) compute_dipole = . false . exit end if end do end if ! Check if dipole derivatives are available (for IR intensities) if ( compute_hess ) then compute_dipole_derivs = . true . do i = 1_int64 , fragment_count if (. not . results ( i )% has_dipole_derivatives ) then compute_dipole_derivs = . false . exit end if end do end if ! Get logger configuration call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) ! Allocate energy arrays (always needed) allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) allocate ( energies ( fragment_count )) sum_by_level = 0.0_dp delta_energies = 0.0_dp ! Extract total energies from results do i = 1_int64 , fragment_count energies ( i ) = results ( i )% energy % total () end do ! Allocate gradient delta arrays if needed if ( compute_grad ) then allocate ( delta_gradients ( 3 , sys_geom % total_atoms , fragment_count )) delta_gradients = 0.0_dp mbe_result % gradient = 0.0_dp end if ! Allocate hessian delta arrays if needed if ( compute_hess ) then allocate ( delta_hessians ( hess_dim , hess_dim , fragment_count )) delta_hessians = 0.0_dp mbe_result % hessian = 0.0_dp end if ! Allocate dipole delta arrays if needed if ( compute_dipole ) then allocate ( delta_dipoles ( 3 , fragment_count )) delta_dipoles = 0.0_dp mbe_result % dipole = 0.0_dp end if ! Allocate dipole derivative delta arrays if needed (for IR intensities) if ( compute_dipole_derivs ) then allocate ( delta_dipole_derivs ( 3 , hess_dim , fragment_count )) delta_dipole_derivs = 0.0_dp allocate ( mbe_result % dipole_derivatives ( 3 , hess_dim )) mbe_result % dipole_derivatives = 0.0_dp end if ! Build hash table for fast fragment lookups block use mqc_error , only : error_t type ( error_t ) :: lookup_error call build_mbe_lookup_table ( polymers , fragment_count , max_level , lookup , lookup_error ) if ( lookup_error % has_error ()) then call logger % error ( \"Failed to build lookup table: \" // lookup_error % get_message ()) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Failed to build lookup table\" end if end if end block ! Bottom-up computation: process fragments by size (1-body, then 2-body, etc.) ! This makes the algorithm independent of input fragment order ! We process by n-mer level to ensure all subsets are computed before they're needed do nlevel = 1 , max_level do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) ! Only process fragments of the current nlevel if ( fragment_size /= nlevel ) cycle if ( fragment_size == 1 ) then ! 1-body: delta = value (no subsets to subtract) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) if ( compute_grad ) then call map_fragment_to_system_gradient ( results ( i )% gradient , & polymers ( i , 1 : fragment_size ), sys_geom , delta_gradients (:, :, i ), bonds , world_comm ) end if if ( compute_hess ) then call map_fragment_to_system_hessian ( results ( i )% hessian , & polymers ( i , 1 : fragment_size ), sys_geom , delta_hessians (:, :, i ), bonds ) end if if ( compute_dipole ) then ! For 1-body, delta dipole is just the fragment dipole delta_dipoles (:, i ) = results ( i )% dipole end if if ( compute_dipole_derivs ) then ! For 1-body, delta dipole derivatives are just the fragment values mapped to system call map_fragment_to_system_dipole_derivatives ( results ( i )% dipole_derivatives , & polymers ( i , 1 : fragment_size ), sys_geom , delta_dipole_derivs (:, :, i ), bonds ) end if else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: delta = value - sum(all subset deltas) delta_E = compute_mbe_delta ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size , world_comm ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E if ( compute_grad ) then call compute_mbe_gradient ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_gradients , fragment_size , sys_geom , bonds , world_comm ) end if if ( compute_hess ) then call compute_mbe_hessian ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_hessians , fragment_size , sys_geom , bonds ) end if if ( compute_dipole ) then call compute_mbe_dipole ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_dipoles , fragment_size , world_comm ) end if if ( compute_dipole_derivs ) then call compute_mbe_dipole_derivatives ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_dipole_derivs , fragment_size , sys_geom , bonds ) end if end if end do end do ! Clean up lookup table call lookup % destroy () ! Compute totals and set status flags mbe_result % total_energy = sum ( sum_by_level ) mbe_result % has_energy = . true . if ( compute_grad ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then mbe_result % gradient = mbe_result % gradient + delta_gradients (:, :, i ) end if end do mbe_result % has_gradient = . true . end if if ( compute_hess ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then mbe_result % hessian = mbe_result % hessian + delta_hessians (:, :, i ) end if end do mbe_result % has_hessian = . true . end if if ( compute_dipole ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then mbe_result % dipole = mbe_result % dipole + delta_dipoles (:, i ) end if end do mbe_result % has_dipole = . true . end if if ( compute_dipole_derivs ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then mbe_result % dipole_derivatives = mbe_result % dipole_derivatives + delta_dipole_derivs (:, :, i ) end if end do mbe_result % has_dipole_derivatives = . true . end if ! Print energy breakdown (always) call print_mbe_energy_breakdown ( sum_by_level , max_level , mbe_result % total_energy ) ! Print gradient info if computed if ( compute_grad ) then call print_mbe_gradient_info ( mbe_result % gradient , sys_geom , current_log_level ) end if ! Print hessian info if computed if ( compute_hess ) then call logger % info ( \"MBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( mbe_result % hessian ** 2 )))) ! Compute and print full vibrational analysis with thermochemistry block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) type ( thermochemistry_result_t ) :: thermo_result integer :: n_at , n_modes call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) if ( compute_dipole_derivs ) then call compute_vibrational_analysis ( mbe_result % hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne , & dipole_derivatives = mbe_result % dipole_derivatives , & ir_intensities = ir_intensities ) else call compute_vibrational_analysis ( mbe_result % hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) end if if ( allocated ( frequencies )) then ! Compute thermochemistry n_at = size ( sys_geom % element_numbers ) n_modes = size ( frequencies ) call compute_thermochemistry ( sys_geom % coordinates , sys_geom % element_numbers , & frequencies , n_at , n_modes , thermo_result ) ! Print vibrational analysis to log if ( allocated ( ir_intensities )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & ir_intensities = ir_intensities , & coordinates = sys_geom % coordinates , & electronic_energy = mbe_result % total_energy ) else call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & coordinates = sys_geom % coordinates , & electronic_energy = mbe_result % total_energy ) end if ! Populate json_data for vibrational output if present if ( present ( json_data )) then json_data % output_mode = OUTPUT_MODE_MBE json_data % total_energy = mbe_result % total_energy json_data % has_energy = mbe_result % has_energy json_data % has_vibrational = . true . ! Copy vibrational data allocate ( json_data % frequencies ( n_modes )) allocate ( json_data % reduced_masses ( n_modes )) allocate ( json_data % force_constants ( n_modes )) json_data % frequencies = frequencies json_data % reduced_masses = reduced_masses json_data % force_constants = fc_mdyne json_data % thermo = thermo_result if ( allocated ( ir_intensities )) then allocate ( json_data % ir_intensities ( n_modes )) json_data % ir_intensities = ir_intensities json_data % has_ir_intensities = . true . end if ! Copy dipole if available if ( mbe_result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = mbe_result % dipole json_data % has_dipole = . true . end if ! Copy gradient if available if ( mbe_result % has_gradient ) then allocate ( json_data % gradient , source = mbe_result % gradient ) json_data % has_gradient = . true . end if ! Copy hessian if available if ( mbe_result % has_hessian ) then allocate ( json_data % hessian , source = mbe_result % hessian ) json_data % has_hessian = . true . end if end if if ( allocated ( ir_intensities )) deallocate ( ir_intensities ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if ! Print dipole info if computed if ( compute_dipole ) then block character ( len = 256 ) :: dipole_line real ( dp ) :: dipole_magnitude dipole_magnitude = norm2 ( mbe_result % dipole ) * 2.541746_dp ! Convert e*Bohr to Debye call logger % info ( \"MBE Dipole moment:\" ) write ( dipole_line , '(a,3f15.8)' ) \"  Dipole (e*Bohr): \" , mbe_result % dipole call logger % info ( trim ( dipole_line )) write ( dipole_line , '(a,f15.8)' ) \"  Dipole magnitude (Debye): \" , dipole_magnitude call logger % info ( trim ( dipole_line )) end block end if ! Print detailed breakdown if requested if ( do_detailed_print ) then call print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) end if ! Populate json_data for non-Hessian case if present ! (Hessian case already handled above in the vibrational block) if ( present ( json_data ) . and . . not . compute_hess ) then json_data % output_mode = OUTPUT_MODE_MBE json_data % total_energy = mbe_result % total_energy json_data % has_energy = mbe_result % has_energy json_data % max_level = max_level json_data % fragment_count = fragment_count ! Copy fragment breakdown data allocate ( json_data % polymers ( fragment_count , max_level )) json_data % polymers = polymers ( 1 : fragment_count , 1 : max_level ) allocate ( json_data % fragment_energies ( fragment_count )) json_data % fragment_energies = energies allocate ( json_data % delta_energies ( fragment_count )) json_data % delta_energies = delta_energies allocate ( json_data % sum_by_level ( max_level )) json_data % sum_by_level = sum_by_level ! Copy fragment distances if available allocate ( json_data % fragment_distances ( fragment_count )) do i = 1_int64 , fragment_count json_data % fragment_distances ( i ) = results ( i )% distance end do ! Copy dipole if available if ( mbe_result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = mbe_result % dipole json_data % has_dipole = . true . end if ! Copy gradient if available if ( mbe_result % has_gradient ) then allocate ( json_data % gradient , source = mbe_result % gradient ) json_data % has_gradient = . true . end if end if ! Cleanup deallocate ( sum_by_level , delta_energies , energies ) if ( allocated ( delta_gradients )) deallocate ( delta_gradients ) if ( allocated ( delta_hessians )) deallocate ( delta_hessians ) if ( allocated ( delta_dipoles )) deallocate ( delta_dipoles ) if ( allocated ( delta_dipole_derivs )) deallocate ( delta_dipole_derivs ) end subroutine compute_mbe","tags":"","url":"proc/compute_mbe.html"},{"title":"build_mbe_lookup_table – metalquicha","text":"private  subroutine build_mbe_lookup_table(polymers, fragment_count, max_level, lookup, error) Uses mqc_error proc~~build_mbe_lookup_table~~UsesGraph proc~build_mbe_lookup_table build_mbe_lookup_table module~mqc_error mqc_error proc~build_mbe_lookup_table->module~mqc_error Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Build hash table for fast fragment lookups Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( fragment_lookup_t ), intent(inout) :: lookup type( error_t ), intent(out), optional :: error Calls proc~~build_mbe_lookup_table~~CallsGraph proc~build_mbe_lookup_table build_mbe_lookup_table debug debug proc~build_mbe_lookup_table->debug get_elapsed_time get_elapsed_time proc~build_mbe_lookup_table->get_elapsed_time proc~error_add_context error_t%error_add_context proc~build_mbe_lookup_table->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_mbe_lookup_table->proc~error_has_error proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert start start proc~build_mbe_lookup_table->start to_char to_char proc~build_mbe_lookup_table->to_char proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash proc~error_set error_t%error_set proc~fragment_lookup_insert->proc~error_set sort sort proc~fragment_lookup_insert->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_mbe_lookup_table~~CalledByGraph proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe compute_mbe proc~compute_mbe->proc~build_mbe_lookup_table proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: fragment_size integer(kind=int64), private :: i type( error_t ), private :: insert_error type(timer_type), private :: lookup_timer Source Code subroutine build_mbe_lookup_table ( polymers , fragment_count , max_level , lookup , error ) !! Build hash table for fast fragment lookups use mqc_error , only : error_t integer , intent ( in ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: max_level type ( fragment_lookup_t ), intent ( inout ) :: lookup type ( error_t ), intent ( out ), optional :: error integer ( int64 ) :: i integer :: fragment_size type ( timer_type ) :: lookup_timer type ( error_t ) :: insert_error call lookup_timer % start () call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) call lookup % insert ( polymers ( i , :), fragment_size , i , insert_error ) if ( insert_error % has_error ()) then if ( present ( error )) then error = insert_error call error % add_context ( \"build_mbe_lookup_table\" ) end if return end if end do call lookup_timer % stop () call logger % debug ( \"Time to build lookup table: \" // to_char ( lookup_timer % get_elapsed_time ()) // \" s\" ) call logger % debug ( \"Hash table size: \" // to_char ( lookup % table_size ) // & \", entries: \" // to_char ( lookup % n_entries )) end subroutine build_mbe_lookup_table","tags":"","url":"proc/build_mbe_lookup_table.html"},{"title":"compute_mbe_dipole – metalquicha","text":"private  subroutine compute_mbe_dipole(fragment_idx, fragment, lookup, results, delta_dipoles, n, world_comm) Uses mqc_result_types proc~~compute_mbe_dipole~~UsesGraph proc~compute_mbe_dipole compute_mbe_dipole module~mqc_result_types mqc_result_types proc~compute_mbe_dipole->module~mqc_result_types module~mqc_error mqc_error module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib pic_types pic_types module~mqc_result_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Bottom-up computation of n-body dipole correction\nExactly mirrors the energy MBE logic: deltaDipole = Dipole - sum(all subset deltaDipoles)\nDipoles are additive vectors in the system frame, no coordinate mapping needed Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_dipoles (:,:) (3, fragment_count) integer, intent(in) :: n type(comm_t), intent(in), optional :: world_comm MPI communicator for abort Calls proc~~compute_mbe_dipole~~CallsGraph proc~compute_mbe_dipole compute_mbe_dipole abort_comm abort_comm proc~compute_mbe_dipole->abort_comm error error proc~compute_mbe_dipole->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_dipole->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_dipole->proc~get_next_combination fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_dipole~~CalledByGraph proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_dipole proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: has_next integer, private :: i integer, private :: indices (MAX_MBE_LEVEL) integer, private :: subset (MAX_MBE_LEVEL) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code subroutine compute_mbe_dipole ( fragment_idx , fragment , lookup , results , delta_dipoles , n , world_comm ) !! Bottom-up computation of n-body dipole correction !! Exactly mirrors the energy MBE logic: deltaDipole = Dipole - sum(all subset deltaDipoles) !! Dipoles are additive vectors in the system frame, no coordinate mapping needed use mqc_result_types , only : calculation_result_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_dipoles (:, :) !! (3, fragment_count) type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer dipole delta_dipoles (:, fragment_idx ) = results ( fragment_idx )% dipole ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx < 0 ) then call logger % error ( \"Subset not found in MBE dipole computation\" ) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Subset not found in MBE dipole!\" end if end if ! Subtract pre-computed delta dipole delta_dipoles (:, fragment_idx ) = delta_dipoles (:, fragment_idx ) - & delta_dipoles (:, subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end subroutine compute_mbe_dipole","tags":"","url":"proc/compute_mbe_dipole.html"},{"title":"compute_mbe_dipole_derivatives – metalquicha","text":"private  subroutine compute_mbe_dipole_derivatives(fragment_idx, fragment, lookup, results, delta_dipole_derivs, n, sys_geom, bonds) Uses mqc_config_parser mqc_result_types mqc_error proc~~compute_mbe_dipole_derivatives~~UsesGraph proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives module~mqc_config_parser mqc_config_parser proc~compute_mbe_dipole_derivatives->module~mqc_config_parser module~mqc_error mqc_error proc~compute_mbe_dipole_derivatives->module~mqc_error module~mqc_result_types mqc_result_types proc~compute_mbe_dipole_derivatives->module~mqc_result_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Bottom-up computation of n-body dipole derivative correction\nMirrors MBE Hessian logic but for dipole derivatives Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_dipole_derivs (:,:,:) (3, 3*total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~compute_mbe_dipole_derivatives~~CallsGraph proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_dipole_derivatives->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_dipole_derivatives->proc~get_next_combination proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~redistribute_cap_dipole_derivatives proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_indices->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_dipole_derivatives~~CalledByGraph proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: has_next integer, private :: i integer, private :: indices (MAX_MBE_LEVEL) integer, private :: subset (MAX_MBE_LEVEL) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code subroutine compute_mbe_dipole_derivatives ( fragment_idx , fragment , lookup , results , delta_dipole_derivs , n , sys_geom , bonds ) !! Bottom-up computation of n-body dipole derivative correction !! Mirrors MBE Hessian logic but for dipole derivatives use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t use mqc_error , only : error_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_dipole_derivs (:, :, :) !! (3, 3*total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer dipole derivatives mapped to system coordinates call map_fragment_to_system_dipole_derivatives ( results ( fragment_idx )% dipole_derivatives , fragment , & sys_geom , delta_dipole_derivs (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do has_next = . true . do while ( has_next ) do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx > 0 ) then ! Subtract this subset's delta dipole derivatives delta_dipole_derivs (:, :, fragment_idx ) = delta_dipole_derivs (:, :, fragment_idx ) - & delta_dipole_derivs (:, :, subset_idx ) end if call get_next_combination ( indices , subset_size , n , has_next ) end do end do end subroutine compute_mbe_dipole_derivatives","tags":"","url":"proc/compute_mbe_dipole_derivatives.html"},{"title":"compute_mbe_gradient – metalquicha","text":"private  subroutine compute_mbe_gradient(fragment_idx, fragment, lookup, results, delta_gradients, n, sys_geom, bonds, world_comm) Uses mqc_config_parser mqc_result_types proc~~compute_mbe_gradient~~UsesGraph proc~compute_mbe_gradient compute_mbe_gradient module~mqc_config_parser mqc_config_parser proc~compute_mbe_gradient->module~mqc_config_parser module~mqc_result_types mqc_result_types proc~compute_mbe_gradient->module~mqc_result_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Bottom-up computation of n-body gradient correction\nExactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs)\nAll gradients are in system coordinates, so subtraction is simple Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_gradients (:,:,:) (3, total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps type(comm_t), intent(in), optional :: world_comm MPI communicator for abort Calls proc~~compute_mbe_gradient~~CallsGraph proc~compute_mbe_gradient compute_mbe_gradient abort_comm abort_comm proc~compute_mbe_gradient->abort_comm error error proc~compute_mbe_gradient->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_gradient->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_gradient->proc~get_next_combination proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~map_fragment_to_system_gradient->abort_comm proc~map_fragment_to_system_gradient->error configuration configuration proc~map_fragment_to_system_gradient->configuration debug debug proc~map_fragment_to_system_gradient->debug proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~map_fragment_to_system_gradient->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_gradient~~CalledByGraph proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_gradient proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: has_next integer, private :: i integer, private :: indices (MAX_MBE_LEVEL) integer, private :: subset (MAX_MBE_LEVEL) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code subroutine compute_mbe_gradient ( fragment_idx , fragment , lookup , results , delta_gradients , n , sys_geom , bonds , world_comm ) !! Bottom-up computation of n-body gradient correction !! Exactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs) !! All gradients are in system coordinates, so subtraction is simple use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_gradients (:, :, :) !! (3, total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer gradient mapped to system coordinates call map_fragment_to_system_gradient ( results ( fragment_idx )% gradient , fragment , & sys_geom , delta_gradients (:, :, fragment_idx ), bonds , world_comm ) ! Subtract all proper subsets (size 1 to n-1) ! This is EXACTLY like the energy calculation, but for each gradient component do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx < 0 ) then call logger % error ( \"Subset not found in MBE gradient computation\" ) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Subset not found in MBE gradient!\" end if end if ! Subtract pre-computed delta gradient (simple array subtraction in system coords) delta_gradients (:, :, fragment_idx ) = delta_gradients (:, :, fragment_idx ) - & delta_gradients (:, :, subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end subroutine compute_mbe_gradient","tags":"","url":"proc/compute_mbe_gradient.html"},{"title":"compute_mbe_hessian – metalquicha","text":"private  subroutine compute_mbe_hessian(fragment_idx, fragment, lookup, results, delta_hessians, n, sys_geom, bonds) Uses mqc_config_parser mqc_result_types mqc_error proc~~compute_mbe_hessian~~UsesGraph proc~compute_mbe_hessian compute_mbe_hessian module~mqc_config_parser mqc_config_parser proc~compute_mbe_hessian->module~mqc_config_parser module~mqc_error mqc_error proc~compute_mbe_hessian->module~mqc_error module~mqc_result_types mqc_result_types proc~compute_mbe_hessian->module~mqc_result_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Bottom-up computation of n-body Hessian correction\nMirrors MBE gradient logic but for second derivatives Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_hessians (:,:,:) (3 total_atoms, 3 total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~compute_mbe_hessian~~CallsGraph proc~compute_mbe_hessian compute_mbe_hessian proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_hessian->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_hessian->proc~get_next_combination proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_indices->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_hessian~~CalledByGraph proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: has_next integer, private :: hess_dim integer, private :: i integer, private :: indices (MAX_MBE_LEVEL) integer, private :: subset (MAX_MBE_LEVEL) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code subroutine compute_mbe_hessian ( fragment_idx , fragment , lookup , results , delta_hessians , n , sys_geom , bonds ) !! Bottom-up computation of n-body Hessian correction !! Mirrors MBE gradient logic but for second derivatives use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t use mqc_error , only : error_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_hessians (:, :, :) !! (3*total_atoms, 3*total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) integer :: subset_size , i , hess_dim integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next hess_dim = 3 * sys_geom % total_atoms ! Start with the full n-mer Hessian mapped to system coordinates call map_fragment_to_system_hessian ( results ( fragment_idx )% hessian , fragment , & sys_geom , delta_hessians (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do has_next = . true . do while ( has_next ) do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx > 0 ) then ! Subtract this subset's delta Hessian delta_hessians (:, :, fragment_idx ) = delta_hessians (:, :, fragment_idx ) - & delta_hessians (:, :, subset_idx ) end if call get_next_combination ( indices , subset_size , n , has_next ) end do end do end subroutine compute_mbe_hessian","tags":"","url":"proc/compute_mbe_hessian.html"},{"title":"get_monomer_atom_list – metalquicha","text":"private  subroutine get_monomer_atom_list(sys_geom, monomer_idx, atom_list, n_atoms) Build 0-indexed atom list for a monomer, handling fixed or variable-sized fragments. Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_idx integer, intent(out), allocatable :: atom_list (:) integer, intent(out) :: n_atoms Called by proc~~get_monomer_atom_list~~CalledByGraph proc~get_monomer_atom_list get_monomer_atom_list proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->proc~get_monomer_atom_list proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~process_intersection_derivatives Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: base_idx integer, private :: i Source Code subroutine get_monomer_atom_list ( sys_geom , monomer_idx , atom_list , n_atoms ) !! Build 0-indexed atom list for a monomer, handling fixed or variable-sized fragments. type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_idx integer , allocatable , intent ( out ) :: atom_list (:) integer , intent ( out ) :: n_atoms integer :: i , base_idx if ( allocated ( sys_geom % fragment_atoms )) then n_atoms = sys_geom % fragment_sizes ( monomer_idx ) if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = sys_geom % fragment_atoms ( 1 : n_atoms , monomer_idx ) else allocate ( atom_list ( 0 )) end if else n_atoms = sys_geom % atoms_per_monomer if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) base_idx = ( monomer_idx - 1 ) * sys_geom % atoms_per_monomer do i = 1 , n_atoms atom_list ( i ) = base_idx + ( i - 1 ) end do else allocate ( atom_list ( 0 )) end if end if end subroutine get_monomer_atom_list","tags":"","url":"proc/get_monomer_atom_list.html"},{"title":"map_fragment_to_system_dipole_derivatives – metalquicha","text":"private  subroutine map_fragment_to_system_dipole_derivatives(frag_dipole_derivs, monomers, sys_geom, sys_dipole_derivs, bonds) Uses mqc_config_parser mqc_error mqc_physical_fragment proc~~map_fragment_to_system_dipole_derivatives~~UsesGraph proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives module~mqc_config_parser mqc_config_parser proc~map_fragment_to_system_dipole_derivatives->module~mqc_config_parser module~mqc_error mqc_error proc~map_fragment_to_system_dipole_derivatives->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment proc~map_fragment_to_system_dipole_derivatives->module~mqc_physical_fragment module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Map fragment dipole derivatives to system coordinates with hydrogen cap redistribution Dipole derivatives have shape (3, 3*N) where each column corresponds to\nthe derivative of dipole w.r.t. one Cartesian coordinate of one atom. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_dipole_derivs (:,:) (3, 3*natoms_frag) integer, intent(in) :: monomers (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_dipole_derivs (:,:) (3, 3*total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~map_fragment_to_system_dipole_derivatives~~CallsGraph proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~redistribute_cap_dipole_derivatives proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_indices->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~map_fragment_to_system_dipole_derivatives~~CalledByGraph proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( error_t ), private :: error type( physical_fragment_t ), private :: fragment Source Code subroutine map_fragment_to_system_dipole_derivatives ( frag_dipole_derivs , monomers , sys_geom , sys_dipole_derivs , bonds ) !! Map fragment dipole derivatives to system coordinates with hydrogen cap redistribution !! !! Dipole derivatives have shape (3, 3*N) where each column corresponds to !! the derivative of dipole w.r.t. one Cartesian coordinate of one atom. use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_dipole_derivatives use mqc_config_parser , only : bond_t use mqc_error , only : error_t real ( dp ), intent ( in ) :: frag_dipole_derivs (:, :) !! (3, 3*natoms_frag) integer , intent ( in ) :: monomers (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_dipole_derivs (:, :) !! (3, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: fragment type ( error_t ) :: error ! Zero out sys_dipole_derivs = 0.0_dp if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , error , bonds ) call redistribute_cap_dipole_derivatives ( fragment , frag_dipole_derivs , sys_dipole_derivs ) call fragment % destroy () else ! Code path for fragments without hydrogen caps ! Map fragment dipole derivative columns to system positions (fixed-size monomers only) block integer :: i_mon , i_atom integer :: frag_atom_idx , sys_atom_idx integer :: frag_col_start , sys_col_start integer :: n_monomers n_monomers = size ( monomers ) frag_atom_idx = 0 ! Map each monomer's atoms do i_mon = 1 , n_monomers do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_idx = frag_atom_idx + 1 sys_atom_idx = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom frag_col_start = ( frag_atom_idx - 1 ) * 3 + 1 sys_col_start = ( sys_atom_idx - 1 ) * 3 + 1 ! Copy the 3 columns (x, y, z derivatives) for this atom sys_dipole_derivs (:, sys_col_start : sys_col_start + 2 ) = & frag_dipole_derivs (:, frag_col_start : frag_col_start + 2 ) end do end do end block end if end subroutine map_fragment_to_system_dipole_derivatives","tags":"","url":"proc/map_fragment_to_system_dipole_derivatives.html"},{"title":"map_fragment_to_system_gradient – metalquicha","text":"private  subroutine map_fragment_to_system_gradient(frag_grad, monomers, sys_geom, sys_grad, bonds, world_comm) Uses pic_logger mqc_config_parser mqc_error mqc_physical_fragment proc~~map_fragment_to_system_gradient~~UsesGraph proc~map_fragment_to_system_gradient map_fragment_to_system_gradient module~mqc_config_parser mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_config_parser module~mqc_error mqc_error proc~map_fragment_to_system_gradient->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment proc~map_fragment_to_system_gradient->module~mqc_physical_fragment pic_logger pic_logger proc~map_fragment_to_system_gradient->pic_logger module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Map fragment gradient to system gradient coordinates with hydrogen cap redistribution This function rebuilds the fragment to get local→global mappings and cap information,\nthen redistributes gradients including hydrogen caps to their original atoms. If bonds are not present, uses the old simple mapping (no caps possible). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_grad (:,:) (3, natoms_frag) integer, intent(in) :: monomers (:) Monomer indices in fragment type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_grad (:,:) (3, total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps type(comm_t), intent(in), optional :: world_comm MPI communicator for abort Calls proc~~map_fragment_to_system_gradient~~CallsGraph proc~map_fragment_to_system_gradient map_fragment_to_system_gradient abort_comm abort_comm proc~map_fragment_to_system_gradient->abort_comm configuration configuration proc~map_fragment_to_system_gradient->configuration debug debug proc~map_fragment_to_system_gradient->debug error error proc~map_fragment_to_system_gradient->error proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~map_fragment_to_system_gradient->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~map_fragment_to_system_gradient~~CalledByGraph proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: current_log_level type( error_t ), private :: error integer, private :: frag_atom_idx type( physical_fragment_t ), private :: fragment integer, private :: i_atom integer, private :: i_mon integer, private :: sys_atom_idx Source Code subroutine map_fragment_to_system_gradient ( frag_grad , monomers , sys_geom , sys_grad , bonds , world_comm ) !! Map fragment gradient to system gradient coordinates with hydrogen cap redistribution !! !! This function rebuilds the fragment to get local→global mappings and cap information, !! then redistributes gradients including hydrogen caps to their original atoms. !! !! If bonds are not present, uses the old simple mapping (no caps possible). use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_gradients use mqc_config_parser , only : bond_t use mqc_error , only : error_t use pic_logger , only : verbose_level real ( dp ), intent ( in ) :: frag_grad (:, :) !! (3, natoms_frag) integer , intent ( in ) :: monomers (:) !! Monomer indices in fragment type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_grad (:, :) !! (3, total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort type ( physical_fragment_t ) :: fragment type ( error_t ) :: error integer :: i_mon , i_atom , frag_atom_idx , sys_atom_idx integer :: current_log_level ! Explicitly zero out the entire sys_grad array sys_grad = 0.0_dp ! Debug output call logger % configuration ( level = current_log_level ) if ( current_log_level >= debug_level ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,*(i0,1x))' ) \"  Mapping fragment with \" , size ( monomers ), \" monomers: \" , monomers call logger % debug ( trim ( debug_msg )) write ( debug_msg , '(a,i0,a)' ) \"  Fragment has \" , size ( frag_grad , 2 ), \" atoms\" call logger % debug ( trim ( debug_msg )) end block end if if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Failed to build fragment in gradient mapping\" end if end if ! Use new gradient redistribution with cap handling call redistribute_cap_gradients ( fragment , frag_grad , sys_grad ) ! Clean up call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment gradient to system positions (fixed-size monomers only) frag_atom_idx = 0 do i_mon = 1 , size ( monomers ) do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_idx = frag_atom_idx + 1 sys_atom_idx = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom if ( current_log_level >= debug_level . and . i_atom == 1 ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,i0,a,i0)' ) & \"    Monomer \" , monomers ( i_mon ), \": frag atoms \" , & frag_atom_idx , \" -> sys atom \" , sys_atom_idx call logger % debug ( trim ( debug_msg )) end block end if sys_grad (:, sys_atom_idx ) = frag_grad (:, frag_atom_idx ) end do end do end if end subroutine map_fragment_to_system_gradient","tags":"","url":"proc/map_fragment_to_system_gradient.html"},{"title":"map_fragment_to_system_hessian – metalquicha","text":"private  subroutine map_fragment_to_system_hessian(frag_hess, monomers, sys_geom, sys_hess, bonds) Uses mqc_config_parser mqc_error mqc_physical_fragment proc~~map_fragment_to_system_hessian~~UsesGraph proc~map_fragment_to_system_hessian map_fragment_to_system_hessian module~mqc_config_parser mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_config_parser module~mqc_error mqc_error proc~map_fragment_to_system_hessian->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment proc~map_fragment_to_system_hessian->module~mqc_physical_fragment module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_hess (:,:) (3 natoms_frag, 3 natoms_frag) integer, intent(in) :: monomers (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_hess (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~map_fragment_to_system_hessian~~CallsGraph proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_indices->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~map_fragment_to_system_hessian~~CalledByGraph proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( error_t ), private :: error type( physical_fragment_t ), private :: fragment Source Code subroutine map_fragment_to_system_hessian ( frag_hess , monomers , sys_geom , sys_hess , bonds ) !! Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_hessian use mqc_config_parser , only : bond_t use mqc_error , only : error_t real ( dp ), intent ( in ) :: frag_hess (:, :) !! (3*natoms_frag, 3*natoms_frag) integer , intent ( in ) :: monomers (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_hess (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: fragment type ( error_t ) :: error ! Zero out sys_hess = 0.0_dp if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , error , bonds ) call redistribute_cap_hessian ( fragment , frag_hess , sys_hess ) call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment Hessian to system positions (fixed-size monomers only) block integer :: i_mon , j_mon , i_atom , j_atom integer :: frag_atom_i , frag_atom_j , sys_atom_i , sys_atom_j integer :: frag_row_start , frag_col_start , sys_row_start , sys_col_start integer :: n_monomers n_monomers = size ( monomers ) frag_atom_i = 0 ! Map each monomer's atoms do i_mon = 1 , n_monomers do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_i = frag_atom_i + 1 sys_atom_i = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom frag_row_start = ( frag_atom_i - 1 ) * 3 + 1 sys_row_start = ( sys_atom_i - 1 ) * 3 + 1 ! Map this atom's Hessian blocks with all other atoms in fragment frag_atom_j = 0 do j_mon = 1 , n_monomers do j_atom = 1 , sys_geom % atoms_per_monomer frag_atom_j = frag_atom_j + 1 sys_atom_j = ( monomers ( j_mon ) - 1 ) * sys_geom % atoms_per_monomer + j_atom frag_col_start = ( frag_atom_j - 1 ) * 3 + 1 sys_col_start = ( sys_atom_j - 1 ) * 3 + 1 ! Copy the 3×3 block for this atom pair sys_hess ( sys_row_start : sys_row_start + 2 , sys_col_start : sys_col_start + 2 ) = & frag_hess ( frag_row_start : frag_row_start + 2 , frag_col_start : frag_col_start + 2 ) end do end do end do end do end block end if end subroutine map_fragment_to_system_hessian","tags":"","url":"proc/map_fragment_to_system_hessian.html"},{"title":"print_gmbe_energy_breakdown – metalquicha","text":"private  subroutine print_gmbe_energy_breakdown(monomer_energy, n_monomers, level_energies, level_counts, max_level, total_energy, has_intersections) Print GMBE energy breakdown using inclusion-exclusion principle Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: monomer_energy integer, intent(in) :: n_monomers real(kind=dp), intent(in), optional :: level_energies (:) integer, intent(in), optional :: level_counts (:) integer, intent(in) :: max_level real(kind=dp), intent(in) :: total_energy logical, intent(in) :: has_intersections Calls proc~~print_gmbe_energy_breakdown~~CallsGraph proc~print_gmbe_energy_breakdown print_gmbe_energy_breakdown info info proc~print_gmbe_energy_breakdown->info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_gmbe_energy_breakdown~~CalledByGraph proc~print_gmbe_energy_breakdown print_gmbe_energy_breakdown proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_gmbe_energy_breakdown Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: k character(len=256), private :: line real(kind=dp), private :: sign_factor Source Code subroutine print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & max_level , total_energy , has_intersections ) !! Print GMBE energy breakdown using inclusion-exclusion principle real ( dp ), intent ( in ) :: monomer_energy integer , intent ( in ) :: n_monomers real ( dp ), intent ( in ), optional :: level_energies (:) integer , intent ( in ), optional :: level_counts (:) integer , intent ( in ) :: max_level real ( dp ), intent ( in ) :: total_energy logical , intent ( in ) :: has_intersections integer :: k real ( dp ) :: sign_factor character ( len = 256 ) :: line if ( has_intersections ) then call logger % info ( \"GMBE Energy breakdown (Inclusion-Exclusion Principle):\" ) write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"):  \" , monomer_energy call logger % info ( trim ( line )) do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) if ( sign_factor > 0.0_dp ) then write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  +\" , level_energies ( k ) else write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  \" , level_energies ( k ) end if call logger % info ( trim ( line )) end if end do write ( line , '(a,f20.10)' ) \"  Total GMBE:      \" , total_energy call logger % info ( trim ( line )) else call logger % info ( \"GMBE Energy breakdown:\" ) write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"): \" , monomer_energy call logger % info ( trim ( line )) write ( line , '(a,f20.10)' ) \"  Total GMBE:  \" , total_energy call logger % info ( trim ( line )) end if end subroutine print_gmbe_energy_breakdown","tags":"","url":"proc/print_gmbe_energy_breakdown.html"},{"title":"print_gmbe_gradient_info – metalquicha","text":"private  subroutine print_gmbe_gradient_info(total_gradient, sys_geom, current_log_level) Print GMBE gradient information Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_gradient (:,:) type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: current_log_level Calls proc~~print_gmbe_gradient_info~~CallsGraph proc~print_gmbe_gradient_info print_gmbe_gradient_info info info proc~print_gmbe_gradient_info->info to_char to_char proc~print_gmbe_gradient_info->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_gmbe_gradient_info~~CalledByGraph proc~print_gmbe_gradient_info print_gmbe_gradient_info proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_gmbe_gradient_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: grad_line integer, private :: iatom Source Code subroutine print_gmbe_gradient_info ( total_gradient , sys_geom , current_log_level ) !! Print GMBE gradient information real ( dp ), intent ( in ) :: total_gradient (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: current_log_level integer :: iatom character ( len = 256 ) :: grad_line call logger % info ( \"GMBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end do call logger % info ( \" \" ) end if end subroutine print_gmbe_gradient_info","tags":"","url":"proc/print_gmbe_gradient_info.html"},{"title":"print_gmbe_intersection_debug – metalquicha","text":"private  subroutine print_gmbe_intersection_debug(n_intersections, n_monomers, intersection_sets, intersection_levels, intersection_results) Uses mqc_result_types proc~~print_gmbe_intersection_debug~~UsesGraph proc~print_gmbe_intersection_debug print_gmbe_intersection_debug module~mqc_result_types mqc_result_types proc~print_gmbe_intersection_debug->module~mqc_result_types module~mqc_error mqc_error module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib pic_types pic_types module~mqc_result_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Print debug information about GMBE intersections Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_intersections integer, intent(in) :: n_monomers integer, intent(in) :: intersection_sets (:,:) integer, intent(in) :: intersection_levels (:) type( calculation_result_t ), intent(in) :: intersection_results (:) Calls proc~~print_gmbe_intersection_debug~~CallsGraph proc~print_gmbe_intersection_debug print_gmbe_intersection_debug debug debug proc~print_gmbe_intersection_debug->debug proc~energy_total energy_t%energy_total proc~print_gmbe_intersection_debug->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_gmbe_intersection_debug~~CalledByGraph proc~print_gmbe_intersection_debug print_gmbe_intersection_debug proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_gmbe_intersection_debug Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=512), private :: detail_line integer, private :: i integer, private :: j integer, private :: set_size character(len=256), private :: set_str real(kind=dp), private :: sign_factor Source Code subroutine print_gmbe_intersection_debug ( n_intersections , n_monomers , intersection_sets , & intersection_levels , intersection_results ) !! Print debug information about GMBE intersections use mqc_result_types , only : calculation_result_t integer , intent ( in ) :: n_intersections , n_monomers integer , intent ( in ) :: intersection_sets (:, :) integer , intent ( in ) :: intersection_levels (:) type ( calculation_result_t ), intent ( in ) :: intersection_results (:) integer :: i , j , set_size real ( dp ) :: sign_factor character ( len = 512 ) :: detail_line character ( len = 256 ) :: set_str if ( n_intersections > 0 ) then call logger % debug ( \"GMBE intersection details:\" ) do i = 1 , n_intersections set_str = \"(\" set_size = 0 do j = 1 , n_monomers if ( intersection_sets ( j , i ) > 0 ) then if ( set_size > 0 ) set_str = trim ( set_str ) // \",\" write ( set_str , '(a,i0)' ) trim ( set_str ), intersection_sets ( j , i ) set_size = set_size + 1 end if end do set_str = trim ( set_str ) // \")\" sign_factor = real (( - 1 ) ** ( intersection_levels ( i ) + 1 ), dp ) write ( detail_line , '(a,i0,a,i0,a,a,a,f16.8)' ) & \"  Intersection \" , i , \": level=\" , intersection_levels ( i ), & \" fragments=\" , trim ( set_str ), \" energy=\" , intersection_results ( i )% energy % total () call logger % debug ( trim ( detail_line )) end do end if end subroutine print_gmbe_intersection_debug","tags":"","url":"proc/print_gmbe_intersection_debug.html"},{"title":"print_mbe_energy_breakdown – metalquicha","text":"private  subroutine print_mbe_energy_breakdown(sum_by_level, max_level, total_energy) Print MBE energy breakdown to logger Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sum_by_level (:) integer, intent(in) :: max_level real(kind=dp), intent(in) :: total_energy Calls proc~~print_mbe_energy_breakdown~~CallsGraph proc~print_mbe_energy_breakdown print_mbe_energy_breakdown info info proc~print_mbe_energy_breakdown->info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_mbe_energy_breakdown~~CalledByGraph proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_mbe_energy_breakdown proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: energy_line integer, private :: nlevel Source Code subroutine print_mbe_energy_breakdown ( sum_by_level , max_level , total_energy ) !! Print MBE energy breakdown to logger real ( dp ), intent ( in ) :: sum_by_level (:) integer , intent ( in ) :: max_level real ( dp ), intent ( in ) :: total_energy integer :: nlevel character ( len = 256 ) :: energy_line call logger % info ( \"MBE Energy breakdown:\" ) do nlevel = 1 , max_level if ( abs ( sum_by_level ( nlevel )) > 1e-15_dp ) then write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , nlevel , \"-body:  \" , sum_by_level ( nlevel ) call logger % info ( trim ( energy_line )) end if end do write ( energy_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( energy_line )) end subroutine print_mbe_energy_breakdown","tags":"","url":"proc/print_mbe_energy_breakdown.html"},{"title":"print_mbe_gradient_info – metalquicha","text":"private  subroutine print_mbe_gradient_info(total_gradient, sys_geom, current_log_level) Print MBE gradient information Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_gradient (:,:) type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: current_log_level Calls proc~~print_mbe_gradient_info~~CallsGraph proc~print_mbe_gradient_info print_mbe_gradient_info info info proc~print_mbe_gradient_info->info to_char to_char proc~print_mbe_gradient_info->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_mbe_gradient_info~~CalledByGraph proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_mbe_gradient_info proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: grad_line integer, private :: iatom Source Code subroutine print_mbe_gradient_info ( total_gradient , sys_geom , current_log_level ) !! Print MBE gradient information real ( dp ), intent ( in ) :: total_gradient (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: current_log_level integer :: iatom character ( len = 256 ) :: grad_line call logger % info ( \"MBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total MBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end do call logger % info ( \" \" ) end if end subroutine print_mbe_gradient_info","tags":"","url":"proc/print_mbe_gradient_info.html"},{"title":"process_intersection_derivatives – metalquicha","text":"private  subroutine process_intersection_derivatives(inter_idx, k, sign_factor, intersection_results, intersection_sets, sys_geom, total_gradient, total_hessian, bonds, compute_grad, compute_hess, hess_dim, world_comm) Uses mqc_gmbe_utils mqc_error mqc_result_types mqc_config_parser mqc_physical_fragment proc~~process_intersection_derivatives~~UsesGraph proc~process_intersection_derivatives process_intersection_derivatives module~mqc_config_parser mqc_config_parser proc~process_intersection_derivatives->module~mqc_config_parser module~mqc_error mqc_error proc~process_intersection_derivatives->module~mqc_error module~mqc_gmbe_utils mqc_gmbe_utils proc~process_intersection_derivatives->module~mqc_gmbe_utils module~mqc_physical_fragment mqc_physical_fragment proc~process_intersection_derivatives->module~mqc_physical_fragment module~mqc_result_types mqc_result_types proc~process_intersection_derivatives->module~mqc_result_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_gmbe_utils->module~mqc_error module~mqc_combinatorics mqc_combinatorics module~mqc_gmbe_utils->module~mqc_combinatorics pic_io pic_io module~mqc_gmbe_utils->pic_io pic_logger pic_logger module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Process derivatives for a single intersection fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: inter_idx integer, intent(in) :: k real(kind=dp), intent(in) :: sign_factor type( calculation_result_t ), intent(in) :: intersection_results (:) integer, intent(in) :: intersection_sets (:,:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: total_gradient (:,:) real(kind=dp), intent(inout), optional :: total_hessian (:,:) type( bond_t ), intent(in), optional :: bonds (:) logical, intent(in) :: compute_grad logical, intent(in) :: compute_hess integer, intent(in) :: hess_dim type(comm_t), intent(in), optional :: world_comm Calls proc~~process_intersection_derivatives~~CallsGraph proc~process_intersection_derivatives process_intersection_derivatives abort_comm abort_comm proc~process_intersection_derivatives->abort_comm error error proc~process_intersection_derivatives->error proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~error_get_full_trace error_t%error_get_full_trace proc~process_intersection_derivatives->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~process_intersection_derivatives->proc~error_has_error proc~find_fragment_intersection find_fragment_intersection proc~process_intersection_derivatives->proc~find_fragment_intersection proc~fragment_destroy physical_fragment_t%fragment_destroy proc~process_intersection_derivatives->proc~fragment_destroy proc~get_monomer_atom_list get_monomer_atom_list proc~process_intersection_derivatives->proc~get_monomer_atom_list proc~redistribute_cap_gradients redistribute_cap_gradients proc~process_intersection_derivatives->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~process_intersection_derivatives->proc~redistribute_cap_hessian warning warning proc~process_intersection_derivatives->warning proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~process_intersection_derivatives~~CalledByGraph proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~process_intersection_derivatives Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: current_atoms (:) integer, private :: current_n logical, private :: has_intersection type( error_t ), private :: inter_error type( physical_fragment_t ), private :: inter_fragment integer, private, allocatable :: intersect_atoms (:) integer, private :: j integer, private :: n_intersect integer, private, allocatable :: next_atoms (:) integer, private :: next_n real(kind=dp), private, allocatable :: term_gradient (:,:) real(kind=dp), private, allocatable :: term_hessian (:,:) Source Code subroutine process_intersection_derivatives ( inter_idx , k , sign_factor , intersection_results , & intersection_sets , sys_geom , total_gradient , & total_hessian , bonds , compute_grad , compute_hess , hess_dim , world_comm ) !! Process derivatives for a single intersection fragment use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_atom_list , & redistribute_cap_gradients , redistribute_cap_hessian use mqc_gmbe_utils , only : find_fragment_intersection use mqc_config_parser , only : bond_t use mqc_error , only : error_t integer , intent ( in ) :: inter_idx , k real ( dp ), intent ( in ) :: sign_factor type ( calculation_result_t ), intent ( in ) :: intersection_results (:) integer , intent ( in ) :: intersection_sets (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: total_gradient (:, :) real ( dp ), intent ( inout ), optional :: total_hessian (:, :) type ( bond_t ), intent ( in ), optional :: bonds (:) logical , intent ( in ) :: compute_grad , compute_hess integer , intent ( in ) :: hess_dim type ( comm_t ), intent ( in ), optional :: world_comm integer :: j , current_n , next_n , n_intersect integer , allocatable :: current_atoms (:), next_atoms (:), intersect_atoms (:) real ( dp ), allocatable :: term_gradient (:, :), term_hessian (:, :) logical :: has_intersection type ( physical_fragment_t ) :: inter_fragment type ( error_t ) :: inter_error ! Build the intersection atom list call get_monomer_atom_list ( sys_geom , intersection_sets ( 1 , inter_idx ), current_atoms , current_n ) if ( current_n > 0 ) then do j = 2 , k call get_monomer_atom_list ( sys_geom , intersection_sets ( j , inter_idx ), next_atoms , next_n ) has_intersection = find_fragment_intersection ( current_atoms , current_n , & next_atoms , next_n , & intersect_atoms , n_intersect ) deallocate ( current_atoms , next_atoms ) if (. not . has_intersection ) then current_n = 0 exit end if current_n = n_intersect allocate ( current_atoms ( current_n )) current_atoms = intersect_atoms deallocate ( intersect_atoms ) end do end if if ( current_n > 0 ) then call build_fragment_from_atom_list ( sys_geom , current_atoms , current_n , & inter_fragment , inter_error , bonds ) if ( inter_error % has_error ()) then call logger % error ( inter_error % get_full_trace ()) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Failed to build intersection fragment in GMBE\" end if end if if ( compute_grad . and . intersection_results ( inter_idx )% has_gradient ) then allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp call redistribute_cap_gradients ( inter_fragment , intersection_results ( inter_idx )% gradient , & term_gradient ) total_gradient = total_gradient + sign_factor * term_gradient deallocate ( term_gradient ) end if if ( compute_hess . and . intersection_results ( inter_idx )% has_hessian ) then allocate ( term_hessian ( hess_dim , hess_dim )) term_hessian = 0.0_dp call redistribute_cap_hessian ( inter_fragment , intersection_results ( inter_idx )% hessian , & term_hessian ) total_hessian = total_hessian + sign_factor * term_hessian deallocate ( term_hessian ) end if call inter_fragment % destroy () else call logger % warning ( \"GMBE intersection has no atoms; skipping derivatives\" ) end if if ( allocated ( current_atoms )) deallocate ( current_atoms ) end subroutine process_intersection_derivatives","tags":"","url":"proc/process_intersection_derivatives.html"},{"title":"get_solvent_dielectric – metalquicha","text":"private pure function get_solvent_dielectric(solvent_name) result(eps) Get dielectric constant for a named solvent Returns the static dielectric constant (relative permittivity) for common solvents.\nReturns -1.0 if the solvent is not found. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: solvent_name Return Value real(kind=wp) Called by proc~~get_solvent_dielectric~~CalledByGraph proc~get_solvent_dielectric get_solvent_dielectric proc~add_solvation_to_calc add_solvation_to_calc proc~add_solvation_to_calc->proc~get_solvent_dielectric proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~xtb_calc_energy->proc~add_solvation_to_calc proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~xtb_calc_gradient->proc~add_solvation_to_calc proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~xtb_calc_gradient Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=32), private :: name_lower Source Code pure function get_solvent_dielectric ( solvent_name ) result ( eps ) !! Get dielectric constant for a named solvent !! !! Returns the static dielectric constant (relative permittivity) for common solvents. !! Returns -1.0 if the solvent is not found. character ( len =* ), intent ( in ) :: solvent_name real ( wp ) :: eps character ( len = 32 ) :: name_lower integer :: i ! Convert to lowercase for case-insensitive matching name_lower = solvent_name do i = 1 , len_trim ( name_lower ) if ( name_lower ( i : i ) >= 'A' . and . name_lower ( i : i ) <= 'Z' ) then name_lower ( i : i ) = char ( ichar ( name_lower ( i : i )) + 32 ) end if end do select case ( trim ( name_lower )) ! Water case ( 'water' , 'h2o' ) eps = 7 8.4_wp ! Alcohols case ( 'methanol' , 'ch3oh' ) eps = 3 2.7_wp case ( 'ethanol' , 'c2h5oh' ) eps = 2 4.6_wp case ( '1-propanol' , 'propanol' ) eps = 2 0.1_wp case ( '2-propanol' , 'isopropanol' ) eps = 1 9.9_wp case ( '1-butanol' , 'butanol' ) eps = 1 7.5_wp case ( '2-butanol' ) eps = 1 5.8_wp case ( '1-octanol' , 'octanol' ) eps = 9.9_wp ! Polar aprotic case ( 'acetone' ) eps = 2 0.7_wp case ( 'acetonitrile' , 'ch3cn' ) eps = 3 7.5_wp case ( 'dmso' , 'dimethylsulfoxide' ) eps = 4 6.7_wp case ( 'dmf' , 'dimethylformamide' ) eps = 3 6.7_wp case ( 'thf' , 'tetrahydrofuran' ) eps = 7.6_wp case ( 'formamide' ) eps = 10 9.5_wp ! Aromatics case ( 'benzene' ) eps = 2.3_wp case ( 'toluene' ) eps = 2.4_wp case ( 'pyridine' ) eps = 1 2.4_wp case ( 'aniline' ) eps = 6.9_wp case ( 'nitrobenzene' ) eps = 3 4.8_wp case ( 'chlorobenzene' ) eps = 5.6_wp ! Halogenated case ( 'chloroform' , 'chcl3' ) eps = 4.8_wp case ( 'dichloromethane' , 'ch2cl2' , 'dcm' ) eps = 8.9_wp case ( 'carbon tetrachloride' , 'ccl4' ) eps = 2.2_wp ! Ethers case ( 'diethylether' , 'ether' ) eps = 4.3_wp case ( 'dioxane' ) eps = 2.2_wp case ( 'furan' ) eps = 2.9_wp ! Alkanes case ( 'pentane' ) eps = 1.8_wp case ( 'hexane' , 'n-hexane' ) eps = 1.9_wp case ( 'cyclohexane' ) eps = 2.0_wp case ( 'heptane' , 'n-heptane' ) eps = 1.9_wp case ( 'octane' , 'n-octane' ) eps = 1.9_wp case ( 'decane' ) eps = 2.0_wp case ( 'hexadecane' ) eps = 2.0_wp ! Other case ( 'nitromethane' ) eps = 3 5.9_wp case ( 'cs2' , 'carbondisulfide' ) eps = 2.6_wp case ( 'ethyl acetate' , 'ethylacetate' ) eps = 6.0_wp case ( 'acetic acid' , 'aceticacid' ) eps = 6.2_wp case ( 'formic acid' , 'formicacid' ) eps = 5 1.1_wp case ( 'phenol' ) eps = 9.8_wp case ( 'woctanol' ) eps = 8.1_wp ! Infinite dielectric (conductor) case ( 'inf' ) eps = 1.0e10_wp case default eps = - 1.0_wp ! Unknown solvent end select end function get_solvent_dielectric","tags":"","url":"proc/get_solvent_dielectric.html"},{"title":"add_solvation_to_calc – metalquicha","text":"private  subroutine add_solvation_to_calc(calc, mol, solvent, solvation_model, method, use_cds, use_shift, dielectric, cpcm_nang, cpcm_rscale, error) Add implicit solvation model to XTB calculator Adds ALPB, GBSA, or CPCM solvation. For ALPB/GBSA, optionally adds CDS and shift corrections.\nCPCM does not support CDS or shift corrections. Arguments Type Intent Optional Attributes Name type(xtb_calculator), intent(inout) :: calc type(structure_type), intent(in) :: mol character(len=*), intent(in) :: solvent Solvent name (can be empty if dielectric > 0) character(len=*), intent(in) :: solvation_model “alpb”, “gbsa”, or “cpcm” character(len=*), intent(in) :: method “gfn1” or “gfn2” logical, intent(in) :: use_cds logical, intent(in) :: use_shift real(kind=wp), intent(in) :: dielectric Direct dielectric constant (-1 = use solvent lookup) integer, intent(in) :: cpcm_nang Angular grid points for CPCM real(kind=wp), intent(in) :: cpcm_rscale Radii scaling for CPCM type(error_type), intent(out), allocatable :: error Calls proc~~add_solvation_to_calc~~CallsGraph proc~add_solvation_to_calc add_solvation_to_calc new_solvation new_solvation proc~add_solvation_to_calc->new_solvation new_solvation_cds new_solvation_cds proc~add_solvation_to_calc->new_solvation_cds new_solvation_shift new_solvation_shift proc~add_solvation_to_calc->new_solvation_shift proc~get_solvent_dielectric get_solvent_dielectric proc~add_solvation_to_calc->proc~get_solvent_dielectric push_back push_back proc~add_solvation_to_calc->push_back Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_solvation_to_calc~~CalledByGraph proc~add_solvation_to_calc add_solvation_to_calc proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~xtb_calc_energy->proc~add_solvation_to_calc proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~xtb_calc_gradient->proc~add_solvation_to_calc proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~xtb_calc_gradient Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial class(container_type), private, allocatable :: cont real(kind=wp), private :: eps class(solvation_type), private, allocatable :: solv type(solvation_input), private :: solv_input logical, private :: use_alpb Source Code subroutine add_solvation_to_calc ( calc , mol , solvent , solvation_model , method , use_cds , use_shift , & dielectric , cpcm_nang , cpcm_rscale , error ) !! Add implicit solvation model to XTB calculator !! !! Adds ALPB, GBSA, or CPCM solvation. For ALPB/GBSA, optionally adds CDS and shift corrections. !! CPCM does not support CDS or shift corrections. type ( xtb_calculator ), intent ( inout ) :: calc type ( structure_type ), intent ( in ) :: mol character ( len =* ), intent ( in ) :: solvent !! Solvent name (can be empty if dielectric > 0) character ( len =* ), intent ( in ) :: solvation_model !! \"alpb\", \"gbsa\", or \"cpcm\" character ( len =* ), intent ( in ) :: method !! \"gfn1\" or \"gfn2\" logical , intent ( in ) :: use_cds , use_shift real ( wp ), intent ( in ) :: dielectric !! Direct dielectric constant (-1 = use solvent lookup) integer , intent ( in ) :: cpcm_nang !! Angular grid points for CPCM real ( wp ), intent ( in ) :: cpcm_rscale !! Radii scaling for CPCM type ( error_type ), allocatable , intent ( out ) :: error type ( solvation_input ) :: solv_input class ( container_type ), allocatable :: cont class ( solvation_type ), allocatable :: solv logical :: use_alpb real ( wp ) :: eps ! Handle CPCM model separately if ( trim ( solvation_model ) == 'cpcm' ) then ! CPCM does not support CDS or shift - silently skip them ! (use_cds and use_shift are ignored for CPCM) ! Get dielectric constant (direct value or lookup from solvent name) if ( dielectric > 0.0_wp ) then eps = dielectric else if ( len_trim ( solvent ) > 0 ) then eps = get_solvent_dielectric ( solvent ) if ( eps < 0.0_wp ) then allocate ( error ) error % message = \"Unknown solvent for CPCM dielectric lookup: \" // trim ( solvent ) return end if else allocate ( error ) error % message = \"CPCM requires either solvent name or dielectric constant\" return end if ! Create CPCM solvation allocate ( solv_input % cpcm ) solv_input % cpcm % dielectric_const = eps solv_input % cpcm % nang = cpcm_nang solv_input % cpcm % rscale = cpcm_rscale call new_solvation ( solv , mol , solv_input , error ) if ( allocated ( error )) return call move_alloc ( solv , cont ) call calc % push_back ( cont ) return end if ! For ALPB/GBSA, we need a solvent name if ( len_trim ( solvent ) == 0 ) then allocate ( error ) error % message = \"ALPB/GBSA solvation requires a solvent name\" return end if ! Determine if using ALPB or GBSA (GBSA = ALPB with alpb flag false) use_alpb = . true . if ( trim ( solvation_model ) == 'gbsa' ) then use_alpb = . false . end if ! 1. Add ALPB/GBSA (polar electrostatic solvation) allocate ( solv_input % alpb ) solv_input % alpb % solvent = solvent solv_input % alpb % alpb = use_alpb call new_solvation ( solv , mol , solv_input , error , method ) if ( allocated ( error )) return call move_alloc ( solv , cont ) call calc % push_back ( cont ) deallocate ( solv_input % alpb ) ! 2. Add CDS (non-polar: cavity, dispersion, surface) if requested if ( use_cds ) then allocate ( solv_input % cds ) solv_input % cds % solvent = solvent call new_solvation_cds ( solv , mol , solv_input , error , method ) if ( allocated ( error )) return call move_alloc ( solv , cont ) call calc % push_back ( cont ) deallocate ( solv_input % cds ) end if ! 3. Add shift (solution state correction) if requested if ( use_shift ) then allocate ( solv_input % shift ) solv_input % shift % solvent = solvent call new_solvation_shift ( solv , solv_input , error , method ) if ( allocated ( error )) return call move_alloc ( solv , cont ) call calc % push_back ( cont ) end if end subroutine add_solvation_to_calc","tags":"","url":"proc/add_solvation_to_calc.html"},{"title":"xtb_calc_energy – metalquicha","text":"private  subroutine xtb_calc_energy(this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Type Bound xtb_method_t Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~xtb_calc_energy~~CallsGraph proc~xtb_calc_energy xtb_method_t%xtb_calc_energy dpat dpat proc~xtb_calc_energy->dpat new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction proc~add_solvation_to_calc add_solvation_to_calc proc~xtb_calc_energy->proc~add_solvation_to_calc proc~energy_total energy_t%energy_total proc~xtb_calc_energy->proc~energy_total proc~error_set error_t%error_set proc~xtb_calc_energy->proc~error_set qat qat proc~xtb_calc_energy->qat xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint new_solvation new_solvation proc~add_solvation_to_calc->new_solvation new_solvation_cds new_solvation_cds proc~add_solvation_to_calc->new_solvation_cds new_solvation_shift new_solvation_shift proc~add_solvation_to_calc->new_solvation_shift proc~get_solvent_dielectric get_solvent_dielectric proc~add_solvation_to_calc->proc~get_solvent_dielectric push_back push_back proc~add_solvation_to_calc->push_back proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(xtb_calculator), private :: calc type(context_type), private :: ctx real(kind=wp), private :: dipole_wp (3) real(kind=wp), private :: energy type(error_type), private, allocatable :: error type(structure_type), private :: mol integer, private, allocatable :: num (:) integer, private :: verbosity type(wavefunction_type), private :: wfn real(kind=wp), private, allocatable :: xyz (:,:) Source Code subroutine xtb_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity real ( wp ) :: dipole_wp ( 3 ) if ( this % verbose ) then print * , \"XTB: Calculating energy using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge if ( allocated ( this % solvent )) then if ( allocated ( this % solvation_model )) then print * , \"XTB: Solvation: \" , trim ( this % solvation_model ), \" with solvent = \" , this % solvent else print * , \"XTB: Solvation: alpb with solvent = \" , this % solvent end if else print * , \"XTB: Solvation: none (gas phase)\" end if end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure ! charge is real(wp), multiplicity converted to uhf (unpaired electrons) call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default call result % error % set ( ERROR_VALIDATION , \"Unknown XTB variant: \" // this % variant ) result % has_error = . true . return end select if ( allocated ( error )) then call result % error % set ( ERROR_GENERIC , \"Failed to create XTB calculator\" ) result % has_error = . true . return end if ! Add solvation if configured (either solvent name or direct dielectric) if ( allocated ( this % solvent ) . or . this % dielectric > 0.0_wp ) then if ( allocated ( this % solvation_model )) then call add_solvation_to_calc ( calc , mol , this % solvent , this % solvation_model , this % variant , & this % use_cds , this % use_shift , this % dielectric , & this % cpcm_nang , this % cpcm_rscale , error ) else call add_solvation_to_calc ( calc , mol , this % solvent , \"alpb\" , this % variant , & this % use_cds , this % use_shift , this % dielectric , & this % cpcm_nang , this % cpcm_rscale , error ) end if if ( allocated ( error )) then call result % error % set ( ERROR_GENERIC , \"Failed to add solvation: \" // error % message ) result % has_error = . true . return end if end if ! Create wavefunction and run single point calculation call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt ) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , verbosity = verbosity ) ! Compute molecular dipole moment from wavefunction dipole_wp (:) = matmul ( mol % xyz , wfn % qat (:, 1 )) + sum ( wfn % dpat (:, :, 1 ), 2 ) ! Store result (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . ! Store dipole moment allocate ( result % dipole ( 3 )) result % dipole = real ( dipole_wp , dp ) result % has_dipole = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () print * , \"XTB: Dipole (e*Bohr) =\" , result % dipole print * , \"XTB: Dipole magnitude (Debye) =\" , norm2 ( result % dipole ) * 2.541746_dp end if deallocate ( num , xyz ) end subroutine xtb_calc_energy","tags":"","url":"proc/xtb_calc_energy.html"},{"title":"xtb_calc_gradient – metalquicha","text":"private  subroutine xtb_calc_gradient(this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Type Bound xtb_method_t Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~xtb_calc_gradient~~CallsGraph proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient dpat dpat proc~xtb_calc_gradient->dpat new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction proc~add_solvation_to_calc add_solvation_to_calc proc~xtb_calc_gradient->proc~add_solvation_to_calc proc~energy_total energy_t%energy_total proc~xtb_calc_gradient->proc~energy_total proc~error_set error_t%error_set proc~xtb_calc_gradient->proc~error_set qat qat proc~xtb_calc_gradient->qat xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint new_solvation new_solvation proc~add_solvation_to_calc->new_solvation new_solvation_cds new_solvation_cds proc~add_solvation_to_calc->new_solvation_cds new_solvation_shift new_solvation_shift proc~add_solvation_to_calc->new_solvation_shift proc~get_solvent_dielectric get_solvent_dielectric proc~add_solvation_to_calc->proc~get_solvent_dielectric push_back push_back proc~add_solvation_to_calc->push_back proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~xtb_calc_gradient~~CalledByGraph proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~xtb_calc_gradient Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(xtb_calculator), private :: calc type(context_type), private :: ctx real(kind=wp), private :: dipole_wp (3) real(kind=wp), private :: energy type(error_type), private, allocatable :: error real(kind=wp), private, allocatable :: gradient (:,:) type(structure_type), private :: mol integer, private, allocatable :: num (:) real(kind=wp), private, allocatable :: sigma (:,:) integer, private :: verbosity type(wavefunction_type), private :: wfn real(kind=wp), private, allocatable :: xyz (:,:) Source Code subroutine xtb_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity real ( wp ), allocatable :: gradient (:, :) real ( wp ), allocatable :: sigma (:, :) real ( wp ) :: dipole_wp ( 3 ) if ( this % verbose ) then print * , \"XTB: Calculating gradient using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge if ( allocated ( this % solvent )) then if ( allocated ( this % solvation_model )) then print * , \"XTB: Solvation: \" , trim ( this % solvation_model ), \" with solvent = \" , this % solvent else print * , \"XTB: Solvation: alpb with solvent = \" , this % solvent end if else print * , \"XTB: Solvation: none (gas phase)\" end if end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default call result % error % set ( ERROR_VALIDATION , \"Unknown XTB variant: \" // this % variant ) result % has_error = . true . return end select if ( allocated ( error )) then call result % error % set ( ERROR_GENERIC , \"Failed to create XTB calculator\" ) result % has_error = . true . return end if ! Add solvation if configured (either solvent name or direct dielectric) if ( allocated ( this % solvent ) . or . this % dielectric > 0.0_wp ) then if ( allocated ( this % solvation_model )) then call add_solvation_to_calc ( calc , mol , this % solvent , this % solvation_model , this % variant , & this % use_cds , this % use_shift , this % dielectric , & this % cpcm_nang , this % cpcm_rscale , error ) else call add_solvation_to_calc ( calc , mol , this % solvent , \"alpb\" , this % variant , & this % use_cds , this % use_shift , this % dielectric , & this % cpcm_nang , this % cpcm_rscale , error ) end if if ( allocated ( error )) then call result % error % set ( ERROR_GENERIC , \"Failed to add solvation: \" // error % message ) result % has_error = . true . return end if end if ! Allocate gradient and sigma arrays (initialize to zero) allocate ( gradient ( 3 , fragment % n_atoms )) allocate ( sigma ( 3 , 3 )) gradient = 0.0_wp sigma = 0.0_wp ! Create wavefunction and run single point calculation with gradient call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt , grad = . true .) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , & gradient = gradient , sigma = sigma , verbosity = verbosity ) ! Compute molecular dipole moment from wavefunction dipole_wp (:) = matmul ( mol % xyz , wfn % qat (:, 1 )) + sum ( wfn % dpat (:, :, 1 ), 2 ) ! Store results (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . ! Store gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = real ( gradient , dp ) result % has_gradient = . true . ! Store sigma (stress tensor) allocate ( result % sigma ( 3 , 3 )) result % sigma = real ( sigma , dp ) result % has_sigma = . true . ! Store dipole moment allocate ( result % dipole ( 3 )) result % dipole = real ( dipole_wp , dp ) result % has_dipole = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () print * , \"XTB: Gradient norm =\" , sqrt ( sum ( result % gradient ** 2 )) print * , \"XTB: Dipole (e*Bohr) =\" , result % dipole print * , \"XTB: Dipole magnitude (Debye) =\" , norm2 ( result % dipole ) * 2.541746_dp print * , \"XTB: Gradient calculation complete\" end if deallocate ( num , xyz , gradient , sigma ) end subroutine xtb_calc_gradient","tags":"","url":"proc/xtb_calc_gradient.html"},{"title":"xtb_calc_hessian – metalquicha","text":"private  subroutine xtb_calc_hessian(this, fragment, result) Uses pic_logger mqc_finite_differences pic_io proc~~xtb_calc_hessian~~UsesGraph proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian module~mqc_finite_differences mqc_finite_differences proc~xtb_calc_hessian->module~mqc_finite_differences pic_io pic_io proc~xtb_calc_hessian->pic_io pic_logger pic_logger proc~xtb_calc_hessian->pic_logger module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calculate Hessian using finite differences of gradients Since tblite does not natively support analytic Hessians, this routine\ncomputes the Hessian numerically via central finite differences:\n  H[i,j] = (grad_j(x_i + h) - grad_j(x_i - h)) / (2h) This requires 6N gradient calculations (forward and backward for each coordinate) Type Bound xtb_method_t Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~xtb_calc_hessian~~CallsGraph proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian info info proc~xtb_calc_hessian->info proc~error_set error_t%error_set proc~xtb_calc_hessian->proc~error_set proc~finite_diff_dipole_derivatives finite_diff_dipole_derivatives proc~xtb_calc_hessian->proc~finite_diff_dipole_derivatives proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~xtb_calc_hessian->proc~xtb_calc_gradient to_char to_char proc~xtb_calc_hessian->to_char proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~xtb_calc_gradient->proc~error_set dpat dpat proc~xtb_calc_gradient->dpat new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction proc~add_solvation_to_calc add_solvation_to_calc proc~xtb_calc_gradient->proc~add_solvation_to_calc proc~energy_total energy_t%energy_total proc~xtb_calc_gradient->proc~energy_total qat qat proc~xtb_calc_gradient->qat xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint new_solvation new_solvation proc~add_solvation_to_calc->new_solvation new_solvation_cds new_solvation_cds proc~add_solvation_to_calc->new_solvation_cds new_solvation_shift new_solvation_shift proc~add_solvation_to_calc->new_solvation_shift proc~get_solvent_dielectric get_solvent_dielectric proc~add_solvation_to_calc->proc~get_solvent_dielectric push_back push_back proc~add_solvation_to_calc->push_back proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: backward_dipoles (:,:) type( displaced_geometry_t ), private, allocatable :: backward_geoms (:) real(kind=dp), private, allocatable :: backward_gradients (:,:,:) logical, private :: compute_dipole_derivs type( calculation_result_t ), private :: disp_result real(kind=dp), private :: displacement real(kind=dp), private, allocatable :: forward_dipoles (:,:) type( displaced_geometry_t ), private, allocatable :: forward_geoms (:) real(kind=dp), private, allocatable :: forward_gradients (:,:,:) integer, private :: i integer, private :: n_atoms integer, private :: n_displacements Source Code subroutine xtb_calc_hessian ( this , fragment , result ) !! Calculate Hessian using finite differences of gradients !! !! Since tblite does not natively support analytic Hessians, this routine !! computes the Hessian numerically via central finite differences: !!   H[i,j] = (grad_j(x_i + h) - grad_j(x_i - h)) / (2h) !! !! This requires 6N gradient calculations (forward and backward for each coordinate) use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , finite_diff_dipole_derivatives , & DEFAULT_DISPLACEMENT use pic_logger , only : logger => global_logger use pic_io , only : to_char class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result type ( displaced_geometry_t ), allocatable :: forward_geoms (:), backward_geoms (:) real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: forward_dipoles (:, :) ! (n_displacements, 3) for IR intensities real ( dp ), allocatable :: backward_dipoles (:, :) ! (n_displacements, 3) for IR intensities type ( calculation_result_t ) :: disp_result real ( dp ) :: displacement integer :: n_atoms , n_displacements , i logical :: compute_dipole_derivs n_atoms = fragment % n_atoms n_displacements = 3 * n_atoms displacement = DEFAULT_DISPLACEMENT if ( this % verbose ) then call logger % info ( \"XTB: Computing Hessian via finite differences\" ) call logger % info ( \"  Method: Central differences of gradients\" ) call logger % info ( \"  Atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) call logger % info ( \"  Finite difference step size: \" // to_char ( displacement ) // \" Bohr\" ) end if ! Generate all perturbed geometries call generate_perturbed_geometries ( fragment , displacement , forward_geoms , backward_geoms ) ! Allocate storage for gradients at displaced geometries allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) ! Allocate storage for dipoles at displaced geometries (for IR intensities) allocate ( forward_dipoles ( n_displacements , 3 )) allocate ( backward_dipoles ( n_displacements , 3 )) forward_dipoles = 0.0_dp backward_dipoles = 0.0_dp compute_dipole_derivs = . true . ! Will be set to false if any dipole is missing ! Compute gradients at all forward-displaced geometries if ( this % verbose ) then call logger % info ( \"  Computing forward-displaced gradients...\" ) end if do i = 1 , n_displacements ! Forward call this % calc_gradient ( forward_geoms ( i )% geometry , disp_result ) if ( disp_result % has_error . or . . not . disp_result % has_gradient ) then call result % error % set ( ERROR_GENERIC , \"Failed to compute gradient for forward displacement \" // to_char ( i )) result % has_error = . true . call disp_result % destroy () return end if forward_gradients ( i , :, :) = disp_result % gradient ! Capture dipole for IR intensity calculation if ( disp_result % has_dipole ) then forward_dipoles ( i , :) = disp_result % dipole else compute_dipole_derivs = . false . end if call disp_result % destroy () ! Backward call this % calc_gradient ( backward_geoms ( i )% geometry , disp_result ) if ( disp_result % has_error . or . . not . disp_result % has_gradient ) then call result % error % set ( ERROR_GENERIC , \"Failed to compute gradient for backward displacement \" // to_char ( i )) result % has_error = . true . call disp_result % destroy () return end if backward_gradients ( i , :, :) = disp_result % gradient ! Capture dipole for IR intensity calculation if ( disp_result % has_dipole ) then backward_dipoles ( i , :) = disp_result % dipole else compute_dipole_derivs = . false . end if call disp_result % destroy () end do if ( this % verbose ) then call logger % info ( \"  Forward and backward gradient calculations complete \" ) end if ! Compute Hessian from finite differences if ( this % verbose ) then call logger % info ( \"  Assembling Hessian matrix...\" ) end if call finite_diff_hessian_from_gradients ( fragment , forward_gradients , backward_gradients , & displacement , result % hessian ) ! Compute dipole derivatives for IR intensity calculation if ( compute_dipole_derivs ) then call finite_diff_dipole_derivatives ( n_atoms , forward_dipoles , backward_dipoles , & displacement , result % dipole_derivatives ) result % has_dipole_derivatives = . true . if ( this % verbose ) then call logger % info ( \"  Dipole derivatives computed for IR intensities\" ) end if end if ! Also compute energy and gradient at reference geometry for completeness call this % calc_gradient ( fragment , disp_result ) if ( disp_result % has_error ) then result % error = disp_result % error result % has_error = . true . call disp_result % destroy () return end if result % energy = disp_result % energy result % has_energy = disp_result % has_energy if ( disp_result % has_gradient ) then allocate ( result % gradient ( 3 , n_atoms )) result % gradient = disp_result % gradient result % has_gradient = . true . end if call disp_result % destroy () result % has_hessian = . true . if ( this % verbose ) then call logger % info ( \"  Hessian calculation complete\" ) end if ! Cleanup deallocate ( forward_gradients , backward_gradients ) deallocate ( forward_dipoles , backward_dipoles ) do i = 1 , n_displacements call forward_geoms ( i )% destroy () call backward_geoms ( i )% destroy () end do deallocate ( forward_geoms , backward_geoms ) end subroutine xtb_calc_hessian","tags":"","url":"proc/xtb_calc_hessian.html"},{"title":"populate_unfragmented_json_data – metalquicha","text":"subroutine populate_unfragmented_json_data(json_data, result) Uses mqc_json_output_types proc~~populate_unfragmented_json_data~~UsesGraph proc~populate_unfragmented_json_data populate_unfragmented_json_data module~mqc_json_output_types mqc_json_output_types proc~populate_unfragmented_json_data->module~mqc_json_output_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry pic_types pic_types module~mqc_json_output_types->pic_types module~mqc_thermochemistry->pic_types module~mqc_elements mqc_elements module~mqc_thermochemistry->module~mqc_elements module~mqc_physical_constants mqc_physical_constants module~mqc_thermochemistry->module~mqc_physical_constants pic_io pic_io module~mqc_thermochemistry->pic_io pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces pic_logger pic_logger module~mqc_thermochemistry->pic_logger module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_constants->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Populate json_data with basic unfragmented calculation results Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(out) :: json_data type( calculation_result_t ), intent(in) :: result Calls proc~~populate_unfragmented_json_data~~CallsGraph proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~energy_total energy_t%energy_total proc~populate_unfragmented_json_data->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~populate_unfragmented_json_data~~CalledByGraph proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~populate_unfragmented_json_data interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine populate_unfragmented_json_data ( json_data , result ) !! Populate json_data with basic unfragmented calculation results use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_UNFRAGMENTED type ( json_output_data_t ), intent ( out ) :: json_data type ( calculation_result_t ), intent ( in ) :: result json_data % output_mode = OUTPUT_MODE_UNFRAGMENTED json_data % total_energy = result % energy % total () json_data % has_energy = . true . ! Copy gradient if available if ( result % has_gradient ) then allocate ( json_data % gradient ( size ( result % gradient , 1 ), size ( result % gradient , 2 ))) json_data % gradient = result % gradient json_data % has_gradient = . true . end if ! Copy dipole if available if ( result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = result % dipole json_data % has_dipole = . true . end if ! Copy Hessian if available if ( result % has_hessian ) then allocate ( json_data % hessian ( size ( result % hessian , 1 ), size ( result % hessian , 2 ))) json_data % hessian = result % hessian json_data % has_hessian = . true . end if end subroutine populate_unfragmented_json_data","tags":"","url":"proc/populate_unfragmented_json_data.html"},{"title":"populate_vibrational_json_data – metalquicha","text":"subroutine populate_vibrational_json_data(json_data, result, frequencies, reduced_masses, force_constants, thermo_result, ir_intensities) Uses mqc_thermochemistry mqc_json_output_types proc~~populate_vibrational_json_data~~UsesGraph proc~populate_vibrational_json_data populate_vibrational_json_data module~mqc_json_output_types mqc_json_output_types proc~populate_vibrational_json_data->module~mqc_json_output_types module~mqc_thermochemistry mqc_thermochemistry proc~populate_vibrational_json_data->module~mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry pic_types pic_types module~mqc_json_output_types->pic_types module~mqc_elements mqc_elements module~mqc_thermochemistry->module~mqc_elements module~mqc_physical_constants mqc_physical_constants module~mqc_thermochemistry->module~mqc_physical_constants pic_io pic_io module~mqc_thermochemistry->pic_io pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces pic_logger pic_logger module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_constants->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Populate json_data with vibrational analysis results Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(out) :: json_data type( calculation_result_t ), intent(in) :: result real(kind=dp), intent(in) :: frequencies (:) real(kind=dp), intent(in) :: reduced_masses (:) real(kind=dp), intent(in) :: force_constants (:) type( thermochemistry_result_t ), intent(in) :: thermo_result real(kind=dp), intent(in), optional :: ir_intensities (:) Calls proc~~populate_vibrational_json_data~~CallsGraph proc~populate_vibrational_json_data populate_vibrational_json_data proc~energy_total energy_t%energy_total proc~populate_vibrational_json_data->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~populate_vibrational_json_data~~CalledByGraph proc~populate_vibrational_json_data populate_vibrational_json_data proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~populate_vibrational_json_data interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: n_modes Source Code subroutine populate_vibrational_json_data ( json_data , result , frequencies , reduced_masses , & force_constants , thermo_result , ir_intensities ) !! Populate json_data with vibrational analysis results use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_UNFRAGMENTED use mqc_thermochemistry , only : thermochemistry_result_t type ( json_output_data_t ), intent ( out ) :: json_data type ( calculation_result_t ), intent ( in ) :: result real ( dp ), intent ( in ) :: frequencies (:) real ( dp ), intent ( in ) :: reduced_masses (:) real ( dp ), intent ( in ) :: force_constants (:) type ( thermochemistry_result_t ), intent ( in ) :: thermo_result real ( dp ), intent ( in ), optional :: ir_intensities (:) integer :: n_modes n_modes = size ( frequencies ) json_data % output_mode = OUTPUT_MODE_UNFRAGMENTED json_data % total_energy = result % energy % total () json_data % has_energy = . true . ! Copy gradient if available if ( result % has_gradient ) then allocate ( json_data % gradient ( size ( result % gradient , 1 ), size ( result % gradient , 2 ))) json_data % gradient = result % gradient json_data % has_gradient = . true . end if ! Copy dipole if available if ( result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = result % dipole json_data % has_dipole = . true . end if ! Copy Hessian if available if ( result % has_hessian ) then allocate ( json_data % hessian ( size ( result % hessian , 1 ), size ( result % hessian , 2 ))) json_data % hessian = result % hessian json_data % has_hessian = . true . end if ! Copy vibrational data allocate ( json_data % frequencies ( n_modes )) allocate ( json_data % reduced_masses ( n_modes )) allocate ( json_data % force_constants ( n_modes )) json_data % frequencies = frequencies json_data % reduced_masses = reduced_masses json_data % force_constants = force_constants json_data % has_vibrational = . true . ! Copy IR intensities if available if ( present ( ir_intensities )) then allocate ( json_data % ir_intensities ( n_modes )) json_data % ir_intensities = ir_intensities json_data % has_ir_intensities = . true . end if ! Copy thermochemistry json_data % thermo = thermo_result end subroutine populate_vibrational_json_data","tags":"","url":"proc/populate_vibrational_json_data.html"},{"title":"ang_mom_char_to_int – metalquicha","text":"public pure function ang_mom_char_to_int(ang_mom_char) result(ang_mom) Convert angular momentum character to integer Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6\nSpecial case: L=-1 (combined S+P shell, requires splitting) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ang_mom_char Angular momentum symbol Return Value integer Corresponding integer value Called by proc~~ang_mom_char_to_int~~CalledByGraph proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~ang_mom_char_to_int proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function ang_mom_char_to_int ( ang_mom_char ) result ( ang_mom ) !! Convert angular momentum character to integer !! !! Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6 !! Special case: L=-1 (combined S+P shell, requires splitting) character ( len = 1 ), intent ( in ) :: ang_mom_char !! Angular momentum symbol integer :: ang_mom !! Corresponding integer value select case ( ang_mom_char ) case ( 'S' ) ang_mom = 0 case ( 'P' ) ang_mom = 1 case ( 'D' ) ang_mom = 2 case ( 'F' ) ang_mom = 3 case ( 'G' ) ang_mom = 4 case ( 'H' ) ang_mom = 5 case ( 'I' ) ang_mom = 6 case ( 'L' ) ang_mom = - 1 ! Special case: L shells are split into S+P case default ang_mom = - 1 end select end function ang_mom_char_to_int","tags":"","url":"proc/ang_mom_char_to_int.html"},{"title":"ang_mom_int_to_char – metalquicha","text":"public pure function ang_mom_int_to_char(ang_mom) result(ang_mom_char) Convert angular momentum integer to character Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I\nReturns ‘?’ for invalid input values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ang_mom Angular momentum quantum number Return Value character(len=1) Corresponding symbol character Source Code pure function ang_mom_int_to_char ( ang_mom ) result ( ang_mom_char ) !! Convert angular momentum integer to character !! !! Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I !! Returns '?' for invalid input values. integer , intent ( in ) :: ang_mom !! Angular momentum quantum number character ( len = 1 ) :: ang_mom_char !! Corresponding symbol character select case ( ang_mom ) case ( 0 ) ang_mom_char = 'S' case ( 1 ) ang_mom_char = 'P' case ( 2 ) ang_mom_char = 'D' case ( 3 ) ang_mom_char = 'F' case ( 4 ) ang_mom_char = 'G' case ( 5 ) ang_mom_char = 'H' case ( 6 ) ang_mom_char = 'I' case default ang_mom_char = '?' end select end function ang_mom_int_to_char","tags":"","url":"proc/ang_mom_int_to_char.html"},{"title":"classify_line – metalquicha","text":"public pure function classify_line(line) result(line_type) Classify a line from a gamess formatted basis set file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer Calls proc~~classify_line~~CallsGraph proc~classify_line classify_line proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~classify_line~~CalledByGraph proc~classify_line classify_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: line_trim Source Code pure function classify_line ( line ) result ( line_type ) !! Classify a line from a gamess formatted basis set file character ( len =* ), intent ( in ) :: line integer :: line_type character ( len = :), allocatable :: line_trim line_trim = trim ( adjustl ( line )) if ( is_blank_or_control ( line_trim )) then line_type = LINE_UNKNOWN else if ( is_function_line ( line_trim )) then line_type = LINE_FUNCTION else if ( is_shell_header ( line_trim )) then line_type = LINE_SHELL else line_type = LINE_ATOM end if end function classify_line","tags":"","url":"proc/classify_line.html"},{"title":"is_blank_or_control – metalquicha","text":"private pure function is_blank_or_control(line) result(res) Check if a line is blank or a control line (starts with ‘$’) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_blank_or_control~~CalledByGraph proc~is_blank_or_control is_blank_or_control proc~classify_line classify_line proc~classify_line->proc~is_blank_or_control proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: trimmed_len Source Code pure function is_blank_or_control ( line ) result ( res ) !! Check if a line is blank or a control line (starts with '$') character ( len =* ), intent ( in ) :: line logical :: res integer :: trimmed_len trimmed_len = len_trim ( line ) if ( trimmed_len == 0 ) then res = . true . else res = ( line ( 1 : 1 ) == '$' ) end if end function is_blank_or_control","tags":"","url":"proc/is_blank_or_control.html"},{"title":"is_function_line – metalquicha","text":"private pure function is_function_line(line) result(res) Check if a line is a function coefficient line (starts with a number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_function_line~~CalledByGraph proc~is_function_line is_function_line proc~classify_line classify_line proc~classify_line->proc~is_function_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: first_char Source Code pure function is_function_line ( line ) result ( res ) !! Check if a line is a function coefficient line (starts with a number) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char if ( len_trim ( line ) == 0 ) then res = . false . return end if first_char = line ( 1 : 1 ) res = ( first_char >= '0' . and . first_char <= '9' ) end function is_function_line","tags":"","url":"proc/is_function_line.html"},{"title":"is_shell_header – metalquicha","text":"private pure function is_shell_header(line) result(res) Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_shell_header~~CalledByGraph proc~is_shell_header is_shell_header proc~classify_line classify_line proc~classify_line->proc~is_shell_header proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: dummy character(len=1), private :: first_char integer, private :: ios Source Code pure function is_shell_header ( line ) result ( res ) !! Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char integer :: ios , dummy res = . false . if ( len_trim ( line ) == 0 ) return first_char = line ( 1 : 1 ) if (. not . any ( first_char == [ 'S' , 'P' , 'D' , 'F' , 'G' , 'H' , 'I' , 'L' ])) return read ( line ( 2 :), * , iostat = ios ) dummy res = ( ios == 0 ) end function is_shell_header","tags":"","url":"proc/is_shell_header.html"},{"title":"build_molecular_basis – metalquicha","text":"public  subroutine build_molecular_basis(basis_string, element_names, mol_basis, error) Build molecular basis from geometry and basis file\nOnly parses unique elements, then copies basis data to atoms Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_names (:) Element for each atom in geometry order type( molecular_basis_type ), intent(out) :: mol_basis type( error_t ), intent(out) :: error Calls proc~~build_molecular_basis~~CallsGraph proc~build_molecular_basis build_molecular_basis proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~build_molecular_basis->proc~atomic_basis_destroy proc~basis_set_allocate_elements molecular_basis_type%basis_set_allocate_elements proc~build_molecular_basis->proc~basis_set_allocate_elements proc~copy_atomic_basis copy_atomic_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~error_add_context error_t%error_add_context proc~build_molecular_basis->proc~error_add_context proc~error_get_message error_t%error_get_message proc~build_molecular_basis->proc~error_get_message proc~error_has_error error_t%error_has_error proc~build_molecular_basis->proc~error_has_error proc~error_set error_t%error_set proc~build_molecular_basis->proc~error_set proc~find_unique_strings find_unique_strings proc~build_molecular_basis->proc~find_unique_strings proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~strings_equal strings_equal proc~build_molecular_basis->proc~strings_equal proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis->proc~allocate_basis_shells proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis->proc~cgto_allocate_arrays proc~find_unique_strings->proc~strings_equal proc~parse_element_basis->proc~error_add_context proc~parse_element_basis->proc~error_has_error proc~parse_element_basis->proc~error_set proc~parse_element_basis->proc~allocate_basis_shells proc~count_shells_for_element count_shells_for_element proc~parse_element_basis->proc~count_shells_for_element proc~fill_element_basis fill_element_basis proc~parse_element_basis->proc~fill_element_basis proc~count_shells_for_element->proc~error_set proc~count_shells_for_element->proc~strings_equal proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~fill_element_basis->proc~error_set proc~fill_element_basis->proc~strings_equal proc~fill_element_basis->proc~cgto_allocate_arrays proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~fill_element_basis->proc~classify_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom integer, private :: iunique integer, private :: match_idx integer, private :: natoms integer, private :: nunique type( atomic_basis_type ), private, allocatable :: unique_bases (:) character(len=:), private, allocatable :: unique_elements (:) Source Code subroutine build_molecular_basis ( basis_string , element_names , mol_basis , error ) !! Build molecular basis from geometry and basis file !! Only parses unique elements, then copies basis data to atoms character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_names (:) !! Element for each atom in geometry order type ( molecular_basis_type ), intent ( out ) :: mol_basis type ( error_t ), intent ( out ) :: error integer :: iatom , natoms , iunique , nunique character ( len = :), allocatable :: unique_elements (:) type ( atomic_basis_type ), allocatable :: unique_bases (:) integer :: match_idx match_idx = 0 natoms = size ( element_names ) ! Find unique elements call find_unique_strings ( element_names , unique_elements , nunique ) print * , \"Found \" , nunique , \" unique elements out of \" , natoms , \" atoms\" ! Allocate for unique bases allocate ( unique_bases ( nunique )) ! Parse basis for each unique element do iunique = 1 , nunique print * , \"Parsing basis for: \" , trim ( unique_elements ( iunique )) call parse_element_basis ( basis_string , unique_elements ( iunique ), & unique_bases ( iunique ), error ) if ( error % has_error ()) then ! Prepend context to error message call error % add_context ( \"mqc_basis_reader:read_basis_from_string\" ) call error % set ( ERROR_PARSE , \"Failed to parse basis for element \" // & trim ( unique_elements ( iunique )) // \": \" // error % get_message ()) return end if end do ! Allocate molecular basis and assign to each atom call mol_basis % allocate_elements ( natoms ) do iatom = 1 , natoms ! Find which unique element this atom corresponds to do iunique = 1 , nunique if ( strings_equal ( element_names ( iatom ), unique_elements ( iunique ))) then match_idx = iunique exit end if end do ! Copy the basis data call copy_atomic_basis ( unique_bases ( match_idx ), mol_basis % elements ( iatom )) end do ! Clean up do iunique = 1 , nunique call unique_bases ( iunique )% destroy () end do end subroutine build_molecular_basis","tags":"","url":"proc/build_molecular_basis.html"},{"title":"parse_element_basis – metalquicha","text":"public pure subroutine parse_element_basis(basis_string, element_name, atom_basis, error) Parse basis set for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(out) :: atom_basis type( error_t ), intent(out) :: error Calls proc~~parse_element_basis~~CallsGraph proc~parse_element_basis parse_element_basis proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~parse_element_basis->proc~allocate_basis_shells proc~count_shells_for_element count_shells_for_element proc~parse_element_basis->proc~count_shells_for_element proc~error_add_context error_t%error_add_context proc~parse_element_basis->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_element_basis->proc~error_has_error proc~error_set error_t%error_set proc~parse_element_basis->proc~error_set proc~fill_element_basis fill_element_basis proc~parse_element_basis->proc~fill_element_basis proc~count_shells_for_element->proc~error_set proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~strings_equal strings_equal proc~count_shells_for_element->proc~strings_equal proc~fill_element_basis->proc~error_set proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~fill_element_basis->proc~cgto_allocate_arrays proc~fill_element_basis->proc~classify_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~fill_element_basis->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_element_basis~~CalledByGraph proc~parse_element_basis parse_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: nshells Source Code pure subroutine parse_element_basis ( basis_string , element_name , atom_basis , error ) !! Parse basis set for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( out ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: nshells ! Pass 1: Find the element and count its shells call count_shells_for_element ( basis_string , element_name , nshells , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_basis_reader:parse_element_basis\" ) return end if if ( nshells == 0 ) then call error % set ( ERROR_PARSE , \"Element \" // trim ( element_name ) // \" not found in basis file\" ) return end if ! ! Allocate shells atom_basis % element = trim ( element_name ) call atom_basis % allocate_shells ( nshells ) ! ! Pass 2: Parse and fill shell data call fill_element_basis ( basis_string , element_name , atom_basis , error ) end subroutine parse_element_basis","tags":"","url":"proc/parse_element_basis.html"},{"title":"copy_atomic_basis – metalquicha","text":"private pure subroutine copy_atomic_basis(source, dest) Deep copy of atomic basis data from source to dest Arguments Type Intent Optional Attributes Name type( atomic_basis_type ), intent(in) :: source type( atomic_basis_type ), intent(out) :: dest Calls proc~~copy_atomic_basis~~CallsGraph proc~copy_atomic_basis copy_atomic_basis proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis->proc~allocate_basis_shells proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis->proc~cgto_allocate_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_atomic_basis~~CalledByGraph proc~copy_atomic_basis copy_atomic_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ishell Source Code pure subroutine copy_atomic_basis ( source , dest ) !! Deep copy of atomic basis data from source to dest type ( atomic_basis_type ), intent ( in ) :: source type ( atomic_basis_type ), intent ( out ) :: dest integer :: ishell dest % element = source % element call dest % allocate_shells ( source % nshells ) do ishell = 1 , source % nshells dest % shells ( ishell )% ang_mom = source % shells ( ishell )% ang_mom call dest % shells ( ishell )% allocate_arrays ( source % shells ( ishell )% nfunc ) dest % shells ( ishell )% exponents = source % shells ( ishell )% exponents dest % shells ( ishell )% coefficients = source % shells ( ishell )% coefficients end do end subroutine copy_atomic_basis","tags":"","url":"proc/copy_atomic_basis.html"},{"title":"count_shells_for_element – metalquicha","text":"private pure subroutine count_shells_for_element(basis_string, element_name, nshells, error) Count the number of shells for a specific element in a GAMESS formatted basis string, Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name integer, intent(out) :: nshells type( error_t ), intent(out) :: error Calls proc~~count_shells_for_element~~CallsGraph proc~count_shells_for_element count_shells_for_element proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~error_set error_t%error_set proc~count_shells_for_element->proc~error_set proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~strings_equal strings_equal proc~count_shells_for_element->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~count_shells_for_element~~CalledByGraph proc~count_shells_for_element count_shells_for_element proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: ang_mom logical, private :: found_element logical, private :: in_target_element character(len=256), private :: line integer, private :: line_end integer, private :: line_start integer, private :: line_type Source Code pure subroutine count_shells_for_element ( basis_string , element_name , nshells , error ) !! Count the number of shells for a specific element in a GAMESS formatted basis string, character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name integer , intent ( out ) :: nshells type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_target_element , found_element character ( len = 1 ) :: ang_mom nshells = 0 in_target_element = . false . found_element = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) case ( LINE_ATOM ) ! Check if this is our target element if ( strings_equal ( line , element_name )) then in_target_element = . true . found_element = . true . else ! Different element - stop counting if we were in target if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Extract angular momentum line = adjustl ( line ) ang_mom = line ( 1 : 1 ) ! L shells become 2 shells (S + P) if ( ang_mom == 'L' ) then nshells = nshells + 2 else nshells = nshells + 1 end if end if case ( LINE_UNKNOWN ) ! Skip blank lines and comments continue case default ! Skip any other line types (e.g., LINE_FUNCTION) continue end select line_start = line_end end do ! Check if we found the element at all if (. not . found_element ) then call error % set ( ERROR_PARSE , \"Element not found in basis string: \" // trim ( element_name )) end if end subroutine count_shells_for_element","tags":"","url":"proc/count_shells_for_element.html"},{"title":"fill_element_basis – metalquicha","text":"private pure subroutine fill_element_basis(basis_string, element_name, atom_basis, error) Fill in the shell data for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(inout) :: atom_basis type( error_t ), intent(out) :: error Calls proc~~fill_element_basis~~CallsGraph proc~fill_element_basis fill_element_basis proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~fill_element_basis->proc~cgto_allocate_arrays proc~classify_line classify_line proc~fill_element_basis->proc~classify_line proc~error_set error_t%error_set proc~fill_element_basis->proc~error_set proc~get_next_line get_next_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~strings_equal strings_equal proc~fill_element_basis->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_element_basis~~CalledByGraph proc~fill_element_basis fill_element_basis proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: ang_mom real(kind=dp), private :: coeff_p real(kind=dp), private :: coeff_s real(kind=dp), private :: exponent integer, private :: func_num logical, private :: has_p integer, private :: ifunc logical, private :: in_data_block logical, private :: in_target_element integer, private :: ishell integer, private :: l_shell_p_idx integer, private :: l_shell_s_idx character(len=256), private :: line integer, private :: line_end integer, private :: line_start integer, private :: line_type integer, private :: nfunc logical, private :: reading_l_shell integer, private :: stat Source Code pure subroutine fill_element_basis ( basis_string , element_name , atom_basis , error ) !! Fill in the shell data for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( inout ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_data_block , in_target_element character ( len = 1 ) :: ang_mom integer :: nfunc , func_num , ishell , ifunc real ( dp ) :: exponent , coeff_s , coeff_p logical :: has_p ! L shell handling: we split into two shells, need to track both logical :: reading_l_shell integer :: l_shell_s_idx , l_shell_p_idx integer :: stat in_data_block = . false . in_target_element = . false . ishell = 0 reading_l_shell = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) ! case (LINE_UNKNOWN) !   if (index(line, '$DATA') > 0) then !     in_data_block = .true. !   else if (index(line, '$END') > 0) then !     exit !   end if case ( LINE_ATOM ) if ( strings_equal ( line , element_name )) then in_target_element = . true . else if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Parse shell header call parse_shell_header ( line , ang_mom , nfunc , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse shell header: \" // trim ( line )) return end if if ( ang_mom == 'L' ) then ! L shell: create two shells (S and P) reading_l_shell = . true . ishell = ishell + 1 l_shell_s_idx = ishell atom_basis % shells ( ishell )% ang_mom = 0 ! S call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ishell = ishell + 1 l_shell_p_idx = ishell atom_basis % shells ( ishell )% ang_mom = 1 ! P call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 ! Reset function counter else ! Regular shell reading_l_shell = . false . ishell = ishell + 1 ! Set angular momentum (S=0, P=1, D=2, F=3, G=4, H=5, I=6) atom_basis % shells ( ishell )% ang_mom = ang_mom_char_to_int ( ang_mom ) call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 end if end if case ( LINE_FUNCTION ) if ( in_target_element ) then call parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse function line: \" // trim ( line )) return end if ifunc = ifunc + 1 if ( reading_l_shell ) then if (. not . has_p ) then call error % set ( ERROR_PARSE , \"L shell requires both S and P coefficients\" ) return end if ! Store in both S and P shells atom_basis % shells ( l_shell_s_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_s_idx )% coefficients ( ifunc ) = coeff_s atom_basis % shells ( l_shell_p_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_p_idx )% coefficients ( ifunc ) = coeff_p else ! Store in current shell atom_basis % shells ( ishell )% exponents ( ifunc ) = exponent atom_basis % shells ( ishell )% coefficients ( ifunc ) = coeff_s end if end if case default ! Skip unknown line types (e.g., LINE_UNKNOWN, blank lines, comments) continue end select line_start = line_end end do end subroutine fill_element_basis","tags":"","url":"proc/fill_element_basis.html"},{"title":"find_unique_strings – metalquicha","text":"private pure subroutine find_unique_strings(input_array, unique_array, nunique) Find unique strings in an array\nReturns array of unique strings and count Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_array (:) character(len=:), intent(out), allocatable :: unique_array (:) integer, intent(out) :: nunique Calls proc~~find_unique_strings~~CallsGraph proc~find_unique_strings find_unique_strings proc~strings_equal strings_equal proc~find_unique_strings->proc~strings_equal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_unique_strings~~CalledByGraph proc~find_unique_strings find_unique_strings proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~find_unique_strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i logical, private :: is_unique integer, private :: j integer, private :: n character(len=len), private, allocatable :: temp_unique (:) Source Code pure subroutine find_unique_strings ( input_array , unique_array , nunique ) !! Find unique strings in an array !! Returns array of unique strings and count character ( len =* ), intent ( in ) :: input_array (:) character ( len = :), allocatable , intent ( out ) :: unique_array (:) integer , intent ( out ) :: nunique integer :: i , j , n logical :: is_unique character ( len = len ( input_array )), allocatable :: temp_unique (:) n = size ( input_array ) allocate ( temp_unique ( n )) ! Max possible size nunique = 0 do i = 1 , n is_unique = . true . ! Check if we've already seen this string do j = 1 , nunique if ( strings_equal ( input_array ( i ), temp_unique ( j ))) then is_unique = . false . exit end if end do if ( is_unique ) then nunique = nunique + 1 temp_unique ( nunique ) = input_array ( i ) end if end do ! Allocate output array with exact size and copy allocate ( character ( len = len ( input_array )) :: unique_array ( nunique )) unique_array = temp_unique ( 1 : nunique ) end subroutine find_unique_strings","tags":"","url":"proc/find_unique_strings.html"},{"title":"get_next_line – metalquicha","text":"private pure subroutine get_next_line(string, line_start, line, line_end) Extract the next line from a string starting at line_start Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: line_start character(len=*), intent(out) :: line integer, intent(out) :: line_end Called by proc~~get_next_line~~CalledByGraph proc~get_next_line get_next_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~get_next_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~get_next_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: newline_pos Source Code pure subroutine get_next_line ( string , line_start , line , line_end ) !! Extract the next line from a string starting at line_start character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: line_start character ( len =* ), intent ( out ) :: line integer , intent ( out ) :: line_end integer :: newline_pos if ( line_start > len ( string )) then line = '' line_end = 0 return end if newline_pos = index ( string ( line_start :), new_line ( 'a' )) if ( newline_pos == 0 ) then ! Last line (no newline at end) line = string ( line_start :) line_end = len ( string ) + 1 else line = string ( line_start : line_start + newline_pos - 2 ) line_end = line_start + newline_pos end if end subroutine get_next_line","tags":"","url":"proc/get_next_line.html"},{"title":"parse_function_line – metalquicha","text":"private pure subroutine parse_function_line(line, func_num, exponent, coeff_s, coeff_p, has_p, stat) Parse function line (e.g., “1 1.0 2.0” or “1 1.0 2.0 3.0” for L shells) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(out) :: func_num real(kind=dp), intent(out) :: exponent real(kind=dp), intent(out) :: coeff_s real(kind=dp), intent(out), optional :: coeff_p logical, intent(out) :: has_p integer, intent(out) :: stat Called by proc~~parse_function_line~~CalledByGraph proc~parse_function_line parse_function_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~parse_function_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: temp_p Source Code pure subroutine parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) !! Parse function line (e.g., \"1 1.0 2.0\" or \"1 1.0 2.0 3.0\" for L shells) character ( len =* ), intent ( in ) :: line integer , intent ( out ) :: func_num real ( dp ), intent ( out ) :: exponent real ( dp ), intent ( out ) :: coeff_s real ( dp ), intent ( out ), optional :: coeff_p logical , intent ( out ) :: has_p integer , intent ( out ) :: stat real ( dp ) :: temp_p has_p = . false . ! Try to read 4 values (func_num, exponent, coeff_s, coeff_p) read ( line , * , iostat = stat ) func_num , exponent , coeff_s , temp_p if ( stat == 0 ) then ! Successfully read 4 values - this is an L shell has_p = . true . if ( present ( coeff_p )) coeff_p = temp_p else ! Try reading just 3 values (func_num, exponent, coeff_s) read ( line , * , iostat = stat ) func_num , exponent , coeff_s end if end subroutine parse_function_line","tags":"","url":"proc/parse_function_line.html"},{"title":"parse_shell_header – metalquicha","text":"private pure subroutine parse_shell_header(line, ang_mom, nfunc, stat) Parse shell header line (e.g., “S 2” or “L 3”) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(out) :: ang_mom integer, intent(out) :: nfunc integer, intent(out) :: stat Called by proc~~parse_shell_header~~CalledByGraph proc~parse_shell_header parse_shell_header proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~parse_shell_header proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: line_trim Source Code pure subroutine parse_shell_header ( line , ang_mom , nfunc , stat ) !! Parse shell header line (e.g., \"S 2\" or \"L 3\") character ( len =* ), intent ( in ) :: line character ( len = 1 ), intent ( out ) :: ang_mom integer , intent ( out ) :: nfunc integer , intent ( out ) :: stat character ( len = 256 ) :: line_trim line_trim = adjustl ( line ) ang_mom = line_trim ( 1 : 1 ) ! Read the number of functions read ( line_trim ( 2 :), * , iostat = stat ) nfunc end subroutine parse_shell_header","tags":"","url":"proc/parse_shell_header.html"},{"title":"create_method – metalquicha","text":"public  function create_method(config) result(method) Convenience function to create a method without instantiating factory Usage:\n  use mqc_method_factory, only: create_method\n  method = create_method(config) Arguments Type Intent Optional Attributes Name type( method_config_t ), intent(in) :: config Return Value class( qc_method_t ), allocatable Calls proc~~create_method~~CallsGraph proc~create_method create_method proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb state_weights state_weights proc~configure_mcscf->state_weights proc~method_type_to_string method_type_to_string proc~configure_xtb->proc~method_type_to_string proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~configure_xtb->proc~xtb_has_solvation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_method~~CalledByGraph proc~create_method create_method proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~create_method proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~create_method proc~hessian_worker hessian_worker proc~hessian_worker->proc~create_method interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( method_factory_t ), private :: factory Source Code function create_method ( config ) result ( method ) !! Convenience function to create a method without instantiating factory !! !! Usage: !!   use mqc_method_factory, only: create_method !!   method = create_method(config) type ( method_config_t ), intent ( in ) :: config class ( qc_method_t ), allocatable :: method type ( method_factory_t ) :: factory method = factory % create ( config ) end function create_method","tags":"","url":"proc/create_method.html"},{"title":"factory_create – metalquicha","text":"private  function factory_create(this, config) result(method) Create a quantum chemistry method instance from configuration Instantiates the appropriate concrete method type based on\nconfig%method_type and configures it from the nested config. Type Bound method_factory_t Arguments Type Intent Optional Attributes Name class( method_factory_t ), intent(in) :: this type( method_config_t ), intent(in) :: config Return Value class( qc_method_t ), allocatable Calls proc~~factory_create~~CallsGraph proc~factory_create method_factory_t%factory_create proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb state_weights state_weights proc~configure_mcscf->state_weights proc~method_type_to_string method_type_to_string proc~configure_xtb->proc~method_type_to_string proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~configure_xtb->proc~xtb_has_solvation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~factory_create~~CalledByGraph proc~factory_create method_factory_t%factory_create proc~create_method create_method proc~create_method->proc~factory_create proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~create_method proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~create_method proc~hessian_worker hessian_worker proc~hessian_worker->proc~create_method interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function factory_create ( this , config ) result ( method ) !! Create a quantum chemistry method instance from configuration !! !! Instantiates the appropriate concrete method type based on !! config%method_type and configures it from the nested config. class ( method_factory_t ), intent ( in ) :: this type ( method_config_t ), intent ( in ) :: config class ( qc_method_t ), allocatable :: method select case ( config % method_type ) #ifndef MQC_WITHOUT_TBLITE case ( METHOD_TYPE_GFN1 , METHOD_TYPE_GFN2 ) allocate ( xtb_method_t :: method ) call configure_xtb ( method , config ) #else case ( METHOD_TYPE_GFN1 , METHOD_TYPE_GFN2 ) error stop \"XTB methods require tblite library (MQC_ENABLE_TBLITE)\" #endif case ( METHOD_TYPE_HF ) allocate ( hf_method_t :: method ) call configure_hf ( method , config ) case ( METHOD_TYPE_DFT ) allocate ( dft_method_t :: method ) call configure_dft ( method , config ) case ( METHOD_TYPE_MCSCF ) allocate ( mcscf_method_t :: method ) call configure_mcscf ( method , config ) case default error stop \"Unknown method type in method_factory_t%create\" end select end function factory_create","tags":"","url":"proc/factory_create.html"},{"title":"configure_dft – metalquicha","text":"private  subroutine configure_dft(method, config) Configure a DFT method instance from config%scf (shared) and config%dft (DFT-specific) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(inout) :: method type( method_config_t ), intent(in) :: config Called by proc~~configure_dft~~CalledByGraph proc~configure_dft configure_dft proc~factory_create method_factory_t%factory_create proc~factory_create->proc~configure_dft proc~create_method create_method proc~create_method->proc~factory_create proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~create_method proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~create_method proc~hessian_worker hessian_worker proc~hessian_worker->proc~create_method interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine configure_dft ( method , config ) !! Configure a DFT method instance from config%scf (shared) and config%dft (DFT-specific) class ( qc_method_t ), intent ( inout ) :: method type ( method_config_t ), intent ( in ) :: config select type ( m => method ) type is ( dft_method_t ) ! Common settings m % options % basis_set = config % basis_set m % options % spherical = config % use_spherical m % options % verbose = config % verbose ! SCF settings from shared config%scf m % options % max_iter = config % scf % max_iter m % options % energy_tol = config % scf % energy_convergence m % options % density_tol = config % scf % density_convergence m % options % use_diis = config % scf % use_diis m % options % diis_size = config % scf % diis_size ! DFT-specific from config%dft m % options % functional = config % dft % functional m % options % grid_type = config % dft % grid_type m % options % radial_points = config % dft % radial_points m % options % angular_points = config % dft % angular_points ! Density fitting m % options % use_density_fitting = config % dft % use_density_fitting m % options % aux_basis_set = config % dft % aux_basis_set ! Dispersion m % options % use_dispersion = config % dft % use_dispersion m % options % dispersion_type = config % dft % dispersion_type end select end subroutine configure_dft","tags":"","url":"proc/configure_dft.html"},{"title":"configure_hf – metalquicha","text":"private  subroutine configure_hf(method, config) Configure a Hartree-Fock method instance from config%scf (shared SCF settings) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(inout) :: method type( method_config_t ), intent(in) :: config Called by proc~~configure_hf~~CalledByGraph proc~configure_hf configure_hf proc~factory_create method_factory_t%factory_create proc~factory_create->proc~configure_hf proc~create_method create_method proc~create_method->proc~factory_create proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~create_method proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~create_method proc~hessian_worker hessian_worker proc~hessian_worker->proc~create_method interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine configure_hf ( method , config ) !! Configure a Hartree-Fock method instance from config%scf (shared SCF settings) class ( qc_method_t ), intent ( inout ) :: method type ( method_config_t ), intent ( in ) :: config select type ( m => method ) type is ( hf_method_t ) ! Common settings m % options % basis_set = config % basis_set m % options % spherical = config % use_spherical m % options % verbose = config % verbose ! SCF settings from shared config%scf m % options % max_iter = config % scf % max_iter m % options % conv_tol = config % scf % energy_convergence m % options % density_tol = config % scf % density_convergence m % options % use_diis = config % scf % use_diis m % options % diis_size = config % scf % diis_size end select end subroutine configure_hf","tags":"","url":"proc/configure_hf.html"},{"title":"configure_mcscf – metalquicha","text":"private  subroutine configure_mcscf(method, config) Configure a MCSCF method instance from config%mcscf Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(inout) :: method type( method_config_t ), intent(in) :: config Calls proc~~configure_mcscf~~CallsGraph proc~configure_mcscf configure_mcscf state_weights state_weights proc~configure_mcscf->state_weights Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~configure_mcscf~~CalledByGraph proc~configure_mcscf configure_mcscf proc~factory_create method_factory_t%factory_create proc~factory_create->proc~configure_mcscf proc~create_method create_method proc~create_method->proc~factory_create proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~create_method proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~create_method proc~hessian_worker hessian_worker proc~hessian_worker->proc~create_method interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine configure_mcscf ( method , config ) !! Configure a MCSCF method instance from config%mcscf class ( qc_method_t ), intent ( inout ) :: method type ( method_config_t ), intent ( in ) :: config select type ( m => method ) type is ( mcscf_method_t ) ! Common settings m % options % basis_set = config % basis_set m % options % spherical = config % use_spherical m % options % verbose = config % verbose ! Active space from config%mcscf m % options % n_active_electrons = config % mcscf % n_active_electrons m % options % n_active_orbitals = config % mcscf % n_active_orbitals m % options % n_inactive_orbitals = config % mcscf % n_inactive_orbitals ! State averaging m % options % n_states = config % mcscf % n_states if ( allocated ( config % mcscf % state_weights )) then if ( allocated ( m % options % state_weights )) deallocate ( m % options % state_weights ) allocate ( m % options % state_weights ( size ( config % mcscf % state_weights ))) m % options % state_weights = config % mcscf % state_weights end if ! Convergence m % options % max_macro_iter = config % mcscf % max_macro_iter m % options % max_micro_iter = config % mcscf % max_micro_iter m % options % orbital_tol = config % mcscf % orbital_convergence m % options % ci_tol = config % mcscf % ci_convergence ! PT2 corrections m % options % use_pt2 = config % mcscf % use_pt2 m % options % pt2_type = config % mcscf % pt2_type m % options % ipea_shift = config % mcscf % ipea_shift m % options % imaginary_shift = config % mcscf % imaginary_shift end select end subroutine configure_mcscf","tags":"","url":"proc/configure_mcscf.html"},{"title":"configure_xtb – metalquicha","text":"private  subroutine configure_xtb(method, config) Configure an XTB method instance from config%xtb Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(inout) :: method type( method_config_t ), intent(in) :: config Calls proc~~configure_xtb~~CallsGraph proc~configure_xtb configure_xtb proc~method_type_to_string method_type_to_string proc~configure_xtb->proc~method_type_to_string proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~configure_xtb->proc~xtb_has_solvation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~configure_xtb~~CalledByGraph proc~configure_xtb configure_xtb proc~factory_create method_factory_t%factory_create proc~factory_create->proc~configure_xtb proc~create_method create_method proc~create_method->proc~factory_create proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~create_method proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~create_method proc~hessian_worker hessian_worker proc~hessian_worker->proc~create_method interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine configure_xtb ( method , config ) !! Configure an XTB method instance from config%xtb class ( qc_method_t ), intent ( inout ) :: method type ( method_config_t ), intent ( in ) :: config select type ( m => method ) type is ( xtb_method_t ) ! Core settings m % variant = method_type_to_string ( config % method_type ) m % verbose = config % verbose m % accuracy = real ( config % xtb % accuracy , wp ) ! Electronic temperature (convert K to Hartree) ! kt = T * k_B, where k_B = 3.166808578545117e-06 Hartree/K m % kt = real ( config % xtb % electronic_temp , wp ) * 3.166808578545117e-06_wp ! Solvation settings from config%xtb if ( config % xtb % has_solvation ()) then m % solvent = trim ( config % xtb % solvent ) if ( len_trim ( config % xtb % solvation_model ) > 0 ) then m % solvation_model = trim ( config % xtb % solvation_model ) else m % solvation_model = \"alpb\" ! Default end if m % use_cds = config % xtb % use_cds m % use_shift = config % xtb % use_shift m % dielectric = real ( config % xtb % dielectric , wp ) m % cpcm_nang = config % xtb % cpcm_nang m % cpcm_rscale = real ( config % xtb % cpcm_rscale , wp ) end if end select end subroutine configure_xtb","tags":"","url":"proc/configure_xtb.html"},{"title":"fragment_should_be_screened – metalquicha","text":"private  function fragment_should_be_screened(fragment, n, sys_geom, driver_config) result(should_screen) Uses mqc_config_adapter mqc_physical_fragment proc~~fragment_should_be_screened~~UsesGraph proc~fragment_should_be_screened fragment_should_be_screened module~mqc_config_adapter mqc_config_adapter proc~fragment_should_be_screened->module~mqc_config_adapter module~mqc_physical_fragment mqc_physical_fragment proc~fragment_should_be_screened->module~mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error pic_logger pic_logger module~mqc_config_adapter->pic_logger pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Check if a fragment should be screened out based on distance cutoffs.\nReturns true if the fragment itself OR any of its k-subsets (k >= 2) exceeds\nthe corresponding k-mer cutoff. This ensures MBE subset consistency. Arguments Type Intent Optional Attributes Name integer, intent(in) :: fragment (:) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( driver_config_t ), intent(in) :: driver_config Return Value logical Calls proc~~fragment_should_be_screened~~CallsGraph proc~fragment_should_be_screened fragment_should_be_screened proc~calculate_monomer_distance calculate_monomer_distance proc~fragment_should_be_screened->proc~calculate_monomer_distance proc~get_next_combination get_next_combination proc~fragment_should_be_screened->proc~get_next_combination proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_should_be_screened~~CalledByGraph proc~fragment_should_be_screened fragment_should_be_screened proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->proc~fragment_should_be_screened proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~apply_distance_screening proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: cutoff real(kind=dp), private :: distance logical, private :: has_next integer, private :: indices (n) integer, private :: j integer, private :: num_cutoffs integer, private :: subset (n) integer, private :: subset_size Source Code function fragment_should_be_screened ( fragment , n , sys_geom , driver_config ) result ( should_screen ) !! Check if a fragment should be screened out based on distance cutoffs. !! Returns true if the fragment itself OR any of its k-subsets (k >= 2) exceeds !! the corresponding k-mer cutoff. This ensures MBE subset consistency. use mqc_physical_fragment , only : calculate_monomer_distance use mqc_config_adapter , only : driver_config_t integer , intent ( in ) :: fragment (:) integer , intent ( in ) :: n type ( system_geometry_t ), intent ( in ) :: sys_geom type ( driver_config_t ), intent ( in ) :: driver_config logical :: should_screen integer :: subset_size , num_cutoffs integer :: indices ( n ), subset ( n ) integer :: j real ( dp ) :: distance , cutoff logical :: has_next should_screen = . false . num_cutoffs = size ( driver_config % fragment_cutoffs ) ! Check all subset sizes from 2 up to n (the full fragment) ! If any k-subset exceeds the k-mer cutoff, screen this fragment do subset_size = 2 , n ! Skip if no cutoff defined for this level if ( subset_size > num_cutoffs ) cycle cutoff = driver_config % fragment_cutoffs ( subset_size ) ! Skip if cutoff is non-positive (no screening for this level) if ( cutoff <= 0.0_dp ) cycle ! Initialize first combination indices do j = 1 , subset_size indices ( j ) = j end do ! Loop through all combinations of this size do ! Build current subset do j = 1 , subset_size subset ( j ) = fragment ( indices ( j )) end do ! Calculate distance for this subset distance = calculate_monomer_distance ( sys_geom , subset ( 1 : subset_size )) ! If subset exceeds cutoff, screen the whole fragment if ( distance > cutoff ) then should_screen = . true . return end if ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end function fragment_should_be_screened","tags":"","url":"proc/fragment_should_be_screened.html"},{"title":"apply_distance_screening – metalquicha","text":"public  subroutine apply_distance_screening(polymers, total_fragments, sys_geom, driver_config, max_level) Uses mqc_config_adapter mqc_physical_fragment proc~~apply_distance_screening~~UsesGraph proc~apply_distance_screening apply_distance_screening module~mqc_config_adapter mqc_config_adapter proc~apply_distance_screening->module~mqc_config_adapter module~mqc_physical_fragment mqc_physical_fragment proc~apply_distance_screening->module~mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error pic_logger pic_logger module~mqc_config_adapter->pic_logger pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Apply distance-based screening to filter out fragments that exceed cutoff distances\nModifies polymers array in-place and updates total_fragments count IMPORTANT: For MBE correctness, if any k-subset of an n-mer exceeds the k-mer cutoff,\nthe entire n-mer must be screened out. Otherwise, compute_mbe will fail when trying\nto look up the missing subset. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: total_fragments type( system_geometry_t ), intent(in) :: sys_geom type( driver_config_t ), intent(in) :: driver_config integer, intent(in) :: max_level Calls proc~~apply_distance_screening~~CallsGraph proc~apply_distance_screening apply_distance_screening info info proc~apply_distance_screening->info proc~fragment_should_be_screened fragment_should_be_screened proc~apply_distance_screening->proc~fragment_should_be_screened to_char to_char proc~apply_distance_screening->to_char proc~calculate_monomer_distance calculate_monomer_distance proc~fragment_should_be_screened->proc~calculate_monomer_distance proc~get_next_combination get_next_combination proc~fragment_should_be_screened->proc~get_next_combination proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~apply_distance_screening~~CalledByGraph proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~apply_distance_screening proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: fragment_size integer(kind=int64), private :: fragments_kept integer(kind=int64), private :: fragments_screened integer(kind=int64), private :: i logical, private :: should_screen Source Code subroutine apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) !! Apply distance-based screening to filter out fragments that exceed cutoff distances !! Modifies polymers array in-place and updates total_fragments count !! !! IMPORTANT: For MBE correctness, if any k-subset of an n-mer exceeds the k-mer cutoff, !! the entire n-mer must be screened out. Otherwise, compute_mbe will fail when trying !! to look up the missing subset. use mqc_physical_fragment , only : calculate_monomer_distance use mqc_config_adapter , only : driver_config_t integer , intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: total_fragments type ( system_geometry_t ), intent ( in ) :: sys_geom type ( driver_config_t ), intent ( in ) :: driver_config integer , intent ( in ) :: max_level integer ( int64 ) :: i , fragments_kept integer :: fragment_size integer ( int64 ) :: fragments_screened logical :: should_screen ! Check if we have cutoffs to apply if (. not . allocated ( driver_config % fragment_cutoffs )) then return ! No screening needed end if fragments_kept = 0_int64 fragments_screened = 0_int64 ! Loop through all fragments and filter based on distance do i = 1_int64 , total_fragments fragment_size = count ( polymers ( i , :) > 0 ) ! Monomers are always kept (distance = 0) if ( fragment_size == 1 ) then fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then ! Compact array - move this fragment to the kept position polymers ( fragments_kept , :) = polymers ( i , :) end if cycle end if ! For n-mers (n >= 2), check if this fragment or any of its subsets should be screened should_screen = fragment_should_be_screened ( polymers ( i , 1 : fragment_size ), fragment_size , & sys_geom , driver_config ) if (. not . should_screen ) then ! Keep this fragment fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then polymers ( fragments_kept , :) = polymers ( i , :) end if else ! Screen out this fragment fragments_screened = fragments_screened + 1_int64 end if end do ! Update total fragment count if ( fragments_screened > 0 ) then call logger % info ( \"Distance-based screening applied:\" ) call logger % info ( \"  Fragments before screening: \" // to_char ( total_fragments )) call logger % info ( \"  Fragments screened out: \" // to_char ( fragments_screened )) call logger % info ( \"  Fragments kept: \" // to_char ( fragments_kept )) total_fragments = fragments_kept end if end subroutine apply_distance_screening","tags":"","url":"proc/apply_distance_screening.html"},{"title":"sort_fragments_by_size – metalquicha","text":"public  subroutine sort_fragments_by_size(polymers, total_fragments, max_level) Uses pic_sorting proc~~sort_fragments_by_size~~UsesGraph proc~sort_fragments_by_size sort_fragments_by_size pic_sorting pic_sorting proc~sort_fragments_by_size->pic_sorting Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Sort fragments by size (largest first) for better load balancing\nUses in-place sorting to reorder the polymers array\nLarger fragments (e.g., tetramers) are computed before smaller ones (e.g., dimers) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: polymers (:,:) integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: max_level Calls proc~~sort_fragments_by_size~~CallsGraph proc~sort_fragments_by_size sort_fragments_by_size info info proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sort_fragments_by_size~~CalledByGraph proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~sort_fragments_by_size proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: fragment_size integer(kind=int64), private, allocatable :: fragment_sizes (:) integer(kind=int64), private :: i integer(kind=int64), private :: j integer, private, allocatable :: polymers_copy (:,:) integer(kind=int_index), private, allocatable :: sort_indices (:) integer(kind=int64), private :: sorted_idx Source Code subroutine sort_fragments_by_size ( polymers , total_fragments , max_level ) !! Sort fragments by size (largest first) for better load balancing !! Uses in-place sorting to reorder the polymers array !! Larger fragments (e.g., tetramers) are computed before smaller ones (e.g., dimers) use pic_sorting , only : sort_index integer , intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level integer ( int64 ), allocatable :: fragment_sizes (:) integer ( int_index ), allocatable :: sort_indices (:) integer , allocatable :: polymers_copy (:, :) integer ( int64 ) :: i , j , sorted_idx integer :: fragment_size ! Nothing to sort if we have 1 or fewer fragments if ( total_fragments <= 1 ) return ! Allocate arrays for sorting (0-indexed for PIC library) allocate ( fragment_sizes ( 0 : total_fragments - 1 )) allocate ( sort_indices ( 0 : total_fragments - 1 )) ! Calculate fragment sizes do i = 0 , total_fragments - 1 fragment_size = count ( polymers ( i + 1 , :) > 0 ) fragment_sizes ( i ) = int ( fragment_size , int64 ) end do ! Get sort permutation in descending order (largest first) call sort_index ( fragment_sizes , sort_indices , reverse = . true .) ! Reorder polymers array based on sort permutation allocate ( polymers_copy ( size ( polymers , 1 ), size ( polymers , 2 ))) polymers_copy = polymers ! Reorder: new position j gets data from original position sort_indices(j) ! NOTE: sort_indices already contains 1-indexed values, so don't add 1! do j = 0 , total_fragments - 1 sorted_idx = sort_indices ( j ) ! Already 1-indexed! polymers ( j + 1 , :) = polymers_copy ( sorted_idx , :) end do deallocate ( polymers_copy ) deallocate ( fragment_sizes ) deallocate ( sort_indices ) call logger % info ( \"Fragments queue sorted!\" ) end subroutine sort_fragments_by_size","tags":"","url":"proc/sort_fragments_by_size.html"},{"title":"get_logger_level – metalquicha","text":"public  function get_logger_level(level_string) result(level_int) Uses pic_logger proc~~get_logger_level~~UsesGraph proc~get_logger_level get_logger_level pic_logger pic_logger proc~get_logger_level->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Convert string log level to integer value\nThis function uses the pic_logger constants Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: level_string Return Value integer Calls proc~~get_logger_level~~CallsGraph proc~get_logger_level get_logger_level warning warning proc~get_logger_level->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_logger_level~~CalledByGraph proc~get_logger_level get_logger_level program~main main program~main->proc~get_logger_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_logger_level ( level_string ) result ( level_int ) !! Convert string log level to integer value !! This function uses the pic_logger constants use pic_logger , only : debug_level , verbose_level , info_level , performance_level , & warning_level , error_level , knowledge_level character ( len =* ), intent ( in ) :: level_string integer :: level_int select case ( trim ( adjustl ( level_string ))) case ( 'debug' , 'Debug' , 'DEBUG' ) level_int = debug_level case ( 'verbose' , 'Verbose' , 'VERBOSE' ) level_int = verbose_level case ( 'info' , 'Info' , 'INFO' ) level_int = info_level case ( 'performance' , 'Performance' , 'PERFORMANCE' ) level_int = performance_level case ( 'warning' , 'Warning' , 'WARNING' ) level_int = warning_level case ( 'error' , 'Error' , 'ERROR' ) level_int = error_level case ( 'knowledge' , 'Knowledge' , 'KNOWLEDGE' ) level_int = knowledge_level case default ! Default to info level if unknown call logger % warning ( \"Unknown log level string: \" // level_string // \". Defaulting to INFO level.\" ) level_int = info_level end select end function get_logger_level","tags":"","url":"proc/get_logger_level.html"},{"title":"check_fragment_overlap – metalquicha","text":"public  subroutine check_fragment_overlap(fragments, nfrag, error) Uses mqc_config_parser pic_io proc~~check_fragment_overlap~~UsesGraph proc~check_fragment_overlap check_fragment_overlap module~mqc_config_parser mqc_config_parser proc~check_fragment_overlap->module~mqc_config_parser pic_io pic_io proc~check_fragment_overlap->pic_io module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Check if any atoms appear in multiple fragments\nThis is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes Arguments Type Intent Optional Attributes Name type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: nfrag type( error_t ), intent(out) :: error Calls proc~~check_fragment_overlap~~CallsGraph proc~check_fragment_overlap check_fragment_overlap proc~error_set error_t%error_set proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_fragment_overlap~~CalledByGraph proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~check_fragment_overlap proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_i integer, private :: atom_j integer, private :: i integer, private :: j integer, private :: k integer, private :: l Source Code subroutine check_fragment_overlap ( fragments , nfrag , error ) !! Check if any atoms appear in multiple fragments !! This is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes use mqc_config_parser , only : input_fragment_t use pic_io , only : to_char type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: nfrag type ( error_t ), intent ( out ) :: error integer :: i , j , k , l integer :: atom_i , atom_j ! Compare each pair of fragments do i = 1 , nfrag - 1 do j = i + 1 , nfrag ! Compare atoms in fragment i with atoms in fragment j do k = 1 , size ( fragments ( i )% indices ) atom_i = fragments ( i )% indices ( k ) do l = 1 , size ( fragments ( j )% indices ) atom_j = fragments ( j )% indices ( l ) if ( atom_i == atom_j ) then ! Found overlapping atom call error % set ( ERROR_VALIDATION , \"Overlapping fragments detected: fragments \" // to_char ( i ) // \" and \" // & to_char ( j ) // \" both contain atom \" // to_char ( atom_i ) // & \". Set allow_overlapping_fragments = true to allow this.\" ) return end if end do end do end do end do end subroutine check_fragment_overlap","tags":"","url":"proc/check_fragment_overlap.html"},{"title":"config_to_driver – metalquicha","text":"public  subroutine config_to_driver(mqc_config, driver_config, molecule_index) Convert mqc_config_t to minimal driver_config_t\nExtracts only the fields needed by the driver\nIf molecule_index is provided, uses that molecule’s fragment count Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( driver_config_t ), intent(out) :: driver_config integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) Called by proc~~config_to_driver~~CalledByGraph proc~config_to_driver config_to_driver proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_driver program~main main program~main->proc~config_to_driver program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: nfrag_to_use Source Code subroutine config_to_driver ( mqc_config , driver_config , molecule_index ) !! Convert mqc_config_t to minimal driver_config_t !! Extracts only the fields needed by the driver !! If molecule_index is provided, uses that molecule's fragment count type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ), intent ( out ) :: driver_config integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: nfrag_to_use ! Copy method and calc_type (already integers) driver_config % method = mqc_config % method driver_config % calc_type = mqc_config % calc_type ! Determine fragment count if ( present ( molecule_index )) then ! Multi-molecule mode: use specific molecule's fragment count if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then nfrag_to_use = 0 else nfrag_to_use = mqc_config % molecules ( molecule_index )% nfrag end if else ! Single molecule mode (backward compatible) nfrag_to_use = mqc_config % nfrag end if ! Set fragmentation level ! For unfragmented calculations (nfrag=0), nlevel must be 0 if ( nfrag_to_use == 0 ) then driver_config % nlevel = 0 else driver_config % nlevel = mqc_config % frag_level end if ! Set GMBE overlapping fragments flag driver_config % allow_overlapping_fragments = mqc_config % allow_overlapping_fragments ! Set GMBE maximum intersection level driver_config % max_intersection_level = mqc_config % max_intersection_level ! Copy fragment distance cutoffs if present if ( allocated ( mqc_config % fragment_cutoffs )) then allocate ( driver_config % fragment_cutoffs ( size ( mqc_config % fragment_cutoffs ))) driver_config % fragment_cutoffs = mqc_config % fragment_cutoffs end if ! Copy XTB solvation settings if ( allocated ( mqc_config % solvent )) then driver_config % solvent = mqc_config % solvent end if if ( allocated ( mqc_config % solvation_model )) then driver_config % solvation_model = mqc_config % solvation_model end if driver_config % use_cds = mqc_config % use_cds driver_config % use_shift = mqc_config % use_shift ! Copy CPCM-specific settings driver_config % dielectric = mqc_config % dielectric driver_config % cpcm_nang = mqc_config % cpcm_nang driver_config % cpcm_rscale = mqc_config % cpcm_rscale ! Set calculation-specific keywords driver_config % hessian % displacement = mqc_config % hessian_displacement driver_config % hessian % temperature = mqc_config % hessian_temperature driver_config % hessian % pressure = mqc_config % hessian_pressure driver_config % aimd % dt = mqc_config % aimd_dt driver_config % aimd % nsteps = mqc_config % aimd_nsteps driver_config % aimd % initial_temperature = mqc_config % aimd_initial_temperature driver_config % aimd % output_frequency = mqc_config % aimd_output_frequency driver_config % scf % max_iterations = mqc_config % scf_maxiter driver_config % scf % convergence_threshold = mqc_config % scf_tolerance ! Output control driver_config % skip_json_output = mqc_config % skip_json_output end subroutine config_to_driver","tags":"","url":"proc/config_to_driver.html"},{"title":"config_to_system_geometry – metalquicha","text":"public  subroutine config_to_system_geometry(mqc_config, sys_geom, error, molecule_index) Convert mqc_config_t geometry to system_geometry_t\nFor unfragmented calculations (nfrag=0), treats entire system as single unit\nFor fragmented calculations, currently assumes monomer-based fragmentation\nIf molecule_index is provided, uses that specific molecule from multi-molecule mode Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) Calls proc~~config_to_system_geometry~~CallsGraph proc~config_to_system_geometry config_to_system_geometry proc~error_add_context error_t%error_add_context proc~config_to_system_geometry->proc~error_add_context proc~error_has_error error_t%error_has_error proc~config_to_system_geometry->proc~error_has_error proc~error_set error_t%error_set proc~config_to_system_geometry->proc~error_set proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~molecule_to_system_geometry->proc~error_set proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~initialize_fragmented_system->proc~error_add_context proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~config_to_system_geometry~~CalledByGraph proc~config_to_system_geometry config_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i logical, private :: use_angstrom Source Code subroutine config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index ) !! Convert mqc_config_t geometry to system_geometry_t !! For unfragmented calculations (nfrag=0), treats entire system as single unit !! For fragmented calculations, currently assumes monomer-based fragmentation !! If molecule_index is provided, uses that specific molecule from multi-molecule mode type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: i logical :: use_angstrom ! Determine units use_angstrom = . true . if ( allocated ( mqc_config % units )) then if ( trim ( mqc_config % units ) == 'bohr' ) then use_angstrom = . false . end if end if ! Handle multi-molecule vs single molecule mode if ( present ( molecule_index )) then ! Multi-molecule mode: extract specific molecule if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then call error % set ( ERROR_VALIDATION , \"Invalid molecule_index in multi-molecule mode\" ) return end if call molecule_to_system_geometry ( mqc_config % molecules ( molecule_index ), & sys_geom , use_angstrom , mqc_config % allow_overlapping_fragments , error ) else ! Single molecule mode (backward compatible) ! Check if geometry is loaded if ( mqc_config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in mqc_config\" ) return end if if ( mqc_config % nfrag == 0 ) then ! Unfragmented calculation: entire system is one \"monomer\" call geometry_to_system_unfragmented ( mqc_config % geometry , sys_geom , use_angstrom ) sys_geom % charge = mqc_config % charge sys_geom % multiplicity = mqc_config % multiplicity else ! Fragmented calculation with explicit fragments call geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_adapter:config_to_system_geometry\" ) return end if end if end if end subroutine config_to_system_geometry","tags":"","url":"proc/config_to_system_geometry.html"},{"title":"geometry_to_system_fragmented – metalquicha","text":"private  subroutine geometry_to_system_fragmented(mqc_config, sys_geom, use_angstrom, error) Convert geometry to system_geometry_t for fragmented calculation\nSupports both identical and variable-sized fragments Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom type( error_t ), intent(out) :: error Calls proc~~geometry_to_system_fragmented~~CallsGraph proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~element_symbol_to_number element_symbol_to_number proc~initialize_fragmented_system->proc~element_symbol_to_number proc~error_add_context error_t%error_add_context proc~initialize_fragmented_system->proc~error_add_context proc~error_has_error error_t%error_has_error proc~initialize_fragmented_system->proc~error_has_error proc~to_bohr to_bohr proc~initialize_fragmented_system->proc~to_bohr proc~error_set error_t%error_set proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~geometry_to_system_fragmented~~CalledByGraph proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) !! Convert geometry to system_geometry_t for fragmented calculation !! Supports both identical and variable-sized fragments type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error call initialize_fragmented_system ( mqc_config % nfrag , mqc_config % geometry , mqc_config % fragments , & mqc_config % charge , mqc_config % multiplicity , & mqc_config % allow_overlapping_fragments , use_angstrom , & sys_geom , error ) end subroutine geometry_to_system_fragmented","tags":"","url":"proc/geometry_to_system_fragmented.html"},{"title":"geometry_to_system_unfragmented – metalquicha","text":"private  subroutine geometry_to_system_unfragmented(geom, sys_geom, use_angstrom) Uses mqc_geometry proc~~geometry_to_system_unfragmented~~UsesGraph proc~geometry_to_system_unfragmented geometry_to_system_unfragmented module~mqc_geometry mqc_geometry proc~geometry_to_system_unfragmented->module~mqc_geometry pic_types pic_types module~mqc_geometry->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Convert geometry to system_geometry_t for unfragmented calculation\nTreats entire system as a single monomer Arguments Type Intent Optional Attributes Name type( geometry_type ), intent(in) :: geom type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom Calls proc~~geometry_to_system_unfragmented~~CallsGraph proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~geometry_to_system_unfragmented~~CalledByGraph proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine geometry_to_system_unfragmented ( geom , sys_geom , use_angstrom ) !! Convert geometry to system_geometry_t for unfragmented calculation !! Treats entire system as a single monomer use mqc_geometry , only : geometry_type type ( geometry_type ), intent ( in ) :: geom type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom integer :: i ! For unfragmented: n_monomers=1, atoms_per_monomer=natoms sys_geom % n_monomers = 1 sys_geom % atoms_per_monomer = geom % natoms sys_geom % total_atoms = geom % natoms allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine geometry_to_system_unfragmented","tags":"","url":"proc/geometry_to_system_unfragmented.html"},{"title":"initialize_fragmented_system – metalquicha","text":"private  subroutine initialize_fragmented_system(nfrag, geom, fragments, charge, multiplicity, allow_overlapping, use_angstrom, sys_geom, error) Uses mqc_geometry mqc_config_parser proc~~initialize_fragmented_system~~UsesGraph proc~initialize_fragmented_system initialize_fragmented_system module~mqc_config_parser mqc_config_parser proc~initialize_fragmented_system->module~mqc_config_parser module~mqc_geometry mqc_geometry proc~initialize_fragmented_system->module~mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_geometry->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Shared helper to initialize system_geometry_t for fragmented calculations\nHandles fragment allocation, size checking, and overlap validation Arguments Type Intent Optional Attributes Name integer, intent(in) :: nfrag type( geometry_type ), intent(in) :: geom type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: charge integer, intent(in) :: multiplicity logical, intent(in) :: allow_overlapping logical, intent(in) :: use_angstrom type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error Calls proc~~initialize_fragmented_system~~CallsGraph proc~initialize_fragmented_system initialize_fragmented_system proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~element_symbol_to_number element_symbol_to_number proc~initialize_fragmented_system->proc~element_symbol_to_number proc~error_add_context error_t%error_add_context proc~initialize_fragmented_system->proc~error_add_context proc~error_has_error error_t%error_has_error proc~initialize_fragmented_system->proc~error_has_error proc~to_bohr to_bohr proc~initialize_fragmented_system->proc~to_bohr proc~error_set error_t%error_set proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initialize_fragmented_system~~CalledByGraph proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: all_same_size integer, private :: atoms_in_first_frag integer, private :: i integer, private :: j integer, private :: max_frag_size Source Code subroutine initialize_fragmented_system ( nfrag , geom , fragments , charge , multiplicity , & allow_overlapping , use_angstrom , sys_geom , error ) !! Shared helper to initialize system_geometry_t for fragmented calculations !! Handles fragment allocation, size checking, and overlap validation use mqc_geometry , only : geometry_type use mqc_config_parser , only : input_fragment_t integer , intent ( in ) :: nfrag type ( geometry_type ), intent ( in ) :: geom type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: charge , multiplicity logical , intent ( in ) :: allow_overlapping logical , intent ( in ) :: use_angstrom type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer :: i , j , atoms_in_first_frag , max_frag_size logical :: all_same_size ! Set up basic system geometry sys_geom % n_monomers = nfrag sys_geom % total_atoms = geom % natoms sys_geom % charge = charge sys_geom % multiplicity = multiplicity ! Allocate fragment info arrays allocate ( sys_geom % fragment_sizes ( nfrag )) allocate ( sys_geom % fragment_charges ( nfrag )) allocate ( sys_geom % fragment_multiplicities ( nfrag )) ! Get fragment sizes max_frag_size = 0 atoms_in_first_frag = size ( fragments ( 1 )% indices ) all_same_size = . true . do i = 1 , nfrag sys_geom % fragment_sizes ( i ) = size ( fragments ( i )% indices ) sys_geom % fragment_charges ( i ) = fragments ( i )% charge sys_geom % fragment_multiplicities ( i ) = fragments ( i )% multiplicity max_frag_size = max ( max_frag_size , sys_geom % fragment_sizes ( i )) if ( sys_geom % fragment_sizes ( i ) /= atoms_in_first_frag ) then all_same_size = . false . end if end do ! Allocate fragment_atoms array allocate ( sys_geom % fragment_atoms ( max_frag_size , nfrag )) sys_geom % fragment_atoms = - 1 ! Initialize with invalid index ! Store fragment atom indices (0-indexed from input file) do i = 1 , nfrag do j = 1 , sys_geom % fragment_sizes ( i ) sys_geom % fragment_atoms ( j , i ) = fragments ( i )% indices ( j ) end do end do ! Check for overlapping fragments if not allowed if (. not . allow_overlapping ) then call check_fragment_overlap ( fragments , nfrag , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_adapter:geometry_to_system_fragmented\" ) return end if end if ! Set atoms_per_monomer: use common size if identical, else 0 if ( all_same_size ) then sys_geom % atoms_per_monomer = atoms_in_first_frag else sys_geom % atoms_per_monomer = 0 ! Signal variable-sized fragments end if allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine initialize_fragmented_system","tags":"","url":"proc/initialize_fragmented_system.html"},{"title":"molecule_to_system_geometry – metalquicha","text":"private  subroutine molecule_to_system_geometry(mol, sys_geom, use_angstrom, allow_overlapping, error) Uses mqc_config_parser proc~~molecule_to_system_geometry~~UsesGraph proc~molecule_to_system_geometry molecule_to_system_geometry module~mqc_config_parser mqc_config_parser proc~molecule_to_system_geometry->module~mqc_config_parser module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Convert a molecule_t to system_geometry_t\nHandles both unfragmented (nfrag=0) and fragmented molecules Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: mol type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom logical, intent(in) :: allow_overlapping type( error_t ), intent(out) :: error Calls proc~~molecule_to_system_geometry~~CallsGraph proc~molecule_to_system_geometry molecule_to_system_geometry proc~error_set error_t%error_set proc~molecule_to_system_geometry->proc~error_set proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~initialize_fragmented_system initialize_fragmented_system proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~initialize_fragmented_system->proc~element_symbol_to_number proc~error_add_context error_t%error_add_context proc~initialize_fragmented_system->proc~error_add_context proc~error_has_error error_t%error_has_error proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~molecule_to_system_geometry~~CalledByGraph proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine molecule_to_system_geometry ( mol , sys_geom , use_angstrom , allow_overlapping , error ) !! Convert a molecule_t to system_geometry_t !! Handles both unfragmented (nfrag=0) and fragmented molecules use mqc_config_parser , only : molecule_t type ( molecule_t ), intent ( in ) :: mol type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error logical , intent ( in ) :: allow_overlapping ! Check if geometry is loaded if ( mol % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in molecule\" ) return end if if ( mol % nfrag == 0 ) then ! Unfragmented molecule call geometry_to_system_unfragmented ( mol % geometry , sys_geom , use_angstrom ) sys_geom % charge = mol % charge sys_geom % multiplicity = mol % multiplicity else ! Fragmented molecule call initialize_fragmented_system ( mol % nfrag , mol % geometry , mol % fragments , & mol % charge , mol % multiplicity , & allow_overlapping , use_angstrom , & sys_geom , error ) end if end subroutine molecule_to_system_geometry","tags":"","url":"proc/molecule_to_system_geometry.html"},{"title":"json_output_data_destroy – metalquicha","text":"private  subroutine json_output_data_destroy(this) Clean up all allocated memory Type Bound json_output_data_t Arguments Type Intent Optional Attributes Name class( json_output_data_t ), intent(inout) :: this Calls proc~~json_output_data_destroy~~CallsGraph proc~json_output_data_destroy json_output_data_t%json_output_data_destroy proc~json_output_data_reset json_output_data_t%json_output_data_reset proc~json_output_data_destroy->proc~json_output_data_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~json_output_data_destroy~~CalledByGraph proc~json_output_data_destroy json_output_data_t%json_output_data_destroy proc~run_calculation run_calculation proc~run_calculation->proc~json_output_data_destroy proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine json_output_data_destroy ( this ) !! Clean up all allocated memory class ( json_output_data_t ), intent ( inout ) :: this ! Common data if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) ! Vibrational data if ( allocated ( this % frequencies )) deallocate ( this % frequencies ) if ( allocated ( this % reduced_masses )) deallocate ( this % reduced_masses ) if ( allocated ( this % force_constants )) deallocate ( this % force_constants ) if ( allocated ( this % ir_intensities )) deallocate ( this % ir_intensities ) ! MBE data if ( allocated ( this % polymers )) deallocate ( this % polymers ) if ( allocated ( this % fragment_energies )) deallocate ( this % fragment_energies ) if ( allocated ( this % delta_energies )) deallocate ( this % delta_energies ) if ( allocated ( this % sum_by_level )) deallocate ( this % sum_by_level ) if ( allocated ( this % fragment_distances )) deallocate ( this % fragment_distances ) ! GMBE PIE data if ( allocated ( this % pie_atom_sets )) deallocate ( this % pie_atom_sets ) if ( allocated ( this % pie_coefficients )) deallocate ( this % pie_coefficients ) if ( allocated ( this % pie_energies )) deallocate ( this % pie_energies ) call this % reset () end subroutine json_output_data_destroy","tags":"","url":"proc/json_output_data_destroy.html"},{"title":"json_output_data_reset – metalquicha","text":"private  subroutine json_output_data_reset(this) Reset all flags and scalar values to defaults Type Bound json_output_data_t Arguments Type Intent Optional Attributes Name class( json_output_data_t ), intent(inout) :: this Called by proc~~json_output_data_reset~~CalledByGraph proc~json_output_data_reset json_output_data_t%json_output_data_reset proc~json_output_data_destroy json_output_data_t%json_output_data_destroy proc~json_output_data_destroy->proc~json_output_data_reset proc~run_calculation run_calculation proc~run_calculation->proc~json_output_data_destroy proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine json_output_data_reset ( this ) !! Reset all flags and scalar values to defaults class ( json_output_data_t ), intent ( inout ) :: this this % output_mode = OUTPUT_MODE_NONE this % total_energy = 0.0_dp this % has_energy = . false . this % has_gradient = . false . this % has_hessian = . false . this % has_dipole = . false . this % has_vibrational = . false . this % has_ir_intensities = . false . this % fragment_count = 0 this % max_level = 0 this % n_pie_terms = 0 end subroutine json_output_data_reset","tags":"","url":"proc/json_output_data_reset.html"},{"title":"arrays_equal_internal – metalquicha","text":"private pure function arrays_equal_internal(a, b, n) result(equal) Check if two arrays are equal Arguments Type Intent Optional Attributes Name integer, intent(in) :: a (:) integer, intent(in) :: b (:) integer, intent(in) :: n Return Value logical Called by proc~~arrays_equal_internal~~CalledByGraph proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~fragment_lookup_find->proc~arrays_equal_internal proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe_delta->proc~fragment_lookup_find proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe_dipole->proc~fragment_lookup_find proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~fragment_lookup_find proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe->proc~compute_mbe_dipole proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure function arrays_equal_internal ( a , b , n ) result ( equal ) !! Check if two arrays are equal integer , intent ( in ) :: a (:), b (:), n logical :: equal integer :: i equal = . true . if ( size ( a ) /= n . or . size ( b ) /= n ) then equal = . false . return end if do i = 1 , n if ( a ( i ) /= b ( i )) then equal = . false . return end if end do end function arrays_equal_internal","tags":"","url":"proc/arrays_equal_internal.html"},{"title":"fragment_lookup_find – metalquicha","text":"private  function fragment_lookup_find(this, monomers, n) result(idx) Find fragment index for given monomer combination Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) Calls proc~~fragment_lookup_find~~CallsGraph proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_find~~CalledByGraph proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe_delta->proc~fragment_lookup_find proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe_dipole->proc~fragment_lookup_find proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~fragment_lookup_find proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe->proc~compute_mbe_dipole proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: bucket type( hash_entry_t ), private, pointer :: entry integer(kind=int32), private :: hash_val integer, private :: sorted_key (n) Source Code function fragment_lookup_find ( this , monomers , n ) result ( idx ) !! Find fragment index for given monomer combination class ( fragment_lookup_t ), intent ( in ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ) :: idx integer ( int32 ) :: hash_val integer :: bucket , sorted_key ( n ) type ( hash_entry_t ), pointer :: entry ! Sort monomers for canonical key sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Search chain if ( allocated ( this % table ( bucket )% key )) then if ( arrays_equal_internal ( this % table ( bucket )% key , sorted_key , n )) then idx = this % table ( bucket )% value return end if entry => this % table ( bucket )% next do while ( associated ( entry )) if ( arrays_equal_internal ( entry % key , sorted_key , n )) then idx = entry % value return end if entry => entry % next end do end if ! Not found idx = - 1 end function fragment_lookup_find","tags":"","url":"proc/fragment_lookup_find.html"},{"title":"next_prime_internal – metalquicha","text":"private pure function next_prime_internal(n) result(p) Find next prime number >= n (simple implementation) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer Called by proc~~next_prime_internal~~CalledByGraph proc~next_prime_internal next_prime_internal proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~fragment_lookup_init->proc~next_prime_internal proc~build_mbe_lookup_table build_mbe_lookup_table proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~compute_mbe compute_mbe proc~compute_mbe->proc~build_mbe_lookup_table proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i logical, private :: is_prime Source Code pure function next_prime_internal ( n ) result ( p ) !! Find next prime number >= n (simple implementation) integer , intent ( in ) :: n integer :: p , i logical :: is_prime p = max ( n , 2 ) if ( modulo ( p , 2 ) == 0 ) p = p + 1 do is_prime = . true . do i = 3 , int ( sqrt ( real ( p ))) + 1 , 2 if ( modulo ( p , i ) == 0 ) then is_prime = . false . exit end if end do if ( is_prime ) return p = p + 2 end do end function next_prime_internal","tags":"","url":"proc/next_prime_internal.html"},{"title":"fragment_lookup_destroy – metalquicha","text":"private pure subroutine fragment_lookup_destroy(this) Clean up hash table and all chains Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this Called by proc~~fragment_lookup_destroy~~CalledByGraph proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe compute_mbe proc~compute_mbe->proc~fragment_lookup_destroy proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( hash_entry_t ), private, pointer :: entry integer, private :: i type( hash_entry_t ), private, pointer :: next_entry Source Code pure subroutine fragment_lookup_destroy ( this ) !! Clean up hash table and all chains class ( fragment_lookup_t ), intent ( inout ) :: this integer :: i type ( hash_entry_t ), pointer :: entry , next_entry if (. not . this % initialized ) return do i = 1 , this % table_size ! Free chain entry => this % table ( i )% next do while ( associated ( entry )) next_entry => entry % next if ( allocated ( entry % key )) deallocate ( entry % key ) deallocate ( entry ) entry => next_entry end do ! Free bucket head if ( allocated ( this % table ( i )% key )) deallocate ( this % table ( i )% key ) end do deallocate ( this % table ) this % initialized = . false . end subroutine fragment_lookup_destroy","tags":"","url":"proc/fragment_lookup_destroy.html"},{"title":"fragment_lookup_init – metalquicha","text":"private pure subroutine fragment_lookup_init(this, estimated_entries) Initialize hash table with estimated size Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries Calls proc~~fragment_lookup_init~~CallsGraph proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_init~~CalledByGraph proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table build_mbe_lookup_table proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~compute_mbe compute_mbe proc~compute_mbe->proc~build_mbe_lookup_table proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine fragment_lookup_init ( this , estimated_entries ) !! Initialize hash table with estimated size class ( fragment_lookup_t ), intent ( inout ) :: this integer ( int64 ), intent ( in ) :: estimated_entries integer :: i ! Use prime number close to estimated size for better distribution this % table_size = next_prime_internal ( int ( estimated_entries * 1.3_dp )) allocate ( this % table ( this % table_size )) ! Initialize all entries as empty do i = 1 , this % table_size nullify ( this % table ( i )% next ) end do this % n_entries = 0 this % initialized = . true . end subroutine fragment_lookup_init","tags":"","url":"proc/fragment_lookup_init.html"},{"title":"fragment_lookup_insert – metalquicha","text":"private  subroutine fragment_lookup_insert(this, monomers, n, fragment_idx, error) Insert a monomer combination -> fragment index mapping Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx type( error_t ), intent(out), optional :: error Calls proc~~fragment_lookup_insert~~CallsGraph proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash proc~error_set error_t%error_set proc~fragment_lookup_insert->proc~error_set sort sort proc~fragment_lookup_insert->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_insert~~CalledByGraph proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table build_mbe_lookup_table proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~compute_mbe compute_mbe proc~compute_mbe->proc~build_mbe_lookup_table proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: bucket integer(kind=int32), private :: hash_val type( hash_entry_t ), private, pointer :: new_entry integer, private, allocatable :: sorted_key (:) Source Code subroutine fragment_lookup_insert ( this , monomers , n , fragment_idx , error ) !! Insert a monomer combination -> fragment index mapping class ( fragment_lookup_t ), intent ( inout ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ), intent ( in ) :: fragment_idx type ( error_t ), intent ( out ), optional :: error integer ( int32 ) :: hash_val integer :: bucket type ( hash_entry_t ), pointer :: new_entry integer , allocatable :: sorted_key (:) if (. not . this % initialized ) then if ( present ( error )) then call error % set ( ERROR_VALIDATION , \"Hash table not initialized\" ) end if return end if ! Sort monomers for canonical key allocate ( sorted_key ( n )) sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Check if this is the first entry in bucket if (. not . allocated ( this % table ( bucket )% key )) then ! First entry in this bucket - use the head entry allocate ( this % table ( bucket )% key ( n )) this % table ( bucket )% key = sorted_key this % table ( bucket )% value = fragment_idx this % n_entries = this % n_entries + 1 else ! Bucket already has entries - chain new entry allocate ( new_entry ) allocate ( new_entry % key ( n )) new_entry % key = sorted_key new_entry % value = fragment_idx new_entry % next => this % table ( bucket )% next this % table ( bucket )% next => new_entry this % n_entries = this % n_entries + 1 end if deallocate ( sorted_key ) end subroutine fragment_lookup_insert","tags":"","url":"proc/fragment_lookup_insert.html"},{"title":"get_frag_level_name – metalquicha","text":"public  function get_frag_level_name(frag_level) result(level_name) Map body level (n-mer) to descriptive name\nSupports up to decamers (10-mers), then falls back to “N-mers” format Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag_level Return Value character(len=32) Called by proc~~get_frag_level_name~~CalledByGraph proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown print_detailed_breakdown proc~print_detailed_breakdown->proc~get_frag_level_name proc~write_mbe_breakdown_json_impl write_mbe_breakdown_json_impl proc~write_mbe_breakdown_json_impl->proc~get_frag_level_name proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_detailed_breakdown proc~write_json_output write_json_output proc~write_json_output->proc~write_mbe_breakdown_json_impl proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~write_json_output proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_frag_level_name ( frag_level ) result ( level_name ) !! Map body level (n-mer) to descriptive name !! Supports up to decamers (10-mers), then falls back to \"N-mers\" format integer , intent ( in ) :: frag_level character ( len = 32 ) :: level_name select case ( frag_level ) case ( 1 ) level_name = \"monomers\" case ( 2 ) level_name = \"dimers\" case ( 3 ) level_name = \"trimers\" case ( 4 ) level_name = \"tetramers\" case ( 5 ) level_name = \"pentamers\" case ( 6 ) level_name = \"hexamers\" case ( 7 ) level_name = \"heptamers\" case ( 8 ) level_name = \"octamers\" case ( 9 ) level_name = \"nonamers\" case ( 10 ) level_name = \"decamers\" case default ! For levels > 10, use generic format write ( level_name , '(i0,a)' ) frag_level , \"-mers\" end select end function get_frag_level_name","tags":"","url":"proc/get_frag_level_name.html"},{"title":"print_detailed_breakdown – metalquicha","text":"public  subroutine print_detailed_breakdown(polymers, fragment_count, max_level, energies, delta_energies) Print detailed energy breakdown for each fragment\nShows full energy and deltaE correction for all monomers, dimers, trimers, etc.\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) Calls proc~~print_detailed_breakdown~~CallsGraph proc~print_detailed_breakdown print_detailed_breakdown header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name verbose verbose proc~print_detailed_breakdown->verbose warning warning proc~print_detailed_breakdown->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_detailed_breakdown~~CalledByGraph proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_detailed_breakdown proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: count_by_level character(len=512), private :: energy_line integer, private :: frag_level integer, private :: fragment_size character(len=512), private :: fragment_str integer(kind=int64), private :: i integer, private :: j Source Code subroutine print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) !! Print detailed energy breakdown for each fragment !! Shows full energy and deltaE correction for all monomers, dimers, trimers, etc. !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) integer ( int64 ) :: i integer :: fragment_size , j , frag_level character ( len = 512 ) :: fragment_str , energy_line integer ( int64 ) :: count_by_level call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) call logger % verbose ( \"Detailed Energy Breakdown by Fragment\" ) call logger % verbose ( \"============================================\" ) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). Using generic N-mers notation.\" ) end if do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then call logger % verbose ( \" \" ) block character ( len = 256 ) :: header character ( len = 32 ) :: level_name level_name = get_frag_level_name ( frag_level ) write ( header , '(a,a,i0,a)' ) trim ( level_name ), \" (\" , count_by_level , \" fragments):\" ! Capitalize first letter if ( len_trim ( level_name ) > 0 ) then if ( level_name ( 1 : 1 ) >= 'a' . and . level_name ( 1 : 1 ) <= 'z' ) then header ( 1 : 1 ) = achar ( iachar ( header ( 1 : 1 )) - 32 ) end if end if call logger % verbose ( trim ( header )) end block call logger % verbose ( \"--------------------------------------------\" ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then fragment_str = \"[\" do j = 1 , fragment_size if ( j > 1 ) then write ( fragment_str , '(a,a,i0)' ) trim ( fragment_str ), \",\" , polymers ( i , j ) else write ( fragment_str , '(a,i0)' ) trim ( fragment_str ), polymers ( i , j ) end if end do write ( fragment_str , '(a,a)' ) trim ( fragment_str ), \"]\" if ( frag_level == 1 ) then write ( energy_line , '(a,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ) else write ( energy_line , '(a,a,f20.10,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ), & \"   deltaE: \" , delta_energies ( i ) end if call logger % verbose ( trim ( energy_line )) end if end do end if end do call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) end subroutine print_detailed_breakdown","tags":"","url":"proc/print_detailed_breakdown.html"},{"title":"print_fragment_xyz – metalquicha","text":"public  subroutine print_fragment_xyz(fragment_idx, phys_frag) Print fragment geometry in XYZ format Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx type( physical_fragment_t ), intent(in) :: phys_frag Calls proc~~print_fragment_xyz~~CallsGraph proc~print_fragment_xyz print_fragment_xyz info info proc~print_fragment_xyz->info proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom to_char to_char proc~print_fragment_xyz->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_fragment_xyz~~CalledByGraph proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: coord_line integer, private :: i character(len=2), private :: symbol Source Code subroutine print_fragment_xyz ( fragment_idx , phys_frag ) !! Print fragment geometry in XYZ format integer ( int64 ), intent ( in ) :: fragment_idx type ( physical_fragment_t ), intent ( in ) :: phys_frag integer :: i character ( len = 2 ) :: symbol character ( len = 256 ) :: coord_line call logger % info ( \"=========================================\" ) call logger % info ( \" Fragment \" // to_char ( fragment_idx )) call logger % info ( \" Number of atoms: \" // to_char ( phys_frag % n_atoms )) call logger % info ( \" Coordinates in Angstroms:\" ) call logger % info ( \"-----------------------------------------\" ) do i = 1 , phys_frag % n_atoms symbol = element_number_to_symbol ( phys_frag % element_numbers ( i )) ! Convert from Bohr back to Angstroms for printing write ( coord_line , '(a2,3f15.8)' ) symbol , to_angstrom ( phys_frag % coordinates ( 1 : 3 , i )) call logger % info ( trim ( coord_line )) end do call logger % info ( \"=========================================\" ) end subroutine print_fragment_xyz","tags":"","url":"proc/print_fragment_xyz.html"},{"title":"hf_calc_energy – metalquicha","text":"private  subroutine hf_calc_energy(this, fragment, result) Calculate electronic energy using Hartree-Fock method Type Bound hf_method_t Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~hf_calc_energy~~CallsGraph proc~hf_calc_energy hf_method_t%hf_calc_energy proc~energy_total energy_t%energy_total proc~hf_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hf_calc_energy~~CalledByGraph proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_gradient->proc~hf_calc_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hf_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement actual HF calculation ! 1. Convert fragment%basis to libcint format ! 2. Build one-electron integrals (S, T, V) ! 3. Run SCF iterations ! 4. Calculate final energy print * , \"HF: Calculating energy for fragment with\" , fragment % n_atoms , \"atoms\" print * , \"HF: nelec =\" , fragment % nelec print * , \"HF: charge =\" , fragment % charge print * , \"HF: multiplicity =\" , fragment % multiplicity ! Dummy result result % energy % scf = - 1.0_dp ! Placeholder result % has_energy = . true . print * , \"HF: Dummy energy =\" , result % energy % total () end subroutine hf_calc_energy","tags":"","url":"proc/hf_calc_energy.html"},{"title":"hf_calc_gradient – metalquicha","text":"private  subroutine hf_calc_gradient(this, fragment, result) Calculate energy gradient using Hartree-Fock method Type Bound hf_method_t Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~hf_calc_gradient~~CallsGraph proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_gradient->proc~hf_calc_energy proc~energy_total energy_t%energy_total proc~hf_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hf_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement gradient calculation ! 1. Calculate energy (call calc_energy) ! 2. Calculate gradient using integral derivatives print * , \"HF: Calculating gradient for fragment with\" , fragment % n_atoms , \"atoms\" ! First get energy call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . print * , \"HF: Dummy gradient allocated\" end subroutine hf_calc_gradient","tags":"","url":"proc/hf_calc_gradient.html"},{"title":"null_hessian – metalquicha","text":"private  subroutine null_hessian(this, fragment, result) Placeholder for Hessian calculation Type Bound hf_method_t Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code subroutine null_hessian ( this , fragment , result ) !! Placeholder for Hessian calculation class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result print * , \"HF: Hessian calculation not implemented yet.\" result % has_hessian = . false . end subroutine null_hessian","tags":"","url":"proc/null_hessian.html"},{"title":"write_json_output – metalquicha","text":"public  subroutine write_json_output(output_data) THE single entry point for all JSON output Dispatches to the appropriate JSON writer based on output_mode.\nThis is the ONLY place in the codebase where JSON files are written. Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(in) :: output_data Calls proc~~write_json_output~~CallsGraph proc~write_json_output write_json_output error error proc~write_json_output->error proc~write_gmbe_pie_json_impl write_gmbe_pie_json_impl proc~write_json_output->proc~write_gmbe_pie_json_impl proc~write_mbe_breakdown_json_impl write_mbe_breakdown_json_impl proc~write_json_output->proc~write_mbe_breakdown_json_impl proc~write_unfragmented_json_impl write_unfragmented_json_impl proc~write_json_output->proc~write_unfragmented_json_impl proc~write_vibrational_json_impl write_vibrational_json_impl proc~write_json_output->proc~write_vibrational_json_impl proc~write_gmbe_pie_json_impl->error add add proc~write_gmbe_pie_json_impl->add create_array create_array proc~write_gmbe_pie_json_impl->create_array create_object create_object proc~write_gmbe_pie_json_impl->create_object destroy destroy proc~write_gmbe_pie_json_impl->destroy info info proc~write_gmbe_pie_json_impl->info initialize initialize proc~write_gmbe_pie_json_impl->initialize proc~get_basename get_basename proc~write_gmbe_pie_json_impl->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~write_gmbe_pie_json_impl->proc~get_output_json_filename proc~write_mbe_breakdown_json_impl->error proc~write_mbe_breakdown_json_impl->add proc~write_mbe_breakdown_json_impl->create_array proc~write_mbe_breakdown_json_impl->create_object proc~write_mbe_breakdown_json_impl->destroy proc~write_mbe_breakdown_json_impl->info proc~write_mbe_breakdown_json_impl->initialize proc~write_mbe_breakdown_json_impl->proc~get_basename proc~get_frag_level_name get_frag_level_name proc~write_mbe_breakdown_json_impl->proc~get_frag_level_name proc~write_mbe_breakdown_json_impl->proc~get_output_json_filename warning warning proc~write_mbe_breakdown_json_impl->warning proc~write_unfragmented_json_impl->error proc~write_unfragmented_json_impl->add proc~write_unfragmented_json_impl->create_object proc~write_unfragmented_json_impl->destroy proc~write_unfragmented_json_impl->info proc~write_unfragmented_json_impl->initialize proc~write_unfragmented_json_impl->proc~get_basename proc~write_unfragmented_json_impl->proc~get_output_json_filename proc~write_vibrational_json_impl->error proc~write_vibrational_json_impl->add proc~write_vibrational_json_impl->create_object proc~write_vibrational_json_impl->destroy proc~write_vibrational_json_impl->info proc~write_vibrational_json_impl->initialize proc~write_vibrational_json_impl->proc~get_basename proc~write_vibrational_json_impl->proc~get_output_json_filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_json_output~~CalledByGraph proc~write_json_output write_json_output proc~run_calculation run_calculation proc~run_calculation->proc~write_json_output proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_json_output ( output_data ) !! THE single entry point for all JSON output !! !! Dispatches to the appropriate JSON writer based on output_mode. !! This is the ONLY place in the codebase where JSON files are written. type ( json_output_data_t ), intent ( in ) :: output_data select case ( output_data % output_mode ) case ( OUTPUT_MODE_UNFRAGMENTED ) if ( output_data % has_vibrational ) then call write_vibrational_json_impl ( output_data ) else call write_unfragmented_json_impl ( output_data ) end if case ( OUTPUT_MODE_MBE ) if ( output_data % has_vibrational ) then call write_vibrational_json_impl ( output_data ) else call write_mbe_breakdown_json_impl ( output_data ) end if case ( OUTPUT_MODE_GMBE_PIE ) if ( output_data % has_vibrational ) then call write_vibrational_json_impl ( output_data ) else call write_gmbe_pie_json_impl ( output_data ) end if case default call logger % error ( \"Unknown output mode in write_json_output\" ) end select end subroutine write_json_output","tags":"","url":"proc/write_json_output.html"},{"title":"write_gmbe_pie_json_impl – metalquicha","text":"private  subroutine write_gmbe_pie_json_impl(data) Write GMBE PIE calculation results to output JSON file Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(in) :: data Calls proc~~write_gmbe_pie_json_impl~~CallsGraph proc~write_gmbe_pie_json_impl write_gmbe_pie_json_impl add add proc~write_gmbe_pie_json_impl->add create_array create_array proc~write_gmbe_pie_json_impl->create_array create_object create_object proc~write_gmbe_pie_json_impl->create_object destroy destroy proc~write_gmbe_pie_json_impl->destroy error error proc~write_gmbe_pie_json_impl->error info info proc~write_gmbe_pie_json_impl->info initialize initialize proc~write_gmbe_pie_json_impl->initialize proc~get_basename get_basename proc~write_gmbe_pie_json_impl->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~write_gmbe_pie_json_impl->proc~get_output_json_filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_gmbe_pie_json_impl~~CalledByGraph proc~write_gmbe_pie_json_impl write_gmbe_pie_json_impl proc~write_json_output write_json_output proc~write_json_output->proc~write_gmbe_pie_json_impl proc~run_calculation run_calculation proc~run_calculation->proc~write_json_output proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: atom_indices (:) character(len=256), private :: basename integer(kind=int64), private :: i integer, private :: io_stat integer, private :: iunit integer, private :: j type(json_core), private :: json type(json_value), private, pointer :: main_obj integer, private :: max_atoms integer, private :: n_atoms integer(kind=int64), private :: n_nonzero_terms character(len=256), private :: output_file type(json_value), private, pointer :: pie_obj type(json_value), private, pointer :: root type(json_value), private, pointer :: term_obj type(json_value), private, pointer :: terms_arr Source Code subroutine write_gmbe_pie_json_impl ( data ) !! Write GMBE PIE calculation results to output JSON file type ( json_output_data_t ), intent ( in ) :: data type ( json_core ) :: json type ( json_value ), pointer :: root , main_obj , pie_obj , terms_arr , term_obj integer :: j , max_atoms , n_atoms , iunit , io_stat integer ( int64 ) :: i , n_nonzero_terms integer , allocatable :: atom_indices (:) character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () call json % initialize ( real_format = JSON_REAL_FORMAT ) call json % create_object ( root , '' ) call json % create_object ( main_obj , trim ( basename )) call json % add ( root , main_obj ) call json % add ( main_obj , 'total_energy' , data % total_energy ) if ( data % has_gradient . and . allocated ( data % gradient )) then call json % add ( main_obj , 'gradient_norm' , sqrt ( sum ( data % gradient ** 2 ))) end if if ( data % has_hessian . and . allocated ( data % hessian )) then call json % add ( main_obj , 'hessian_frobenius_norm' , sqrt ( sum ( data % hessian ** 2 ))) end if ! Count non-zero coefficient terms if ( allocated ( data % pie_coefficients )) then n_nonzero_terms = count ( data % pie_coefficients ( 1 : data % n_pie_terms ) /= 0 ) else n_nonzero_terms = 0 end if ! PIE terms section call json % create_object ( pie_obj , 'pie_terms' ) call json % add ( main_obj , pie_obj ) call json % add ( pie_obj , 'count' , int ( n_nonzero_terms )) call json % create_array ( terms_arr , 'terms' ) call json % add ( pie_obj , terms_arr ) if ( allocated ( data % pie_atom_sets ) . and . allocated ( data % pie_coefficients ) . and . & allocated ( data % pie_energies )) then max_atoms = size ( data % pie_atom_sets , 1 ) do i = 1_int64 , data % n_pie_terms if ( data % pie_coefficients ( i ) == 0 ) cycle call json % create_object ( term_obj , '' ) call json % add ( terms_arr , term_obj ) ! Extract atom list size (atoms until negative sentinel) n_atoms = 0 do while ( n_atoms < max_atoms . and . data % pie_atom_sets ( n_atoms + 1 , i ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_indices ( n_atoms )) atom_indices = data % pie_atom_sets ( 1 : n_atoms , i ) call json % add ( term_obj , 'atom_indices' , atom_indices ) deallocate ( atom_indices ) call json % add ( term_obj , 'coefficient' , data % pie_coefficients ( i )) call json % add ( term_obj , 'energy' , data % pie_energies ( i )) call json % add ( term_obj , 'weighted_energy' , real ( data % pie_coefficients ( i ), dp ) * data % pie_energies ( i )) end do end if ! Write to file call logger % info ( \"Writing GMBE PIE JSON output to \" // trim ( output_file )) open ( newunit = iunit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) call json % destroy ( root ) return end if call json % print ( root , iunit ) close ( iunit ) call json % destroy ( root ) call logger % info ( \"GMBE PIE JSON output written successfully to \" // trim ( output_file )) end subroutine write_gmbe_pie_json_impl","tags":"","url":"proc/write_gmbe_pie_json_impl.html"},{"title":"write_mbe_breakdown_json_impl – metalquicha","text":"private  subroutine write_mbe_breakdown_json_impl(data) Write detailed MBE energy breakdown to JSON file Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(in) :: data Calls proc~~write_mbe_breakdown_json_impl~~CallsGraph proc~write_mbe_breakdown_json_impl write_mbe_breakdown_json_impl add add proc~write_mbe_breakdown_json_impl->add create_array create_array proc~write_mbe_breakdown_json_impl->create_array create_object create_object proc~write_mbe_breakdown_json_impl->create_object destroy destroy proc~write_mbe_breakdown_json_impl->destroy error error proc~write_mbe_breakdown_json_impl->error info info proc~write_mbe_breakdown_json_impl->info initialize initialize proc~write_mbe_breakdown_json_impl->initialize proc~get_basename get_basename proc~write_mbe_breakdown_json_impl->proc~get_basename proc~get_frag_level_name get_frag_level_name proc~write_mbe_breakdown_json_impl->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~write_mbe_breakdown_json_impl->proc~get_output_json_filename warning warning proc~write_mbe_breakdown_json_impl->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_mbe_breakdown_json_impl~~CalledByGraph proc~write_mbe_breakdown_json_impl write_mbe_breakdown_json_impl proc~write_json_output write_json_output proc~write_json_output->proc~write_mbe_breakdown_json_impl proc~run_calculation run_calculation proc~run_calculation->proc~write_json_output proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename integer(kind=int64), private :: count_by_level type(json_value), private, pointer :: dipole_obj integer, private :: frag_level type(json_value), private, pointer :: frag_obj integer, private :: fragment_size type(json_value), private, pointer :: frags_arr integer(kind=int64), private :: i integer, private, allocatable :: indices (:) integer, private :: io_stat integer, private :: iunit integer, private :: j type(json_core), private :: json character(len=32), private :: level_name type(json_value), private, pointer :: level_obj type(json_value), private, pointer :: levels_arr type(json_value), private, pointer :: main_obj character(len=256), private :: output_file type(json_value), private, pointer :: root Source Code subroutine write_mbe_breakdown_json_impl ( data ) !! Write detailed MBE energy breakdown to JSON file type ( json_output_data_t ), intent ( in ) :: data type ( json_core ) :: json type ( json_value ), pointer :: root , main_obj , levels_arr , level_obj , frags_arr , frag_obj type ( json_value ), pointer :: dipole_obj integer ( int64 ) :: i , count_by_level integer :: fragment_size , j , frag_level , iunit , io_stat integer , allocatable :: indices (:) character ( len = 32 ) :: level_name character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () if ( data % max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). JSON will use generic N-mers notation.\" ) end if call json % initialize ( real_format = JSON_REAL_FORMAT ) call json % create_object ( root , '' ) call json % create_object ( main_obj , trim ( basename )) call json % add ( root , main_obj ) call json % add ( main_obj , 'total_energy' , data % total_energy ) ! Build levels array call json % create_array ( levels_arr , 'levels' ) call json % add ( main_obj , levels_arr ) do frag_level = 1 , data % max_level count_by_level = 0_int64 do i = 1_int64 , data % fragment_count fragment_size = count ( data % polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then call json % create_object ( level_obj , '' ) call json % add ( levels_arr , level_obj ) level_name = get_frag_level_name ( frag_level ) call json % add ( level_obj , 'frag_level' , frag_level ) call json % add ( level_obj , 'name' , trim ( level_name )) call json % add ( level_obj , 'count' , int ( count_by_level )) if ( allocated ( data % sum_by_level )) then call json % add ( level_obj , 'total_energy' , data % sum_by_level ( frag_level )) end if call json % create_array ( frags_arr , 'fragments' ) call json % add ( level_obj , frags_arr ) do i = 1_int64 , data % fragment_count fragment_size = count ( data % polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then call json % create_object ( frag_obj , '' ) call json % add ( frags_arr , frag_obj ) allocate ( indices ( fragment_size )) indices = data % polymers ( i , 1 : fragment_size ) call json % add ( frag_obj , 'indices' , indices ) deallocate ( indices ) if ( allocated ( data % fragment_energies )) then call json % add ( frag_obj , 'energy' , data % fragment_energies ( i )) end if if ( allocated ( data % fragment_distances )) then call json % add ( frag_obj , 'distance' , data % fragment_distances ( i )) end if if ( frag_level > 1 . and . allocated ( data % delta_energies )) then call json % add ( frag_obj , 'delta_energy' , data % delta_energies ( i )) end if end if end do end if end do ! Add dipole if computed if ( data % has_dipole . and . allocated ( data % dipole )) then call json % create_object ( dipole_obj , 'dipole' ) call json % add ( main_obj , dipole_obj ) call json % add ( dipole_obj , 'x' , data % dipole ( 1 )) call json % add ( dipole_obj , 'y' , data % dipole ( 2 )) call json % add ( dipole_obj , 'z' , data % dipole ( 3 )) call json % add ( dipole_obj , 'magnitude_debye' , norm2 ( data % dipole ) * AU_TO_DEBYE ) end if if ( data % has_gradient . and . allocated ( data % gradient )) then call json % add ( main_obj , 'gradient_norm' , sqrt ( sum ( data % gradient ** 2 ))) end if if ( data % has_hessian . and . allocated ( data % hessian )) then call json % add ( main_obj , 'hessian_frobenius_norm' , sqrt ( sum ( data % hessian ** 2 ))) end if ! Write to file call logger % info ( \"Writing JSON output to \" // trim ( output_file )) open ( newunit = iunit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) call json % destroy ( root ) return end if call json % print ( root , iunit ) close ( iunit ) call json % destroy ( root ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine write_mbe_breakdown_json_impl","tags":"","url":"proc/write_mbe_breakdown_json_impl.html"},{"title":"write_unfragmented_json_impl – metalquicha","text":"private  subroutine write_unfragmented_json_impl(data) Write unfragmented calculation results to output JSON file Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(in) :: data Calls proc~~write_unfragmented_json_impl~~CallsGraph proc~write_unfragmented_json_impl write_unfragmented_json_impl add add proc~write_unfragmented_json_impl->add create_object create_object proc~write_unfragmented_json_impl->create_object destroy destroy proc~write_unfragmented_json_impl->destroy error error proc~write_unfragmented_json_impl->error info info proc~write_unfragmented_json_impl->info initialize initialize proc~write_unfragmented_json_impl->initialize proc~get_basename get_basename proc~write_unfragmented_json_impl->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~write_unfragmented_json_impl->proc~get_output_json_filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_unfragmented_json_impl~~CalledByGraph proc~write_unfragmented_json_impl write_unfragmented_json_impl proc~write_json_output write_json_output proc~write_json_output->proc~write_unfragmented_json_impl proc~run_calculation run_calculation proc~run_calculation->proc~write_json_output proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename type(json_value), private, pointer :: dipole_obj integer, private :: io_stat integer, private :: iunit type(json_core), private :: json type(json_value), private, pointer :: main_obj character(len=256), private :: output_file type(json_value), private, pointer :: root Source Code subroutine write_unfragmented_json_impl ( data ) !! Write unfragmented calculation results to output JSON file type ( json_output_data_t ), intent ( in ) :: data type ( json_core ) :: json type ( json_value ), pointer :: root , main_obj , dipole_obj integer :: iunit , io_stat character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () call json % initialize ( real_format = JSON_REAL_FORMAT ) call json % create_object ( root , '' ) call json % create_object ( main_obj , trim ( basename )) call json % add ( root , main_obj ) if ( data % has_energy ) call json % add ( main_obj , 'total_energy' , data % total_energy ) if ( data % has_dipole . and . allocated ( data % dipole )) then call json % create_object ( dipole_obj , 'dipole' ) call json % add ( main_obj , dipole_obj ) call json % add ( dipole_obj , 'x' , data % dipole ( 1 )) call json % add ( dipole_obj , 'y' , data % dipole ( 2 )) call json % add ( dipole_obj , 'z' , data % dipole ( 3 )) call json % add ( dipole_obj , 'magnitude_debye' , norm2 ( data % dipole ) * AU_TO_DEBYE ) end if if ( data % has_gradient . and . allocated ( data % gradient )) then call json % add ( main_obj , 'gradient_norm' , sqrt ( sum ( data % gradient ** 2 ))) end if if ( data % has_hessian . and . allocated ( data % hessian )) then call json % add ( main_obj , 'hessian_frobenius_norm' , sqrt ( sum ( data % hessian ** 2 ))) end if call logger % info ( \"Writing JSON output to \" // trim ( output_file )) open ( newunit = iunit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) call json % destroy ( root ) return end if call json % print ( root , iunit ) close ( iunit ) call json % destroy ( root ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine write_unfragmented_json_impl","tags":"","url":"proc/write_unfragmented_json_impl.html"},{"title":"write_vibrational_json_impl – metalquicha","text":"private  subroutine write_vibrational_json_impl(data) Write vibrational analysis and thermochemistry results to JSON file Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(in) :: data Calls proc~~write_vibrational_json_impl~~CallsGraph proc~write_vibrational_json_impl write_vibrational_json_impl add add proc~write_vibrational_json_impl->add create_object create_object proc~write_vibrational_json_impl->create_object destroy destroy proc~write_vibrational_json_impl->destroy error error proc~write_vibrational_json_impl->error info info proc~write_vibrational_json_impl->info initialize initialize proc~write_vibrational_json_impl->initialize proc~get_basename get_basename proc~write_vibrational_json_impl->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~write_vibrational_json_impl->proc~get_output_json_filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_vibrational_json_impl~~CalledByGraph proc~write_vibrational_json_impl write_vibrational_json_impl proc~write_json_output write_json_output proc~write_json_output->proc~write_vibrational_json_impl proc~run_calculation run_calculation proc~run_calculation->proc~write_json_output proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: Cp_trans real(kind=dp), private :: Cv_int real(kind=dp), private :: Cv_total real(kind=dp), private :: H_int_cal real(kind=dp), private :: H_rot_cal real(kind=dp), private :: H_total_cal real(kind=dp), private :: H_trans_cal real(kind=dp), private :: H_vib_cal real(kind=dp), private :: S_int real(kind=dp), private :: S_int_J real(kind=dp), private :: S_total real(kind=dp), private :: S_total_J character(len=256), private :: basename type(json_value), private, pointer :: contrib_obj type(json_value), private, pointer :: dipole_obj type(json_value), private, pointer :: elec_obj real(kind=dp), private :: grad_norm real(kind=dp), private :: hess_norm type(json_value), private, pointer :: int_row integer, private :: io_stat integer, private :: iunit type(json_core), private :: json type(json_value), private, pointer :: main_obj type(json_value), private, pointer :: moi_obj character(len=256), private :: output_file real(kind=dp), private :: pV_cal type(json_value), private, pointer :: pf_obj type(json_value), private, pointer :: root type(json_value), private, pointer :: rot_contrib type(json_value), private, pointer :: rot_obj type(json_value), private, pointer :: rot_row type(json_value), private, pointer :: table_obj type(json_value), private, pointer :: thermal_obj type(json_value), private, pointer :: thermo_obj type(json_value), private, pointer :: tot_row type(json_value), private, pointer :: total_e_obj type(json_value), private, pointer :: tr_row type(json_value), private, pointer :: trans_obj type(json_value), private, pointer :: vib_contrib type(json_value), private, pointer :: vib_obj type(json_value), private, pointer :: vib_row Source Code subroutine write_vibrational_json_impl ( data ) !! Write vibrational analysis and thermochemistry results to JSON file type ( json_output_data_t ), intent ( in ) :: data type ( json_core ) :: json type ( json_value ), pointer :: root , main_obj , dipole_obj , vib_obj , thermo_obj type ( json_value ), pointer :: moi_obj , rot_obj , pf_obj , contrib_obj , table_obj type ( json_value ), pointer :: trans_obj , rot_contrib , vib_contrib , elec_obj type ( json_value ), pointer :: vib_row , rot_row , int_row , tr_row , tot_row type ( json_value ), pointer :: thermal_obj , total_e_obj integer :: io_stat , iunit character ( len = 256 ) :: output_file , basename real ( dp ) :: pV_cal , H_vib_cal , H_rot_cal , H_trans_cal , H_total_cal real ( dp ) :: Cv_total , S_total , S_total_J , H_int_cal , Cv_int , S_int , S_int_J , Cp_trans real ( dp ) :: grad_norm , hess_norm output_file = get_output_json_filename () basename = get_basename () call json % initialize ( real_format = JSON_REAL_FORMAT ) ! Create root object call json % create_object ( root , '' ) ! Create main object with basename as key call json % create_object ( main_obj , trim ( basename )) call json % add ( root , main_obj ) ! Total energy if ( data % has_energy ) call json % add ( main_obj , 'total_energy' , data % total_energy ) ! Dipole if ( data % has_dipole . and . allocated ( data % dipole )) then call json % create_object ( dipole_obj , 'dipole' ) call json % add ( main_obj , dipole_obj ) call json % add ( dipole_obj , 'x' , data % dipole ( 1 )) call json % add ( dipole_obj , 'y' , data % dipole ( 2 )) call json % add ( dipole_obj , 'z' , data % dipole ( 3 )) call json % add ( dipole_obj , 'magnitude_debye' , norm2 ( data % dipole ) * AU_TO_DEBYE ) end if ! Gradient and Hessian norms if ( data % has_gradient . and . allocated ( data % gradient )) then grad_norm = sqrt ( sum ( data % gradient ** 2 )) call json % add ( main_obj , 'gradient_norm' , grad_norm ) end if if ( data % has_hessian . and . allocated ( data % hessian )) then hess_norm = sqrt ( sum ( data % hessian ** 2 )) call json % add ( main_obj , 'hessian_frobenius_norm' , hess_norm ) end if ! Vibrational analysis section call json % create_object ( vib_obj , 'vibrational_analysis' ) call json % add ( main_obj , vib_obj ) if ( allocated ( data % frequencies )) then call json % add ( vib_obj , 'n_modes' , size ( data % frequencies )) call json % add ( vib_obj , 'frequencies_cm1' , data % frequencies ) end if if ( allocated ( data % reduced_masses )) then call json % add ( vib_obj , 'reduced_masses_amu' , data % reduced_masses ) end if if ( allocated ( data % force_constants )) then call json % add ( vib_obj , 'force_constants_mdyne_ang' , data % force_constants ) end if if ( data % has_ir_intensities . and . allocated ( data % ir_intensities )) then call json % add ( vib_obj , 'ir_intensities_km_mol' , data % ir_intensities ) end if ! Thermochemistry section call json % create_object ( thermo_obj , 'thermochemistry' ) call json % add ( main_obj , thermo_obj ) ! Conditions call json % add ( thermo_obj , 'temperature_K' , data % thermo % temperature ) call json % add ( thermo_obj , 'pressure_atm' , data % thermo % pressure ) call json % add ( thermo_obj , 'molecular_mass_amu' , data % thermo % total_mass ) call json % add ( thermo_obj , 'symmetry_number' , data % thermo % symmetry_number ) call json % add ( thermo_obj , 'spin_multiplicity' , data % thermo % spin_multiplicity ) call json % add ( thermo_obj , 'is_linear' , data % thermo % is_linear ) call json % add ( thermo_obj , 'n_real_frequencies' , data % thermo % n_real_freqs ) call json % add ( thermo_obj , 'n_imaginary_frequencies' , data % thermo % n_imag_freqs ) ! Moments of inertia call json % create_object ( moi_obj , 'moments_of_inertia_amu_ang2' ) call json % add ( thermo_obj , moi_obj ) call json % add ( moi_obj , 'Ia' , data % thermo % moments ( 1 )) call json % add ( moi_obj , 'Ib' , data % thermo % moments ( 2 )) call json % add ( moi_obj , 'Ic' , data % thermo % moments ( 3 )) ! Rotational constants call json % create_object ( rot_obj , 'rotational_constants_GHz' ) call json % add ( thermo_obj , rot_obj ) call json % add ( rot_obj , 'A' , data % thermo % rot_const ( 1 )) call json % add ( rot_obj , 'B' , data % thermo % rot_const ( 2 )) call json % add ( rot_obj , 'C' , data % thermo % rot_const ( 3 )) ! Partition functions call json % create_object ( pf_obj , 'partition_functions' ) call json % add ( thermo_obj , pf_obj ) call json % add ( pf_obj , 'translational' , data % thermo % q_trans ) call json % add ( pf_obj , 'rotational' , data % thermo % q_rot ) call json % add ( pf_obj , 'vibrational' , data % thermo % q_vib ) ! Thermodynamic contributions call json % create_object ( contrib_obj , 'contributions' ) call json % add ( thermo_obj , contrib_obj ) call json % create_object ( trans_obj , 'translational' ) call json % add ( contrib_obj , trans_obj ) call json % add ( trans_obj , 'energy_hartree' , data % thermo % E_trans ) call json % add ( trans_obj , 'entropy_cal_mol_K' , data % thermo % S_trans ) call json % add ( trans_obj , 'Cv_cal_mol_K' , data % thermo % Cv_trans ) call json % create_object ( rot_contrib , 'rotational' ) call json % add ( contrib_obj , rot_contrib ) call json % add ( rot_contrib , 'energy_hartree' , data % thermo % E_rot ) call json % add ( rot_contrib , 'entropy_cal_mol_K' , data % thermo % S_rot ) call json % add ( rot_contrib , 'Cv_cal_mol_K' , data % thermo % Cv_rot ) call json % create_object ( vib_contrib , 'vibrational' ) call json % add ( contrib_obj , vib_contrib ) call json % add ( vib_contrib , 'energy_hartree' , data % thermo % E_vib ) call json % add ( vib_contrib , 'entropy_cal_mol_K' , data % thermo % S_vib ) call json % add ( vib_contrib , 'Cv_cal_mol_K' , data % thermo % Cv_vib ) call json % create_object ( elec_obj , 'electronic' ) call json % add ( contrib_obj , elec_obj ) call json % add ( elec_obj , 'energy_hartree' , data % thermo % E_elec ) call json % add ( elec_obj , 'entropy_cal_mol_K' , data % thermo % S_elec ) ! Contribution table pV_cal = R_CALMOLK * data % thermo % temperature H_vib_cal = data % thermo % E_vib * HARTREE_TO_CALMOL H_rot_cal = data % thermo % E_rot * HARTREE_TO_CALMOL H_trans_cal = data % thermo % E_trans * HARTREE_TO_CALMOL + pV_cal H_total_cal = H_vib_cal + H_rot_cal + H_trans_cal H_int_cal = H_vib_cal + H_rot_cal Cp_trans = data % thermo % Cv_trans + R_CALMOLK Cv_int = data % thermo % Cv_vib + data % thermo % Cv_rot Cv_total = Cp_trans + data % thermo % Cv_rot + data % thermo % Cv_vib S_int = data % thermo % S_vib + data % thermo % S_rot S_int_J = S_int * CAL_TO_J S_total = data % thermo % S_trans + data % thermo % S_rot + data % thermo % S_vib + data % thermo % S_elec S_total_J = S_total * CAL_TO_J call json % create_object ( table_obj , 'contribution_table' ) call json % add ( thermo_obj , table_obj ) call json % create_object ( vib_row , 'VIB' ) call json % add ( table_obj , vib_row ) call json % add ( vib_row , 'H_cal_mol' , H_vib_cal ) call json % add ( vib_row , 'Cp_cal_mol_K' , data % thermo % Cv_vib ) call json % add ( vib_row , 'S_cal_mol_K' , data % thermo % S_vib ) call json % add ( vib_row , 'S_J_mol_K' , data % thermo % S_vib * CAL_TO_J ) call json % create_object ( rot_row , 'ROT' ) call json % add ( table_obj , rot_row ) call json % add ( rot_row , 'H_cal_mol' , H_rot_cal ) call json % add ( rot_row , 'Cp_cal_mol_K' , data % thermo % Cv_rot ) call json % add ( rot_row , 'S_cal_mol_K' , data % thermo % S_rot ) call json % add ( rot_row , 'S_J_mol_K' , data % thermo % S_rot * CAL_TO_J ) call json % create_object ( int_row , 'INT' ) call json % add ( table_obj , int_row ) call json % add ( int_row , 'H_cal_mol' , H_int_cal ) call json % add ( int_row , 'Cp_cal_mol_K' , Cv_int ) call json % add ( int_row , 'S_cal_mol_K' , S_int ) call json % add ( int_row , 'S_J_mol_K' , S_int_J ) call json % create_object ( tr_row , 'TR' ) call json % add ( table_obj , tr_row ) call json % add ( tr_row , 'H_cal_mol' , H_trans_cal ) call json % add ( tr_row , 'Cp_cal_mol_K' , Cp_trans ) call json % add ( tr_row , 'S_cal_mol_K' , data % thermo % S_trans ) call json % add ( tr_row , 'S_J_mol_K' , data % thermo % S_trans * CAL_TO_J ) call json % create_object ( tot_row , 'TOT' ) call json % add ( table_obj , tot_row ) call json % add ( tot_row , 'H_cal_mol' , H_total_cal ) call json % add ( tot_row , 'Cp_cal_mol_K' , Cv_total ) call json % add ( tot_row , 'S_cal_mol_K' , S_total ) call json % add ( tot_row , 'S_J_mol_K' , S_total_J ) ! Zero-point energy call json % add ( thermo_obj , 'zero_point_energy_hartree' , data % thermo % zpe_hartree ) call json % add ( thermo_obj , 'zero_point_energy_kcal_mol' , data % thermo % zpe_kcalmol ) ! Thermal corrections call json % create_object ( thermal_obj , 'thermal_corrections_hartree' ) call json % add ( thermo_obj , thermal_obj ) call json % add ( thermal_obj , 'to_energy' , data % thermo % thermal_correction_energy ) call json % add ( thermal_obj , 'to_enthalpy' , data % thermo % thermal_correction_enthalpy ) call json % add ( thermal_obj , 'to_gibbs' , data % thermo % thermal_correction_gibbs ) ! Total energies call json % create_object ( total_e_obj , 'total_energies_hartree' ) call json % add ( thermo_obj , total_e_obj ) call json % add ( total_e_obj , 'electronic' , data % total_energy ) call json % add ( total_e_obj , 'electronic_plus_zpe' , data % total_energy + data % thermo % zpe_hartree ) call json % add ( total_e_obj , 'electronic_plus_thermal_E' , data % total_energy + data % thermo % thermal_correction_energy ) call json % add ( total_e_obj , 'electronic_plus_thermal_H' , data % total_energy + data % thermo % thermal_correction_enthalpy ) call json % add ( total_e_obj , 'electronic_plus_thermal_G' , data % total_energy + data % thermo % thermal_correction_gibbs ) ! Write to file call logger % info ( \"Writing vibrational/thermochemistry JSON to \" // trim ( output_file )) open ( newunit = iunit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) call json % destroy ( root ) return end if call json % print ( root , iunit ) close ( iunit ) call json % destroy ( root ) call logger % info ( \"Vibrational/thermochemistry JSON written successfully to \" // trim ( output_file )) end subroutine write_vibrational_json_impl","tags":"","url":"proc/write_vibrational_json_impl.html"},{"title":"compute_energy_and_forces – metalquicha","text":"public  subroutine compute_energy_and_forces(sys_geom, driver_config, resources, energy, gradient, hessian, bonds) Uses mqc_config_adapter mqc_driver proc~~compute_energy_and_forces~~UsesGraph proc~compute_energy_and_forces compute_energy_and_forces module~mqc_config_adapter mqc_config_adapter proc~compute_energy_and_forces->module~mqc_config_adapter module~mqc_driver mqc_driver proc~compute_energy_and_forces->module~mqc_driver module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment pic_logger pic_logger module~mqc_config_adapter->pic_logger pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_driver->module~mqc_config_adapter module~mqc_calc_types mqc_calc_types module~mqc_driver->module~mqc_calc_types module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_error module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_io_helpers mqc_io_helpers module~mqc_driver->module~mqc_io_helpers module~mqc_json mqc_json module~mqc_driver->module~mqc_json module~mqc_json_output_types mqc_json_output_types module~mqc_driver->module~mqc_json_output_types module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_method_config mqc_method_config module~mqc_driver->module~mqc_method_config module~mqc_method_types mqc_method_types module~mqc_driver->module~mqc_method_types module~mqc_driver->module~mqc_physical_fragment module~mqc_resources mqc_resources module~mqc_driver->module~mqc_resources module~mqc_result_types mqc_result_types module~mqc_driver->module~mqc_result_types omp_lib omp_lib module~mqc_driver->omp_lib pic_io pic_io module~mqc_driver->pic_io module~mqc_driver->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_driver->pic_mpi_lib module~mqc_driver->pic_types module~mqc_calc_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->pic_io module~mqc_gmbe_fragment_distribution_scheme->pic_logger module~mqc_gmbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_gmbe_fragment_distribution_scheme->pic_types module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_thermochemistry mqc_thermochemistry module~mqc_gmbe_fragment_distribution_scheme->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis pic_timer pic_timer module~mqc_gmbe_fragment_distribution_scheme->pic_timer module~mqc_json->pic_io module~mqc_json->pic_logger module~mqc_json_output_types->pic_types module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_json_writer->module~mqc_io_helpers module~mqc_json_writer->module~mqc_json_output_types module~mqc_json_writer->pic_logger module~mqc_json_writer->pic_types json_module json_module module~mqc_json_writer->json_module module~mqc_mbe_io mqc_mbe_io module~mqc_json_writer->module~mqc_mbe_io module~mqc_physical_constants mqc_physical_constants module~mqc_json_writer->module~mqc_physical_constants module~mqc_program_limits mqc_program_limits module~mqc_json_writer->module~mqc_program_limits module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_program_limits module~mqc_mbe->module~mqc_thermochemistry module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe->pic_timer module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_resources module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme->omp_lib module~mqc_mbe_fragment_distribution_scheme->pic_io module~mqc_mbe_fragment_distribution_scheme->pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_timer module~mqc_method_config->module~mqc_method_types module~mqc_method_config->pic_types module~mqc_method_types->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms module~mqc_result_types->module~mqc_error module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->module~mqc_error module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_geometry->pic_types module~mqc_gmbe_utils->module~mqc_error module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_mbe_io->module~mqc_elements module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_method_factory->module~mqc_method_config module~mqc_method_factory->module~mqc_method_types module~mqc_method_factory->pic_types module~mqc_method_factory->module~mqc_method_base mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_mpi_comms->pic_mpi_lib module~mqc_mpi_tags->pic_types module~mqc_physical_constants->pic_types module~mqc_program_limits->pic_types module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->pic_io module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_thermochemistry->module~mqc_physical_constants pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->pic_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->pic_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb->module~mqc_error module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_logger module~mqc_method_xtb->pic_types module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->pic_timer module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute energy and forces for current geometry\nThis is the main interface for optimization/dynamics codes Master rank provides updated geometry, all ranks compute fragments,\nresults are returned on master rank only Usage:\n  1. Master rank updates sys_geom%coordinates\n  2. Call this subroutine (all ranks)\n  3. Master rank receives energy/gradient/hessian\n  4. Master rank updates geometry based on forces\n  5. Repeat from step 1 Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(inout) :: sys_geom type( driver_config_t ), intent(in) :: driver_config type( resources_t ), intent(in) :: resources real(kind=dp), intent(out) :: energy real(kind=dp), intent(out), optional :: gradient (:,:) (3, total_atoms) real(kind=dp), intent(out), optional :: hessian (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~compute_energy_and_forces~~CallsGraph proc~compute_energy_and_forces compute_energy_and_forces abort_comm abort_comm proc~compute_energy_and_forces->abort_comm error error proc~compute_energy_and_forces->error proc~energy_total energy_t%energy_total proc~compute_energy_and_forces->proc~energy_total proc~result_destroy calculation_result_t%result_destroy proc~compute_energy_and_forces->proc~result_destroy proc~run_calculation run_calculation proc~compute_energy_and_forces->proc~run_calculation proc~sync_geometry_to_workers sync_geometry_to_workers proc~compute_energy_and_forces->proc~sync_geometry_to_workers proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset info info proc~run_calculation->info omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~json_output_data_destroy json_output_data_t%json_output_data_destroy proc~run_calculation->proc~json_output_data_destroy proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~write_json_output write_json_output proc~run_calculation->proc~write_json_output proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~run_calculation->proc~xtb_has_solvation to_char to_char proc~run_calculation->to_char warning warning proc~run_calculation->warning proc~json_output_data_reset json_output_data_t%json_output_data_reset proc~json_output_data_destroy->proc~json_output_data_reset proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear proc~run_fragmented_calculation->abort_comm proc~run_fragmented_calculation->error proc~run_fragmented_calculation->info proc~run_fragmented_calculation->omp_set_num_threads proc~run_fragmented_calculation->to_char allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_coordinator node_coordinator proc~run_fragmented_calculation->interface~node_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation->proc~apply_distance_screening proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~error_get_message error_t%error_get_message proc~run_fragmented_calculation->proc~error_get_message proc~error_has_error error_t%error_has_error proc~run_fragmented_calculation->proc~error_has_error proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation->proc~sort_fragments_by_size verbose verbose proc~run_fragmented_calculation->verbose proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~run_unfragmented_calculation->verbose proc~write_json_output->error proc~write_gmbe_pie_json_impl write_gmbe_pie_json_impl proc~write_json_output->proc~write_gmbe_pie_json_impl proc~write_mbe_breakdown_json_impl write_mbe_breakdown_json_impl proc~write_json_output->proc~write_mbe_breakdown_json_impl proc~write_unfragmented_json_impl write_unfragmented_json_impl proc~write_json_output->proc~write_unfragmented_json_impl proc~write_vibrational_json_impl write_vibrational_json_impl proc~write_json_output->proc~write_vibrational_json_impl proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~node_worker node_worker interface~node_worker->proc~node_worker proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~apply_distance_screening->info proc~apply_distance_screening->to_char proc~fragment_should_be_screened fragment_should_be_screened proc~apply_distance_screening->proc~fragment_should_be_screened proc~combine_util combine_util proc~combine->proc~combine_util proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->to_char proc~gmbe_enumerate_pie_terms->proc~error_has_error atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~error_set error_t%error_set proc~gmbe_enumerate_pie_terms->proc~error_set proc~gmbe_pie_coordinator->abort_comm proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->proc~energy_total proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->proc~error_get_message proc~gmbe_pie_coordinator->verbose cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies get_elapsed_time get_elapsed_time proc~gmbe_pie_coordinator->get_elapsed_time iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_thermochemistry compute_thermochemistry proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~gmbe_pie_coordinator->proc~redistribute_cap_dipole_derivatives proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses start start proc~gmbe_pie_coordinator->start proc~serial_gmbe_pie_processor->error proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->proc~error_get_message proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->cart_disp proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->fc_mdyne proc~serial_gmbe_pie_processor->force_constants proc~serial_gmbe_pie_processor->frequencies interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~error_get_full_trace error_t%error_get_full_trace proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~redistribute_cap_dipole_derivatives proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor->reduced_masses proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index proc~write_gmbe_pie_json_impl->error proc~write_gmbe_pie_json_impl->info add add proc~write_gmbe_pie_json_impl->add create_array create_array proc~write_gmbe_pie_json_impl->create_array create_object create_object proc~write_gmbe_pie_json_impl->create_object destroy destroy proc~write_gmbe_pie_json_impl->destroy initialize initialize proc~write_gmbe_pie_json_impl->initialize proc~get_basename get_basename proc~write_gmbe_pie_json_impl->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~write_gmbe_pie_json_impl->proc~get_output_json_filename proc~write_mbe_breakdown_json_impl->error proc~write_mbe_breakdown_json_impl->info proc~write_mbe_breakdown_json_impl->warning proc~write_mbe_breakdown_json_impl->add proc~write_mbe_breakdown_json_impl->create_array proc~write_mbe_breakdown_json_impl->create_object proc~write_mbe_breakdown_json_impl->destroy proc~write_mbe_breakdown_json_impl->initialize proc~write_mbe_breakdown_json_impl->proc~get_basename proc~get_frag_level_name get_frag_level_name proc~write_mbe_breakdown_json_impl->proc~get_frag_level_name proc~write_mbe_breakdown_json_impl->proc~get_output_json_filename proc~write_unfragmented_json_impl->error proc~write_unfragmented_json_impl->info proc~write_unfragmented_json_impl->add proc~write_unfragmented_json_impl->create_object proc~write_unfragmented_json_impl->destroy proc~write_unfragmented_json_impl->initialize proc~write_unfragmented_json_impl->proc~get_basename proc~write_unfragmented_json_impl->proc~get_output_json_filename proc~write_vibrational_json_impl->error proc~write_vibrational_json_impl->info proc~write_vibrational_json_impl->add proc~write_vibrational_json_impl->create_object proc~write_vibrational_json_impl->destroy proc~write_vibrational_json_impl->initialize proc~write_vibrational_json_impl->proc~get_basename proc~write_vibrational_json_impl->proc~get_output_json_filename proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~combine_util->proc~combine_util proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~dfs_pie_accumulate->proc~error_has_error proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect barrier barrier proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~calculate_monomer_distance calculate_monomer_distance proc~fragment_should_be_screened->proc~calculate_monomer_distance proc~get_next_combination get_next_combination proc~fragment_should_be_screened->proc~get_next_combination proc~global_coordinator->abort_comm proc~global_coordinator->error proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->proc~error_get_message proc~global_coordinator->verbose proc~global_coordinator->destroy proc~global_coordinator->get_elapsed_time proc~global_coordinator->iprobe proc~global_coordinator->irecv proc~global_coordinator->isend proc~global_coordinator->proc~result_irecv proc~global_coordinator->start allocate_dipole allocate_dipole proc~global_coordinator->allocate_dipole allocate_gradient allocate_gradient proc~global_coordinator->allocate_gradient allocate_hessian allocate_hessian proc~global_coordinator->allocate_hessian debug debug proc~global_coordinator->debug proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~node_coordinator->abort_comm proc~node_coordinator->error proc~node_coordinator->to_char proc~node_coordinator->proc~error_get_message proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->abort_comm proc~node_worker->error proc~node_worker->to_char proc~node_worker->proc~error_has_error proc~node_worker->interface~do_fragment_work proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~error_get_full_trace proc~node_worker->proc~fragment_destroy proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~result_isend proc~node_worker->recv proc~print_vibrational_analysis->info proc~print_vibrational_analysis->warning proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~result_irecv->irecv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~serial_fragment_processor->error proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->info proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->to_char proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->proc~error_get_message proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->verbose proc~serial_fragment_processor->configuration proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~error_get_full_trace proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~mbe_result_allocate_dipole mbe_result_t%mbe_result_allocate_dipole proc~serial_fragment_processor->proc~mbe_result_allocate_dipole proc~mbe_result_allocate_gradient mbe_result_t%mbe_result_allocate_gradient proc~serial_fragment_processor->proc~mbe_result_allocate_gradient proc~mbe_result_allocate_hessian mbe_result_t%mbe_result_allocate_hessian proc~serial_fragment_processor->proc~mbe_result_allocate_hessian proc~unfragmented_calculation->error proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~result_destroy proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char proc~unfragmented_calculation->proc~error_get_message proc~unfragmented_calculation->proc~error_has_error proc~unfragmented_calculation->cart_disp proc~unfragmented_calculation->configuration proc~unfragmented_calculation->fc_mdyne proc~unfragmented_calculation->force_constants proc~unfragmented_calculation->frequencies proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~unfragmented_calculation->proc~error_get_full_trace proc~unfragmented_calculation->proc~print_vibrational_analysis proc~unfragmented_calculation->reduced_masses eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues ir_intensities ir_intensities proc~unfragmented_calculation->ir_intensities proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~fragment_compute_nelec projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: need_gradient logical, private :: need_hessian type( calculation_result_t ), private :: result Source Code subroutine compute_energy_and_forces ( sys_geom , driver_config , resources , & energy , gradient , hessian , bonds ) !! Compute energy and forces for current geometry !! This is the main interface for optimization/dynamics codes !! !! Master rank provides updated geometry, all ranks compute fragments, !! results are returned on master rank only !! !! Usage: !!   1. Master rank updates sys_geom%coordinates !!   2. Call this subroutine (all ranks) !!   3. Master rank receives energy/gradient/hessian !!   4. Master rank updates geometry based on forces !!   5. Repeat from step 1 use mqc_driver , only : run_calculation use mqc_config_adapter , only : driver_config_t type ( system_geometry_t ), intent ( inout ) :: sys_geom type ( driver_config_t ), intent ( in ) :: driver_config type ( resources_t ), intent ( in ) :: resources real ( dp ), intent ( out ) :: energy real ( dp ), intent ( out ), optional :: gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( out ), optional :: hessian (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ) :: result logical :: need_gradient , need_hessian ! Determine what we need based on what's requested need_gradient = present ( gradient ) need_hessian = present ( hessian ) ! Synchronize geometry from master to all ranks ! (Master may have updated coordinates for optimization/dynamics) call sync_geometry_to_workers ( sys_geom , resources % mpi_comms % world_comm ) ! Call the main calculation driver ! This handles both fragmented and unfragmented cases call run_calculation ( resources , driver_config , sys_geom , bonds , result ) ! Extract results (only valid on master rank) if ( resources % mpi_comms % world_comm % rank () == 0 ) then energy = result % energy % total () if ( need_gradient . and . result % has_gradient ) then gradient = result % gradient else if ( need_gradient ) then call logger % error ( \"Gradient requested but not computed!\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if if ( need_hessian . and . result % has_hessian ) then hessian = result % hessian else if ( need_hessian ) then call logger % error ( \"Hessian requested but not computed!\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Clean up call result % destroy () end if end subroutine compute_energy_and_forces","tags":"","url":"proc/compute_energy_and_forces.html"},{"title":"sync_geometry_to_workers – metalquicha","text":"public  subroutine sync_geometry_to_workers(sys_geom, comm) Synchronize geometry coordinates from master rank to all worker ranks\nThis is needed when master rank updates coordinates for optimization/dynamics TODO: Implement explicit broadcast if needed. Currently, the fragmented\ncalculation infrastructure may already handle geometry distribution.\nFor unfragmented calculations on master rank only, this is not needed. Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(inout) :: sys_geom type(comm_t), intent(in) :: comm Called by proc~~sync_geometry_to_workers~~CalledByGraph proc~sync_geometry_to_workers sync_geometry_to_workers proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~sync_geometry_to_workers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sync_geometry_to_workers ( sys_geom , comm ) !! Synchronize geometry coordinates from master rank to all worker ranks !! This is needed when master rank updates coordinates for optimization/dynamics !! !! TODO: Implement explicit broadcast if needed. Currently, the fragmented !! calculation infrastructure may already handle geometry distribution. !! For unfragmented calculations on master rank only, this is not needed. type ( system_geometry_t ), intent ( inout ) :: sys_geom type ( comm_t ), intent ( in ) :: comm ! NOTE: For now, we rely on the existing calculation infrastructure ! to handle geometry as needed. If explicit broadcasting is required, ! we can add MPI send/recv logic here later. end subroutine sync_geometry_to_workers","tags":"","url":"proc/sync_geometry_to_workers.html"},{"title":"run_calculation – metalquicha","text":"public  subroutine run_calculation(resources, config, sys_geom, bonds, result_out, all_ranks_write_json) Main calculation dispatcher - routes to fragmented or unfragmented calculation Determines calculation type based on nlevel and dispatches to appropriate\ncalculation routine with proper MPI setup and validation.\nIf result_out is present, returns result instead of writing JSON (for dynamics/optimization) Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources Resources container (MPI comms, etc.) type( driver_config_t ), intent(in) :: config Driver configuration type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( calculation_result_t ), intent(out), optional :: result_out Optional result output logical, intent(in), optional :: all_ranks_write_json If true, all ranks write JSON (for multi-molecule) Calls proc~~run_calculation~~CallsGraph proc~run_calculation run_calculation info info proc~run_calculation->info omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~json_output_data_destroy json_output_data_t%json_output_data_destroy proc~run_calculation->proc~json_output_data_destroy proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~write_json_output write_json_output proc~run_calculation->proc~write_json_output proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~run_calculation->proc~xtb_has_solvation to_char to_char proc~run_calculation->to_char warning warning proc~run_calculation->warning proc~json_output_data_reset json_output_data_t%json_output_data_reset proc~json_output_data_destroy->proc~json_output_data_reset proc~run_fragmented_calculation->info proc~run_fragmented_calculation->omp_set_num_threads proc~run_fragmented_calculation->to_char abort_comm abort_comm proc~run_fragmented_calculation->abort_comm allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast error error proc~run_fragmented_calculation->error interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_coordinator node_coordinator proc~run_fragmented_calculation->interface~node_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation->proc~apply_distance_screening proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~error_get_message error_t%error_get_message proc~run_fragmented_calculation->proc~error_get_message proc~error_has_error error_t%error_has_error proc~run_fragmented_calculation->proc~error_has_error proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation->proc~sort_fragments_by_size verbose verbose proc~run_fragmented_calculation->verbose proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~run_unfragmented_calculation->verbose proc~write_json_output->error proc~write_gmbe_pie_json_impl write_gmbe_pie_json_impl proc~write_json_output->proc~write_gmbe_pie_json_impl proc~write_mbe_breakdown_json_impl write_mbe_breakdown_json_impl proc~write_json_output->proc~write_mbe_breakdown_json_impl proc~write_unfragmented_json_impl write_unfragmented_json_impl proc~write_json_output->proc~write_unfragmented_json_impl proc~write_vibrational_json_impl write_vibrational_json_impl proc~write_json_output->proc~write_vibrational_json_impl proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~node_worker node_worker interface~node_worker->proc~node_worker proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~apply_distance_screening->info proc~apply_distance_screening->to_char proc~fragment_should_be_screened fragment_should_be_screened proc~apply_distance_screening->proc~fragment_should_be_screened proc~combine_util combine_util proc~combine->proc~combine_util proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->to_char proc~gmbe_enumerate_pie_terms->proc~error_has_error atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~error_set error_t%error_set proc~gmbe_enumerate_pie_terms->proc~error_set proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->abort_comm proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->proc~error_get_message proc~gmbe_pie_coordinator->verbose cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies get_elapsed_time get_elapsed_time proc~gmbe_pie_coordinator->get_elapsed_time iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_thermochemistry compute_thermochemistry proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~gmbe_pie_coordinator->proc~redistribute_cap_dipole_derivatives proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses start start proc~gmbe_pie_coordinator->start proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->error proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->proc~error_get_message proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->cart_disp proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->fc_mdyne proc~serial_gmbe_pie_processor->force_constants proc~serial_gmbe_pie_processor->frequencies interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~redistribute_cap_dipole_derivatives proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor->reduced_masses proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index proc~write_gmbe_pie_json_impl->info proc~write_gmbe_pie_json_impl->error add add proc~write_gmbe_pie_json_impl->add create_array create_array proc~write_gmbe_pie_json_impl->create_array create_object create_object proc~write_gmbe_pie_json_impl->create_object destroy destroy proc~write_gmbe_pie_json_impl->destroy initialize initialize proc~write_gmbe_pie_json_impl->initialize proc~get_basename get_basename proc~write_gmbe_pie_json_impl->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~write_gmbe_pie_json_impl->proc~get_output_json_filename proc~write_mbe_breakdown_json_impl->info proc~write_mbe_breakdown_json_impl->warning proc~write_mbe_breakdown_json_impl->error proc~write_mbe_breakdown_json_impl->add proc~write_mbe_breakdown_json_impl->create_array proc~write_mbe_breakdown_json_impl->create_object proc~write_mbe_breakdown_json_impl->destroy proc~write_mbe_breakdown_json_impl->initialize proc~write_mbe_breakdown_json_impl->proc~get_basename proc~get_frag_level_name get_frag_level_name proc~write_mbe_breakdown_json_impl->proc~get_frag_level_name proc~write_mbe_breakdown_json_impl->proc~get_output_json_filename proc~write_unfragmented_json_impl->info proc~write_unfragmented_json_impl->error proc~write_unfragmented_json_impl->add proc~write_unfragmented_json_impl->create_object proc~write_unfragmented_json_impl->destroy proc~write_unfragmented_json_impl->initialize proc~write_unfragmented_json_impl->proc~get_basename proc~write_unfragmented_json_impl->proc~get_output_json_filename proc~write_vibrational_json_impl->info proc~write_vibrational_json_impl->error proc~write_vibrational_json_impl->add proc~write_vibrational_json_impl->create_object proc~write_vibrational_json_impl->destroy proc~write_vibrational_json_impl->initialize proc~write_vibrational_json_impl->proc~get_basename proc~write_vibrational_json_impl->proc~get_output_json_filename proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~combine_util->proc~combine_util proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~dfs_pie_accumulate->proc~error_has_error proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect barrier barrier proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~calculate_monomer_distance calculate_monomer_distance proc~fragment_should_be_screened->proc~calculate_monomer_distance proc~get_next_combination get_next_combination proc~fragment_should_be_screened->proc~get_next_combination proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->abort_comm proc~global_coordinator->error proc~global_coordinator->proc~error_get_message proc~global_coordinator->verbose proc~global_coordinator->destroy proc~global_coordinator->get_elapsed_time proc~global_coordinator->iprobe proc~global_coordinator->irecv proc~global_coordinator->isend proc~global_coordinator->proc~result_irecv proc~global_coordinator->start allocate_dipole allocate_dipole proc~global_coordinator->allocate_dipole allocate_gradient allocate_gradient proc~global_coordinator->allocate_gradient allocate_hessian allocate_hessian proc~global_coordinator->allocate_hessian debug debug proc~global_coordinator->debug proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~node_coordinator->to_char proc~node_coordinator->abort_comm proc~node_coordinator->error proc~node_coordinator->proc~error_get_message proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->to_char proc~node_worker->abort_comm proc~node_worker->error proc~node_worker->proc~error_has_error proc~node_worker->interface~do_fragment_work proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~error_get_full_trace proc~node_worker->proc~fragment_destroy proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~result_isend proc~node_worker->recv proc~print_vibrational_analysis->info proc~print_vibrational_analysis->warning proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~result_irecv->irecv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~serial_fragment_processor->info proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->to_char proc~serial_fragment_processor->error proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->proc~error_get_message proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->verbose proc~serial_fragment_processor->configuration proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~error_get_full_trace proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~mbe_result_allocate_dipole mbe_result_t%mbe_result_allocate_dipole proc~serial_fragment_processor->proc~mbe_result_allocate_dipole proc~mbe_result_allocate_gradient mbe_result_t%mbe_result_allocate_gradient proc~serial_fragment_processor->proc~mbe_result_allocate_gradient proc~mbe_result_allocate_hessian mbe_result_t%mbe_result_allocate_hessian proc~serial_fragment_processor->proc~mbe_result_allocate_hessian proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char proc~unfragmented_calculation->error proc~unfragmented_calculation->proc~error_get_message proc~unfragmented_calculation->proc~error_has_error proc~unfragmented_calculation->cart_disp proc~unfragmented_calculation->configuration proc~unfragmented_calculation->fc_mdyne proc~unfragmented_calculation->force_constants proc~unfragmented_calculation->frequencies proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~error_get_full_trace proc~unfragmented_calculation->proc~print_vibrational_analysis proc~unfragmented_calculation->reduced_masses eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues ir_intensities ir_intensities proc~unfragmented_calculation->ir_intensities proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~fragment_compute_nelec proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_fragment_from_indices->proc~error_has_error proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~error_add_context proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->error proc~check_duplicate_atoms->proc~error_set proc~check_duplicate_atoms->proc~element_number_to_symbol proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_mbe->info proc~compute_mbe->to_char proc~compute_mbe->warning proc~compute_mbe->abort_comm proc~compute_mbe->error proc~compute_mbe->cart_disp proc~compute_mbe->configuration proc~compute_mbe->fc_mdyne proc~compute_mbe->force_constants proc~compute_mbe->frequencies proc~compute_mbe->proc~compute_thermochemistry proc~compute_mbe->proc~compute_vibrational_analysis proc~compute_mbe->proc~energy_total proc~compute_mbe->proc~print_vibrational_analysis proc~compute_mbe->reduced_masses get_message get_message proc~compute_mbe->get_message has_error has_error proc~compute_mbe->has_error proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe->proc~compute_mbe_dipole proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->warning pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->warning proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_zpe->to_char proc~compute_zpe->warning proc~do_fragment_work->to_char proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->configuration proc~do_fragment_work->proc~error_set proc~do_fragment_work->proc~error_add_context calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~grow_pie_storage->to_char proc~grow_pie_storage->proc~error_set proc~print_thermochemistry->info proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~result_isend->isend send send proc~result_isend->send proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_calculation~~CalledByGraph proc~run_calculation run_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Loop counter type( json_output_data_t ), private :: json_data Cached output data for centralized JSON writing integer, private :: max_level Maximum fragment level (nlevel from config) type( method_config_t ), private :: method_config Method configuration built from driver config logical, private :: should_write_json Whether this rank should write JSON Source Code subroutine run_calculation ( resources , config , sys_geom , bonds , result_out , all_ranks_write_json ) !! Main calculation dispatcher - routes to fragmented or unfragmented calculation !! !! Determines calculation type based on nlevel and dispatches to appropriate !! calculation routine with proper MPI setup and validation. !! If result_out is present, returns result instead of writing JSON (for dynamics/optimization) type ( resources_t ), intent ( in ) :: resources !! Resources container (MPI comms, etc.) type ( driver_config_t ), intent ( in ) :: config !! Driver configuration type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( calculation_result_t ), intent ( out ), optional :: result_out !! Optional result output logical , intent ( in ), optional :: all_ranks_write_json !! If true, all ranks write JSON (for multi-molecule) ! Local variables integer :: max_level !! Maximum fragment level (nlevel from config) integer :: i !! Loop counter type ( json_output_data_t ) :: json_data !! Cached output data for centralized JSON writing logical :: should_write_json !! Whether this rank should write JSON type ( method_config_t ) :: method_config !! Method configuration built from driver config ! Build method_config from driver_config method_config % method_type = config % method method_config % verbose = . false . ! Controlled by logger level in do_fragment_work ! XTB-specific settings (nested in method_config%xtb) method_config % xtb % use_cds = config % use_cds method_config % xtb % use_shift = config % use_shift method_config % xtb % dielectric = config % dielectric method_config % xtb % cpcm_nang = config % cpcm_nang method_config % xtb % cpcm_rscale = config % cpcm_rscale if ( allocated ( config % solvent )) method_config % xtb % solvent = config % solvent if ( allocated ( config % solvation_model )) then method_config % xtb % solvation_model = config % solvation_model else if ( allocated ( config % solvent ) . or . config % dielectric > 0.0_dp ) then method_config % xtb % solvation_model = 'alpb' ! Default solvation model end if ! Log solvation settings if ( method_config % xtb % has_solvation ()) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then if ( trim ( method_config % xtb % solvation_model ) == 'cpcm' ) then if ( config % dielectric > 0.0_dp ) then call logger % info ( \"XTB solvation enabled: cpcm with dielectric = \" // to_char ( config % dielectric )) else call logger % info ( \"XTB solvation enabled: cpcm with \" // trim ( method_config % xtb % solvent )) end if call logger % info ( \"  CPCM grid points (nang): \" // to_char ( config % cpcm_nang )) call logger % info ( \"  CPCM radii scale: \" // to_char ( config % cpcm_rscale )) else call logger % info ( \"XTB solvation enabled: \" // trim ( method_config % xtb % solvation_model ) // \" with \" // & trim ( method_config % xtb % solvent )) if ( config % use_cds ) call logger % info ( \"  CDS (non-polar) terms: enabled\" ) if ( config % use_shift ) call logger % info ( \"  Solution state shift: enabled\" ) end if end if end if ! Set max_level from config max_level = config % nlevel if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % info ( \"============================================\" ) call logger % info ( \"Loaded geometry:\" ) call logger % info ( \"  Total monomers: \" // to_char ( sys_geom % n_monomers )) call logger % info ( \"  Atoms per monomer: \" // to_char ( sys_geom % atoms_per_monomer )) call logger % info ( \"  Total atoms: \" // to_char ( sys_geom % total_atoms )) call logger % info ( \"  Fragment level: \" // to_char ( max_level )) call logger % info ( \"============================================\" ) end if ! Warn if overlapping fragments flag is set but nlevel=0 if ( config % allow_overlapping_fragments . and . max_level == 0 ) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % warning ( \"allow_overlapping_fragments is set to true, but nlevel=0\" ) call logger % warning ( \"Running unfragmented calculation - overlapping fragments flag will be ignored\" ) end if end if ! GMBE (overlapping fragments) with inclusion-exclusion principle ! GMBE(1): Base fragments are monomers ! GMBE(N): Base fragments are N-mers (e.g., dimers for N=2) ! Algorithm: Generate primaries, use DFS to enumerate overlapping cliques, ! accumulate PIE coefficients per unique atom set, evaluate each once if ( max_level == 0 ) then call omp_set_num_threads ( 1 ) if ( present ( result_out )) then ! For dynamics/optimization: return result directly, no JSON output call run_unfragmented_calculation ( resources % mpi_comms % world_comm , sys_geom , & method_config , config % calc_type , bonds , config , result_out ) else ! Normal mode: collect json_data for centralized output call run_unfragmented_calculation ( resources % mpi_comms % world_comm , sys_geom , & method_config , config % calc_type , bonds , config , & json_data = json_data ) end if else if ( present ( result_out )) then ! For fragmented calculations with result_out (future use) call run_fragmented_calculation ( resources , method_config , config % calc_type , sys_geom , max_level , & config % allow_overlapping_fragments , & config % max_intersection_level , bonds , config ) else ! Normal mode: collect json_data for centralized output call run_fragmented_calculation ( resources , method_config , config % calc_type , sys_geom , max_level , & config % allow_overlapping_fragments , & config % max_intersection_level , bonds , config , json_data ) end if end if ! Centralized JSON output (rank 0 only by default, or all ranks if all_ranks_write_json is set) if (. not . present ( result_out )) then ! Check if JSON output should be skipped if ( config % skip_json_output ) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % info ( \"Skipping JSON output (skip_json_output = true)\" ) end if else ! Determine if this rank should write JSON should_write_json = ( resources % mpi_comms % world_comm % rank () == 0 ) if ( present ( all_ranks_write_json )) then if ( all_ranks_write_json ) should_write_json = . true . end if if ( should_write_json ) then if ( json_data % output_mode /= OUTPUT_MODE_NONE ) then call write_json_output ( json_data ) call json_data % destroy () end if end if end if end if end subroutine run_calculation","tags":"","url":"proc/run_calculation.html"},{"title":"run_multi_molecule_calculations – metalquicha","text":"public  subroutine run_multi_molecule_calculations(resources, mqc_config) Uses mqc_io_helpers mqc_error mqc_json mqc_config_parser mqc_config_adapter proc~~run_multi_molecule_calculations~~UsesGraph proc~run_multi_molecule_calculations run_multi_molecule_calculations module~mqc_config_adapter mqc_config_adapter proc~run_multi_molecule_calculations->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_parser module~mqc_error mqc_error proc~run_multi_molecule_calculations->module~mqc_error module~mqc_io_helpers mqc_io_helpers proc~run_multi_molecule_calculations->module~mqc_io_helpers module~mqc_json mqc_json proc~run_multi_molecule_calculations->module~mqc_json module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_error module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment pic_logger pic_logger module~mqc_config_adapter->pic_logger pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types pic_io pic_io module~mqc_json->pic_io module~mqc_json->pic_logger module~mqc_calc_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Run calculations for multiple molecules with MPI parallelization\nEach molecule is independent, so assign one molecule per rank Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources type( mqc_config_t ), intent(in) :: mqc_config Calls proc~~run_multi_molecule_calculations~~CallsGraph proc~run_multi_molecule_calculations run_multi_molecule_calculations abort_comm abort_comm proc~run_multi_molecule_calculations->abort_comm barrier barrier proc~run_multi_molecule_calculations->barrier error error proc~run_multi_molecule_calculations->error info info proc~run_multi_molecule_calculations->info proc~config_to_driver config_to_driver proc~run_multi_molecule_calculations->proc~config_to_driver proc~config_to_system_geometry config_to_system_geometry proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~error_add_context error_t%error_add_context proc~run_multi_molecule_calculations->proc~error_add_context proc~error_get_full_trace error_t%error_get_full_trace proc~run_multi_molecule_calculations->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~run_multi_molecule_calculations->proc~error_has_error proc~get_output_json_filename get_output_json_filename proc~run_multi_molecule_calculations->proc~get_output_json_filename proc~merge_multi_molecule_json merge_multi_molecule_json proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~set_molecule_suffix set_molecule_suffix proc~run_multi_molecule_calculations->proc~set_molecule_suffix proc~system_destroy system_geometry_t%system_destroy proc~run_multi_molecule_calculations->proc~system_destroy to_char to_char proc~run_multi_molecule_calculations->to_char verbose verbose proc~run_multi_molecule_calculations->verbose proc~config_to_system_geometry->proc~error_add_context proc~config_to_system_geometry->proc~error_has_error proc~error_set error_t%error_set proc~config_to_system_geometry->proc~error_set proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~error_get_full_trace->proc~error_has_error proc~merge_multi_molecule_json->error proc~merge_multi_molecule_json->info proc~merge_multi_molecule_json->to_char proc~read_json_content read_json_content proc~merge_multi_molecule_json->proc~read_json_content proc~run_calculation->info proc~run_calculation->to_char omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~json_output_data_destroy json_output_data_t%json_output_data_destroy proc~run_calculation->proc~json_output_data_destroy proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~write_json_output write_json_output proc~run_calculation->proc~write_json_output proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~run_calculation->proc~xtb_has_solvation warning warning proc~run_calculation->warning proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~json_output_data_reset json_output_data_t%json_output_data_reset proc~json_output_data_destroy->proc~json_output_data_reset proc~molecule_to_system_geometry->proc~error_set proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name proc~run_fragmented_calculation->abort_comm proc~run_fragmented_calculation->error proc~run_fragmented_calculation->info proc~run_fragmented_calculation->proc~error_has_error proc~run_fragmented_calculation->to_char proc~run_fragmented_calculation->verbose proc~run_fragmented_calculation->omp_set_num_threads allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_coordinator node_coordinator proc~run_fragmented_calculation->interface~node_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation->proc~apply_distance_screening proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~error_get_message error_t%error_get_message proc~run_fragmented_calculation->proc~error_get_message proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation->proc~sort_fragments_by_size proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char proc~run_unfragmented_calculation->verbose interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~write_json_output->error proc~write_gmbe_pie_json_impl write_gmbe_pie_json_impl proc~write_json_output->proc~write_gmbe_pie_json_impl proc~write_mbe_breakdown_json_impl write_mbe_breakdown_json_impl proc~write_json_output->proc~write_mbe_breakdown_json_impl proc~write_unfragmented_json_impl write_unfragmented_json_impl proc~write_json_output->proc~write_unfragmented_json_impl proc~write_vibrational_json_impl write_vibrational_json_impl proc~write_json_output->proc~write_vibrational_json_impl proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~node_worker node_worker interface~node_worker->proc~node_worker proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~apply_distance_screening->info proc~apply_distance_screening->to_char proc~fragment_should_be_screened fragment_should_be_screened proc~apply_distance_screening->proc~fragment_should_be_screened proc~combine_util combine_util proc~combine->proc~combine_util to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->proc~error_has_error proc~gmbe_enumerate_pie_terms->to_char proc~gmbe_enumerate_pie_terms->proc~error_set atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~gmbe_pie_coordinator->abort_comm proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose proc~gmbe_pie_coordinator->proc~error_get_message cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies get_elapsed_time get_elapsed_time proc~gmbe_pie_coordinator->get_elapsed_time iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_thermochemistry compute_thermochemistry proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~gmbe_pie_coordinator->proc~redistribute_cap_dipole_derivatives proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses start start proc~gmbe_pie_coordinator->start proc~initialize_fragmented_system->proc~error_add_context proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~serial_gmbe_pie_processor->error proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->proc~error_get_message proc~serial_gmbe_pie_processor->cart_disp proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->fc_mdyne proc~serial_gmbe_pie_processor->force_constants proc~serial_gmbe_pie_processor->frequencies interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~redistribute_cap_dipole_derivatives proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor->reduced_masses proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index proc~write_gmbe_pie_json_impl->error proc~write_gmbe_pie_json_impl->info proc~write_gmbe_pie_json_impl->proc~get_output_json_filename add add proc~write_gmbe_pie_json_impl->add create_array create_array proc~write_gmbe_pie_json_impl->create_array create_object create_object proc~write_gmbe_pie_json_impl->create_object destroy destroy proc~write_gmbe_pie_json_impl->destroy initialize initialize proc~write_gmbe_pie_json_impl->initialize proc~get_basename get_basename proc~write_gmbe_pie_json_impl->proc~get_basename proc~write_mbe_breakdown_json_impl->error proc~write_mbe_breakdown_json_impl->info proc~write_mbe_breakdown_json_impl->proc~get_output_json_filename proc~write_mbe_breakdown_json_impl->warning proc~write_mbe_breakdown_json_impl->add proc~write_mbe_breakdown_json_impl->create_array proc~write_mbe_breakdown_json_impl->create_object proc~write_mbe_breakdown_json_impl->destroy proc~write_mbe_breakdown_json_impl->initialize proc~write_mbe_breakdown_json_impl->proc~get_basename proc~get_frag_level_name get_frag_level_name proc~write_mbe_breakdown_json_impl->proc~get_frag_level_name proc~write_unfragmented_json_impl->error proc~write_unfragmented_json_impl->info proc~write_unfragmented_json_impl->proc~get_output_json_filename proc~write_unfragmented_json_impl->add proc~write_unfragmented_json_impl->create_object proc~write_unfragmented_json_impl->destroy proc~write_unfragmented_json_impl->initialize proc~write_unfragmented_json_impl->proc~get_basename proc~write_vibrational_json_impl->error proc~write_vibrational_json_impl->info proc~write_vibrational_json_impl->proc~get_output_json_filename proc~write_vibrational_json_impl->add proc~write_vibrational_json_impl->create_object proc~write_vibrational_json_impl->destroy proc~write_vibrational_json_impl->initialize proc~write_vibrational_json_impl->proc~get_basename proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_add_context proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~check_fragment_overlap->to_char proc~check_fragment_overlap->proc~error_set proc~combine_util->proc~combine_util proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~dfs_pie_accumulate->proc~error_has_error proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~calculate_monomer_distance calculate_monomer_distance proc~fragment_should_be_screened->proc~calculate_monomer_distance proc~get_next_combination get_next_combination proc~fragment_should_be_screened->proc~get_next_combination proc~global_coordinator->abort_comm proc~global_coordinator->error proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->verbose proc~global_coordinator->proc~error_get_message proc~global_coordinator->destroy proc~global_coordinator->get_elapsed_time proc~global_coordinator->iprobe proc~global_coordinator->irecv proc~global_coordinator->isend proc~global_coordinator->proc~result_irecv proc~global_coordinator->start allocate_dipole allocate_dipole proc~global_coordinator->allocate_dipole allocate_gradient allocate_gradient proc~global_coordinator->allocate_gradient allocate_hessian allocate_hessian proc~global_coordinator->allocate_hessian debug debug proc~global_coordinator->debug proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~node_coordinator->abort_comm proc~node_coordinator->error proc~node_coordinator->to_char proc~node_coordinator->proc~error_get_message proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->abort_comm proc~node_worker->error proc~node_worker->proc~error_get_full_trace proc~node_worker->proc~error_has_error proc~node_worker->to_char proc~node_worker->interface~do_fragment_work proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~fragment_destroy proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~result_isend proc~node_worker->recv proc~print_vibrational_analysis->info proc~print_vibrational_analysis->warning proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~result_irecv->irecv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~serial_fragment_processor->error proc~serial_fragment_processor->info proc~serial_fragment_processor->proc~error_get_full_trace proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->to_char proc~serial_fragment_processor->verbose proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->proc~error_get_message proc~serial_fragment_processor->configuration proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~mbe_result_allocate_dipole mbe_result_t%mbe_result_allocate_dipole proc~serial_fragment_processor->proc~mbe_result_allocate_dipole proc~mbe_result_allocate_gradient mbe_result_t%mbe_result_allocate_gradient proc~serial_fragment_processor->proc~mbe_result_allocate_gradient proc~mbe_result_allocate_hessian mbe_result_t%mbe_result_allocate_hessian proc~serial_fragment_processor->proc~mbe_result_allocate_hessian proc~unfragmented_calculation->error proc~unfragmented_calculation->info proc~unfragmented_calculation->proc~error_get_full_trace proc~unfragmented_calculation->proc~error_has_error proc~unfragmented_calculation->to_char proc~unfragmented_calculation->proc~error_get_message proc~unfragmented_calculation->cart_disp proc~unfragmented_calculation->configuration proc~unfragmented_calculation->fc_mdyne proc~unfragmented_calculation->force_constants proc~unfragmented_calculation->frequencies proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~print_vibrational_analysis proc~unfragmented_calculation->reduced_masses eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues ir_intensities ir_intensities proc~unfragmented_calculation->ir_intensities proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~fragment_compute_nelec proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_multi_molecule_calculations~~CalledByGraph proc~run_multi_molecule_calculations run_multi_molecule_calculations program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: color type( driver_config_t ), private :: config type( error_t ), private :: error logical, private :: has_fragmented_molecules integer, private :: imol character(len=256), private, allocatable :: individual_json_files (:) character(len=:), private, allocatable :: mol_name type( resources_t ), private :: mol_resources integer, private :: molecules_processed integer, private :: my_rank integer, private :: num_ranks type( system_geometry_t ), private :: sys_geom Source Code subroutine run_multi_molecule_calculations ( resources , mqc_config ) !! Run calculations for multiple molecules with MPI parallelization !! Each molecule is independent, so assign one molecule per rank use mqc_config_parser , only : mqc_config_t use mqc_config_adapter , only : config_to_system_geometry use mqc_error , only : error_t use mqc_io_helpers , only : set_molecule_suffix , get_output_json_filename use mqc_json , only : merge_multi_molecule_json type ( resources_t ), intent ( in ) :: resources type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ) :: config type ( system_geometry_t ) :: sys_geom type ( resources_t ) :: mol_resources type ( error_t ) :: error integer :: imol , my_rank , num_ranks , color integer :: molecules_processed character ( len = :), allocatable :: mol_name logical :: has_fragmented_molecules character ( len = 256 ), allocatable :: individual_json_files (:) my_rank = resources % mpi_comms % world_comm % rank () num_ranks = resources % mpi_comms % world_comm % size () ! Allocate array to track individual JSON files for merging allocate ( individual_json_files ( mqc_config % nmol )) ! Check if any molecules have fragments (nlevel > 0) has_fragmented_molecules = . false . do imol = 1 , mqc_config % nmol if ( mqc_config % molecules ( imol )% nfrag > 0 ) then has_fragmented_molecules = . true . exit end if end do if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"Multi-molecule mode: \" // to_char ( mqc_config % nmol ) // \" molecules\" ) call logger % info ( \"MPI ranks: \" // to_char ( num_ranks )) if ( has_fragmented_molecules ) then call logger % info ( \"Mode: Sequential execution (fragmented molecules detected)\" ) call logger % info ( \"  Each molecule will use all \" // to_char ( num_ranks ) // \" rank(s) for its calculation\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Mode: Sequential execution (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) call logger % info ( \"Note: More ranks than molecules - ranks \" // to_char ( mqc_config % nmol ) // & \" to \" // to_char ( num_ranks - 1 ) // \" will be idle\" ) else call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) end if call logger % info ( \"============================================\" ) call logger % info ( \" \" ) end if ! Determine execution mode: ! 1. Sequential: Single rank OR fragmented molecules (each molecule needs all ranks) ! 2. Parallel: Multiple ranks AND unfragmented molecules (distribute molecules across ranks) molecules_processed = 0 if ( num_ranks == 1 . or . has_fragmented_molecules ) then ! Sequential mode: process all molecules one after another ! Each molecule uses all available ranks for its calculation do imol = 1 , mqc_config % nmol ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Processing molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) end if ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then call error % add_context ( \"mqc_driver:run_multi_molecule_calculation\" ) if ( my_rank == 0 ) then call logger % error ( \"Error converting geometry for \" // mol_name // \": \" // error % get_full_trace ()) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule call run_calculation ( resources , config , sys_geom , mqc_config % molecules ( imol )% bonds ) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () if ( my_rank == 0 ) then call logger % info ( \"Completed molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) end if molecules_processed = molecules_processed + 1 end do else ! Multiple ranks: distribute molecules across ranks in round-robin fashion molecules_processed = 0 do imol = 1 , mqc_config % nmol ! This rank processes molecules where (imol - 1) mod num_ranks == my_rank if ( mod ( imol - 1 , num_ranks ) == my_rank ) then ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Processing molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then call error % add_context ( \"mqc_driver:run_multi_molecule_calculation\" ) call logger % error ( \"Rank \" // to_char ( my_rank ) // \": Error converting geometry for \" // mol_name // \": \" // error % get_full_trace ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule (all ranks write JSON in parallel mode) call run_calculation ( resources , config , sys_geom , mqc_config % molecules ( imol )% bonds , & all_ranks_write_json = . true .) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Completed molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) molecules_processed = molecules_processed + 1 end if end do if ( molecules_processed == 0 ) then ! Idle rank - no molecules assigned call logger % verbose ( \"Rank \" // to_char ( my_rank ) // \": No molecules assigned (idle)\" ) end if end if ! Synchronize all ranks call resources % mpi_comms % world_comm % barrier () ! In parallel execution, rank 0 needs to reconstruct all JSON filenames for merging ! since each rank only populated its own entry if ( my_rank == 0 . and . num_ranks > 1 . and . . not . has_fragmented_molecules ) then ! Rank 0 constructs filenames for all molecules do imol = 1 , mqc_config % nmol ! Get molecule name if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if ! Construct JSON filename pattern: output_<basename>_<molname>.json ! This mirrors what get_output_json_filename() returns after set_molecule_suffix() call set_molecule_suffix ( \"_\" // trim ( mol_name )) individual_json_files ( imol ) = get_output_json_filename () end do end if ! Merge individual JSON files into one combined file (rank 0 only) if ( my_rank == 0 ) then call merge_multi_molecule_json ( individual_json_files , mqc_config % nmol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"All \" // to_char ( mqc_config % nmol ) // \" molecules completed\" ) if ( has_fragmented_molecules ) then call logger % info ( \"Execution: Sequential (each molecule used all ranks)\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Execution: Sequential (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Execution: Parallel (active ranks: \" // to_char ( mqc_config % nmol ) // \"/\" // to_char ( num_ranks ) // \")\" ) else call logger % info ( \"Execution: Parallel (all ranks active)\" ) end if call logger % info ( \"============================================\" ) end if end subroutine run_multi_molecule_calculations","tags":"","url":"proc/run_multi_molecule_calculations.html"},{"title":"run_fragmented_calculation – metalquicha","text":"private  subroutine run_fragmented_calculation(resources, method_config, calc_type, sys_geom, max_level, allow_overlapping_fragments, max_intersection_level, bonds, driver_config, json_data) Handle fragmented calculation (nlevel > 0) Generates fragments, distributes work across MPI processes organized in nodes,\nand coordinates many-body expansion calculation using hierarchical parallelism.\nIf allow_overlapping_fragments=true, uses GMBE with intersection correction. Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources Resources container (MPI comms, etc.) type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type Calculation type type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info integer, intent(in) :: max_level Maximum fragment level for MBE logical, intent(in) :: allow_overlapping_fragments Use GMBE for overlapping fragments integer, intent(in) :: max_intersection_level Maximum k-way intersection depth for GMBE type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( driver_config_t ), intent(in) :: driver_config Driver configuration with cutoffs type( json_output_data_t ), intent(out), optional :: json_data JSON output data Calls proc~~run_fragmented_calculation~~CallsGraph proc~run_fragmented_calculation run_fragmented_calculation abort_comm abort_comm proc~run_fragmented_calculation->abort_comm allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast error error proc~run_fragmented_calculation->error info info proc~run_fragmented_calculation->info interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_coordinator node_coordinator proc~run_fragmented_calculation->interface~node_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads omp_set_num_threads omp_set_num_threads proc~run_fragmented_calculation->omp_set_num_threads proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation->proc~apply_distance_screening proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~error_get_message error_t%error_get_message proc~run_fragmented_calculation->proc~error_get_message proc~error_has_error error_t%error_has_error proc~run_fragmented_calculation->proc~error_has_error proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation->proc~sort_fragments_by_size to_char to_char proc~run_fragmented_calculation->to_char verbose verbose proc~run_fragmented_calculation->verbose proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~node_worker node_worker interface~node_worker->proc~node_worker proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~apply_distance_screening->info proc~apply_distance_screening->to_char proc~fragment_should_be_screened fragment_should_be_screened proc~apply_distance_screening->proc~fragment_should_be_screened proc~combine_util combine_util proc~combine->proc~combine_util proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->proc~error_has_error proc~gmbe_enumerate_pie_terms->to_char atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~error_set error_t%error_set proc~gmbe_enumerate_pie_terms->proc~error_set proc~gmbe_pie_coordinator->abort_comm proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->proc~error_get_message proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies get_elapsed_time get_elapsed_time proc~gmbe_pie_coordinator->get_elapsed_time iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_thermochemistry compute_thermochemistry proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~gmbe_pie_coordinator->proc~redistribute_cap_dipole_derivatives proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses start start proc~gmbe_pie_coordinator->start proc~serial_gmbe_pie_processor->error proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->proc~error_get_message proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->cart_disp proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->fc_mdyne proc~serial_gmbe_pie_processor->force_constants proc~serial_gmbe_pie_processor->frequencies interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~calc_type_to_string calc_type_to_string proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~redistribute_cap_dipole_derivatives proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor->reduced_masses proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~combine_util->proc~combine_util proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~dfs_pie_accumulate->proc~error_has_error proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~calculate_monomer_distance calculate_monomer_distance proc~fragment_should_be_screened->proc~calculate_monomer_distance proc~get_next_combination get_next_combination proc~fragment_should_be_screened->proc~get_next_combination proc~global_coordinator->abort_comm proc~global_coordinator->error proc~global_coordinator->info proc~global_coordinator->proc~error_get_message proc~global_coordinator->to_char proc~global_coordinator->verbose proc~global_coordinator->get_elapsed_time proc~global_coordinator->iprobe proc~global_coordinator->irecv proc~global_coordinator->isend proc~global_coordinator->proc~result_irecv proc~global_coordinator->start allocate_dipole allocate_dipole proc~global_coordinator->allocate_dipole allocate_gradient allocate_gradient proc~global_coordinator->allocate_gradient allocate_hessian allocate_hessian proc~global_coordinator->allocate_hessian debug debug proc~global_coordinator->debug destroy destroy proc~global_coordinator->destroy proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~node_coordinator->abort_comm proc~node_coordinator->error proc~node_coordinator->proc~error_get_message proc~node_coordinator->to_char proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->abort_comm proc~node_worker->error proc~node_worker->proc~error_has_error proc~node_worker->to_char proc~node_worker->interface~do_fragment_work proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~error_get_full_trace proc~node_worker->proc~fragment_destroy proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~result_isend proc~node_worker->recv proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry warning warning proc~print_vibrational_analysis->warning proc~result_irecv->irecv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~serial_fragment_processor->error proc~serial_fragment_processor->info proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->proc~error_get_message proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->to_char proc~serial_fragment_processor->verbose proc~serial_fragment_processor->configuration proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~error_get_full_trace proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~mbe_result_allocate_dipole mbe_result_t%mbe_result_allocate_dipole proc~serial_fragment_processor->proc~mbe_result_allocate_dipole proc~mbe_result_allocate_gradient mbe_result_t%mbe_result_allocate_gradient proc~serial_fragment_processor->proc~mbe_result_allocate_gradient proc~mbe_result_allocate_hessian mbe_result_t%mbe_result_allocate_hessian proc~serial_fragment_processor->proc~mbe_result_allocate_hessian proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_fragment_from_indices->proc~error_has_error proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~error_add_context proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->proc~error_set proc~check_duplicate_atoms->proc~element_number_to_symbol proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_mbe->abort_comm proc~compute_mbe->error proc~compute_mbe->info proc~compute_mbe->to_char proc~compute_mbe->cart_disp proc~compute_mbe->configuration proc~compute_mbe->fc_mdyne proc~compute_mbe->force_constants proc~compute_mbe->frequencies proc~compute_mbe->proc~compute_thermochemistry proc~compute_mbe->proc~compute_vibrational_analysis proc~compute_mbe->proc~energy_total proc~compute_mbe->proc~print_vibrational_analysis proc~compute_mbe->reduced_masses proc~compute_mbe->warning get_message get_message proc~compute_mbe->get_message has_error has_error proc~compute_mbe->has_error proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe->proc~compute_mbe_dipole proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->warning pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_zpe->to_char proc~compute_zpe->warning proc~do_fragment_work->to_char proc~do_fragment_work->configuration proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->proc~error_set proc~do_fragment_work->proc~error_add_context calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~grow_pie_storage->to_char proc~grow_pie_storage->proc~error_set proc~print_thermochemistry->info proc~result_isend->isend send send proc~result_isend->send proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~build_mbe_lookup_table->proc~error_has_error proc~build_mbe_lookup_table->to_char proc~build_mbe_lookup_table->get_elapsed_time proc~build_mbe_lookup_table->start proc~build_mbe_lookup_table->debug proc~build_mbe_lookup_table->proc~error_add_context proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~compute_mbe_delta->abort_comm proc~compute_mbe_delta->error proc~compute_mbe_delta->proc~get_next_combination proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~compute_mbe_dipole->abort_comm proc~compute_mbe_dipole->error proc~compute_mbe_dipole->proc~get_next_combination proc~compute_mbe_dipole->proc~fragment_lookup_find proc~compute_mbe_dipole_derivatives->proc~get_next_combination proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~fragment_lookup_find proc~compute_mbe_gradient->abort_comm proc~compute_mbe_gradient->error proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~map_fragment_to_system_dipole_derivatives->proc~redistribute_cap_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->abort_comm proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->proc~error_has_error proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_gradient->debug proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~mass_weight_hessian->proc~element_mass proc~print_detailed_breakdown->verbose proc~print_detailed_breakdown->warning header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_fragment_xyz->proc~to_angstrom proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_fragmented_calculation~~CalledByGraph proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: all_node_leader_ranks (:) Node leader status for all ranks integer, private :: global_node_rank Global rank if this process leads a node, -1 otherwise integer, private :: i Loop counters integer, private, allocatable :: intersection_levels (:) Level k of each intersection (n_intersections) integer, private, allocatable :: intersection_sets (:,:) k-tuples for each intersection (n_monomers, n_intersections) integer, private, allocatable :: intersections (:,:) Intersection atom lists (max_atoms, n_intersections) integer, private :: j Loop counters integer, private, allocatable :: monomers (:) Temporary monomer list for fragment generation integer(kind=int64), private :: n_expected_frags Expected number of fragments based on combinatorics (int64 to handle large systems) integer, private :: n_intersections Counts for GMBE integer, private :: n_monomers Counts for GMBE integer(kind=int64), private :: n_pie_terms Number of unique PIE terms integer, private :: n_primaries Number of primary polymers integer(kind=int64), private :: n_primaries_i64 For binomial calculation integer(kind=int64), private :: n_rows Number of rows needed for polymers array (int64 to handle large systems) integer, private, allocatable :: node_leader_ranks (:) Ranks of processes that lead each node integer, private :: num_nodes Number of compute nodes integer, private, allocatable :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, private, allocatable :: pie_coefficients (:) PIE coefficient for each term type( error_t ), private :: pie_error Error from PIE enumeration integer, private, allocatable :: polymers (:,:) Fragment composition array (fragment, monomer_indices) integer(kind=int64), private :: total_fragments Total number of fragments generated (int64 to handle large systems) Source Code subroutine run_fragmented_calculation ( resources , method_config , calc_type , sys_geom , max_level , & allow_overlapping_fragments , max_intersection_level , bonds , driver_config , json_data ) !! Handle fragmented calculation (nlevel > 0) !! !! Generates fragments, distributes work across MPI processes organized in nodes, !! and coordinates many-body expansion calculation using hierarchical parallelism. !! If allow_overlapping_fragments=true, uses GMBE with intersection correction. type ( resources_t ), intent ( in ) :: resources !! Resources container (MPI comms, etc.) type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info integer , intent ( in ) :: max_level !! Maximum fragment level for MBE logical , intent ( in ) :: allow_overlapping_fragments !! Use GMBE for overlapping fragments integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth for GMBE type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( driver_config_t ), intent ( in ) :: driver_config !! Driver configuration with cutoffs type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data integer ( int64 ) :: total_fragments !! Total number of fragments generated (int64 to handle large systems) integer , allocatable :: polymers (:, :) !! Fragment composition array (fragment, monomer_indices) integer :: num_nodes !! Number of compute nodes integer :: i , j !! Loop counters integer , allocatable :: node_leader_ranks (:) !! Ranks of processes that lead each node integer , allocatable :: monomers (:) !! Temporary monomer list for fragment generation integer ( int64 ) :: n_expected_frags !! Expected number of fragments based on combinatorics (int64 to handle large systems) integer ( int64 ) :: n_rows !! Number of rows needed for polymers array (int64 to handle large systems) integer :: global_node_rank !! Global rank if this process leads a node, -1 otherwise integer , allocatable :: all_node_leader_ranks (:) !! Node leader status for all ranks ! GMBE-specific variables (old approach - kept for compatibility) integer , allocatable :: intersections (:, :) !! Intersection atom lists (max_atoms, n_intersections) integer , allocatable :: intersection_sets (:, :) !! k-tuples for each intersection (n_monomers, n_intersections) integer , allocatable :: intersection_levels (:) !! Level k of each intersection (n_intersections) integer :: n_intersections , n_monomers !! Counts for GMBE ! GMBE PIE-based variables (new approach) integer :: n_primaries !! Number of primary polymers integer ( int64 ) :: n_primaries_i64 !! For binomial calculation integer , allocatable :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , allocatable :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ) :: n_pie_terms !! Number of unique PIE terms type ( error_t ) :: pie_error !! Error from PIE enumeration ! Generate fragments if ( resources % mpi_comms % world_comm % rank () == 0 ) then if ( allow_overlapping_fragments ) then ! GMBE mode: PIE-based inclusion-exclusion ! GMBE(1): primaries are monomers ! GMBE(N): primaries are N-mers (e.g., dimers for N=2) ! Generate primaries if ( max_level == 1 ) then ! GMBE(1): primaries are base monomers n_primaries = sys_geom % n_monomers allocate ( polymers ( n_primaries , 1 )) do i = 1 , n_primaries polymers ( i , 1 ) = i end do else ! GMBE(N): primaries are all C(M, N) N-tuples n_primaries_i64 = binomial ( sys_geom % n_monomers , max_level ) n_primaries = int ( n_primaries_i64 ) allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_primaries , max_level )) polymers = 0 call create_monomer_list ( monomers ) total_fragments = 0_int64 call combine ( monomers , sys_geom % n_monomers , max_level , polymers , total_fragments ) n_primaries = int ( total_fragments ) deallocate ( monomers ) ! Apply distance-based screening to primaries if cutoffs are provided if ( max_level > 1 ) then ! Only screen if primaries are n-mers (not for GMBE(1) where primaries are monomers) total_fragments = int ( n_primaries , int64 ) call apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) n_primaries = int ( total_fragments ) end if ! Sort primaries by size (largest first) ! TODO: Currently disabled - see comment in MBE section above ! total_fragments = int(n_primaries, int64) call sort_fragments_by_size ( polymers , total_fragments , max_level ) end if call logger % info ( \"Generated \" // to_char ( n_primaries ) // \" primary \" // to_char ( max_level ) // \"-mers for GMBE(\" // & to_char ( max_level ) // \")\" ) ! Use DFS to enumerate PIE terms with coefficients call gmbe_enumerate_pie_terms ( sys_geom , polymers , n_primaries , max_level , max_intersection_level , & pie_atom_sets , pie_coefficients , n_pie_terms , pie_error ) if ( pie_error % has_error ()) then call logger % error ( \"GMBE PIE enumeration failed: \" // pie_error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if call logger % info ( \"GMBE PIE enumeration complete: \" // to_char ( n_pie_terms ) // \" unique subsystems to evaluate\" ) ! For now: total_fragments = n_pie_terms (each PIE term is a subsystem to evaluate) total_fragments = n_pie_terms else ! Standard MBE mode ! Calculate expected number of fragments n_expected_frags = get_nfrags ( sys_geom % n_monomers , max_level ) n_rows = n_expected_frags ! Allocate monomer list and polymers array allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_rows , max_level )) polymers = 0 ! Create monomer list [1, 2, 3, ..., n_monomers] call create_monomer_list ( monomers ) ! Generate all fragments (includes monomers in polymers array) total_fragments = 0_int64 ! First add monomers do i = 1 , sys_geom % n_monomers total_fragments = total_fragments + 1_int64 polymers ( total_fragments , 1 ) = i end do ! Then add n-mers for n >= 2 call generate_fragment_list ( monomers , max_level , polymers , total_fragments ) deallocate ( monomers ) ! Apply distance-based screening if cutoffs are provided call apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) ! Sort fragments by size (largest first) for better load balancing ! TODO: Currently disabled - MBE assembly is now order-independent (uses nested loops), ! but sorting still causes \"Subset not found\" errors in real validation cases. ! Unit tests pass with arbitrary order, so there may be an issue with the hash table ! or fragment generation in production code. Needs investigation. call sort_fragments_by_size ( polymers , total_fragments , max_level ) call logger % info ( \"Generated fragments:\" ) call logger % info ( \"  Total fragments: \" // to_char ( total_fragments )) call logger % info ( \"  Max level: \" // to_char ( max_level )) end if end if ! Broadcast total_fragments to all ranks call bcast ( resources % mpi_comms % world_comm , total_fragments , 1 , 0 ) ! Determine node leaders global_node_rank = - 1 if ( resources % mpi_comms % node_comm % rank () == 0 ) global_node_rank = resources % mpi_comms % world_comm % rank () allocate ( all_node_leader_ranks ( resources % mpi_comms % world_comm % size ())) call allgather ( resources % mpi_comms % world_comm , global_node_rank , all_node_leader_ranks ) num_nodes = count ( all_node_leader_ranks /= - 1 ) if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % info ( \"Running with \" // to_char ( num_nodes ) // \" node(s)\" ) end if allocate ( node_leader_ranks ( num_nodes )) i = 0 do j = 1 , resources % mpi_comms % world_comm % size () if ( all_node_leader_ranks ( j ) /= - 1 ) then i = i + 1 node_leader_ranks ( i ) = all_node_leader_ranks ( j ) end if end do deallocate ( all_node_leader_ranks ) ! Execute appropriate role if ( resources % mpi_comms % world_comm % size () == 1 ) then ! Single rank: process fragments serially call logger % info ( \"Running in serial mode (single MPI rank)\" ) if ( allow_overlapping_fragments ) then ! GMBE serial processing with PIE coefficients call serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , sys_geom , method_config , calc_type , & bonds , json_data ) else ! Standard MBE serial processing call serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method_config , calc_type , bonds , & json_data ) end if else if ( resources % mpi_comms % world_comm % leader () . and . resources % mpi_comms % node_comm % leader ()) then ! Global coordinator (rank 0, node leader on node 0) call omp_set_num_threads ( omp_get_max_threads ()) call logger % verbose ( \"Rank 0: Acting as global coordinator\" ) if ( allow_overlapping_fragments ) then ! GMBE MPI processing - PIE-based approach call gmbe_pie_coordinator ( resources , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method_config , calc_type , bonds , json_data ) else ! Standard MBE MPI processing call global_coordinator ( resources , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , method_config , calc_type , bonds , json_data ) end if else if ( resources % mpi_comms % node_comm % leader ()) then ! Node coordinator (node leader on other nodes) call logger % verbose ( \"Rank \" // to_char ( resources % mpi_comms % world_comm % rank ()) // \": Acting as node coordinator\" ) ! Node coordinator works for both MBE and GMBE (receives fragments from global coordinator) call node_coordinator ( resources , method_config , calc_type ) else ! Worker call omp_set_num_threads ( 1 ) call logger % verbose ( \"Rank \" // to_char ( resources % mpi_comms % world_comm % rank ()) // \": Acting as worker\" ) ! Worker processes work for both MBE and GMBE (fragment_type distinguishes them) call node_worker ( resources , sys_geom , method_config , calc_type , bonds ) end if ! Cleanup if ( resources % mpi_comms % world_comm % rank () == 0 ) then if ( allocated ( polymers )) deallocate ( polymers ) if ( allocated ( node_leader_ranks )) deallocate ( node_leader_ranks ) if ( allocated ( intersections )) deallocate ( intersections ) if ( allocated ( intersection_sets )) deallocate ( intersection_sets ) if ( allocated ( intersection_levels )) deallocate ( intersection_levels ) if ( allocated ( pie_atom_sets )) deallocate ( pie_atom_sets ) if ( allocated ( pie_coefficients )) deallocate ( pie_coefficients ) end if end subroutine run_fragmented_calculation","tags":"","url":"proc/run_fragmented_calculation.html"},{"title":"run_unfragmented_calculation – metalquicha","text":"private  subroutine run_unfragmented_calculation(world_comm, sys_geom, method_config, calc_type, bonds, driver_config, result_out, json_data) Handle unfragmented calculation (nlevel=0) For single-molecule mode: Only rank 0 runs (validates single rank)\nFor multi-molecule mode: ALL ranks can run (each with their own molecule)\nFor Hessian calculations with multiple ranks: Uses distributed parallelization\nIf result_out is present, returns result instead of writing JSON Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type( system_geometry_t ), intent(in) :: sys_geom Complete system geometry type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type Calculation type type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( driver_config_t ), intent(in), optional :: driver_config Driver configuration type( calculation_result_t ), intent(out), optional :: result_out Optional result output type( json_output_data_t ), intent(out), optional :: json_data JSON output data Calls proc~~run_unfragmented_calculation~~CallsGraph proc~run_unfragmented_calculation run_unfragmented_calculation info info proc~run_unfragmented_calculation->info interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string to_char to_char proc~run_unfragmented_calculation->to_char verbose verbose proc~run_unfragmented_calculation->verbose proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation barrier barrier proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char cart_disp cart_disp proc~unfragmented_calculation->cart_disp configuration configuration proc~unfragmented_calculation->configuration eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues error error proc~unfragmented_calculation->error fc_mdyne fc_mdyne proc~unfragmented_calculation->fc_mdyne force_constants force_constants proc~unfragmented_calculation->force_constants frequencies frequencies proc~unfragmented_calculation->frequencies interface~do_fragment_work do_fragment_work proc~unfragmented_calculation->interface~do_fragment_work ir_intensities ir_intensities proc~unfragmented_calculation->ir_intensities proc~check_duplicate_atoms check_duplicate_atoms proc~unfragmented_calculation->proc~check_duplicate_atoms proc~compute_thermochemistry compute_thermochemistry proc~unfragmented_calculation->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~energy_total energy_t%energy_total proc~unfragmented_calculation->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~unfragmented_calculation->proc~error_get_full_trace proc~error_get_message error_t%error_get_message proc~unfragmented_calculation->proc~error_get_message proc~error_has_error error_t%error_has_error proc~unfragmented_calculation->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_vibrational_analysis print_vibrational_analysis proc~unfragmented_calculation->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian reduced_masses reduced_masses proc~unfragmented_calculation->reduced_masses proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->warning proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_zpe->to_char proc~compute_zpe->warning proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->to_char proc~do_fragment_work->configuration proc~do_fragment_work->proc~error_set calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~error_add_context error_t%error_add_context proc~do_fragment_work->proc~error_add_context proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~hessian_coordinator->info proc~hessian_coordinator->to_char proc~hessian_coordinator->cart_disp proc~hessian_coordinator->configuration proc~hessian_coordinator->fc_mdyne proc~hessian_coordinator->force_constants proc~hessian_coordinator->ir_intensities proc~hessian_coordinator->proc~compute_thermochemistry proc~hessian_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~hessian_coordinator->proc~energy_total proc~hessian_coordinator->proc~fragment_compute_nelec proc~hessian_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator->proc~result_destroy proc~hessian_coordinator->reduced_masses proc~hessian_coordinator->calc_gradient get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time iprobe iprobe proc~hessian_coordinator->iprobe irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~hessian_coordinator->proc~create_method proc~finite_diff_dipole_derivatives finite_diff_dipole_derivatives proc~hessian_coordinator->proc~finite_diff_dipole_derivatives proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~hessian_coordinator->proc~populate_unfragmented_json_data proc~populate_vibrational_json_data populate_vibrational_json_data proc~hessian_coordinator->proc~populate_vibrational_json_data recv recv proc~hessian_coordinator->recv start start proc~hessian_coordinator->start vib_freqs vib_freqs proc~hessian_coordinator->vib_freqs proc~hessian_worker->to_char proc~hessian_worker->error proc~hessian_worker->proc~error_get_message proc~hessian_worker->proc~fragment_compute_nelec proc~hessian_worker->proc~result_destroy abort_comm abort_comm proc~hessian_worker->abort_comm proc~hessian_worker->calc_gradient proc~hessian_worker->irecv proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~hessian_worker->proc~create_method send send proc~hessian_worker->send proc~mass_weight_hessian->proc~element_mass proc~print_thermochemistry->info pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_unfragmented_calculation~~CalledByGraph proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine run_unfragmented_calculation ( world_comm , sys_geom , method_config , & calc_type , bonds , driver_config , result_out , json_data ) !! Handle unfragmented calculation (nlevel=0) !! !! For single-molecule mode: Only rank 0 runs (validates single rank) !! For multi-molecule mode: ALL ranks can run (each with their own molecule) !! For Hessian calculations with multiple ranks: Uses distributed parallelization !! If result_out is present, returns result instead of writing JSON type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( system_geometry_t ), intent ( in ) :: sys_geom !! Complete system geometry type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( driver_config_t ), intent ( in ), optional :: driver_config !! Driver configuration type ( calculation_result_t ), intent ( out ), optional :: result_out !! Optional result output type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data ! For Hessian calculations with multiple ranks, use distributed approach if ( calc_type == CALC_TYPE_HESSIAN . and . world_comm % size () > 1 ) then if ( world_comm % rank () == 0 ) then call logger % info ( \" \" ) call logger % info ( \"Running distributed unfragmented Hessian calculation\" ) call logger % info ( \"  MPI ranks: \" // to_char ( world_comm % size ())) call logger % info ( \" \" ) end if call distributed_unfragmented_hessian ( world_comm , sys_geom , method_config , driver_config , json_data ) return end if ! Check if this is multi-molecule mode or single-molecule mode ! In multi-molecule mode, each rank processes its own molecule ! In single-molecule mode, only rank 0 should work if ( world_comm % size () == 1 . or . world_comm % rank () == 0 ) then ! Either single-rank calculation, or rank 0 in multi-rank setup call logger % info ( \" \" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) call logger % info ( \" \" ) if ( present ( driver_config )) then call unfragmented_calculation ( sys_geom , method_config , calc_type , bonds , result_out , & driver_config % hessian % temperature , driver_config % hessian % pressure , json_data ) else call unfragmented_calculation ( sys_geom , method_config , calc_type , bonds , result_out , json_data = json_data ) end if else if ( sys_geom % total_atoms > 0 ) then ! Multi-molecule mode: non-zero rank with a molecule call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Running unfragmented calculation\" ) if ( present ( driver_config )) then call unfragmented_calculation ( sys_geom , method_config , calc_type , bonds , result_out , & driver_config % hessian % temperature , driver_config % hessian % pressure , json_data ) else call unfragmented_calculation ( sys_geom , method_config , calc_type , bonds , result_out , json_data = json_data ) end if end if end subroutine run_unfragmented_calculation","tags":"","url":"proc/run_unfragmented_calculation.html"},{"title":"normalize_basis_name – metalquicha","text":"public pure function normalize_basis_name(basis_name) result(normalized) Normalize basis set name to filename-safe format Rules:\n  * -> s\n  + -> p\n  Remove parentheses and commas Examples:\n  6-31G -> 6-31Gs\n  6-31+G -> 6-31pGs\n  6-31G(d)    -> 6-31Gd\n  6-311G(d,p) -> 6-311Gdp\n  6-311++G**  -> 6-311ppGss\n  cc-pVDZ     -> cc-pVDZ (unchanged) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name Return Value character(len=:), allocatable Called by proc~~normalize_basis_name~~CalledByGraph proc~normalize_basis_name normalize_basis_name proc~find_basis_file find_basis_file proc~find_basis_file->proc~normalize_basis_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: buffer integer, private :: i logical, private :: in_parens integer, private :: out_pos Source Code pure function normalize_basis_name ( basis_name ) result ( normalized ) !! Normalize basis set name to filename-safe format !! !! Rules: !!   * -> s !!   + -> p !!   Remove parentheses and commas !! !! Examples: !!   6-31G*      -> 6-31Gs !!   6-31+G*     -> 6-31pGs !!   6-31G(d)    -> 6-31Gd !!   6-311G(d,p) -> 6-311Gdp !!   6-311++G**  -> 6-311ppGss !!   cc-pVDZ     -> cc-pVDZ (unchanged) character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable :: normalized integer :: i , out_pos character ( len = 256 ) :: buffer logical :: in_parens buffer = \"\" out_pos = 0 in_parens = . false . do i = 1 , len_trim ( basis_name ) select case ( basis_name ( i : i )) case ( '*' ) ! Star becomes 's' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 's' case ( '+' ) ! Plus becomes 'p' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 'p' case ( '(' ) ! Start of parentheses - we'll extract contents in_parens = . true . case ( ')' ) ! End of parentheses in_parens = . false . case ( ',' , ' ' ) ! Skip commas and spaces (inside or outside parentheses) continue case default ! Copy character as-is out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = basis_name ( i : i ) end select end do normalized = trim ( buffer ( 1 : out_pos )) end function normalize_basis_name","tags":"","url":"proc/normalize_basis_name.html"},{"title":"find_basis_file – metalquicha","text":"public  subroutine find_basis_file(basis_name, filename, error) Find basis set file using normalized name Search strategy:\n  1. Normalize the basis name (e.g., 6-31G* -> 6-31Gs)\n  2. Look for basis_sets/{normalized}.txt\n  3. If not found, return error This is a simple, straightforward approach that assumes\nthe JSON/mqc input provides the correct basis set name. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name character(len=:), intent(out), allocatable :: filename type( error_t ), intent(out) :: error Calls proc~~find_basis_file~~CallsGraph proc~find_basis_file find_basis_file proc~error_set error_t%error_set proc~find_basis_file->proc~error_set proc~normalize_basis_name normalize_basis_name proc~find_basis_file->proc~normalize_basis_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: file_exists character(len=512), private :: filepath character(len=:), private, allocatable :: normalized Source Code subroutine find_basis_file ( basis_name , filename , error ) !! Find basis set file using normalized name !! !! Search strategy: !!   1. Normalize the basis name (e.g., 6-31G* -> 6-31Gs) !!   2. Look for basis_sets/{normalized}.txt !!   3. If not found, return error !! !! This is a simple, straightforward approach that assumes !! the JSON/mqc input provides the correct basis set name. character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable , intent ( out ) :: filename type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: normalized logical :: file_exists character ( len = 512 ) :: filepath ! Normalize the basis name normalized = normalize_basis_name ( basis_name ) ! Construct file path: basis_sets/{normalized}.txt filepath = \"basis_sets/\" // trim ( normalized ) // \".txt\" ! Check if file exists inquire ( file = trim ( filepath ), exist = file_exists ) if ( file_exists ) then filename = trim ( filepath ) else call error % set ( ERROR_IO , \"Basis set file not found: \" // trim ( filepath ) // & \" (from basis name: \" // trim ( basis_name ) // \")\" ) end if end subroutine find_basis_file","tags":"","url":"proc/find_basis_file.html"},{"title":"geometry_destroy – metalquicha","text":"private  subroutine geometry_destroy(this) Clean up allocated memory in geometry_type Type Bound geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this Called by proc~~geometry_destroy~~CalledByGraph proc~geometry_destroy geometry_type%geometry_destroy proc~config_destroy mqc_config_t%config_destroy proc~config_destroy->proc~geometry_destroy proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~geometry_destroy proc~molecule_destroy molecule_t%molecule_destroy proc~molecule_destroy->proc~geometry_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine geometry_destroy ( this ) !! Clean up allocated memory in geometry_type class ( geometry_type ), intent ( inout ) :: this if ( allocated ( this % elements )) deallocate ( this % elements ) if ( allocated ( this % coords )) deallocate ( this % coords ) if ( allocated ( this % comment )) deallocate ( this % comment ) this % natoms = 0 end subroutine geometry_destroy","tags":"","url":"proc/geometry_destroy.html"},{"title":"strings_equal – metalquicha","text":"public pure function strings_equal(str1, str2) result(equal) Compare two strings after trimming and adjusting (removing leading/trailing whitespace)\nCompare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical Called by proc~~strings_equal~~CalledByGraph proc~strings_equal strings_equal proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~strings_equal proc~find_unique_strings find_unique_strings proc~build_molecular_basis->proc~find_unique_strings proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~strings_equal proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~strings_equal proc~find_unique_strings->proc~strings_equal proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function strings_equal ( str1 , str2 ) result ( equal ) !! Compare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) character ( len =* ), intent ( in ) :: str1 , str2 logical :: equal equal = trim ( adjustl ( str1 )) == trim ( adjustl ( str2 )) end function strings_equal","tags":"","url":"proc/strings_equal.html"},{"title":"is_letter – metalquicha","text":"private pure function is_letter(c) result(is_alpha) Check if character is a letter (A-Z or a-z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_letter~~CalledByGraph proc~is_letter is_letter proc~extract_element extract_element proc~extract_element->proc~is_letter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code pure function is_letter ( c ) result ( is_alpha ) !! Check if character is a letter (A-Z or a-z) character ( len = 1 ), intent ( in ) :: c logical :: is_alpha integer :: ic ic = iachar ( c ) is_alpha = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) . or . & ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) end function is_letter","tags":"","url":"proc/is_letter.html"},{"title":"is_uppercase_letter – metalquicha","text":"private pure function is_uppercase_letter(c) result(is_upper) Check if character is an uppercase letter (A-Z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_uppercase_letter~~CalledByGraph proc~is_uppercase_letter is_uppercase_letter proc~extract_element extract_element proc~extract_element->proc~is_uppercase_letter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code pure function is_uppercase_letter ( c ) result ( is_upper ) !! Check if character is an uppercase letter (A-Z) character ( len = 1 ), intent ( in ) :: c logical :: is_upper integer :: ic ic = iachar ( c ) is_upper = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) end function is_uppercase_letter","tags":"","url":"proc/is_uppercase_letter.html"},{"title":"uppercase – metalquicha","text":"private pure function uppercase(str) result(upper) Convert a string to uppercase, should use pic_ascii! Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:), allocatable Called by proc~~uppercase~~CalledByGraph proc~uppercase uppercase proc~extract_element extract_element proc~extract_element->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: ic Source Code pure function uppercase ( str ) result ( upper ) !! Convert a string to uppercase, should use pic_ascii! character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: upper integer :: i , ic allocate ( character ( len = len ( str )) :: upper ) upper = str do i = 1 , len ( str ) ic = iachar ( str ( i : i )) if ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) then upper ( i : i ) = achar ( ic - 32 ) end if end do end function uppercase","tags":"","url":"proc/uppercase.html"},{"title":"extract_element – metalquicha","text":"public  subroutine extract_element(basis_file, element, element_content, error) Extract the basis set data for a specific element from the basis file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(in) :: basis_file character(len=*), intent(in) :: element character(len=:), intent(out), allocatable :: element_content type( error_t ), intent(out) :: error Calls proc~~extract_element~~CallsGraph proc~extract_element extract_element proc~error_set error_t%error_set proc~extract_element->proc~error_set proc~is_letter is_letter proc~extract_element->proc~is_letter proc~is_uppercase_letter is_uppercase_letter proc~extract_element->proc~is_uppercase_letter proc~uppercase uppercase proc~extract_element->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: at_line_start integer, private :: end_pos integer, private :: i character(len=:), private, allocatable :: search_element integer, private :: start_pos Source Code subroutine extract_element ( basis_file , element , element_content , error ) !! Extract the basis set data for a specific element from the basis file type ( basis_file_t ), intent ( in ) :: basis_file character ( len =* ), intent ( in ) :: element character ( len = :), allocatable , intent ( out ) :: element_content type ( error_t ), intent ( out ) :: error integer :: start_pos , end_pos , i character ( len = :), allocatable :: search_element logical :: at_line_start ! Convert element to uppercase for searching search_element = uppercase ( trim ( element )) ! Find the element name (it appears on its own line) start_pos = index ( basis_file % data_section , new_line ( 'a' ) // trim ( search_element ) // new_line ( 'a' )) if ( start_pos == 0 ) then ! Try without leading newline (might be first element after $DATA) if ( index ( basis_file % data_section , trim ( search_element ) // new_line ( 'a' )) == 1 ) then start_pos = 1 else call error % set ( ERROR_VALIDATION , \"Element not found in basis set file: \" // element ) return end if else start_pos = start_pos + 1 ! Skip the leading newline end if ! Find the next element by looking for a line that: ! - Starts with an uppercase letter ! - Has a second character that is also a letter (not a space or number) ! This distinguishes \"CARBON\" from \"S   3\" end_pos = len ( basis_file % data_section ) at_line_start = . false . i = start_pos + len ( search_element ) + 1 do while ( i < len ( basis_file % data_section )) if ( basis_file % data_section ( i : i ) == new_line ( 'a' )) then at_line_start = . true . i = i + 1 cycle end if if ( at_line_start ) then ! We're at the start of a new line if ( is_uppercase_letter ( basis_file % data_section ( i : i ))) then ! Check if next character is also a letter if ( i + 1 <= len ( basis_file % data_section )) then if ( is_letter ( basis_file % data_section ( i + 1 : i + 1 ))) then ! Found next element! end_pos = i - 1 exit end if end if end if at_line_start = . false . end if i = i + 1 end do ! Extract the section element_content = basis_file % data_section ( start_pos : end_pos ) end subroutine extract_element","tags":"","url":"proc/extract_element.html"},{"title":"open_basis_file – metalquicha","text":"public  subroutine open_basis_file(basis_file, filename, error) Open and read a GAMESS formatted basis set file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(out) :: basis_file character(len=*), intent(in) :: filename type( error_t ), intent(out) :: error Calls proc~~open_basis_file~~CallsGraph proc~open_basis_file open_basis_file proc~error_set error_t%error_set proc~open_basis_file->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: data_end integer, private :: data_start logical, private :: file_exists integer, private :: file_size integer, private :: iostat integer, private :: unit Source Code subroutine open_basis_file ( basis_file , filename , error ) !! Open and read a GAMESS formatted basis set file type ( basis_file_t ), intent ( out ) :: basis_file character ( len =* ), intent ( in ) :: filename type ( error_t ), intent ( out ) :: error integer :: unit , iostat , file_size logical :: file_exists integer :: data_start , data_end ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"Basis set file not found: \" // filename ) return end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: basis_file % full_content ) ! Open and read entire file open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = iostat ) if ( iostat /= 0 ) then call error % set ( ERROR_IO , \"Error opening file: \" // filename ) return end if read ( unit , iostat = iostat ) basis_file % full_content if ( iostat /= 0 ) then close ( unit ) call error % set ( ERROR_IO , \"Error reading file: \" // filename ) return end if close ( unit ) ! Extract the $DATA section data_start = index ( basis_file % full_content , \"$DATA\" ) if ( data_start == 0 ) then call error % set ( ERROR_VALIDATION , \"Could not find $DATA section in basis set file: \" // filename ) return end if data_end = index ( basis_file % full_content ( data_start :), \"$END\" ) if ( data_end == 0 ) then call error % set ( ERROR_VALIDATION , \"Could not find $END marker in basis set file: \" // filename ) return end if ! Store just the data section (between $DATA and $END) basis_file % data_section = basis_file % full_content ( data_start + 5 : data_start + data_end - 2 ) end subroutine open_basis_file","tags":"","url":"proc/open_basis_file.html"},{"title":"distributed_unfragmented_hessian – metalquicha","text":"interface Calls interface~~distributed_unfragmented_hessian~~CallsGraph interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian barrier barrier proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker calc_gradient calc_gradient proc~hessian_coordinator->calc_gradient cart_disp cart_disp proc~hessian_coordinator->cart_disp configuration configuration proc~hessian_coordinator->configuration fc_mdyne fc_mdyne proc~hessian_coordinator->fc_mdyne force_constants force_constants proc~hessian_coordinator->force_constants get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time info info proc~hessian_coordinator->info iprobe iprobe proc~hessian_coordinator->iprobe ir_intensities ir_intensities proc~hessian_coordinator->ir_intensities irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~compute_thermochemistry compute_thermochemistry proc~hessian_coordinator->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~create_method create_method proc~hessian_coordinator->proc~create_method proc~energy_total energy_t%energy_total proc~hessian_coordinator->proc~energy_total proc~finite_diff_dipole_derivatives finite_diff_dipole_derivatives proc~hessian_coordinator->proc~finite_diff_dipole_derivatives proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_coordinator->proc~fragment_compute_nelec proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~hessian_coordinator->proc~populate_unfragmented_json_data proc~populate_vibrational_json_data populate_vibrational_json_data proc~hessian_coordinator->proc~populate_vibrational_json_data proc~print_vibrational_analysis print_vibrational_analysis proc~hessian_coordinator->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~hessian_coordinator->proc~result_destroy recv recv proc~hessian_coordinator->recv reduced_masses reduced_masses proc~hessian_coordinator->reduced_masses start start proc~hessian_coordinator->start to_char to_char proc~hessian_coordinator->to_char vib_freqs vib_freqs proc~hessian_coordinator->vib_freqs abort_comm abort_comm proc~hessian_worker->abort_comm proc~hessian_worker->calc_gradient error error proc~hessian_worker->error proc~hessian_worker->irecv proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~hessian_worker->proc~create_method proc~error_get_message error_t%error_get_message proc~hessian_worker->proc~error_get_message proc~hessian_worker->proc~fragment_compute_nelec proc~hessian_worker->proc~result_destroy send send proc~hessian_worker->send proc~hessian_worker->to_char proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~populate_unfragmented_json_data->proc~energy_total proc~populate_vibrational_json_data->proc~energy_total proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~distributed_unfragmented_hessian~~CalledByGraph interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine distributed_unfragmented_hessian(world_comm, sys_geom, method_config, driver_config, json_data) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration type( driver_config_t ), intent(in), optional :: driver_config Driver configuration type( json_output_data_t ), intent(out), optional :: json_data JSON output data","tags":"","url":"interface/distributed_unfragmented_hessian.html"},{"title":"do_fragment_work – metalquicha","text":"interface Calls interface~~do_fragment_work~~CallsGraph interface~do_fragment_work do_fragment_work proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian configuration configuration proc~do_fragment_work->configuration proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~error_add_context error_t%error_add_context proc~do_fragment_work->proc~error_add_context proc~error_set error_t%error_set proc~do_fragment_work->proc~error_set proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz to_char to_char proc~do_fragment_work->to_char proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->to_char info info proc~print_fragment_xyz->info proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb state_weights state_weights proc~configure_mcscf->state_weights proc~method_type_to_string method_type_to_string proc~configure_xtb->proc~method_type_to_string proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~configure_xtb->proc~xtb_has_solvation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~do_fragment_work~~CalledByGraph interface~do_fragment_work do_fragment_work proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine do_fragment_work(fragment_idx, result, method_config, phys_frag, calc_type, world_comm) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx type( calculation_result_t ), intent(out) :: result type( method_config_t ), intent(in) :: method_config Method configuration type( physical_fragment_t ), intent(in), optional :: phys_frag integer(kind=int32), intent(in) :: calc_type type(comm_t), intent(in), optional :: world_comm","tags":"","url":"interface/do_fragment_work.html"},{"title":"global_coordinator – metalquicha","text":"interface Calls interface~~global_coordinator~~CallsGraph interface~global_coordinator global_coordinator proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator abort_comm abort_comm proc~global_coordinator->abort_comm allocate_dipole allocate_dipole proc~global_coordinator->allocate_dipole allocate_gradient allocate_gradient proc~global_coordinator->allocate_gradient allocate_hessian allocate_hessian proc~global_coordinator->allocate_hessian debug debug proc~global_coordinator->debug destroy destroy proc~global_coordinator->destroy error error proc~global_coordinator->error get_elapsed_time get_elapsed_time proc~global_coordinator->get_elapsed_time info info proc~global_coordinator->info iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~error_get_message error_t%error_get_message proc~global_coordinator->proc~error_get_message proc~result_irecv result_irecv proc~global_coordinator->proc~result_irecv proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker start start proc~global_coordinator->start to_char to_char proc~global_coordinator->to_char verbose verbose proc~global_coordinator->verbose proc~compute_mbe->abort_comm proc~compute_mbe->error proc~compute_mbe->info proc~compute_mbe->to_char cart_disp cart_disp proc~compute_mbe->cart_disp configuration configuration proc~compute_mbe->configuration fc_mdyne fc_mdyne proc~compute_mbe->fc_mdyne force_constants force_constants proc~compute_mbe->force_constants frequencies frequencies proc~compute_mbe->frequencies get_message get_message proc~compute_mbe->get_message has_error has_error proc~compute_mbe->has_error proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe->proc~compute_mbe_dipole proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_thermochemistry compute_thermochemistry proc~compute_mbe->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_mbe->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~compute_mbe->proc~energy_total proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis reduced_masses reduced_masses proc~compute_mbe->reduced_masses warning warning proc~compute_mbe->warning proc~result_irecv->irecv recv recv proc~result_irecv->recv proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~build_mbe_lookup_table->debug proc~build_mbe_lookup_table->get_elapsed_time proc~build_mbe_lookup_table->start proc~build_mbe_lookup_table->to_char proc~error_add_context error_t%error_add_context proc~build_mbe_lookup_table->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_mbe_lookup_table->proc~error_has_error proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~compute_mbe_delta->abort_comm proc~compute_mbe_delta->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_dipole->abort_comm proc~compute_mbe_dipole->error proc~compute_mbe_dipole->proc~fragment_lookup_find proc~compute_mbe_dipole->proc~get_next_combination proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~fragment_lookup_find proc~compute_mbe_dipole_derivatives->proc~get_next_combination proc~compute_mbe_gradient->abort_comm proc~compute_mbe_gradient->error proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~redistribute_cap_dipole_derivatives proc~map_fragment_to_system_gradient->abort_comm proc~map_fragment_to_system_gradient->debug proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_has_error proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->verbose proc~print_detailed_breakdown->warning header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~print_vibrational_analysis->warning proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~build_fragment_from_indices->proc~error_add_context proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->warning pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_zpe->to_char proc~compute_zpe->warning proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal proc~fragment_lookup_insert->fnv_1a_hash proc~error_set error_t%error_set proc~fragment_lookup_insert->proc~error_set proc~fragment_lookup_insert->sort proc~print_thermochemistry->info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~global_coordinator~~CalledByGraph interface~global_coordinator global_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine global_coordinator(resources, total_fragments, polymers, max_level, node_leader_ranks, num_nodes, sys_geom, method_config, calc_type, bonds, json_data) Implementation → Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data","tags":"","url":"interface/global_coordinator.html"},{"title":"node_coordinator – metalquicha","text":"interface Calls interface~~node_coordinator~~CallsGraph interface~node_coordinator node_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator abort_comm abort_comm proc~node_coordinator->abort_comm error error proc~node_coordinator->error iprobe iprobe proc~node_coordinator->iprobe irecv irecv proc~node_coordinator->irecv isend isend proc~node_coordinator->isend proc~error_get_message error_t%error_get_message proc~node_coordinator->proc~error_get_message proc~result_irecv result_irecv proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv to_char to_char proc~node_coordinator->to_char proc~result_irecv->irecv proc~result_irecv->recv proc~result_isend->isend send send proc~result_isend->send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~node_coordinator~~CalledByGraph interface~node_coordinator node_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine node_coordinator(resources, method_config, calc_type) Implementation → Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type","tags":"","url":"interface/node_coordinator.html"},{"title":"node_worker – metalquicha","text":"interface Calls interface~~node_worker~~CallsGraph interface~node_worker node_worker proc~node_worker node_worker interface~node_worker->proc~node_worker abort_comm abort_comm proc~node_worker->abort_comm error error proc~node_worker->error interface~do_fragment_work do_fragment_work proc~node_worker->interface~do_fragment_work irecv irecv proc~node_worker->irecv isend isend proc~node_worker->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_atom_list proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~node_worker->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~node_worker->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~node_worker->proc~fragment_destroy proc~result_isend result_isend proc~node_worker->proc~result_isend recv recv proc~node_worker->recv to_char to_char proc~node_worker->to_char proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~build_fragment_from_indices->proc~error_has_error proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~error_add_context proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~result_isend->isend send send proc~result_isend->send proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~do_fragment_work->to_char proc~do_fragment_work->proc~error_add_context calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian configuration configuration proc~do_fragment_work->configuration proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~do_fragment_work->proc~error_set proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_fragment_xyz->proc~to_angstrom info info proc~print_fragment_xyz->info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~node_worker~~CalledByGraph interface~node_worker node_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine node_worker(resources, sys_geom, method_config, calc_type, bonds) Implementation → Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:)","tags":"","url":"interface/node_worker.html"},{"title":"serial_fragment_processor – metalquicha","text":"interface Calls interface~~serial_fragment_processor~~CallsGraph interface~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor configuration configuration proc~serial_fragment_processor->configuration error error proc~serial_fragment_processor->error get_elapsed_time get_elapsed_time proc~serial_fragment_processor->get_elapsed_time info info proc~serial_fragment_processor->info interface~do_fragment_work do_fragment_work proc~serial_fragment_processor->interface~do_fragment_work omp_get_max_threads omp_get_max_threads proc~serial_fragment_processor->omp_get_max_threads omp_set_num_threads omp_set_num_threads proc~serial_fragment_processor->omp_set_num_threads proc~build_fragment_from_indices build_fragment_from_indices proc~serial_fragment_processor->proc~build_fragment_from_indices proc~calc_type_to_string calc_type_to_string proc~serial_fragment_processor->proc~calc_type_to_string proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~energy_total energy_t%energy_total proc~serial_fragment_processor->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~serial_fragment_processor->proc~error_get_full_trace proc~error_get_message error_t%error_get_message proc~serial_fragment_processor->proc~error_get_message proc~error_has_error error_t%error_has_error proc~serial_fragment_processor->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~serial_fragment_processor->proc~fragment_destroy proc~mbe_result_allocate_dipole mbe_result_t%mbe_result_allocate_dipole proc~serial_fragment_processor->proc~mbe_result_allocate_dipole proc~mbe_result_allocate_gradient mbe_result_t%mbe_result_allocate_gradient proc~serial_fragment_processor->proc~mbe_result_allocate_gradient proc~mbe_result_allocate_hessian mbe_result_t%mbe_result_allocate_hessian proc~serial_fragment_processor->proc~mbe_result_allocate_hessian start start proc~serial_fragment_processor->start to_char to_char proc~serial_fragment_processor->to_char verbose verbose proc~serial_fragment_processor->verbose proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~compute_mbe->configuration proc~compute_mbe->error proc~compute_mbe->info proc~compute_mbe->proc~energy_total proc~compute_mbe->to_char abort_comm abort_comm proc~compute_mbe->abort_comm cart_disp cart_disp proc~compute_mbe->cart_disp fc_mdyne fc_mdyne proc~compute_mbe->fc_mdyne force_constants force_constants proc~compute_mbe->force_constants frequencies frequencies proc~compute_mbe->frequencies get_message get_message proc~compute_mbe->get_message has_error has_error proc~compute_mbe->has_error proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe->proc~compute_mbe_dipole proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_thermochemistry compute_thermochemistry proc~compute_mbe->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_mbe->proc~compute_vibrational_analysis proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis reduced_masses reduced_masses proc~compute_mbe->reduced_masses warning warning proc~compute_mbe->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_mbe_lookup_table->get_elapsed_time proc~build_mbe_lookup_table->proc~error_has_error proc~build_mbe_lookup_table->start proc~build_mbe_lookup_table->to_char proc~build_mbe_lookup_table->proc~error_add_context debug debug proc~build_mbe_lookup_table->debug proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~compute_mbe_delta->error proc~compute_mbe_delta->abort_comm proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_dipole->error proc~compute_mbe_dipole->abort_comm proc~compute_mbe_dipole->proc~fragment_lookup_find proc~compute_mbe_dipole->proc~get_next_combination proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~fragment_lookup_find proc~compute_mbe_dipole_derivatives->proc~get_next_combination proc~compute_mbe_gradient->error proc~compute_mbe_gradient->abort_comm proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~do_fragment_work->configuration proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->to_char proc~do_fragment_work->proc~error_add_context calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~do_fragment_work->proc~error_set proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~redistribute_cap_dipole_derivatives proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_has_error proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_gradient->abort_comm proc~map_fragment_to_system_gradient->debug proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->verbose proc~print_detailed_breakdown->warning header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~print_vibrational_analysis->warning proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->warning pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_zpe->to_char proc~compute_zpe->warning proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal proc~fragment_lookup_insert->proc~error_set proc~fragment_lookup_insert->fnv_1a_hash proc~fragment_lookup_insert->sort proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_fragment_xyz->proc~to_angstrom proc~print_thermochemistry->info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~serial_fragment_processor~~CalledByGraph interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine serial_fragment_processor(total_fragments, polymers, max_level, sys_geom, method_config, calc_type, bonds, json_data) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data","tags":"","url":"interface/serial_fragment_processor.html"},{"title":"unfragmented_calculation – metalquicha","text":"interface Calls interface~~unfragmented_calculation~~CallsGraph interface~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation cart_disp cart_disp proc~unfragmented_calculation->cart_disp configuration configuration proc~unfragmented_calculation->configuration eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues error error proc~unfragmented_calculation->error fc_mdyne fc_mdyne proc~unfragmented_calculation->fc_mdyne force_constants force_constants proc~unfragmented_calculation->force_constants frequencies frequencies proc~unfragmented_calculation->frequencies info info proc~unfragmented_calculation->info interface~do_fragment_work do_fragment_work proc~unfragmented_calculation->interface~do_fragment_work ir_intensities ir_intensities proc~unfragmented_calculation->ir_intensities proc~check_duplicate_atoms check_duplicate_atoms proc~unfragmented_calculation->proc~check_duplicate_atoms proc~compute_thermochemistry compute_thermochemistry proc~unfragmented_calculation->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~energy_total energy_t%energy_total proc~unfragmented_calculation->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~unfragmented_calculation->proc~error_get_full_trace proc~error_get_message error_t%error_get_message proc~unfragmented_calculation->proc~error_get_message proc~error_has_error error_t%error_has_error proc~unfragmented_calculation->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_vibrational_analysis print_vibrational_analysis proc~unfragmented_calculation->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian reduced_masses reduced_masses proc~unfragmented_calculation->reduced_masses to_char to_char proc~unfragmented_calculation->to_char proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->warning proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_zpe->to_char proc~compute_zpe->warning proc~do_fragment_work->configuration proc~do_fragment_work->to_char proc~do_fragment_work->proc~error_set calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~error_add_context error_t%error_add_context proc~do_fragment_work->proc~error_add_context proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~mass_weight_hessian->proc~element_mass proc~print_thermochemistry->info pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~unfragmented_calculation~~CalledByGraph interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine unfragmented_calculation(sys_geom, method_config, calc_type, bonds, result_out, temperature, pressure, json_data) Implementation → Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( calculation_result_t ), intent(out), optional :: result_out real(kind=dp), intent(in), optional :: temperature real(kind=dp), intent(in), optional :: pressure type( json_output_data_t ), intent(out), optional :: json_data","tags":"","url":"interface/unfragmented_calculation.html"},{"title":"hessian_coordinator – metalquicha","text":"interface Calls interface~~hessian_coordinator~~CallsGraph interface~hessian_coordinator hessian_coordinator proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator calc_gradient calc_gradient proc~hessian_coordinator->calc_gradient cart_disp cart_disp proc~hessian_coordinator->cart_disp configuration configuration proc~hessian_coordinator->configuration fc_mdyne fc_mdyne proc~hessian_coordinator->fc_mdyne force_constants force_constants proc~hessian_coordinator->force_constants get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time info info proc~hessian_coordinator->info iprobe iprobe proc~hessian_coordinator->iprobe ir_intensities ir_intensities proc~hessian_coordinator->ir_intensities irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~compute_thermochemistry compute_thermochemistry proc~hessian_coordinator->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~create_method create_method proc~hessian_coordinator->proc~create_method proc~energy_total energy_t%energy_total proc~hessian_coordinator->proc~energy_total proc~finite_diff_dipole_derivatives finite_diff_dipole_derivatives proc~hessian_coordinator->proc~finite_diff_dipole_derivatives proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_coordinator->proc~fragment_compute_nelec proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~hessian_coordinator->proc~populate_unfragmented_json_data proc~populate_vibrational_json_data populate_vibrational_json_data proc~hessian_coordinator->proc~populate_vibrational_json_data proc~print_vibrational_analysis print_vibrational_analysis proc~hessian_coordinator->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~hessian_coordinator->proc~result_destroy recv recv proc~hessian_coordinator->recv reduced_masses reduced_masses proc~hessian_coordinator->reduced_masses start start proc~hessian_coordinator->start to_char to_char proc~hessian_coordinator->to_char vib_freqs vib_freqs proc~hessian_coordinator->vib_freqs proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses error error proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~populate_unfragmented_json_data->proc~energy_total proc~populate_vibrational_json_data->proc~energy_total proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->warning proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_zpe->to_char proc~compute_zpe->warning proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb proc~mass_weight_hessian->proc~element_mass proc~print_thermochemistry->info pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear state_weights state_weights proc~configure_mcscf->state_weights proc~method_type_to_string method_type_to_string proc~configure_xtb->proc~method_type_to_string proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~configure_xtb->proc~xtb_has_solvation proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~hessian_coordinator~~CalledByGraph interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module subroutine hessian_coordinator(world_comm, sys_geom, method_config, displacement, temperature, pressure, json_data) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr) real(kind=dp), intent(in) :: temperature Temperature for thermochemistry (K) real(kind=dp), intent(in) :: pressure Pressure for thermochemistry (atm) type( json_output_data_t ), intent(out), optional :: json_data JSON output data","tags":"","url":"interface/hessian_coordinator.html"},{"title":"hessian_worker – metalquicha","text":"interface Calls interface~~hessian_worker~~CallsGraph interface~hessian_worker hessian_worker proc~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker abort_comm abort_comm proc~hessian_worker->abort_comm calc_gradient calc_gradient proc~hessian_worker->calc_gradient error error proc~hessian_worker->error irecv irecv proc~hessian_worker->irecv isend isend proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~create_method create_method proc~hessian_worker->proc~create_method proc~error_get_message error_t%error_get_message proc~hessian_worker->proc~error_get_message proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_worker->proc~fragment_compute_nelec proc~result_destroy calculation_result_t%result_destroy proc~hessian_worker->proc~result_destroy send send proc~hessian_worker->send to_char to_char proc~hessian_worker->to_char proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear state_weights state_weights proc~configure_mcscf->state_weights proc~method_type_to_string method_type_to_string proc~configure_xtb->proc~method_type_to_string proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~configure_xtb->proc~xtb_has_solvation proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~hessian_worker~~CalledByGraph interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_worker interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module subroutine hessian_worker(world_comm, sys_geom, method_config, displacement) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr)","tags":"","url":"interface/hessian_worker.html"},{"title":"parse_command_line – metalquicha","text":"public  subroutine parse_command_line(args, error) Parse command line arguments for geometry file and basis set Extracts XYZ file path and basis set name from command line,\nvalidates arguments, and handles help requests. Arguments Type Intent Optional Attributes Name type( cli_args_type ), intent(out) :: args Parsed argument container type( error_t ), intent(out) :: error Error object Calls proc~~parse_command_line~~CallsGraph proc~parse_command_line parse_command_line proc~error_set error_t%error_set proc~parse_command_line->proc~error_set proc~print_usage print_usage proc~parse_command_line->proc~print_usage Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: arg_buffer Temporary argument buffer integer, private :: arg_len Length of current argument integer, private :: nargs Number of command line arguments integer, private :: stat Local status for intrinsic calls Source Code subroutine parse_command_line ( args , error ) !! Parse command line arguments for geometry file and basis set !! !! Extracts XYZ file path and basis set name from command line, !! validates arguments, and handles help requests. type ( cli_args_type ), intent ( out ) :: args !! Parsed argument container type ( error_t ), intent ( out ) :: error !! Error object integer :: nargs !! Number of command line arguments character ( len = 256 ) :: arg_buffer !! Temporary argument buffer integer :: arg_len !! Length of current argument integer :: stat !! Local status for intrinsic calls ! Get number of command line arguments nargs = command_argument_count () ! Check for help flag if ( nargs >= 1 ) then call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading command line argument 1\" ) return end if arg_buffer = trim ( arg_buffer ) if ( arg_buffer == \"-h\" . or . arg_buffer == \"--help\" ) then call print_usage () call error % set ( ERROR_PARSE , \"HELP_REQUESTED\" ) ! Special marker for help return end if end if ! Validate number of arguments if ( nargs < 2 ) then call error % set ( ERROR_PARSE , \"Error: Insufficient arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if if ( nargs > 2 ) then call error % set ( ERROR_PARSE , \"Error: Too many arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if ! Parse argument 1: XYZ file call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry file argument\" ) return end if args % xyz_file = trim ( arg_buffer ) ! Parse argument 2: Basis set name call get_command_argument ( 2 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading basis set name argument\" ) return end if args % basis_name = trim ( arg_buffer ) end subroutine parse_command_line","tags":"","url":"proc/parse_command_line.html"},{"title":"print_usage – metalquicha","text":"public  subroutine print_usage() Print usage information Arguments None Called by proc~~print_usage~~CalledByGraph proc~print_usage print_usage proc~parse_command_line parse_command_line proc~parse_command_line->proc~print_usage Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: prog_name integer, private :: stat Source Code subroutine print_usage () character ( len = 256 ) :: prog_name integer :: stat call get_command_argument ( 0 , prog_name , status = stat ) if ( stat /= 0 ) prog_name = \"pic_basis_reader\" print * print * , \"Usage: \" , trim ( prog_name ), \" <geometry.xyz> <basis_name>\" print * print * , \"Arguments:\" print * , \"  geometry.xyz   XYZ format molecular geometry file\" print * , \"  basis_name     Name of basis set (e.g., 6-31G, 6-311G**)\" print * print * , \"Options:\" print * , \"  -h, --help     Show this help message\" print * print * , \"Example:\" print * , \"  \" , trim ( prog_name ), \" water.xyz 6-31G\" print * end subroutine print_usage","tags":"","url":"proc/print_usage.html"},{"title":"cli_args_destroy – metalquicha","text":"private  subroutine cli_args_destroy(this) Clean up CLI args Type Bound cli_args_type Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this Source Code subroutine cli_args_destroy ( this ) class ( cli_args_type ), intent ( inout ) :: this if ( allocated ( this % xyz_file )) deallocate ( this % xyz_file ) if ( allocated ( this % basis_name )) deallocate ( this % basis_name ) end subroutine cli_args_destroy","tags":"","url":"proc/cli_args_destroy.html"},{"title":"mcscf_calc_energy – metalquicha","text":"private  subroutine mcscf_calc_energy(this, fragment, result) Calculate electronic energy using CASSCF TODO: Implementation requires:\n1. Build basis set and compute integrals\n2. Initial orbital guess (HF or read from file)\n3. Partition orbitals: inactive, active, virtual\n4. Macro iterations:\n   a. Transform integrals to MO basis\n   b. Solve CI in active space (Davidson or direct)\n   c. Build 1- and 2-RDMs from CI vector\n   d. Compute orbital gradient\n   e. Update orbitals (super-CI, Newton-Raphson, etc.)\n   f. Check convergence\n5. Optional: CASPT2/NEVPT2 correction Type Bound mcscf_method_t Arguments Type Intent Optional Attributes Name class( mcscf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~mcscf_calc_energy~~CallsGraph proc~mcscf_calc_energy mcscf_method_t%mcscf_calc_energy proc~energy_total energy_t%energy_total proc~mcscf_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mcscf_calc_energy~~CalledByGraph proc~mcscf_calc_energy mcscf_method_t%mcscf_calc_energy proc~mcscf_calc_gradient mcscf_method_t%mcscf_calc_gradient proc~mcscf_calc_gradient->proc~mcscf_calc_energy proc~mcscf_calc_hessian mcscf_method_t%mcscf_calc_hessian proc~mcscf_calc_hessian->proc~mcscf_calc_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: n_inactive Source Code subroutine mcscf_calc_energy ( this , fragment , result ) !! Calculate electronic energy using CASSCF !! !! TODO: Implementation requires: !! 1. Build basis set and compute integrals !! 2. Initial orbital guess (HF or read from file) !! 3. Partition orbitals: inactive, active, virtual !! 4. Macro iterations: !!    a. Transform integrals to MO basis !!    b. Solve CI in active space (Davidson or direct) !!    c. Build 1- and 2-RDMs from CI vector !!    d. Compute orbital gradient !!    e. Update orbitals (super-CI, Newton-Raphson, etc.) !!    f. Check convergence !! 5. Optional: CASPT2/NEVPT2 correction class ( mcscf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result integer :: n_inactive if ( this % options % verbose ) then print * , \"MCSCF: Calculating CASSCF energy\" print * , \"MCSCF: Basis set: \" , trim ( this % options % basis_set ) print * , \"MCSCF: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"MCSCF: nelec =\" , fragment % nelec print * , \"MCSCF: charge =\" , fragment % charge print * , \"MCSCF: Active space: (\" , this % options % n_active_electrons , \",\" , & this % options % n_active_orbitals , \")\" ! Calculate inactive orbitals if ( this % options % n_inactive_orbitals < 0 ) then n_inactive = ( fragment % nelec - this % options % n_active_electrons ) / 2 else n_inactive = this % options % n_inactive_orbitals end if print * , \"MCSCF: Inactive orbitals:\" , n_inactive if ( this % options % n_states > 1 ) then print * , \"MCSCF: State-averaged over\" , this % options % n_states , \"states\" end if if ( this % options % use_pt2 ) then print * , \"MCSCF: Will apply \" , trim ( this % options % pt2_type ), \" correction\" end if end if ! Validate active space if ( this % options % n_active_electrons <= 0 . or . this % options % n_active_orbitals <= 0 ) then print * , \"MCSCF: ERROR - Active space not defined!\" print * , \"MCSCF: Set n_active_electrons and n_active_orbitals in config\" result % has_error = . true . return end if ! Placeholder: Return dummy energy ! TODO: Implement actual CASSCF calculation result % energy % scf = - 1.0_dp * fragment % n_atoms ! Placeholder result % has_energy = . true . if ( this % options % verbose ) then print * , \"MCSCF: [STUB] CASSCF Energy =\" , result % energy % total () end if end subroutine mcscf_calc_energy","tags":"","url":"proc/mcscf_calc_energy.html"},{"title":"mcscf_calc_gradient – metalquicha","text":"private  subroutine mcscf_calc_gradient(this, fragment, result) Calculate energy gradient using CASSCF TODO: Implementation requires:\n1. Converged CASSCF (orbitals and CI)\n2. Solve Z-vector (CPHF-like) equations for response\n3. Compute gradient contributions:\n   a. One-electron derivative terms\n   b. Two-electron derivative terms (with 2-RDM)\n   c. Orbital response contribution\n   d. CI response contribution (for state-specific)\nFor state-averaged: gradient of weighted energy Type Bound mcscf_method_t Arguments Type Intent Optional Attributes Name class( mcscf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~mcscf_calc_gradient~~CallsGraph proc~mcscf_calc_gradient mcscf_method_t%mcscf_calc_gradient proc~mcscf_calc_energy mcscf_method_t%mcscf_calc_energy proc~mcscf_calc_gradient->proc~mcscf_calc_energy proc~energy_total energy_t%energy_total proc~mcscf_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mcscf_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using CASSCF !! !! TODO: Implementation requires: !! 1. Converged CASSCF (orbitals and CI) !! 2. Solve Z-vector (CPHF-like) equations for response !! 3. Compute gradient contributions: !!    a. One-electron derivative terms !!    b. Two-electron derivative terms (with 2-RDM) !!    c. Orbital response contribution !!    d. CI response contribution (for state-specific) !! For state-averaged: gradient of weighted energy class ( mcscf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result if ( this % options % verbose ) then print * , \"MCSCF: Calculating CASSCF gradient\" end if ! First get energy (and converged orbitals/CI) call this % calc_energy ( fragment , result ) if ( result % has_error ) return ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . if ( this % options % verbose ) then print * , \"MCSCF: [STUB] Gradient computed\" end if end subroutine mcscf_calc_gradient","tags":"","url":"proc/mcscf_calc_gradient.html"},{"title":"mcscf_calc_hessian – metalquicha","text":"private  subroutine mcscf_calc_hessian(this, fragment, result) Calculate energy Hessian using CASSCF TODO: Analytical CASSCF Hessian is very complex:\n- Requires second derivatives of integrals\n- Coupled-perturbed MCSCF equations\n- CI second derivatives\nTypically done via finite difference of gradients Type Bound mcscf_method_t Arguments Type Intent Optional Attributes Name class( mcscf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~mcscf_calc_hessian~~CallsGraph proc~mcscf_calc_hessian mcscf_method_t%mcscf_calc_hessian proc~mcscf_calc_energy mcscf_method_t%mcscf_calc_energy proc~mcscf_calc_hessian->proc~mcscf_calc_energy proc~energy_total energy_t%energy_total proc~mcscf_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mcscf_calc_hessian ( this , fragment , result ) !! Calculate energy Hessian using CASSCF !! !! TODO: Analytical CASSCF Hessian is very complex: !! - Requires second derivatives of integrals !! - Coupled-perturbed MCSCF equations !! - CI second derivatives !! Typically done via finite difference of gradients class ( mcscf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result if ( this % options % verbose ) then print * , \"MCSCF: Analytical Hessian not implemented\" print * , \"MCSCF: Use finite difference of gradients instead\" end if ! For now, just compute energy call this % calc_energy ( fragment , result ) result % has_hessian = . false . end subroutine mcscf_calc_hessian","tags":"","url":"proc/mcscf_calc_hessian.html"},{"title":"copy_and_displace_geometry – metalquicha","text":"public  subroutine copy_and_displace_geometry(reference_geom, atom_idx, coord_idx, displacement, displaced_geom) Create a copy of reference geometry with one coordinate displaced Args:\n  reference_geom: Original geometry to copy\n  atom_idx: Atom to displace (1-based)\n  coord_idx: Coordinate to displace (1=x, 2=y, 3=z)\n  displacement: Amount to displace in Bohr (positive or negative)\n  displaced_geom: Output displaced geometry Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom integer, intent(in) :: atom_idx integer, intent(in) :: coord_idx real(kind=dp), intent(in) :: displacement type( physical_fragment_t ), intent(out) :: displaced_geom Called by proc~~copy_and_displace_geometry~~CalledByGraph proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries generate_perturbed_geometries proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~hessian_worker hessian_worker proc~hessian_worker->proc~copy_and_displace_geometry interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_worker interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine copy_and_displace_geometry ( reference_geom , atom_idx , coord_idx , displacement , displaced_geom ) !! Create a copy of reference geometry with one coordinate displaced !! !! Args: !!   reference_geom: Original geometry to copy !!   atom_idx: Atom to displace (1-based) !!   coord_idx: Coordinate to displace (1=x, 2=y, 3=z) !!   displacement: Amount to displace in Bohr (positive or negative) !!   displaced_geom: Output displaced geometry type ( physical_fragment_t ), intent ( in ) :: reference_geom integer , intent ( in ) :: atom_idx , coord_idx real ( dp ), intent ( in ) :: displacement type ( physical_fragment_t ), intent ( out ) :: displaced_geom ! Copy basic properties displaced_geom % n_atoms = reference_geom % n_atoms displaced_geom % charge = reference_geom % charge displaced_geom % multiplicity = reference_geom % multiplicity displaced_geom % nelec = reference_geom % nelec displaced_geom % n_caps = reference_geom % n_caps ! Allocate and copy arrays allocate ( displaced_geom % element_numbers ( displaced_geom % n_atoms )) allocate ( displaced_geom % coordinates ( 3 , displaced_geom % n_atoms )) displaced_geom % element_numbers = reference_geom % element_numbers displaced_geom % coordinates = reference_geom % coordinates ! Copy hydrogen cap information if present if ( reference_geom % n_caps > 0 ) then allocate ( displaced_geom % cap_replaces_atom ( displaced_geom % n_caps )) displaced_geom % cap_replaces_atom = reference_geom % cap_replaces_atom end if ! Copy gradient redistribution mapping if present if ( allocated ( reference_geom % local_to_global )) then allocate ( displaced_geom % local_to_global ( size ( reference_geom % local_to_global ))) displaced_geom % local_to_global = reference_geom % local_to_global end if ! Apply displacement to specified coordinate displaced_geom % coordinates ( coord_idx , atom_idx ) = & displaced_geom % coordinates ( coord_idx , atom_idx ) + displacement ! Copy basis set if present (same basis, just different geometry) if ( allocated ( reference_geom % basis )) then ! Note: Basis set will need to be rebuilt with new coordinates ! For now, we don't copy it - it should be set up during calculation end if end subroutine copy_and_displace_geometry","tags":"","url":"proc/copy_and_displace_geometry.html"},{"title":"finite_diff_dipole_derivatives – metalquicha","text":"public  subroutine finite_diff_dipole_derivatives(n_atoms, forward_dipoles, backward_dipoles, displacement, dipole_derivatives) Compute dipole moment derivatives via central finite differences Computes: d_mu_k/d_x_j = (mu_k(+h) - mu_k(-h)) / (2h) This is used for IR intensity calculations, where we need the dipole\nmoment derivatives with respect to Cartesian nuclear coordinates. Args:\n  n_atoms: Number of atoms\n  forward_dipoles: Dipoles at forward-displaced geometries (3 n_atoms, 3)\n  backward_dipoles: Dipoles at backward-displaced geometries (3 n_atoms, 3)\n  displacement: Step size in Bohr\n  dipole_derivatives: Output derivatives (3, 3*n_atoms) in a.u. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_atoms real(kind=dp), intent(in) :: forward_dipoles (:,:) (3*n_atoms, 3) real(kind=dp), intent(in) :: backward_dipoles (:,:) (3*n_atoms, 3) real(kind=dp), intent(in) :: displacement real(kind=dp), intent(out), allocatable :: dipole_derivatives (:,:) (3, 3*n_atoms) Called by proc~~finite_diff_dipole_derivatives~~CalledByGraph proc~finite_diff_dipole_derivatives finite_diff_dipole_derivatives proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~finite_diff_dipole_derivatives proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~finite_diff_dipole_derivatives interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: j integer, private :: k integer, private :: n_coords Source Code subroutine finite_diff_dipole_derivatives ( n_atoms , forward_dipoles , backward_dipoles , & displacement , dipole_derivatives ) !! Compute dipole moment derivatives via central finite differences !! !! Computes: d_mu_k/d_x_j = (mu_k(+h) - mu_k(-h)) / (2h) !! !! This is used for IR intensity calculations, where we need the dipole !! moment derivatives with respect to Cartesian nuclear coordinates. !! !! Args: !!   n_atoms: Number of atoms !!   forward_dipoles: Dipoles at forward-displaced geometries (3*n_atoms, 3) !!   backward_dipoles: Dipoles at backward-displaced geometries (3*n_atoms, 3) !!   displacement: Step size in Bohr !!   dipole_derivatives: Output derivatives (3, 3*n_atoms) in a.u. integer , intent ( in ) :: n_atoms real ( dp ), intent ( in ) :: forward_dipoles (:, :) !! (3*n_atoms, 3) real ( dp ), intent ( in ) :: backward_dipoles (:, :) !! (3*n_atoms, 3) real ( dp ), intent ( in ) :: displacement real ( dp ), intent ( out ), allocatable :: dipole_derivatives (:, :) !! (3, 3*n_atoms) integer :: n_coords , j , k n_coords = 3 * n_atoms allocate ( dipole_derivatives ( 3 , n_coords )) ! Central difference: d_mu_k/d_x_j = (mu_k(x_j+h) - mu_k(x_j-h)) / (2h) do j = 1 , n_coords ! Cartesian coordinate index (which coordinate was displaced) do k = 1 , 3 ! Dipole component (x, y, z) dipole_derivatives ( k , j ) = ( forward_dipoles ( j , k ) - backward_dipoles ( j , k )) / & ( 2.0_dp * displacement ) end do end do end subroutine finite_diff_dipole_derivatives","tags":"","url":"proc/finite_diff_dipole_derivatives.html"},{"title":"finite_diff_hessian_from_gradients – metalquicha","text":"public  subroutine finite_diff_hessian_from_gradients(reference_geom, forward_gradients, backward_gradients, displacement, hessian) Compute Hessian matrix from finite differences of gradients Uses central finite differences: H_ij = (grad_i(+h) - grad_i(-h)) / (2h) Args:\n  reference_geom: Reference geometry (for dimensioning)\n  forward_gradients: Gradients at forward-displaced geometries (3 n_atoms, 3, n_atoms)\n  backward_gradients: Gradients at backward-displaced geometries (3 n_atoms, 3, n_atoms)\n  displacement: Step size used in Bohr\n  hessian: Output Hessian matrix (3 n_atoms, 3 n_atoms) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: forward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: backward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: displacement real(kind=dp), intent(out), allocatable :: hessian (:,:) (3 n_atoms, 3 n_atoms) Called by proc~~finite_diff_hessian_from_gradients~~CalledByGraph proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: disp_idx integer, private :: i_global integer, private :: iatom integer, private :: icoord integer, private :: j_global integer, private :: jatom integer, private :: jcoord integer, private :: n_atoms integer, private :: n_coords Source Code subroutine finite_diff_hessian_from_gradients ( reference_geom , forward_gradients , backward_gradients , & displacement , hessian ) !! Compute Hessian matrix from finite differences of gradients !! !! Uses central finite differences: H_ij = (grad_i(+h) - grad_i(-h)) / (2h) !! !! Args: !!   reference_geom: Reference geometry (for dimensioning) !!   forward_gradients: Gradients at forward-displaced geometries (3*n_atoms, 3, n_atoms) !!   backward_gradients: Gradients at backward-displaced geometries (3*n_atoms, 3, n_atoms) !!   displacement: Step size used in Bohr !!   hessian: Output Hessian matrix (3*n_atoms, 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: forward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: backward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: displacement real ( dp ), intent ( out ), allocatable :: hessian (:, :) !! (3*n_atoms, 3*n_atoms) integer :: n_atoms , n_coords integer :: iatom , jatom , icoord , jcoord integer :: i_global , j_global integer :: disp_idx n_atoms = reference_geom % n_atoms n_coords = 3 * n_atoms allocate ( hessian ( n_coords , n_coords )) hessian = 0.0_dp ! Build Hessian using central differences ! H[i,j] = d²E/(dx_i dx_j) = (dE/dx_j at x_i+h - dE/dx_j at x_i-h) / (2h) disp_idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 disp_idx = disp_idx + 1 i_global = 3 * ( iatom - 1 ) + icoord ! For each displacement, compute derivatives of all gradient components do jatom = 1 , n_atoms do jcoord = 1 , 3 j_global = 3 * ( jatom - 1 ) + jcoord ! Central difference: (grad_j(+h) - grad_j(-h)) / (2h) hessian ( i_global , j_global ) = & ( forward_gradients ( disp_idx , jcoord , jatom ) - & backward_gradients ( disp_idx , jcoord , jatom )) / ( 2.0_dp * displacement ) end do end do end do end do ! Symmetrize the Hessian: H = (H + H&#94;T) / 2 ! This reduces numerical noise from finite differences do i_global = 1 , n_coords do j_global = i_global + 1 , n_coords hessian ( i_global , j_global ) = 0.5_dp * ( hessian ( i_global , j_global ) + hessian ( j_global , i_global )) hessian ( j_global , i_global ) = hessian ( i_global , j_global ) end do end do end subroutine finite_diff_hessian_from_gradients","tags":"","url":"proc/finite_diff_hessian_from_gradients.html"},{"title":"generate_perturbed_geometries – metalquicha","text":"public  subroutine generate_perturbed_geometries(reference_geom, displacement, forward_geoms, backward_geoms) Generate all forward and backward displaced geometries for finite difference calculations For a system with N atoms, this generates:\n  - 3N forward-displaced geometries (+x, +y, +z for each atom)\n  - 3N backward-displaced geometries (-x, -y, -z for each atom) These can be used to compute:\n  - Gradient: from energies at ±displacement\n  - Hessian: from gradients at ±displacement Args:\n  reference_geom: The reference geometry to perturb\n  displacement: Step size in Bohr (typical: 0.001 Bohr)\n  forward_geoms: Output array of forward-displaced geometries (size: 3 n_atoms)\n  backward_geoms: Output array of backward-displaced geometries (size: 3 n_atoms) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: displacement type( displaced_geometry_t ), intent(out), allocatable :: forward_geoms (:) type( displaced_geometry_t ), intent(out), allocatable :: backward_geoms (:) Calls proc~~generate_perturbed_geometries~~CallsGraph proc~generate_perturbed_geometries generate_perturbed_geometries proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_perturbed_geometries~~CalledByGraph proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~generate_perturbed_geometries Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: iatom integer, private :: icoord integer, private :: idx integer, private :: n_atoms integer, private :: n_displacements Source Code subroutine generate_perturbed_geometries ( reference_geom , displacement , forward_geoms , backward_geoms ) !! Generate all forward and backward displaced geometries for finite difference calculations !! !! For a system with N atoms, this generates: !!   - 3N forward-displaced geometries (+x, +y, +z for each atom) !!   - 3N backward-displaced geometries (-x, -y, -z for each atom) !! !! These can be used to compute: !!   - Gradient: from energies at ±displacement !!   - Hessian: from gradients at ±displacement !! !! Args: !!   reference_geom: The reference geometry to perturb !!   displacement: Step size in Bohr (typical: 0.001 Bohr) !!   forward_geoms: Output array of forward-displaced geometries (size: 3*n_atoms) !!   backward_geoms: Output array of backward-displaced geometries (size: 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: displacement type ( displaced_geometry_t ), intent ( out ), allocatable :: forward_geoms (:) type ( displaced_geometry_t ), intent ( out ), allocatable :: backward_geoms (:) integer :: n_atoms , n_displacements integer :: iatom , icoord , idx integer :: i n_atoms = reference_geom % n_atoms n_displacements = 3 * n_atoms ! x, y, z for each atom allocate ( forward_geoms ( n_displacements )) allocate ( backward_geoms ( n_displacements )) ! Generate all displaced geometries idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 ! x, y, z idx = idx + 1 ! Forward displacement (+h) forward_geoms ( idx )% atom_index = iatom forward_geoms ( idx )% coordinate = icoord forward_geoms ( idx )% direction = + 1 forward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , + displacement , & forward_geoms ( idx )% geometry ) ! Backward displacement (-h) backward_geoms ( idx )% atom_index = iatom backward_geoms ( idx )% coordinate = icoord backward_geoms ( idx )% direction = - 1 backward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , - displacement , & backward_geoms ( idx )% geometry ) end do end do end subroutine generate_perturbed_geometries","tags":"","url":"proc/generate_perturbed_geometries.html"},{"title":"displaced_geometry_destroy – metalquicha","text":"private  subroutine displaced_geometry_destroy(this) Clean up memory for displaced geometry Type Bound displaced_geometry_t Arguments Type Intent Optional Attributes Name class( displaced_geometry_t ), intent(inout) :: this Calls proc~~displaced_geometry_destroy~~CallsGraph proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine displaced_geometry_destroy ( this ) !! Clean up memory for displaced geometry class ( displaced_geometry_t ), intent ( inout ) :: this call this % geometry % destroy () end subroutine displaced_geometry_destroy","tags":"","url":"proc/displaced_geometry_destroy.html"},{"title":"error_get_code – metalquicha","text":"private pure function error_get_code(this) result(code) Get the error code Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value integer Source Code pure function error_get_code ( this ) result ( code ) !! Get the error code class ( error_t ), intent ( in ) :: this integer :: code code = this % code end function error_get_code","tags":"","url":"proc/error_get_code.html"},{"title":"error_get_full_trace – metalquicha","text":"private  function error_get_full_trace(this) result(trace) Get complete error message with stack trace\nReturns a multi-line string with error and call stack Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable Calls proc~~error_get_full_trace~~CallsGraph proc~error_get_full_trace error_t%error_get_full_trace proc~error_has_error error_t%error_has_error proc~error_get_full_trace->proc~error_has_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~error_get_full_trace~~CalledByGraph proc~error_get_full_trace error_t%error_get_full_trace proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~error_get_full_trace proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~node_worker node_worker proc~node_worker->proc~error_get_full_trace proc~process_intersection_derivatives->proc~error_get_full_trace proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~error_get_full_trace proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~error_get_full_trace proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~error_get_full_trace interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator program~main main program~main->proc~run_multi_molecule_calculations program~main->proc~run_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=2048), private :: buffer integer, private :: i integer, private :: pos Source Code function error_get_full_trace ( this ) result ( trace ) !! Get complete error message with stack trace !! Returns a multi-line string with error and call stack class ( error_t ), intent ( in ) :: this character ( len = :), allocatable :: trace character ( len = 2048 ) :: buffer integer :: i , pos if (. not . this % has_error ()) then trace = \"\" return end if ! Build error message write ( buffer , '(A,I0,A)' ) \"Error \" , this % code , \": \" pos = len_trim ( buffer ) + 1 if ( allocated ( this % message )) then buffer ( pos :) = this % message pos = len_trim ( buffer ) + 1 end if ! Add stack trace if available if ( this % stack_depth > 0 ) then buffer ( pos :) = new_line ( 'a' ) // \"Call stack (most recent first):\" pos = len_trim ( buffer ) + 1 do i = this % stack_depth , 1 , - 1 write ( buffer ( pos :), '(A,I0,A)' ) new_line ( 'a' ) // \"  [\" , i , \"] \" pos = len_trim ( buffer ) + 1 buffer ( pos :) = trim ( this % call_stack ( i )) pos = len_trim ( buffer ) + 1 end do end if trace = trim ( buffer ) end function error_get_full_trace","tags":"","url":"proc/error_get_full_trace.html"},{"title":"error_get_message – metalquicha","text":"private pure function error_get_message(this) result(message) Get the error message (without stack trace) Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable Called by proc~~error_get_message~~CalledByGraph proc~error_get_message error_t%error_get_message proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~error_get_message proc~global_coordinator global_coordinator proc~global_coordinator->proc~error_get_message proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~error_get_message proc~hessian_worker hessian_worker proc~hessian_worker->proc~error_get_message proc~node_coordinator node_coordinator proc~node_coordinator->proc~error_get_message proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~error_get_message proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_coordinator node_coordinator proc~run_fragmented_calculation->interface~node_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~error_get_message proc~serial_gmbe_pie_processor->proc~error_get_message proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~error_get_message program~main main program~main->proc~error_get_message proc~run_calculation run_calculation program~main->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations program~main->proc~run_multi_molecule_calculations interface~global_coordinator->proc~global_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~node_coordinator->proc~node_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_multi_molecule_calculations->proc~run_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function error_get_message ( this ) result ( message ) !! Get the error message (without stack trace) class ( error_t ), intent ( in ) :: this character ( len = :), allocatable :: message if ( allocated ( this % message )) then message = this % message else message = \"\" end if end function error_get_message","tags":"","url":"proc/error_get_message.html"},{"title":"error_has_error – metalquicha","text":"private pure function error_has_error(this) result(has_err) Check if an error is set Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value logical Called by proc~~error_has_error~~CalledByGraph proc~error_has_error error_t%error_has_error proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~error_has_error proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~error_has_error proc~build_mbe_lookup_table build_mbe_lookup_table proc~build_mbe_lookup_table->proc~error_has_error proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~error_has_error proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~error_has_error proc~compute_gmbe->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~compute_gmbe->proc~error_get_full_trace proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~error_has_error proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~error_has_error proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~error_get_full_trace->proc~error_has_error proc~error_print_trace error_t%error_print_trace proc~error_print_trace->proc~error_has_error proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~error_has_error proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~error_has_error proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~error_has_error proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~error_has_error proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~node_worker node_worker proc~node_worker->proc~error_has_error proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~error_get_full_trace proc~parse_element_basis->proc~error_has_error proc~parse_fragment parse_fragment proc~parse_fragment->proc~error_has_error proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~error_has_error proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~parse_fragment proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~error_has_error proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_single_molecule->proc~error_has_error proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~process_intersection_derivatives->proc~error_has_error proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~process_intersection_derivatives->proc~error_get_full_trace proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~error_has_error proc~read_mqc_file->proc~parse_fragmentation_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~read_xyz_file->proc~error_has_error proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~error_has_error proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~error_has_error proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~run_multi_molecule_calculations->proc~error_get_full_trace proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~error_get_full_trace proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~error_has_error proc~unfragmented_calculation->proc~error_get_full_trace program~main main program~main->proc~error_has_error program~main->proc~config_to_system_geometry program~main->proc~read_mqc_file program~main->proc~run_multi_molecule_calculations program~main->proc~run_calculation interface~node_worker->proc~node_worker interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~global_coordinator->proc~global_coordinator Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function error_has_error ( this ) result ( has_err ) !! Check if an error is set class ( error_t ), intent ( in ) :: this logical :: has_err has_err = ( this % code /= SUCCESS ) end function error_has_error","tags":"","url":"proc/error_has_error.html"},{"title":"error_add_context – metalquicha","text":"private pure subroutine error_add_context(this, location) Add a call location to the stack trace\nTypically called when propagating errors upward Example:\n  call some_routine(…, error)\n  if (error%has_error()) then\n     call error%add_context(“mqc_mbe:compute_energy”)\n     return\n  end if Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this character(len=*), intent(in) :: location Called by proc~~error_add_context~~CalledByGraph proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~error_add_context proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~error_add_context proc~build_mbe_lookup_table build_mbe_lookup_table proc~build_mbe_lookup_table->proc~error_add_context proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~error_add_context proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~error_add_context proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~error_add_context proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~error_add_context proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~error_add_context proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~parse_element_basis->proc~error_add_context proc~parse_fragment parse_fragment proc~parse_fragment->proc~error_add_context proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~error_add_context proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~error_add_context proc~parse_fragments_generic->proc~parse_fragment proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~error_add_context proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_single_molecule->proc~error_add_context proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~error_add_context proc~read_mqc_file->proc~parse_fragmentation_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~read_xyz_file->proc~error_add_context proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~error_add_context proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~compute_mbe compute_mbe proc~compute_mbe->proc~build_mbe_lookup_table proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~node_worker->interface~do_fragment_work proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->interface~do_fragment_work program~main main program~main->proc~config_to_system_geometry program~main->proc~read_mqc_file program~main->proc~run_multi_molecule_calculations program~main->proc~run_calculation interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~global_coordinator->proc~global_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine error_add_context ( this , location ) !! Add a call location to the stack trace !! Typically called when propagating errors upward !! !! Example: !!   call some_routine(..., error) !!   if (error%has_error()) then !!      call error%add_context(\"mqc_mbe:compute_energy\") !!      return !!   end if class ( error_t ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: location if ( this % stack_depth < MAX_STACK_DEPTH ) then this % stack_depth = this % stack_depth + 1 this % call_stack ( this % stack_depth ) = location end if ! If stack is full, silently ignore (could print warning in non-pure version) end subroutine error_add_context","tags":"","url":"proc/error_add_context.html"},{"title":"error_clear – metalquicha","text":"private pure subroutine error_clear(this) Clear the error state and stack trace Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this Called by proc~~error_clear~~CalledByGraph proc~error_clear error_t%error_clear proc~result_reset calculation_result_t%result_reset proc~result_reset->proc~error_clear proc~result_destroy calculation_result_t%result_destroy proc~result_destroy->proc~result_reset proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~result_destroy proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~result_destroy proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~result_destroy interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine error_clear ( this ) !! Clear the error state and stack trace class ( error_t ), intent ( inout ) :: this this % code = SUCCESS this % stack_depth = 0 if ( allocated ( this % message )) deallocate ( this % message ) end subroutine error_clear","tags":"","url":"proc/error_clear.html"},{"title":"error_print_trace – metalquicha","text":"private  subroutine error_print_trace(this, unit) Print error with stack trace to specified unit\nIf unit not specified, prints to stdout (unit 6) Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this integer, intent(in), optional :: unit Calls proc~~error_print_trace~~CallsGraph proc~error_print_trace error_t%error_print_trace proc~error_has_error error_t%error_has_error proc~error_print_trace->proc~error_has_error Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: out_unit Source Code subroutine error_print_trace ( this , unit ) !! Print error with stack trace to specified unit !! If unit not specified, prints to stdout (unit 6) class ( error_t ), intent ( in ) :: this integer , intent ( in ), optional :: unit integer :: out_unit , i out_unit = 6 ! stdout if ( present ( unit )) out_unit = unit if (. not . this % has_error ()) return ! Print error message write ( out_unit , '(A,I0,A)' , advance = 'no' ) \"Error \" , this % code , \": \" if ( allocated ( this % message )) then write ( out_unit , '(A)' ) trim ( this % message ) else write ( out_unit , '(A)' ) \"(no message)\" end if ! Print stack trace if available if ( this % stack_depth > 0 ) then write ( out_unit , '(A)' ) \"Call stack (most recent first):\" do i = this % stack_depth , 1 , - 1 write ( out_unit , '(A,I0,A)' , advance = 'no' ) \"  [\" , i , \"] \" write ( out_unit , '(A)' ) trim ( this % call_stack ( i )) end do end if end subroutine error_print_trace","tags":"","url":"proc/error_print_trace.html"},{"title":"error_set – metalquicha","text":"private pure subroutine error_set(this, code, message) Set an error with code and message\nResets the stack trace Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this integer, intent(in) :: code character(len=*), intent(in) :: message Called by proc~~error_set~~CalledByGraph proc~error_set error_t%error_set proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~error_set proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~check_duplicate_atoms check_duplicate_atoms proc~check_duplicate_atoms->proc~error_set proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->proc~error_set proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~error_set proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~error_set proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~error_set proc~extract_element extract_element proc~extract_element->proc~error_set proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~error_set proc~find_basis_file find_basis_file proc~find_basis_file->proc~error_set proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~fragment_lookup_insert->proc~error_set proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~error_set proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~grow_pie_storage grow_pie_storage proc~grow_pie_storage->proc~error_set proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~error_set proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~molecule_to_system_geometry->proc~error_set proc~initialize_fragmented_system initialize_fragmented_system proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~open_basis_file open_basis_file proc~open_basis_file->proc~error_set proc~parse_aimd_section parse_aimd_section proc~parse_aimd_section->proc~error_set proc~parse_command_line parse_command_line proc~parse_command_line->proc~error_set proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~parse_driver_section parse_driver_section proc~parse_driver_section->proc~error_set proc~parse_element_basis->proc~error_set proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~parse_fragment parse_fragment proc~parse_fragment->proc~error_set proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~error_set proc~validate_cutoffs validate_cutoffs proc~parse_fragmentation_section->proc~validate_cutoffs proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_generic->proc~skip_to_end proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_generic->proc~error_set proc~parse_hessian_section parse_hessian_section proc~parse_hessian_section->proc~error_set proc~parse_indices_line->proc~error_set proc~parse_model_section parse_model_section proc~parse_model_section->proc~error_set proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~error_set proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~skip_to_end proc~parse_scf_section parse_scf_section proc~parse_scf_section->proc~error_set proc~parse_schema_section parse_schema_section proc~parse_schema_section->proc~error_set proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic parse_structure_generic proc~parse_structure_generic->proc~error_set proc~parse_system_section parse_system_section proc~parse_system_section->proc~error_set proc~parse_xtb_section parse_xtb_section proc~parse_xtb_section->proc~error_set proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~error_set proc~read_mqc_file->proc~parse_aimd_section proc~read_mqc_file->proc~parse_driver_section proc~read_mqc_file->proc~parse_fragmentation_section proc~read_mqc_file->proc~parse_hessian_section proc~read_mqc_file->proc~parse_model_section proc~read_mqc_file->proc~parse_molecules_section proc~read_mqc_file->proc~parse_scf_section proc~read_mqc_file->proc~parse_schema_section proc~read_mqc_file->proc~parse_system_section proc~read_mqc_file->proc~parse_xtb_section proc~read_mqc_file->proc~skip_to_end proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_geometry_section parse_geometry_section proc~read_mqc_file->proc~parse_geometry_section proc~parse_structure_section parse_structure_section proc~read_mqc_file->proc~parse_structure_section proc~read_xyz_file->proc~error_set proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~read_xyz_string->proc~error_set proc~skip_to_end->proc~error_set proc~validate_cutoffs->proc~error_set proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~xtb_calc_energy->proc~error_set proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~xtb_calc_gradient->proc~error_set proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~error_set proc~xtb_calc_hessian->proc~xtb_calc_gradient interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_mbe_lookup_table build_mbe_lookup_table proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~dfs_pie_accumulate->proc~grow_pie_storage proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~initialize_fragmented_system->proc~check_fragment_overlap proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->interface~do_fragment_work program~main main program~main->proc~config_to_system_geometry program~main->proc~read_mqc_file program~main->proc~run_multi_molecule_calculations program~main->proc~run_calculation interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~compute_mbe compute_mbe proc~compute_mbe->proc~build_mbe_lookup_table proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker->proc~node_worker interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine error_set ( this , code , message ) !! Set an error with code and message !! Resets the stack trace class ( error_t ), intent ( inout ) :: this integer , intent ( in ) :: code character ( len =* ), intent ( in ) :: message this % code = code this % message = trim ( message ) this % stack_depth = 0 ! Reset stack when setting new error end subroutine error_set","tags":"","url":"proc/error_set.html"},{"title":"gmbe_pie_coordinator – metalquicha","text":"public  subroutine gmbe_pie_coordinator(resources, pie_atom_sets, pie_coefficients, n_pie_terms, node_leader_ranks, num_nodes, sys_geom, method_config, calc_type, bonds, json_data) Uses mqc_resources mqc_error pic_logger mqc_physical_fragment mqc_calc_types proc~~gmbe_pie_coordinator~~UsesGraph proc~gmbe_pie_coordinator gmbe_pie_coordinator module~mqc_calc_types mqc_calc_types proc~gmbe_pie_coordinator->module~mqc_calc_types module~mqc_error mqc_error proc~gmbe_pie_coordinator->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment proc~gmbe_pie_coordinator->module~mqc_physical_fragment module~mqc_resources mqc_resources proc~gmbe_pie_coordinator->module~mqc_resources pic_logger pic_logger proc~gmbe_pie_coordinator->pic_logger pic_types pic_types module~mqc_calc_types->pic_types module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types pic_mpi_lib pic_mpi_lib module~mqc_mpi_comms->pic_mpi_lib module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. MPI coordinator for PIE-based GMBE calculations\nDistributes PIE terms across MPI ranks and accumulates results\nIf json_data is present, populates it for centralized JSON output Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(in) :: n_pie_terms integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data Calls proc~~gmbe_pie_coordinator~~CallsGraph proc~gmbe_pie_coordinator gmbe_pie_coordinator abort_comm abort_comm proc~gmbe_pie_coordinator->abort_comm cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration error error proc~gmbe_pie_coordinator->error fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies get_elapsed_time get_elapsed_time proc~gmbe_pie_coordinator->get_elapsed_time info info proc~gmbe_pie_coordinator->info iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_thermochemistry compute_thermochemistry proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~error_get_message error_t%error_get_message proc~gmbe_pie_coordinator->proc~error_get_message proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~gmbe_pie_coordinator->proc~redistribute_cap_dipole_derivatives proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses start start proc~gmbe_pie_coordinator->start to_char to_char proc~gmbe_pie_coordinator->to_char verbose verbose proc~gmbe_pie_coordinator->verbose proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_atom_list->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry warning warning proc~print_vibrational_analysis->warning proc~result_irecv->irecv recv recv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->warning pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_zpe->to_char proc~compute_zpe->warning proc~print_thermochemistry->info proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gmbe_pie_coordinator~~CalledByGraph proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(timer_type), private :: coord_timer integer(kind=int64), private :: current_term_idx integer, private :: dummy_msg integer, private :: finished_nodes logical, private :: handling_local_workers logical, private :: has_pending integer, private :: hess_dim real(kind=dp), private, allocatable :: ir_intensities (:) IR intensities in km/mol integer, private :: local_dummy integer, private :: local_finished_workers type(MPI_Status), private :: local_status type(request_t), private :: req integer, private :: request_source type( calculation_result_t ), private, allocatable :: results (:) integer(kind=int64), private :: results_received type(MPI_Status), private :: status integer(kind=int64), private :: term_idx real(kind=dp), private, allocatable :: total_dipole_derivs (:,:) Total dipole derivatives (3, 3*total_atoms) real(kind=dp), private :: total_energy real(kind=dp), private, allocatable :: total_gradient (:,:) real(kind=dp), private, allocatable :: total_hessian (:,:) integer, private :: worker_source integer(kind=int64), private :: worker_term_map (resources%mpi_comms%node_comm%size()) Source Code subroutine gmbe_pie_coordinator ( resources , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method_config , calc_type , bonds , json_data ) !! MPI coordinator for PIE-based GMBE calculations !! Distributes PIE terms across MPI ranks and accumulates results !! If json_data is present, populates it for centralized JSON output use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian , & redistribute_cap_dipole_derivatives use mqc_resources , only : resources_t type ( resources_t ), intent ( in ) :: resources integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( in ) :: n_pie_terms integer , intent ( in ) :: node_leader_ranks (:), num_nodes type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data type ( timer_type ) :: coord_timer integer ( int64 ) :: current_term_idx , results_received , term_idx integer :: finished_nodes integer :: request_source , dummy_msg type ( MPI_Status ) :: status , local_status logical :: handling_local_workers , has_pending integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer ( int64 ) :: worker_term_map ( resources % mpi_comms % node_comm % size ()) integer :: worker_source real ( dp ) :: total_energy real ( dp ), allocatable :: total_gradient (:, :) real ( dp ), allocatable :: total_hessian (:, :) real ( dp ), allocatable :: total_dipole_derivs (:, :) !! Total dipole derivatives (3, 3*total_atoms) real ( dp ), allocatable :: ir_intensities (:) !! IR intensities in km/mol integer :: hess_dim ! MPI request handles type ( request_t ) :: req if ( int ( size ( pie_atom_sets , 2 ), int64 ) < n_pie_terms . or . & int ( size ( pie_coefficients ), int64 ) < n_pie_terms ) then call logger % error ( \"PIE term arrays are smaller than n_pie_terms\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if current_term_idx = n_pie_terms finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( resources % mpi_comms % node_comm % size () > 1 ) results_received = 0_int64 worker_term_map = 0 allocate ( results ( n_pie_terms )) call logger % verbose ( \"GMBE PIE coordinator starting with \" // to_char ( n_pie_terms ) // & \" PIE terms for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers if ( handling_local_workers ) then do call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE if ( worker_term_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no term was assigned!\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if call result_irecv ( results ( worker_term_map ( worker_source )), resources % mpi_comms % node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Check for calculation errors from worker if ( results ( worker_term_map ( worker_source ))% has_error ) then call logger % error ( \"PIE term \" // to_char ( worker_term_map ( worker_source )) // & \" calculation failed: \" // & results ( worker_term_map ( worker_source ))% error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if worker_term_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , n_pie_terms / 10_int64 )) == 0 . or . & results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( resources % mpi_comms % world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit call irecv ( resources % mpi_comms % world_comm , term_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( term_idx ), resources % mpi_comms % world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) ! Check for calculation errors from node coordinator if ( results ( term_idx )% has_error ) then call logger % error ( \"PIE term \" // to_char ( term_idx ) // \" calculation failed: \" // & results ( term_idx )% error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , n_pie_terms / 10_int64 )) == 0 . or . & results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( resources % mpi_comms % world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( resources % mpi_comms % world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_term_idx >= 1 ) then call send_pie_term_to_node ( resources % mpi_comms % world_comm , current_term_idx , pie_atom_sets , request_source ) current_term_idx = current_term_idx - 1 else call isend ( resources % mpi_comms % world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < resources % mpi_comms % node_comm % size () - 1 ) then call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then if ( worker_term_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( resources % mpi_comms % node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_term_idx >= 1 ) then call send_pie_term_to_worker ( resources % mpi_comms % node_comm , & current_term_idx , pie_atom_sets , local_status % MPI_SOURCE ) worker_term_map ( local_status % MPI_SOURCE ) = current_term_idx current_term_idx = current_term_idx - 1 else call isend ( resources % mpi_comms % node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= resources % mpi_comms % node_comm % size () - 1 & . and . results_received >= n_pie_terms ) then handling_local_workers = . false . finished_nodes = finished_nodes + 1 end if end do call logger % verbose ( \"GMBE PIE coordinator finished all terms\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all PIE terms \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Accumulate results with PIE coefficients call logger % info ( \" \" ) call logger % info ( \"Computing GMBE PIE energy...\" ) call coord_timer % start () total_energy = 0.0_dp do term_idx = 1_int64 , n_pie_terms total_energy = total_energy + real ( pie_coefficients ( term_idx ), dp ) * results ( term_idx )% energy % total () end do ! Handle gradients if computed if ( calc_type == CALC_TYPE_GRADIENT ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp do term_idx = 1_int64 , n_pie_terms if ( results ( term_idx )% has_gradient ) then ! Map fragment gradient to system coordinates block use mqc_error , only : error_t real ( dp ), allocatable :: term_gradient (:, :) type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) call phys_frag % destroy () deallocate ( atom_list ) end if ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system block use pic_logger , only : info_level integer :: iatom , current_log_level call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end block deallocate ( total_gradient ) end if ! Handle Hessians if computed if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp ! Also allocate gradient for Hessian calculations if (. not . allocated ( total_gradient )) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if ! Allocate dipole derivative arrays for IR intensities allocate ( total_dipole_derivs ( 3 , hess_dim )) total_dipole_derivs = 0.0_dp do term_idx = 1_int64 , n_pie_terms if ( results ( term_idx )% has_hessian . or . results ( term_idx )% has_gradient ) then block use mqc_error , only : error_t real ( dp ), allocatable :: term_gradient (:, :), term_hessian (:, :), term_dipole_derivs (:, :) type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) ! Redistribute gradient if present if ( results ( term_idx )% has_gradient ) then allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end if ! Redistribute Hessian if present if ( results ( term_idx )% has_hessian ) then allocate ( term_hessian ( hess_dim , hess_dim )) term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( term_idx )% hessian , term_hessian ) total_hessian = total_hessian + real ( pie_coefficients ( term_idx ), dp ) * term_hessian deallocate ( term_hessian ) ! Accumulate dipole derivatives if present (for IR intensities) if ( results ( term_idx )% has_dipole_derivatives ) then allocate ( term_dipole_derivs ( 3 , hess_dim )) term_dipole_derivs = 0.0_dp call redistribute_cap_dipole_derivatives ( phys_frag , & results ( term_idx )% dipole_derivatives , & term_dipole_derivs ) total_dipole_derivs = total_dipole_derivs + & real ( pie_coefficients ( term_idx ), dp ) * term_dipole_derivs deallocate ( term_dipole_derivs ) end if end if call phys_frag % destroy () deallocate ( atom_list ) end if end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print Hessian information call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis with thermochemistry block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) type ( thermochemistry_result_t ) :: thermo_result type ( mbe_result_t ) :: gmbe_result integer :: n_at , n_modes call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne , & dipole_derivatives = total_dipole_derivs , & ir_intensities = ir_intensities ) if ( allocated ( frequencies )) then ! Compute thermochemistry n_at = size ( sys_geom % element_numbers ) n_modes = size ( frequencies ) call compute_thermochemistry ( sys_geom % coordinates , sys_geom % element_numbers , & frequencies , n_at , n_modes , thermo_result ) ! Print vibrational analysis to log call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & ir_intensities = ir_intensities , & coordinates = sys_geom % coordinates , & electronic_energy = total_energy ) ! Build temporary mbe_result for JSON output gmbe_result % total_energy = total_energy gmbe_result % has_energy = . true . gmbe_result % has_hessian = . true . if ( allocated ( total_gradient )) then gmbe_result % has_gradient = . true . allocate ( gmbe_result % gradient , source = total_gradient ) end if allocate ( gmbe_result % hessian , source = total_hessian ) ! Populate json_data for vibrational output if present if ( present ( json_data )) then json_data % output_mode = OUTPUT_MODE_GMBE_PIE json_data % total_energy = total_energy json_data % has_energy = . true . json_data % has_vibrational = . true . allocate ( json_data % frequencies ( n_modes )) allocate ( json_data % reduced_masses ( n_modes )) allocate ( json_data % force_constants ( n_modes )) json_data % frequencies = frequencies json_data % reduced_masses = reduced_masses json_data % force_constants = fc_mdyne json_data % thermo = thermo_result if ( allocated ( ir_intensities )) then allocate ( json_data % ir_intensities ( n_modes )) json_data % ir_intensities = ir_intensities json_data % has_ir_intensities = . true . end if if ( allocated ( total_gradient )) then allocate ( json_data % gradient , source = total_gradient ) json_data % has_gradient = . true . end if allocate ( json_data % hessian , source = total_hessian ) json_data % has_hessian = . true . end if if ( allocated ( ir_intensities )) deallocate ( ir_intensities ) call gmbe_result % destroy () deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block if ( allocated ( total_dipole_derivs )) deallocate ( total_dipole_derivs ) end if call coord_timer % stop () call logger % info ( \"Time to compute GMBE PIE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) call logger % info ( \" \" ) ! Populate json_data for non-Hessian case if present if ( present ( json_data ) . and . calc_type /= CALC_TYPE_HESSIAN ) then block real ( dp ), allocatable :: pie_energies (:) allocate ( pie_energies ( n_pie_terms )) do term_idx = 1_int64 , n_pie_terms pie_energies ( term_idx ) = results ( term_idx )% energy % total () end do json_data % output_mode = OUTPUT_MODE_GMBE_PIE json_data % total_energy = total_energy json_data % has_energy = . true . json_data % n_pie_terms = n_pie_terms allocate ( json_data % pie_atom_sets , source = pie_atom_sets (:, 1 : n_pie_terms )) allocate ( json_data % pie_coefficients ( n_pie_terms )) json_data % pie_coefficients = pie_coefficients ( 1 : n_pie_terms ) allocate ( json_data % pie_energies ( n_pie_terms )) json_data % pie_energies = pie_energies if ( allocated ( total_gradient )) then allocate ( json_data % gradient , source = total_gradient ) json_data % has_gradient = . true . end if if ( allocated ( total_hessian )) then allocate ( json_data % hessian , source = total_hessian ) json_data % has_hessian = . true . end if deallocate ( pie_energies ) end block end if deallocate ( results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) end subroutine gmbe_pie_coordinator","tags":"","url":"proc/gmbe_pie_coordinator.html"},{"title":"serial_gmbe_pie_processor – metalquicha","text":"public  subroutine serial_gmbe_pie_processor(pie_atom_sets, pie_coefficients, n_pie_terms, sys_geom, method_config, calc_type, bonds, json_data) Uses pic_logger mqc_error mqc_physical_fragment mqc_calc_types proc~~serial_gmbe_pie_processor~~UsesGraph proc~serial_gmbe_pie_processor serial_gmbe_pie_processor module~mqc_calc_types mqc_calc_types proc~serial_gmbe_pie_processor->module~mqc_calc_types module~mqc_error mqc_error proc~serial_gmbe_pie_processor->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment proc~serial_gmbe_pie_processor->module~mqc_physical_fragment pic_logger pic_logger proc~serial_gmbe_pie_processor->pic_logger pic_types pic_types module~mqc_calc_types->pic_types module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Serial GMBE processor using PIE coefficients\nEvaluates each unique atom set once and sums with PIE coefficients\nSupports energy-only, energy+gradient, and energy+gradient+Hessian calculations\nIf json_data is present, populates it for centralized JSON output Arguments Type Intent Optional Attributes Name integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(in) :: n_pie_terms type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data Calls proc~~serial_gmbe_pie_processor~~CallsGraph proc~serial_gmbe_pie_processor serial_gmbe_pie_processor cart_disp cart_disp proc~serial_gmbe_pie_processor->cart_disp configuration configuration proc~serial_gmbe_pie_processor->configuration error error proc~serial_gmbe_pie_processor->error fc_mdyne fc_mdyne proc~serial_gmbe_pie_processor->fc_mdyne force_constants force_constants proc~serial_gmbe_pie_processor->force_constants frequencies frequencies proc~serial_gmbe_pie_processor->frequencies info info proc~serial_gmbe_pie_processor->info interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~calc_type_to_string calc_type_to_string proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~compute_thermochemistry compute_thermochemistry proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~serial_gmbe_pie_processor->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~error_get_message error_t%error_get_message proc~serial_gmbe_pie_processor->proc~error_get_message proc~error_has_error error_t%error_has_error proc~serial_gmbe_pie_processor->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~print_vibrational_analysis print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~serial_gmbe_pie_processor->proc~redistribute_cap_dipole_derivatives proc~redistribute_cap_gradients redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian reduced_masses reduced_masses proc~serial_gmbe_pie_processor->reduced_masses to_char to_char proc~serial_gmbe_pie_processor->to_char verbose verbose proc~serial_gmbe_pie_processor->verbose proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry warning warning proc~print_vibrational_analysis->warning proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->warning pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_zpe->to_char proc~compute_zpe->warning proc~do_fragment_work->configuration proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->to_char proc~do_fragment_work->proc~error_add_context calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~do_fragment_work->proc~error_set proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~print_thermochemistry->info proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~mass_weight_hessian->proc~element_mass proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~serial_gmbe_pie_processor~~CalledByGraph proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: atom_list (:) integer, private :: coeff integer, private :: current_log_level type( error_t ), private :: error integer, private :: hess_dim integer, private :: iatom real(kind=dp), private, allocatable :: ir_intensities (:) IR intensities in km/mol integer, private :: max_atoms integer, private :: n_atoms type( physical_fragment_t ), private :: phys_frag real(kind=dp), private, allocatable :: pie_energies (:) Store individual energies for JSON output type( calculation_result_t ), private, allocatable :: results (:) real(kind=dp), private, allocatable :: term_dipole_derivs (:,:) Temporary dipole derivatives for each term real(kind=dp), private :: term_energy real(kind=dp), private, allocatable :: term_gradient (:,:) Temporary gradient for each term real(kind=dp), private, allocatable :: term_hessian (:,:) Temporary Hessian for each term integer(kind=int64), private :: term_idx real(kind=dp), private, allocatable :: total_dipole_derivs (:,:) Total dipole derivatives (3, 3*total_atoms) real(kind=dp), private :: total_energy real(kind=dp), private, allocatable :: total_gradient (:,:) Total gradient (3, total_atoms) real(kind=dp), private, allocatable :: total_hessian (:,:) Total Hessian (3 total_atoms, 3 total_atoms) Source Code subroutine serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , & sys_geom , method_config , calc_type , bonds , json_data ) !! Serial GMBE processor using PIE coefficients !! Evaluates each unique atom set once and sums with PIE coefficients !! Supports energy-only, energy+gradient, and energy+gradient+Hessian calculations !! If json_data is present, populates it for centralized JSON output use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN , CALC_TYPE_ENERGY , calc_type_to_string use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian , & redistribute_cap_dipole_derivatives use mqc_error , only : error_t use pic_logger , only : info_level integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( in ) :: n_pie_terms type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data type ( physical_fragment_t ) :: phys_frag type ( calculation_result_t ), allocatable :: results (:) type ( error_t ) :: error integer :: n_atoms , max_atoms , iatom , current_log_level , hess_dim integer ( int64 ) :: term_idx integer , allocatable :: atom_list (:) real ( dp ) :: total_energy , term_energy real ( dp ), allocatable :: pie_energies (:) !! Store individual energies for JSON output real ( dp ), allocatable :: total_gradient (:, :) !! Total gradient (3, total_atoms) real ( dp ), allocatable :: term_gradient (:, :) !! Temporary gradient for each term real ( dp ), allocatable :: total_hessian (:, :) !! Total Hessian (3*total_atoms, 3*total_atoms) real ( dp ), allocatable :: term_hessian (:, :) !! Temporary Hessian for each term real ( dp ), allocatable :: total_dipole_derivs (:, :) !! Total dipole derivatives (3, 3*total_atoms) real ( dp ), allocatable :: term_dipole_derivs (:, :) !! Temporary dipole derivatives for each term real ( dp ), allocatable :: ir_intensities (:) !! IR intensities in km/mol integer :: coeff if ( int ( size ( pie_atom_sets , 2 ), int64 ) < n_pie_terms . or . & int ( size ( pie_coefficients ), int64 ) < n_pie_terms ) then call logger % error ( \"PIE term arrays are smaller than n_pie_terms\" ) error stop \"Invalid PIE term array sizes\" end if call logger % info ( \"Processing \" // to_char ( n_pie_terms ) // \" unique PIE terms...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) total_energy = 0.0_dp max_atoms = size ( pie_atom_sets , 1 ) allocate ( pie_energies ( n_pie_terms )) allocate ( results ( n_pie_terms )) ! Allocate gradient and Hessian arrays if needed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) allocate ( term_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp ! Allocate dipole derivative arrays for IR intensities allocate ( total_dipole_derivs ( 3 , hess_dim )) allocate ( term_dipole_derivs ( 3 , hess_dim )) total_dipole_derivs = 0.0_dp end if do term_idx = 1_int64 , n_pie_terms coeff = pie_coefficients ( term_idx ) ! Skip terms with zero coefficient (shouldn't happen, but safety check) if ( coeff == 0 ) then pie_energies ( term_idx ) = 0.0_dp ! Mark as skipped cycle end if ! Extract atom list for this term n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms == 0 ) then pie_energies ( term_idx ) = 0.0_dp ! Mark as skipped cycle end if allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment from atom list call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build intersection fragment\" end if ! Compute energy (and gradient if requested) call do_fragment_work ( term_idx , results ( term_idx ), method_config , phys_frag , calc_type ) ! Check for calculation errors if ( results ( term_idx )% has_error ) then call logger % error ( \"PIE term \" // to_char ( term_idx ) // \" calculation failed: \" // & results ( term_idx )% error % get_message ()) error stop \"PIE term calculation failed in serial processing\" end if term_energy = results ( term_idx )% energy % total () ! Store energy for JSON output pie_energies ( term_idx ) = term_energy ! Accumulate with PIE coefficient total_energy = total_energy + real ( coeff , dp ) * term_energy ! Accumulate gradient if present if (( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) . and . & results ( term_idx )% has_gradient ) then ! Map fragment gradient to system coordinates with proper cap handling term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( coeff , dp ) * term_gradient end if ! Accumulate Hessian if present if ( calc_type == CALC_TYPE_HESSIAN . and . results ( term_idx )% has_hessian ) then ! Map fragment Hessian to system coordinates with proper cap handling term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( term_idx )% hessian , term_hessian ) ! Accumulate with PIE coefficient total_hessian = total_hessian + real ( coeff , dp ) * term_hessian ! Accumulate dipole derivatives if present (for IR intensities) if ( results ( term_idx )% has_dipole_derivatives ) then term_dipole_derivs = 0.0_dp call redistribute_cap_dipole_derivatives ( phys_frag , results ( term_idx )% dipole_derivatives , & term_dipole_derivs ) total_dipole_derivs = total_dipole_derivs + real ( coeff , dp ) * term_dipole_derivs end if end if call logger % verbose ( \"PIE term \" // to_char ( term_idx ) // \"/\" // to_char ( n_pie_terms ) // & \": \" // to_char ( n_atoms ) // \" atoms, coeff=\" // to_char ( coeff ) // & \", E=\" // to_char ( term_energy )) deallocate ( atom_list ) call phys_frag % destroy () end do call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) ! Print gradient info if computed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end if ! Print Hessian info if computed if ( calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis with thermochemistry block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) type ( thermochemistry_result_t ) :: thermo_result type ( mbe_result_t ) :: gmbe_result integer :: n_at , n_modes call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne , & dipole_derivatives = total_dipole_derivs , & ir_intensities = ir_intensities ) if ( allocated ( frequencies )) then ! Compute thermochemistry n_at = size ( sys_geom % element_numbers ) n_modes = size ( frequencies ) call compute_thermochemistry ( sys_geom % coordinates , sys_geom % element_numbers , & frequencies , n_at , n_modes , thermo_result ) ! Print vibrational analysis to log call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & ir_intensities = ir_intensities , & coordinates = sys_geom % coordinates , & electronic_energy = total_energy ) ! Build temporary mbe_result for JSON output gmbe_result % total_energy = total_energy gmbe_result % has_energy = . true . gmbe_result % has_hessian = . true . if ( allocated ( total_gradient )) then gmbe_result % has_gradient = . true . allocate ( gmbe_result % gradient , source = total_gradient ) end if allocate ( gmbe_result % hessian , source = total_hessian ) ! Populate json_data for vibrational output if present if ( present ( json_data )) then json_data % output_mode = OUTPUT_MODE_GMBE_PIE json_data % total_energy = total_energy json_data % has_energy = . true . json_data % has_vibrational = . true . allocate ( json_data % frequencies ( n_modes )) allocate ( json_data % reduced_masses ( n_modes )) allocate ( json_data % force_constants ( n_modes )) json_data % frequencies = frequencies json_data % reduced_masses = reduced_masses json_data % force_constants = fc_mdyne json_data % thermo = thermo_result if ( allocated ( ir_intensities )) then allocate ( json_data % ir_intensities ( n_modes )) json_data % ir_intensities = ir_intensities json_data % has_ir_intensities = . true . end if if ( allocated ( total_gradient )) then allocate ( json_data % gradient , source = total_gradient ) json_data % has_gradient = . true . end if allocate ( json_data % hessian , source = total_hessian ) json_data % has_hessian = . true . end if if ( allocated ( ir_intensities )) deallocate ( ir_intensities ) call gmbe_result % destroy () deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if call logger % info ( \" \" ) ! Populate json_data for non-Hessian case if present if ( present ( json_data ) . and . calc_type /= CALC_TYPE_HESSIAN ) then json_data % output_mode = OUTPUT_MODE_GMBE_PIE json_data % total_energy = total_energy json_data % has_energy = . true . json_data % n_pie_terms = n_pie_terms ! Copy PIE data allocate ( json_data % pie_atom_sets , source = pie_atom_sets (:, 1 : n_pie_terms )) allocate ( json_data % pie_coefficients ( n_pie_terms )) json_data % pie_coefficients = pie_coefficients ( 1 : n_pie_terms ) allocate ( json_data % pie_energies ( n_pie_terms )) json_data % pie_energies = pie_energies if ( allocated ( total_gradient )) then allocate ( json_data % gradient , source = total_gradient ) json_data % has_gradient = . true . end if if ( allocated ( total_hessian )) then allocate ( json_data % hessian , source = total_hessian ) json_data % has_hessian = . true . end if end if deallocate ( pie_energies , results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( term_gradient )) deallocate ( term_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) if ( allocated ( term_hessian )) deallocate ( term_hessian ) if ( allocated ( total_dipole_derivs )) deallocate ( total_dipole_derivs ) if ( allocated ( term_dipole_derivs )) deallocate ( term_dipole_derivs ) end subroutine serial_gmbe_pie_processor","tags":"","url":"proc/serial_gmbe_pie_processor.html"},{"title":"send_pie_term_to_node – metalquicha","text":"private  subroutine send_pie_term_to_node(world_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to remote node coordinator Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank Calls proc~~send_pie_term_to_node~~CallsGraph proc~send_pie_term_to_node send_pie_term_to_node isend isend proc~send_pie_term_to_node->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_pie_term_to_node~~CalledByGraph proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: atom_list (:) integer(kind=int32), private :: fragment_type integer, private :: max_atoms integer, private :: n_atoms type(request_t), private :: req (4) Source Code subroutine send_pie_term_to_node ( world_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to remote node coordinator type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( world_comm , term_idx , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , n_atoms , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , atom_list , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_node","tags":"","url":"proc/send_pie_term_to_node.html"},{"title":"send_pie_term_to_worker – metalquicha","text":"private  subroutine send_pie_term_to_worker(node_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to local worker Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank Calls proc~~send_pie_term_to_worker~~CallsGraph proc~send_pie_term_to_worker send_pie_term_to_worker isend isend proc~send_pie_term_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_pie_term_to_worker~~CalledByGraph proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: atom_list (:) integer(kind=int32), private :: fragment_type integer, private :: max_atoms integer, private :: n_atoms type(request_t), private :: req (4) Source Code subroutine send_pie_term_to_worker ( node_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to local worker type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( node_comm , term_idx , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , n_atoms , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , atom_list , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_worker","tags":"","url":"proc/send_pie_term_to_worker.html"},{"title":"find_fragment_intersection – metalquicha","text":"public  function find_fragment_intersection(frag1_atoms, n1, frag2_atoms, n2, intersection, n_intersect) result(has_intersection) Find shared atoms between two fragments (for GMBE with overlapping fragments) This function identifies atoms that appear in both fragments, which is essential\nfor computing intersection-corrected energies in GMBE. Algorithm: O(n1 * n2) brute-force comparison\n- Loop through all atoms in fragment 1\n- For each atom, check if it appears in fragment 2\n- Collect all shared atoms Returns:\n  .true. if fragments share at least one atom, .false. otherwise Output:\n  intersection - allocatable array containing shared atom indices\n  n_intersect - number of shared atoms Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag1_atoms (:) Atom indices in fragment 1 (0-indexed) integer, intent(in) :: n1 Number of atoms in fragment 1 integer, intent(in) :: frag2_atoms (:) Atom indices in fragment 2 (0-indexed) integer, intent(in) :: n2 Number of atoms in fragment 2 integer, intent(out), allocatable :: intersection (:) Shared atom indices integer, intent(out) :: n_intersect Number of shared atoms Return Value logical Called by proc~~find_fragment_intersection~~CalledByGraph proc~find_fragment_intersection find_fragment_intersection proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->proc~find_fragment_intersection proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->proc~find_fragment_intersection proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~process_intersection_derivatives proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: temp_count integer, private, allocatable :: temp_intersection (:) Source Code function find_fragment_intersection ( frag1_atoms , n1 , frag2_atoms , n2 , & intersection , n_intersect ) result ( has_intersection ) !! Find shared atoms between two fragments (for GMBE with overlapping fragments) !! !! This function identifies atoms that appear in both fragments, which is essential !! for computing intersection-corrected energies in GMBE. !! !! Algorithm: O(n1 * n2) brute-force comparison !! - Loop through all atoms in fragment 1 !! - For each atom, check if it appears in fragment 2 !! - Collect all shared atoms !! !! Returns: !!   .true. if fragments share at least one atom, .false. otherwise !! !! Output: !!   intersection - allocatable array containing shared atom indices !!   n_intersect - number of shared atoms integer , intent ( in ) :: frag1_atoms (:) !! Atom indices in fragment 1 (0-indexed) integer , intent ( in ) :: n1 !! Number of atoms in fragment 1 integer , intent ( in ) :: frag2_atoms (:) !! Atom indices in fragment 2 (0-indexed) integer , intent ( in ) :: n2 !! Number of atoms in fragment 2 integer , allocatable , intent ( out ) :: intersection (:) !! Shared atom indices integer , intent ( out ) :: n_intersect !! Number of shared atoms logical :: has_intersection integer :: i , j integer , allocatable :: temp_intersection (:) integer :: temp_count ! Allocate temporary array (max possible size is min(n1, n2)) allocate ( temp_intersection ( min ( n1 , n2 ))) temp_count = 0 ! Find all shared atoms do i = 1 , n1 do j = 1 , n2 if ( frag1_atoms ( i ) == frag2_atoms ( j )) then ! Found a shared atom temp_count = temp_count + 1 temp_intersection ( temp_count ) = frag1_atoms ( i ) exit ! Move to next atom in frag1 end if end do end do ! Set output n_intersect = temp_count has_intersection = ( temp_count > 0 ) ! Allocate and copy result if intersection exists if ( has_intersection ) then allocate ( intersection ( n_intersect )) intersection = temp_intersection ( 1 : n_intersect ) end if deallocate ( temp_intersection ) end function find_fragment_intersection","tags":"","url":"proc/find_fragment_intersection.html"},{"title":"atom_sets_equal – metalquicha","text":"private pure function atom_sets_equal(set1, set2, n_atoms) result(equal) Check if two atom sets are equal (assuming sorted) Arguments Type Intent Optional Attributes Name integer, intent(in) :: set1 (:) integer, intent(in) :: set2 (:) integer, intent(in) :: n_atoms Return Value logical Called by proc~~atom_sets_equal~~CalledByGraph proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~atom_sets_equal proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure function atom_sets_equal ( set1 , set2 , n_atoms ) result ( equal ) !! Check if two atom sets are equal (assuming sorted) integer , intent ( in ) :: set1 (:), set2 (:) integer , intent ( in ) :: n_atoms logical :: equal integer :: i equal = . true . do i = 1 , n_atoms if ( set1 ( i ) /= set2 ( i )) then equal = . false . return end if end do end function atom_sets_equal","tags":"","url":"proc/atom_sets_equal.html"},{"title":"compute_polymer_atoms – metalquicha","text":"public pure subroutine compute_polymer_atoms(sys_geom, polymer, polymer_size, atom_list, n_atoms) Uses mqc_physical_fragment proc~~compute_polymer_atoms~~UsesGraph proc~compute_polymer_atoms compute_polymer_atoms module~mqc_physical_fragment mqc_physical_fragment proc~compute_polymer_atoms->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute the atom list for a polymer (union of atoms from base fragments)\npolymer(:) contains base fragment indices (1-based) Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymer (:) Base fragment indices in this polymer integer, intent(in) :: polymer_size Number of base fragments in polymer integer, intent(out), allocatable :: atom_list (:) Unique atoms in this polymer integer, intent(out) :: n_atoms Number of unique atoms Called by proc~~compute_polymer_atoms~~CalledByGraph proc~compute_polymer_atoms compute_polymer_atoms proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~compute_polymer_atoms proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: already_present integer, private :: frag_idx integer, private :: frag_size integer, private :: i integer, private :: j integer, private, allocatable :: temp_atoms (:) integer, private :: temp_count Source Code pure subroutine compute_polymer_atoms ( sys_geom , polymer , polymer_size , atom_list , n_atoms ) !! Compute the atom list for a polymer (union of atoms from base fragments) !! polymer(:) contains base fragment indices (1-based) use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymer (:) !! Base fragment indices in this polymer integer , intent ( in ) :: polymer_size !! Number of base fragments in polymer integer , allocatable , intent ( out ) :: atom_list (:) !! Unique atoms in this polymer integer , intent ( out ) :: n_atoms !! Number of unique atoms integer , allocatable :: temp_atoms (:) integer :: i , j , frag_idx , frag_size , temp_count logical :: already_present ! Allocate temporary array (worst case: all atoms from all fragments) allocate ( temp_atoms ( sys_geom % total_atoms )) temp_count = 0 ! Loop through each base fragment in the polymer do i = 1 , polymer_size frag_idx = polymer ( i ) if ( frag_idx == 0 ) exit ! Padding zeros frag_size = sys_geom % fragment_sizes ( frag_idx ) ! Add each atom from this fragment (avoid duplicates) do j = 1 , frag_size already_present = . false . ! Check if this atom is already in our list block integer :: k , current_atom current_atom = sys_geom % fragment_atoms ( j , frag_idx ) do k = 1 , temp_count if ( temp_atoms ( k ) == current_atom ) then already_present = . true . exit end if end do end block ! Add if not already present if (. not . already_present ) then temp_count = temp_count + 1 temp_atoms ( temp_count ) = sys_geom % fragment_atoms ( j , frag_idx ) end if end do end do ! Copy to output array n_atoms = temp_count allocate ( atom_list ( n_atoms )) atom_list = temp_atoms ( 1 : n_atoms ) deallocate ( temp_atoms ) end subroutine compute_polymer_atoms","tags":"","url":"proc/compute_polymer_atoms.html"},{"title":"generate_intersections – metalquicha","text":"public  subroutine generate_intersections(sys_geom, monomers, polymers, n_monomers, max_intersection_level, intersections, intersection_sets, intersection_levels, n_intersections) Uses mqc_physical_fragment proc~~generate_intersections~~UsesGraph proc~generate_intersections generate_intersections module~mqc_physical_fragment mqc_physical_fragment proc~generate_intersections->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) For a system with overlapping fragments, this computes k-way intersections\nfollowing the inclusion-exclusion principle for GMBE.\nThe max_intersection_level parameter controls the maximum depth to avoid combinatorial explosion. Algorithm:\n- For each k from 2 to min(max_intersection_level, n_monomers):\n  - Generate all C(n_monomers, k) combinations\n  - For each combination, compute intersection of all k fragments\n  - Store non-empty intersections with their level k Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) Monomer indices integer, intent(inout) :: polymers (:,:) Output: monomers stored here integer, intent(in) :: n_monomers Number of monomers integer, intent(in) :: max_intersection_level Maximum k-way intersection depth integer, intent(out), allocatable :: intersections (:,:) Intersection atom lists integer, intent(out), allocatable :: intersection_sets (:,:) Which k-tuple created each intersection integer, intent(out), allocatable :: intersection_levels (:) Level (k) of each intersection integer, intent(out) :: n_intersections Number of intersections found Calls proc~~generate_intersections~~CallsGraph proc~generate_intersections generate_intersections info info proc~generate_intersections->info proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_intersections->proc~generate_k_way_intersections_for_level to_char to_char proc~generate_intersections->to_char proc~find_fragment_intersection find_fragment_intersection proc~generate_k_way_intersections_for_level->proc~find_fragment_intersection proc~next_combination next_combination proc~generate_k_way_intersections_for_level->proc~next_combination proc~next_combination_init next_combination_init proc~generate_k_way_intersections_for_level->proc~next_combination_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: combination (:) integer, private, allocatable :: current_intersection (:) integer, private :: current_n_intersect logical, private :: has_intersection integer, private :: i integer, private :: idx integer, private :: intersection_count integer, private :: k integer, private :: max_atoms integer, private :: max_intersections integer, private :: max_k_level integer, private, allocatable :: temp_intersection (:) integer, private, allocatable :: temp_intersections (:,:) integer, private, allocatable :: temp_levels (:) integer, private :: temp_n_intersect integer, private, allocatable :: temp_sets (:,:) Source Code subroutine generate_intersections ( sys_geom , monomers , polymers , n_monomers , max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) !! !! For a system with overlapping fragments, this computes k-way intersections !! following the inclusion-exclusion principle for GMBE. !! The max_intersection_level parameter controls the maximum depth to avoid combinatorial explosion. !! !! Algorithm: !! - For each k from 2 to min(max_intersection_level, n_monomers): !!   - Generate all C(n_monomers, k) combinations !!   - For each combination, compute intersection of all k fragments !!   - Store non-empty intersections with their level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:) !! Monomer indices integer , intent ( inout ) :: polymers (:, :) !! Output: monomers stored here integer , intent ( in ) :: n_monomers !! Number of monomers integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth integer , allocatable , intent ( out ) :: intersections (:, :) !! Intersection atom lists integer , allocatable , intent ( out ) :: intersection_sets (:, :) !! Which k-tuple created each intersection integer , allocatable , intent ( out ) :: intersection_levels (:) !! Level (k) of each intersection integer , intent ( out ) :: n_intersections !! Number of intersections found ! Temporaries for storing intersections integer , allocatable :: temp_intersections (:, :) integer , allocatable :: temp_sets (:, :) integer , allocatable :: temp_levels (:) integer , allocatable :: temp_intersection (:) integer , allocatable :: current_intersection (:) integer :: temp_n_intersect , current_n_intersect logical :: has_intersection integer :: k , intersection_count , max_atoms , max_intersections , max_k_level integer :: i , idx integer , allocatable :: combination (:) ! Store monomers in polymers array polymers ( 1 : n_monomers , 1 ) = monomers ( 1 : n_monomers ) if ( n_monomers < 2 ) then n_intersections = 0 return end if ! Count maximum possible intersections: sum of C(n,k) for k=2 to n ! For small n, this is 2&#94;n - n - 1 max_intersections = 2 ** n_monomers - n_monomers - 1 ! Find maximum atoms in any fragment for allocation max_atoms = maxval ( sys_geom % fragment_sizes ( 1 : n_monomers )) ! Allocate temporary arrays allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_monomers , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 ! Determine actual maximum intersection level to use max_k_level = min ( max_intersection_level , n_monomers ) if ( max_k_level < n_monomers ) then call logger % info ( \"Generating k-way intersections up to k=\" // to_char ( max_k_level ) // & \" (limited by max_intersection_level)\" ) else call logger % info ( \"Generating all k-way intersections for GMBE (inclusion-exclusion principle)\" ) end if ! Loop over intersection levels k from 2 to max_k_level do k = 2 , max_k_level ! Generate all C(n_monomers, k) combinations allocate ( combination ( k )) call generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_monomers , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_monomers , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , max_k_level idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else call logger % info ( \"No intersections found (fragments are non-overlapping)\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections","tags":"","url":"proc/generate_intersections.html"},{"title":"generate_polymer_intersections – metalquicha","text":"public  subroutine generate_polymer_intersections(sys_geom, polymers, n_polymers, max_level, intersections, intersection_sets, intersection_levels, n_intersections) Uses pic_logger pic_io mqc_physical_fragment proc~~generate_polymer_intersections~~UsesGraph proc~generate_polymer_intersections generate_polymer_intersections module~mqc_physical_fragment mqc_physical_fragment proc~generate_polymer_intersections->module~mqc_physical_fragment pic_io pic_io proc~generate_polymer_intersections->pic_io pic_logger pic_logger proc~generate_polymer_intersections->pic_logger module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate all k-way intersections for polymers at any level (GMBE-N)\nThis works with dynamically generated polymers, not just base fragments Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymers (:,:) Polymer definitions (n_polymers, max_level) integer, intent(in) :: n_polymers integer, intent(in) :: max_level integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections Calls proc~~generate_polymer_intersections~~CallsGraph proc~generate_polymer_intersections generate_polymer_intersections atom_list atom_list proc~generate_polymer_intersections->atom_list info info proc~generate_polymer_intersections->info proc~compute_polymer_atoms compute_polymer_atoms proc~generate_polymer_intersections->proc~compute_polymer_atoms proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists to_char to_char proc~generate_polymer_intersections->to_char proc~generate_intersections_from_atom_lists->info proc~generate_intersections_from_atom_lists->to_char proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~next_combination next_combination proc~generate_k_way_intersections_from_lists->proc~next_combination proc~next_combination_init next_combination_init proc~generate_k_way_intersections_from_lists->proc~next_combination_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: max_atoms_per_polymer integer, private :: max_intersection_level integer, private, allocatable :: polymer_atoms (:,:) Atom lists for each polymer integer, private, allocatable :: polymer_n_atoms (:) Number of atoms in each polymer integer, private :: polymer_size Source Code subroutine generate_polymer_intersections ( sys_geom , polymers , n_polymers , max_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for polymers at any level (GMBE-N) !! This works with dynamically generated polymers, not just base fragments use mqc_physical_fragment , only : system_geometry_t use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymers (:, :) !! Polymer definitions (n_polymers, max_level) integer , intent ( in ) :: n_polymers , max_level integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer , allocatable :: polymer_atoms (:, :) !! Atom lists for each polymer integer , allocatable :: polymer_n_atoms (:) !! Number of atoms in each polymer integer :: max_atoms_per_polymer integer :: i , polymer_size , max_intersection_level call logger % info ( \"Computing atom compositions for \" // to_char ( n_polymers ) // \" polymers...\" ) ! First, compute atom list for each polymer ! Find max atoms needed max_atoms_per_polymer = 0 do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) ! Worst case: all atoms from all fragments in this polymer max_atoms_per_polymer = max ( max_atoms_per_polymer , polymer_size * maxval ( sys_geom % fragment_sizes )) end do allocate ( polymer_atoms ( max_atoms_per_polymer , n_polymers )) allocate ( polymer_n_atoms ( n_polymers )) polymer_atoms = 0 ! Compute atoms for each polymer do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , polymers ( i , 1 : polymer_size ), polymer_size , atom_list , n_atoms ) polymer_n_atoms ( i ) = n_atoms polymer_atoms ( 1 : n_atoms , i ) = atom_list deallocate ( atom_list ) end block end do call logger % info ( \"Finding intersections between polymers...\" ) ! For GMBE(N), limit intersections to level N+1 to prevent combinatorial explosion ! GMBE(2): dimers → 3-way intersections max ! GMBE(3): trimers → 4-way intersections max max_intersection_level = max_level + 1 call logger % info ( \"Limiting intersections to level \" // to_char ( max_intersection_level ) // & \" (polymer level \" // to_char ( max_level ) // \" + 1)\" ) ! Now generate intersections between these polymer atom sets call generate_intersections_from_atom_lists ( polymer_atoms , polymer_n_atoms , n_polymers , & max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) deallocate ( polymer_atoms , polymer_n_atoms ) end subroutine generate_polymer_intersections","tags":"","url":"proc/generate_polymer_intersections.html"},{"title":"gmbe_enumerate_pie_terms – metalquicha","text":"public  subroutine gmbe_enumerate_pie_terms(sys_geom, primaries, n_primaries, polymer_level, max_k_level, pie_atom_sets, pie_coefficients, n_pie_terms, error, initial_max_terms) Uses mqc_physical_fragment proc~~gmbe_enumerate_pie_terms~~UsesGraph proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms module~mqc_physical_fragment mqc_physical_fragment proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Enumerate all unique intersections via DFS and accumulate PIE coefficients\nThis implements the GMBE(N) algorithm with inclusion-exclusion principle Algorithm:\n1. For each primary i, start DFS with clique=[i]\n2. Recursively grow cliques by adding overlapping primaries\n3. For each clique of size k, compute intersection and add PIE coefficient:\n   coefficient = (+1) if k odd, (-1) if k even\n4. Accumulate coefficients for each unique atom set Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: primaries (:,:) Primary polymers (n_primaries, polymer_level) integer, intent(in) :: n_primaries Number of primary polymers integer, intent(in) :: polymer_level Level of primaries (1=monomers, 2=dimers, etc.) integer, intent(in) :: max_k_level Maximum clique size (intersection depth limit) integer, intent(out), allocatable :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_terms) integer, intent(out), allocatable :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(out) :: n_pie_terms Number of unique PIE terms type( error_t ), intent(out) :: error Error status integer(kind=int64), intent(in), optional :: initial_max_terms Initial PIE storage capacity Calls proc~~gmbe_enumerate_pie_terms~~CallsGraph proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list info info proc~gmbe_enumerate_pie_terms->info proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~error_has_error error_t%error_has_error proc~gmbe_enumerate_pie_terms->proc~error_has_error proc~error_set error_t%error_set proc~gmbe_enumerate_pie_terms->proc~error_set to_char to_char proc~gmbe_enumerate_pie_terms->to_char proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~dfs_pie_accumulate->proc~error_has_error new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~grow_pie_storage->proc~error_set proc~grow_pie_storage->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gmbe_enumerate_pie_terms~~CalledByGraph proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private, parameter :: INITIAL_MAX_PIE_TERMS = 100000_int64 integer, private, allocatable :: candidates (:) Candidate primaries to add integer, private, allocatable :: clique (:) Current clique being built integer, private, allocatable :: current_atoms (:) Current intersection atoms integer, private :: i integer, private :: j integer, private :: max_atoms integer(kind=int64), private :: max_terms integer(kind=default_int), private :: max_terms_i integer, private :: n_candidates integer, private, allocatable :: primary_atoms (:,:) Precomputed atom lists for each primary integer, private, allocatable :: primary_n_atoms (:) Atom counts for each primary integer, private, allocatable :: temp_atom_sets (:,:) integer, private, allocatable :: temp_coefficients (:) Source Code subroutine gmbe_enumerate_pie_terms ( sys_geom , primaries , n_primaries , polymer_level , max_k_level , & pie_atom_sets , pie_coefficients , n_pie_terms , error , initial_max_terms ) !! Enumerate all unique intersections via DFS and accumulate PIE coefficients !! This implements the GMBE(N) algorithm with inclusion-exclusion principle !! !! Algorithm: !! 1. For each primary i, start DFS with clique=[i] !! 2. Recursively grow cliques by adding overlapping primaries !! 3. For each clique of size k, compute intersection and add PIE coefficient: !!    coefficient = (+1) if k odd, (-1) if k even !! 4. Accumulate coefficients for each unique atom set use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: primaries (:, :) !! Primary polymers (n_primaries, polymer_level) integer , intent ( in ) :: n_primaries !! Number of primary polymers integer , intent ( in ) :: polymer_level !! Level of primaries (1=monomers, 2=dimers, etc.) integer , intent ( in ) :: max_k_level !! Maximum clique size (intersection depth limit) integer , allocatable , intent ( out ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_terms) integer , allocatable , intent ( out ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( out ) :: n_pie_terms !! Number of unique PIE terms type ( error_t ), intent ( out ) :: error !! Error status integer ( int64 ), intent ( in ), optional :: initial_max_terms !! Initial PIE storage capacity ! Temporary storage for PIE terms (allocate generously) integer ( int64 ), parameter :: INITIAL_MAX_PIE_TERMS = 100000_int64 ! Adjust if needed integer ( int64 ) :: max_terms integer ( default_int ) :: max_terms_i integer , allocatable :: temp_atom_sets (:, :) integer , allocatable :: temp_coefficients (:) integer , allocatable :: primary_atoms (:, :) !! Precomputed atom lists for each primary integer , allocatable :: primary_n_atoms (:) !! Atom counts for each primary integer , allocatable :: clique (:) !! Current clique being built integer , allocatable :: current_atoms (:) !! Current intersection atoms integer , allocatable :: candidates (:) !! Candidate primaries to add integer :: i , j , max_atoms , n_candidates call logger % info ( \"Enumerating GMBE PIE terms via DFS...\" ) ! Find maximum atoms in any fragment max_atoms = sys_geom % total_atoms ! Allocate temporary storage if ( present ( initial_max_terms )) then max_terms = initial_max_terms else max_terms = INITIAL_MAX_PIE_TERMS end if if ( max_terms < 1_int64 ) then call error % set ( ERROR_VALIDATION , \"Initial PIE term capacity must be positive\" ) return end if if ( max_terms > int ( huge ( 0_default_int ), int64 )) then call error % set ( ERROR_VALIDATION , \"Initial PIE term capacity exceeds default integer limit\" ) return end if max_terms_i = int ( max_terms , default_int ) allocate ( temp_atom_sets ( max_atoms , max_terms_i )) allocate ( temp_coefficients ( max_terms_i )) temp_atom_sets = - 1 temp_coefficients = 0 n_pie_terms = 0_int64 ! Precompute atom lists for all primaries allocate ( primary_atoms ( max_atoms , n_primaries )) allocate ( primary_n_atoms ( n_primaries )) primary_atoms = - 1 do i = 1 , n_primaries block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , primaries ( i , :), polymer_level , atom_list , n_atoms ) primary_n_atoms ( i ) = n_atoms primary_atoms ( 1 : n_atoms , i ) = atom_list ( 1 : n_atoms ) deallocate ( atom_list ) end block end do ! Allocate work arrays allocate ( clique ( max_k_level )) allocate ( current_atoms ( max_atoms )) allocate ( candidates ( n_primaries )) ! Start DFS from each primary do i = 1 , n_primaries ! Initial clique: just primary i clique ( 1 ) = i current_atoms ( 1 : primary_n_atoms ( i )) = primary_atoms ( 1 : primary_n_atoms ( i ), i ) ! Candidates: all primaries after i (to avoid duplicates) n_candidates = n_primaries - i if ( n_candidates > 0 ) then candidates ( 1 : n_candidates ) = [( i + j , j = 1 , n_candidates )] end if ! DFS from this primary call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , 1 , current_atoms ( 1 : primary_n_atoms ( i )), primary_n_atoms ( i ), & candidates , n_candidates , max_k_level , & temp_atom_sets , temp_coefficients , n_pie_terms , max_terms , error ) if ( error % has_error ()) return end do ! Copy to output arrays if ( n_pie_terms > 0_int64 ) then if ( n_pie_terms > int ( huge ( 0_default_int ), int64 )) then call error % set ( ERROR_VALIDATION , \"n_pie_terms exceeds default integer limit\" ) return end if allocate ( pie_atom_sets ( max_atoms , int ( n_pie_terms , default_int ))) allocate ( pie_coefficients ( int ( n_pie_terms , default_int ))) pie_atom_sets = temp_atom_sets (:, 1 : n_pie_terms ) pie_coefficients = temp_coefficients ( 1 : n_pie_terms ) end if call logger % info ( \"Generated \" // to_char ( n_pie_terms ) // \" unique PIE terms\" ) ! Cleanup deallocate ( temp_atom_sets , temp_coefficients , primary_atoms , primary_n_atoms ) deallocate ( clique , current_atoms , candidates ) end subroutine gmbe_enumerate_pie_terms","tags":"","url":"proc/gmbe_enumerate_pie_terms.html"},{"title":"dfs_pie_accumulate – metalquicha","text":"private recursive subroutine dfs_pie_accumulate(primary_atoms, primary_n_atoms, n_primaries, max_atoms, clique, clique_size, current_atoms, n_current_atoms, candidates, n_candidates, max_k_level, atom_sets, coefficients, n_terms, max_terms, error) DFS helper: accumulate PIE coefficients for intersections Arguments Type Intent Optional Attributes Name integer, intent(in) :: primary_atoms (:,:) Precomputed atom lists integer, intent(in) :: primary_n_atoms (:) Atom counts integer, intent(in) :: n_primaries integer, intent(in) :: max_atoms integer, intent(in) :: clique (:) Current clique integer, intent(in) :: clique_size Size of current clique integer, intent(in) :: current_atoms (:) Atoms in current intersection integer, intent(in) :: n_current_atoms Number of atoms in intersection integer, intent(in) :: candidates (:) Candidate primaries integer, intent(in) :: n_candidates integer, intent(in) :: max_k_level integer, intent(inout), allocatable :: atom_sets (:,:) integer, intent(inout), allocatable :: coefficients (:) integer(kind=int64), intent(inout) :: n_terms integer(kind=int64), intent(inout) :: max_terms type( error_t ), intent(inout) :: error Error status Calls proc~~dfs_pie_accumulate~~CallsGraph proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~error_has_error error_t%error_has_error proc~dfs_pie_accumulate->proc~error_has_error proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~error_set error_t%error_set proc~grow_pie_storage->proc~error_set to_char to_char proc~grow_pie_storage->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dfs_pie_accumulate~~CalledByGraph proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: candidate_idx integer, private :: candidate_pos logical, private :: found integer, private :: i integer, private :: n_new_atoms integer, private :: n_new_candidates integer, private, allocatable :: new_atoms (:) integer, private, allocatable :: new_candidates (:) integer, private :: sign integer(kind=int64), private :: term_idx Source Code recursive subroutine dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , clique_size , current_atoms , n_current_atoms , & candidates , n_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms , error ) !! DFS helper: accumulate PIE coefficients for intersections integer , intent ( in ) :: primary_atoms (:, :) !! Precomputed atom lists integer , intent ( in ) :: primary_n_atoms (:) !! Atom counts integer , intent ( in ) :: n_primaries , max_atoms integer , intent ( in ) :: clique (:) !! Current clique integer , intent ( in ) :: clique_size !! Size of current clique integer , intent ( in ) :: current_atoms (:) !! Atoms in current intersection integer , intent ( in ) :: n_current_atoms !! Number of atoms in intersection integer , intent ( in ) :: candidates (:) !! Candidate primaries integer , intent ( in ) :: n_candidates integer , intent ( in ) :: max_k_level integer , allocatable , intent ( inout ) :: atom_sets (:, :) integer , allocatable , intent ( inout ) :: coefficients (:) integer ( int64 ), intent ( inout ) :: n_terms integer ( int64 ), intent ( inout ) :: max_terms type ( error_t ), intent ( inout ) :: error !! Error status integer :: sign , i , candidate_idx , candidate_pos integer ( int64 ) :: term_idx integer , allocatable :: new_atoms (:), new_candidates (:) integer :: n_new_atoms , n_new_candidates logical :: found ! Skip empty intersections if ( n_current_atoms == 0 ) return ! Compute PIE sign: (+1) for odd clique size, (-1) for even sign = merge ( 1 , - 1 , mod ( clique_size , 2 ) == 1 ) ! Find or create entry for this atom set found = . false . do term_idx = 1_int64 , n_terms if ( atom_sets_equal ( atom_sets (:, term_idx ), current_atoms , n_current_atoms )) then coefficients ( term_idx ) = coefficients ( term_idx ) + sign found = . true . exit end if end do if (. not . found ) then ! New atom set if ( n_terms >= max_terms ) then call grow_pie_storage ( atom_sets , coefficients , max_terms , max_atoms , error ) if ( error % has_error ()) return end if n_terms = n_terms + 1_int64 atom_sets ( 1 : n_current_atoms , n_terms ) = current_atoms ( 1 : n_current_atoms ) atom_sets ( n_current_atoms + 1 :, n_terms ) = - 1 coefficients ( n_terms ) = sign end if ! Stop if we've reached maximum clique size if ( clique_size >= max_k_level ) return if ( n_candidates == 0 ) return ! Try adding each candidate to the clique allocate ( new_atoms ( max_atoms )) allocate ( new_candidates ( n_primaries )) do i = 1 , n_candidates candidate_idx = candidates ( i ) ! Compute intersection with this candidate call intersect_atom_lists ( current_atoms , n_current_atoms , & primary_atoms (:, candidate_idx ), primary_n_atoms ( candidate_idx ), & new_atoms , n_new_atoms ) ! Skip if no intersection if ( n_new_atoms == 0 ) cycle ! New candidates: must come after this one and overlap with new_atoms n_new_candidates = 0 do candidate_pos = i + 1 , n_candidates block integer :: test_candidate , test_n_intersect integer , allocatable :: test_intersect (:) test_candidate = candidates ( candidate_pos ) allocate ( test_intersect ( max_atoms )) call intersect_atom_lists ( new_atoms , n_new_atoms , & primary_atoms (:, test_candidate ), primary_n_atoms ( test_candidate ), & test_intersect , test_n_intersect ) if ( test_n_intersect > 0 ) then n_new_candidates = n_new_candidates + 1 new_candidates ( n_new_candidates ) = test_candidate end if deallocate ( test_intersect ) end block end do ! Recurse block integer :: new_clique ( clique_size + 1 ) new_clique ( 1 : clique_size ) = clique ( 1 : clique_size ) new_clique ( clique_size + 1 ) = candidate_idx call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & new_clique , clique_size + 1 , new_atoms , n_new_atoms , & new_candidates , n_new_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms , error ) if ( error % has_error ()) then deallocate ( new_atoms , new_candidates ) return end if end block end do deallocate ( new_atoms , new_candidates ) end subroutine dfs_pie_accumulate","tags":"","url":"proc/dfs_pie_accumulate.html"},{"title":"generate_intersections_from_atom_lists – metalquicha","text":"private  subroutine generate_intersections_from_atom_lists(atom_lists, n_atoms_list, n_sets, max_k_level, intersections, intersection_sets, intersection_levels, n_intersections) Uses pic_logger pic_io proc~~generate_intersections_from_atom_lists~~UsesGraph proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists pic_io pic_io proc~generate_intersections_from_atom_lists->pic_io pic_logger pic_logger proc~generate_intersections_from_atom_lists->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate k-way intersections from arbitrary atom lists (not tied to sys_geom)\nmax_k_level limits the maximum intersection order to prevent combinatorial explosion Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) (max_atoms, n_sets) integer, intent(in) :: n_atoms_list (:) Number of atoms in each set integer, intent(in) :: n_sets Number of sets (polymers) integer, intent(in) :: max_k_level Maximum intersection level to compute integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections Calls proc~~generate_intersections_from_atom_lists~~CallsGraph proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists info info proc~generate_intersections_from_atom_lists->info proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists to_char to_char proc~generate_intersections_from_atom_lists->to_char proc~next_combination next_combination proc~generate_k_way_intersections_from_lists->proc~next_combination proc~next_combination_init next_combination_init proc~generate_k_way_intersections_from_lists->proc~next_combination_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_intersections_from_atom_lists~~CalledByGraph proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: actual_max_k integer, private, allocatable :: combination (:) integer, private :: idx integer, private :: intersection_count integer, private :: k integer, private :: max_atoms integer, private :: max_intersections integer, private, allocatable :: temp_intersections (:,:) integer, private, allocatable :: temp_levels (:) integer, private, allocatable :: temp_sets (:,:) Source Code subroutine generate_intersections_from_atom_lists ( atom_lists , n_atoms_list , n_sets , max_k_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate k-way intersections from arbitrary atom lists (not tied to sys_geom) !! max_k_level limits the maximum intersection order to prevent combinatorial explosion use pic_logger , only : logger => global_logger use pic_io , only : to_char integer , intent ( in ) :: atom_lists (:, :) !! (max_atoms, n_sets) integer , intent ( in ) :: n_atoms_list (:) !! Number of atoms in each set integer , intent ( in ) :: n_sets !! Number of sets (polymers) integer , intent ( in ) :: max_k_level !! Maximum intersection level to compute integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer :: max_intersections , max_atoms integer , allocatable :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer :: intersection_count , k , idx , actual_max_k integer , allocatable :: combination (:) if ( n_sets < 2 ) then n_intersections = 0 return end if ! Limit k-way intersections to min(max_k_level, n_sets) actual_max_k = min ( max_k_level , n_sets ) max_intersections = 2 ** n_sets - n_sets - 1 max_atoms = maxval ( n_atoms_list ) allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_sets , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 call logger % info ( \"Generating k-way intersections (k=2 to \" // to_char ( actual_max_k ) // \")\" ) ! Loop over intersection levels k from 2 to actual_max_k do k = 2 , actual_max_k allocate ( combination ( k )) call generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_sets , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_sets , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , actual_max_k idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else allocate ( intersections ( 1 , 0 )) allocate ( intersection_sets ( 1 , 0 )) allocate ( intersection_levels ( 0 )) call logger % info ( \"No intersections found\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections_from_atom_lists","tags":"","url":"proc/generate_intersections_from_atom_lists.html"},{"title":"generate_k_way_intersections_for_level – metalquicha","text":"private recursive subroutine generate_k_way_intersections_for_level(sys_geom, monomers, n_monomers, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Uses mqc_physical_fragment proc~~generate_k_way_intersections_for_level~~UsesGraph proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level module~mqc_physical_fragment mqc_physical_fragment proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Helper to generate all k-way intersections at a specific level k Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count Calls proc~~generate_k_way_intersections_for_level~~CallsGraph proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~find_fragment_intersection find_fragment_intersection proc~generate_k_way_intersections_for_level->proc~find_fragment_intersection proc~next_combination next_combination proc~generate_k_way_intersections_for_level->proc~next_combination proc~next_combination_init next_combination_init proc~generate_k_way_intersections_for_level->proc~next_combination_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_k_way_intersections_for_level~~CalledByGraph proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: current_intersection (:) integer, private :: current_n_intersect integer, private :: frag_size logical, private :: has_intersection integer, private :: i integer, private :: j integer, private :: mono_idx integer, private, allocatable :: temp_intersection (:) integer, private :: temp_n_intersect Source Code recursive subroutine generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Helper to generate all k-way intersections at a specific level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:), n_monomers , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , mono_idx , frag_size logical :: has_intersection ! Generate combinations using an iterative approach call next_combination_init ( combination , k ) do ! Compute intersection of all fragments in this combination has_intersection = . false . ! Start with the first fragment in the combination mono_idx = monomers ( combination ( 1 )) frag_size = sys_geom % fragment_sizes ( mono_idx ) allocate ( current_intersection ( frag_size )) current_intersection = sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ) current_n_intersect = frag_size ! Intersect with each subsequent fragment do i = 2 , k mono_idx = monomers ( combination ( i )) frag_size = sys_geom % fragment_sizes ( mono_idx ) has_intersection = find_fragment_intersection ( & current_intersection , current_n_intersect , & sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ), frag_size , & temp_intersection , temp_n_intersect ) if (. not . has_intersection ) then ! Intersection is empty, break early deallocate ( current_intersection ) if ( allocated ( temp_intersection )) deallocate ( temp_intersection ) exit end if ! Replace current_intersection with the new intersection deallocate ( current_intersection ) allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection current_n_intersect = temp_n_intersect deallocate ( temp_intersection ) end do ! If we have a non-empty intersection, store it if ( has_intersection . and . allocated ( current_intersection )) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection temp_sets ( 1 : k , intersection_count ) = monomers ( combination ) temp_levels ( intersection_count ) = k deallocate ( current_intersection ) end if ! Get next combination if (. not . next_combination ( combination , k , n_monomers )) exit end do end subroutine generate_k_way_intersections_for_level","tags":"","url":"proc/generate_k_way_intersections_for_level.html"},{"title":"generate_k_way_intersections_from_lists – metalquicha","text":"private  subroutine generate_k_way_intersections_from_lists(atom_lists, n_atoms_list, n_sets, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Generate all k-way intersections from atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) integer, intent(in) :: n_atoms_list (:) integer, intent(in) :: n_sets integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count Calls proc~~generate_k_way_intersections_from_lists~~CallsGraph proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~next_combination next_combination proc~generate_k_way_intersections_from_lists->proc~next_combination proc~next_combination_init next_combination_init proc~generate_k_way_intersections_from_lists->proc~next_combination_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_k_way_intersections_from_lists~~CalledByGraph proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: current_intersection (:) integer, private :: current_n_intersect logical, private :: has_intersection integer, private :: i integer, private :: j integer, private :: set_idx integer, private, allocatable :: temp_intersection (:) integer, private :: temp_n_intersect Source Code subroutine generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Generate all k-way intersections from atom lists integer , intent ( in ) :: atom_lists (:, :), n_atoms_list (:), n_sets , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , set_idx logical :: has_intersection call next_combination_init ( combination , k ) do ! Compute intersection of all sets in this combination has_intersection = . false . ! Start with the first set in the combination set_idx = combination ( 1 ) allocate ( current_intersection ( n_atoms_list ( set_idx ))) current_intersection = atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) current_n_intersect = n_atoms_list ( set_idx ) ! Intersect with each subsequent set do i = 2 , k set_idx = combination ( i ) allocate ( temp_intersection ( current_n_intersect )) ! Find intersection temp_n_intersect = 0 do j = 1 , current_n_intersect if ( any ( atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) == current_intersection ( j ))) then temp_n_intersect = temp_n_intersect + 1 temp_intersection ( temp_n_intersect ) = current_intersection ( j ) end if end do ! Update current intersection deallocate ( current_intersection ) if ( temp_n_intersect > 0 ) then allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection ( 1 : temp_n_intersect ) current_n_intersect = temp_n_intersect has_intersection = . true . else has_intersection = . false . end if deallocate ( temp_intersection ) if (. not . has_intersection ) exit end do ! Store if we found an intersection if ( has_intersection . and . current_n_intersect > 0 ) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection ( 1 : current_n_intersect ) temp_sets ( 1 : k , intersection_count ) = combination ( 1 : k ) temp_levels ( intersection_count ) = k end if if ( allocated ( current_intersection )) deallocate ( current_intersection ) ! Get next combination if (. not . next_combination ( combination , k , n_sets )) exit end do end subroutine generate_k_way_intersections_from_lists","tags":"","url":"proc/generate_k_way_intersections_from_lists.html"},{"title":"grow_pie_storage – metalquicha","text":"private  subroutine grow_pie_storage(atom_sets, coefficients, max_terms, max_atoms, error) Grow PIE term storage arrays when capacity is exceeded. Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: atom_sets (:,:) integer, intent(inout), allocatable :: coefficients (:) integer(kind=int64), intent(inout) :: max_terms integer, intent(in) :: max_atoms type( error_t ), intent(inout) :: error Calls proc~~grow_pie_storage~~CallsGraph proc~grow_pie_storage grow_pie_storage proc~error_set error_t%error_set proc~grow_pie_storage->proc~error_set to_char to_char proc~grow_pie_storage->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~grow_pie_storage~~CalledByGraph proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~grow_pie_storage proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: max_default_int integer, private, allocatable :: new_atom_sets (:,:) integer, private, allocatable :: new_coefficients (:) integer(kind=int64), private :: new_max_terms integer(kind=default_int), private :: new_terms_i integer(kind=default_int), private :: old_terms_i Source Code subroutine grow_pie_storage ( atom_sets , coefficients , max_terms , max_atoms , error ) !! Grow PIE term storage arrays when capacity is exceeded. integer , allocatable , intent ( inout ) :: atom_sets (:, :) integer , allocatable , intent ( inout ) :: coefficients (:) integer ( int64 ), intent ( inout ) :: max_terms integer , intent ( in ) :: max_atoms type ( error_t ), intent ( inout ) :: error integer ( int64 ) :: new_max_terms integer ( default_int ) :: old_terms_i , new_terms_i integer , allocatable :: new_atom_sets (:, :) integer , allocatable :: new_coefficients (:) integer ( int64 ) :: max_default_int max_default_int = int ( huge ( 0_default_int ), int64 ) new_max_terms = max_terms * 2_int64 if ( new_max_terms <= max_terms ) then call error % set ( ERROR_VALIDATION , \"PIE term capacity overflow\" ) return end if if ( new_max_terms > max_default_int ) then new_max_terms = max_default_int end if if ( new_max_terms == max_terms ) then call error % set ( ERROR_VALIDATION , \"Exceeded maximum PIE terms (\" // to_char ( max_terms ) // \")\" ) return end if old_terms_i = int ( max_terms , default_int ) new_terms_i = int ( new_max_terms , default_int ) allocate ( new_atom_sets ( max_atoms , new_terms_i )) new_atom_sets = - 1 new_atom_sets (:, 1 : old_terms_i ) = atom_sets (:, 1 : old_terms_i ) allocate ( new_coefficients ( new_terms_i )) new_coefficients = 0 new_coefficients ( 1 : old_terms_i ) = coefficients ( 1 : old_terms_i ) call move_alloc ( new_atom_sets , atom_sets ) call move_alloc ( new_coefficients , coefficients ) max_terms = new_max_terms end subroutine grow_pie_storage","tags":"","url":"proc/grow_pie_storage.html"},{"title":"intersect_atom_lists – metalquicha","text":"private pure subroutine intersect_atom_lists(atoms1, n1, atoms2, n2, intersection, n_intersect) Compute intersection of two atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms1 (:) integer, intent(in) :: n1 integer, intent(in) :: atoms2 (:) integer, intent(in) :: n2 integer, intent(out) :: intersection (:) integer, intent(out) :: n_intersect Called by proc~~intersect_atom_lists~~CalledByGraph proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~intersect_atom_lists proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j Source Code pure subroutine intersect_atom_lists ( atoms1 , n1 , atoms2 , n2 , intersection , n_intersect ) !! Compute intersection of two atom lists integer , intent ( in ) :: atoms1 (:), n1 , atoms2 (:), n2 integer , intent ( out ) :: intersection (:) integer , intent ( out ) :: n_intersect integer :: i , j n_intersect = 0 do i = 1 , n1 if ( atoms1 ( i ) < 0 ) cycle do j = 1 , n2 if ( atoms2 ( j ) < 0 ) cycle if ( atoms1 ( i ) == atoms2 ( j )) then n_intersect = n_intersect + 1 intersection ( n_intersect ) = atoms1 ( i ) exit end if end do end do end subroutine intersect_atom_lists","tags":"","url":"proc/intersect_atom_lists.html"},{"title":"int_to_string – metalquicha","text":"private pure function int_to_string(i) result(str) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Called by proc~~int_to_string~~CalledByGraph proc~int_to_string int_to_string proc~read_xyz_string read_xyz_string proc~read_xyz_string->proc~int_to_string proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: buffer Source Code pure function int_to_string ( i ) result ( str ) !! Convert integer to string integer , intent ( in ) :: i character ( len = :), allocatable :: str character ( len = 20 ) :: buffer write ( buffer , '(I0)' ) i str = trim ( adjustl ( buffer )) end function int_to_string","tags":"","url":"proc/int_to_string.html"},{"title":"read_xyz_file – metalquicha","text":"public  subroutine read_xyz_file(filename, geom, error) Read molecular geometry from XYZ format file Parses standard XYZ files with format:\nLine 1: Number of atoms\nLine 2: Comment/title line\nLines 3+: Element X Y Z (coordinates in Angstrom) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Path to XYZ file type( geometry_type ), intent(out) :: geom Parsed molecular geometry type( error_t ), intent(out) :: error Error handling Calls proc~~read_xyz_file~~CallsGraph proc~read_xyz_file read_xyz_file proc~error_add_context error_t%error_add_context proc~read_xyz_file->proc~error_add_context proc~error_has_error error_t%error_has_error proc~read_xyz_file->proc~error_has_error proc~error_set error_t%error_set proc~read_xyz_file->proc~error_set proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~read_xyz_string->proc~error_set proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_xyz_file~~CalledByGraph proc~read_xyz_file read_xyz_file proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: file_contents Full file content buffer logical, private :: file_exists Whether file exists on disk integer, private :: file_size File size in bytes integer, private :: io_stat I/O operation status integer, private :: unit File unit number Source Code subroutine read_xyz_file ( filename , geom , error ) !! Read molecular geometry from XYZ format file !! !! Parses standard XYZ files with format: !! Line 1: Number of atoms !! Line 2: Comment/title line !! Lines 3+: Element X Y Z (coordinates in Angstrom) character ( len =* ), intent ( in ) :: filename !! Path to XYZ file type ( geometry_type ), intent ( out ) :: geom !! Parsed molecular geometry type ( error_t ), intent ( out ) :: error !! Error handling integer :: unit !! File unit number integer :: io_stat !! I/O operation status integer :: file_size !! File size in bytes logical :: file_exists !! Whether file exists on disk character ( len = :), allocatable :: file_contents !! Full file content buffer ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"XYZ file not found: \" // trim ( filename )) return end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: file_contents ) ! Open and read entire file as stream open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening file: \" // trim ( filename )) return end if read ( unit , iostat = io_stat ) file_contents close ( unit ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error reading file: \" // trim ( filename )) return end if ! Parse the contents call read_xyz_string ( file_contents , geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_xyz_reader:read_xyz_file\" ) return end if end subroutine read_xyz_file","tags":"","url":"proc/read_xyz_file.html"},{"title":"read_xyz_string – metalquicha","text":"public pure subroutine read_xyz_string(xyz_string, geom, error) Parse molecular geometry from XYZ format string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xyz_string type( geometry_type ), intent(out) :: geom type( error_t ), intent(out) :: error Calls proc~~read_xyz_string~~CallsGraph proc~read_xyz_string read_xyz_string proc~error_set error_t%error_set proc~read_xyz_string->proc~error_set proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_xyz_string~~CalledByGraph proc~read_xyz_string read_xyz_string proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: element integer, private :: iatom integer, private :: io_stat character(len=:), private, allocatable :: lines (:) integer, private :: nlines real(kind=dp), private :: x real(kind=dp), private :: y real(kind=dp), private :: z Source Code pure subroutine read_xyz_string ( xyz_string , geom , error ) !! Parse molecular geometry from XYZ format string character ( len =* ), intent ( in ) :: xyz_string type ( geometry_type ), intent ( out ) :: geom type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: lines (:) integer :: nlines , iatom , io_stat character ( len = 256 ) :: element real ( dp ) :: x , y , z ! Split into lines call split_lines ( xyz_string , lines , nlines ) if ( nlines < 2 ) then call error % set ( ERROR_PARSE , \"XYZ file must have at least 2 lines (natoms + comment)\" ) return end if ! Read number of atoms from first line read ( lines ( 1 ), * , iostat = io_stat ) geom % natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to read number of atoms from first line\" ) return end if if ( geom % natoms < 0 ) then call error % set ( ERROR_PARSE , \"Number of atoms must be non-negative\" ) return end if ! Store comment line geom % comment = trim ( adjustl ( lines ( 2 ))) ! Check we have enough lines if ( nlines < 2 + geom % natoms ) then call error % set ( ERROR_PARSE , \"XYZ file has insufficient lines: expected \" // & trim ( int_to_string ( 2 + geom % natoms )) // \", got \" // & trim ( int_to_string ( nlines ))) return end if ! Allocate arrays allocate ( character ( len = MAX_ELEMENT_SYMBOL_LEN ) :: geom % elements ( geom % natoms )) allocate ( geom % coords ( 3 , geom % natoms )) ! Read atom data do iatom = 1 , geom % natoms read ( lines ( 2 + iatom ), * , iostat = io_stat ) element , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse atom data on line \" // & trim ( int_to_string ( 2 + iatom )) // \": '\" // & trim ( lines ( 2 + iatom )) // \"'\" ) return end if geom % elements ( iatom ) = trim ( adjustl ( element )) geom % coords ( 1 , iatom ) = x geom % coords ( 2 , iatom ) = y geom % coords ( 3 , iatom ) = z end do end subroutine read_xyz_string","tags":"","url":"proc/read_xyz_string.html"},{"title":"split_lines – metalquicha","text":"public pure subroutine split_lines(text, lines, nlines) Split input text into lines based on CR, LF, or CRLF line endings\nTrailing newlines do not create empty lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text character(len=:), intent(out), allocatable :: lines (:) integer, intent(out) :: nlines Called by proc~~split_lines~~CalledByGraph proc~split_lines split_lines proc~read_xyz_string read_xyz_string proc~read_xyz_string->proc~split_lines proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: line_end integer, private :: line_start integer, private :: max_line_len character(len=:), private, allocatable :: temp_lines (:) Source Code pure subroutine split_lines ( text , lines , nlines ) !! Split input text into lines based on CR, LF, or CRLF line endings !! Trailing newlines do not create empty lines character ( len =* ), intent ( in ) :: text character ( len = :), allocatable , intent ( out ) :: lines (:) integer , intent ( out ) :: nlines integer :: i , line_start , line_end , max_line_len character ( len = :), allocatable :: temp_lines (:) if ( len ( text ) == 0 ) then nlines = 0 allocate ( character ( len = 1 ) :: lines ( 0 )) return end if ! Pass 1: Count lines and find maximum line length nlines = 0 max_line_len = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 ! Skip both CR and LF else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 max_line_len = max ( max_line_len , len ( text ) - line_start + 1 ) end if ! Handle empty text or ensure at least length 1 if ( max_line_len == 0 ) max_line_len = 1 ! Allocate output array allocate ( character ( len = max_line_len ) :: temp_lines ( nlines )) ! Pass 2: Extract lines nlines = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = len ( text ) - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if ! Copy to output (use explicit loop for Intel compiler compatibility) allocate ( character ( len = max_line_len ) :: lines ( nlines )) block integer :: iline do iline = 1 , nlines lines ( iline ) = temp_lines ( iline ) end do end block end subroutine split_lines","tags":"","url":"proc/split_lines.html"},{"title":"calc_type_from_string – metalquicha","text":"public pure function calc_type_from_string(calc_type_str) result(calc_type) Convert calculation type string to integer constant Performs case-insensitive comparison and returns appropriate constant.\nReturns CALC_TYPE_UNKNOWN for unrecognized strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: calc_type_str Input string (e.g., “energy”, “gradient”) Return Value integer(kind=int32) Output integer constant Called by proc~~calc_type_from_string~~CalledByGraph proc~calc_type_from_string calc_type_from_string proc~parse_driver_section parse_driver_section proc~parse_driver_section->proc~calc_type_from_string proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_driver_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=len_trim), private :: lower_str Source Code pure function calc_type_from_string ( calc_type_str ) result ( calc_type ) !! Convert calculation type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns CALC_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: calc_type_str !! Input string (e.g., \"energy\", \"gradient\") integer ( int32 ) :: calc_type !! Output integer constant character ( len = len_trim ( calc_type_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( calc_type_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) case ( 'energy' ) calc_type = CALC_TYPE_ENERGY case ( 'gradient' ) calc_type = CALC_TYPE_GRADIENT case ( 'hessian' ) calc_type = CALC_TYPE_HESSIAN case default calc_type = CALC_TYPE_UNKNOWN end select end function calc_type_from_string","tags":"","url":"proc/calc_type_from_string.html"},{"title":"calc_type_to_string – metalquicha","text":"public pure function calc_type_to_string(calc_type) result(calc_type_str) Convert calculation type integer constant to string Provides human-readable string representation of calculation type. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: calc_type Input integer constant Return Value character(len=:), allocatable Output string representation Called by proc~~calc_type_to_string~~CalledByGraph proc~calc_type_to_string calc_type_to_string proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~calc_type_to_string proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~calc_type_to_string interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~calc_type_to_string interface~do_fragment_work do_fragment_work proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->interface~do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~serial_fragment_processor interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations interface~node_worker->proc~node_worker interface~unfragmented_calculation->proc~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function calc_type_to_string ( calc_type ) result ( calc_type_str ) !! Convert calculation type integer constant to string !! !! Provides human-readable string representation of calculation type. integer ( int32 ), intent ( in ) :: calc_type !! Input integer constant character ( len = :), allocatable :: calc_type_str !! Output string representation select case ( calc_type ) case ( CALC_TYPE_ENERGY ) calc_type_str = \"energy\" case ( CALC_TYPE_GRADIENT ) calc_type_str = \"gradient\" case ( CALC_TYPE_HESSIAN ) calc_type_str = \"hessian\" case default calc_type_str = \"unknown\" end select end function calc_type_to_string","tags":"","url":"proc/calc_type_to_string.html"},{"title":"cc_total – metalquicha","text":"private pure function cc_total(this) result(total) Compute total CC correlation energy Type Bound cc_energy_t Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code pure function cc_total ( this ) result ( total ) !! Compute total CC correlation energy class ( cc_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % singles + this % doubles + this % triples end function cc_total","tags":"","url":"proc/cc_total.html"},{"title":"energy_total – metalquicha","text":"private pure function energy_total(this) result(total) Compute total energy from all components Type Bound energy_t Arguments Type Intent Optional Attributes Name class( energy_t ), intent(in) :: this Return Value real(kind=dp) Calls proc~~energy_total~~CallsGraph proc~energy_total energy_t%energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~energy_total~~CalledByGraph proc~energy_total energy_t%energy_total proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~energy_total proc~run_calculation run_calculation proc~compute_energy_and_forces->proc~run_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~energy_total proc~print_gmbe_intersection_debug print_gmbe_intersection_debug proc~compute_gmbe->proc~print_gmbe_intersection_debug proc~compute_mbe compute_mbe proc~compute_mbe->proc~energy_total proc~dft_calc_energy dft_method_t%dft_calc_energy proc~dft_calc_energy->proc~energy_total proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~energy_total proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~energy_total proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~hessian_coordinator->proc~populate_unfragmented_json_data proc~populate_vibrational_json_data populate_vibrational_json_data proc~hessian_coordinator->proc~populate_vibrational_json_data proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_energy->proc~energy_total proc~mcscf_calc_energy mcscf_method_t%mcscf_calc_energy proc~mcscf_calc_energy->proc~energy_total proc~populate_unfragmented_json_data->proc~energy_total proc~populate_vibrational_json_data->proc~energy_total proc~print_gmbe_intersection_debug->proc~energy_total proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~energy_total proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~energy_total proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~xtb_calc_energy->proc~energy_total proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~xtb_calc_gradient->proc~energy_total interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~dft_calc_gradient dft_method_t%dft_calc_gradient proc~dft_calc_gradient->proc~dft_calc_energy proc~dft_calc_hessian dft_method_t%dft_calc_hessian proc~dft_calc_hessian->proc~dft_calc_energy proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_gradient->proc~hf_calc_energy proc~mcscf_calc_gradient mcscf_method_t%mcscf_calc_gradient proc~mcscf_calc_gradient->proc~mcscf_calc_energy proc~mcscf_calc_hessian mcscf_method_t%mcscf_calc_hessian proc~mcscf_calc_hessian->proc~mcscf_calc_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~serial_fragment_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~xtb_calc_gradient interface~global_coordinator->proc~global_coordinator proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function energy_total ( this ) result ( total ) !! Compute total energy from all components class ( energy_t ), intent ( in ) :: this real ( dp ) :: total ! this line needs to me modified if more components are added total = this % scf + this % mp2 % total () + this % cc % total () end function energy_total","tags":"","url":"proc/energy_total.html"},{"title":"mp2_scs – metalquicha","text":"private pure function mp2_scs(this) result(scs_energy) Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy\nSCS-MP2 uses: E_SCS = (1/3) E_SS + 1.2 E_OS Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code pure function mp2_scs ( this ) result ( scs_energy ) !! Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy !! SCS-MP2 uses: E_SCS = (1/3)*E_SS + 1.2*E_OS class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: scs_energy scs_energy = SCS_SS_SCALE * this % ss + SCS_OS_SCALE * this % os end function mp2_scs","tags":"","url":"proc/mp2_scs.html"},{"title":"mp2_total – metalquicha","text":"private pure function mp2_total(this) result(total) Compute total MP2 correlation energy Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Called by proc~~mp2_total~~CalledByGraph proc~mp2_total mp2_energy_t%mp2_total proc~energy_total energy_t%energy_total proc~energy_total->proc~mp2_total proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~energy_total proc~run_calculation run_calculation proc~compute_energy_and_forces->proc~run_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~energy_total proc~print_gmbe_intersection_debug print_gmbe_intersection_debug proc~compute_gmbe->proc~print_gmbe_intersection_debug proc~compute_mbe compute_mbe proc~compute_mbe->proc~energy_total proc~dft_calc_energy dft_method_t%dft_calc_energy proc~dft_calc_energy->proc~energy_total proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~energy_total proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~energy_total proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~hessian_coordinator->proc~populate_unfragmented_json_data proc~populate_vibrational_json_data populate_vibrational_json_data proc~hessian_coordinator->proc~populate_vibrational_json_data proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_energy->proc~energy_total proc~mcscf_calc_energy mcscf_method_t%mcscf_calc_energy proc~mcscf_calc_energy->proc~energy_total proc~populate_unfragmented_json_data->proc~energy_total proc~populate_vibrational_json_data->proc~energy_total proc~print_gmbe_intersection_debug->proc~energy_total proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~energy_total proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~energy_total proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~xtb_calc_energy->proc~energy_total proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~xtb_calc_gradient->proc~energy_total interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~dft_calc_gradient dft_method_t%dft_calc_gradient proc~dft_calc_gradient->proc~dft_calc_energy proc~dft_calc_hessian dft_method_t%dft_calc_hessian proc~dft_calc_hessian->proc~dft_calc_energy proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_gradient->proc~hf_calc_energy proc~mcscf_calc_gradient mcscf_method_t%mcscf_calc_gradient proc~mcscf_calc_gradient->proc~mcscf_calc_energy proc~mcscf_calc_hessian mcscf_method_t%mcscf_calc_hessian proc~mcscf_calc_hessian->proc~mcscf_calc_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~serial_fragment_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~xtb_calc_gradient interface~global_coordinator->proc~global_coordinator proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function mp2_total ( this ) result ( total ) !! Compute total MP2 correlation energy class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % ss + this % os end function mp2_total","tags":"","url":"proc/mp2_total.html"},{"title":"result_irecv – metalquicha","text":"public  subroutine result_irecv(result, comm, source, tag, req) Receive calculation result over MPI (non-blocking)\nReceives SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(request_t), intent(out) :: req Calls proc~~result_irecv~~CallsGraph proc~result_irecv result_irecv irecv irecv proc~result_irecv->irecv recv recv proc~result_irecv->recv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_irecv~~CalledByGraph proc~result_irecv result_irecv proc~global_coordinator global_coordinator proc~global_coordinator->proc~result_irecv proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~result_irecv proc~node_coordinator node_coordinator proc~node_coordinator->proc~result_irecv interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->interface~global_coordinator proc~run_fragmented_calculation->interface~node_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(MPI_Status), private :: status Source Code subroutine result_irecv ( result , comm , source , tag , req ) !! Receive calculation result over MPI (non-blocking) !! Receives SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( request_t ), intent ( out ) :: req type ( MPI_Status ) :: status ! Receive SCF energy (non-blocking) call irecv ( comm , result % energy % scf , source , tag , req ) ! Receive other energy components (blocking to avoid needing multiple request handles) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive fragment metadata call recv ( comm , result % distance , source , tag , status ) ! Receive gradient flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if ! Receive dipole flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_dipole , source , tag , status ) if ( result % has_dipole ) then ! Receive allocatable dipole array (MPI lib handles allocation) call recv ( comm , result % dipole , source , tag , status ) end if ! Receive dipole derivatives flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_dipole_derivatives , source , tag , status ) if ( result % has_dipole_derivatives ) then ! Receive allocatable dipole derivatives array (MPI lib handles allocation) call recv ( comm , result % dipole_derivatives , source , tag , status ) end if end subroutine result_irecv","tags":"","url":"proc/result_irecv.html"},{"title":"result_isend – metalquicha","text":"public  subroutine result_isend(result, comm, dest, tag, req) Send calculation result over MPI (non-blocking)\nSends SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag type(request_t), intent(out) :: req Calls proc~~result_isend~~CallsGraph proc~result_isend result_isend isend isend proc~result_isend->isend send send proc~result_isend->send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_isend~~CalledByGraph proc~result_isend result_isend proc~node_coordinator node_coordinator proc~node_coordinator->proc~result_isend proc~node_worker node_worker proc~node_worker->proc~result_isend interface~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator interface~node_worker node_worker interface~node_worker->proc~node_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_coordinator proc~run_fragmented_calculation->interface~node_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_isend ( result , comm , dest , tag , req ) !! Send calculation result over MPI (non-blocking) !! Sends SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag type ( request_t ), intent ( out ) :: req ! Send SCF energy (non-blocking) call isend ( comm , result % energy % scf , dest , tag , req ) ! Send other energy components (blocking to avoid needing multiple request handles) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send fragment metadata call send ( comm , result % distance , dest , tag ) ! Send gradient flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if ! Send Hessian flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_hessian , dest , tag ) if ( result % has_hessian ) then call send ( comm , result % hessian , dest , tag ) end if ! Send dipole flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_dipole , dest , tag ) if ( result % has_dipole ) then call send ( comm , result % dipole , dest , tag ) end if ! Send dipole derivatives flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_dipole_derivatives , dest , tag ) if ( result % has_dipole_derivatives ) then call send ( comm , result % dipole_derivatives , dest , tag ) end if end subroutine result_isend","tags":"","url":"proc/result_isend.html"},{"title":"result_recv – metalquicha","text":"public  subroutine result_recv(result, comm, source, tag, status) Receive calculation result over MPI (blocking)\nReceives energy components and conditionally receives gradient based on flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(MPI_Status), intent(out) :: status Calls proc~~result_recv~~CallsGraph proc~result_recv result_recv recv recv proc~result_recv->recv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_recv ( result , comm , source , tag , status ) !! Receive calculation result over MPI (blocking) !! Receives energy components and conditionally receives gradient based on flag type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( MPI_Status ), intent ( out ) :: status ! Receive energy components call recv ( comm , result % energy % scf , source , tag , status ) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive fragment metadata call recv ( comm , result % distance , source , tag , status ) ! Receive gradient flag and data if present call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data if present call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if ! Receive dipole flag and data if present call recv ( comm , result % has_dipole , source , tag , status ) if ( result % has_dipole ) then ! Receive allocatable dipole array (MPI lib handles allocation) call recv ( comm , result % dipole , source , tag , status ) end if ! Receive dipole derivatives flag and data if present call recv ( comm , result % has_dipole_derivatives , source , tag , status ) if ( result % has_dipole_derivatives ) then ! Receive allocatable dipole derivatives array (MPI lib handles allocation) call recv ( comm , result % dipole_derivatives , source , tag , status ) end if end subroutine result_recv","tags":"","url":"proc/result_recv.html"},{"title":"result_send – metalquicha","text":"public  subroutine result_send(result, comm, dest, tag) Send calculation result over MPI (blocking)\nSends energy components and conditionally sends gradient based on has_gradient flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag Calls proc~~result_send~~CallsGraph proc~result_send result_send send send proc~result_send->send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_send ( result , comm , dest , tag ) !! Send calculation result over MPI (blocking) !! Sends energy components and conditionally sends gradient based on has_gradient flag type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag ! Send energy components call send ( comm , result % energy % scf , dest , tag ) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send fragment metadata call send ( comm , result % distance , dest , tag ) ! Send gradient flag and data if present call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if ! Send Hessian flag and data if present call send ( comm , result % has_hessian , dest , tag ) if ( result % has_hessian ) then call send ( comm , result % hessian , dest , tag ) end if ! Send dipole flag and data if present call send ( comm , result % has_dipole , dest , tag ) if ( result % has_dipole ) then call send ( comm , result % dipole , dest , tag ) end if ! Send dipole derivatives flag and data if present call send ( comm , result % has_dipole_derivatives , dest , tag ) if ( result % has_dipole_derivatives ) then call send ( comm , result % dipole_derivatives , dest , tag ) end if end subroutine result_send","tags":"","url":"proc/result_send.html"},{"title":"cc_check_stability – metalquicha","text":"private  subroutine cc_check_stability(this) Uses pic_logger proc~~cc_check_stability~~UsesGraph proc~cc_check_stability cc_energy_t%cc_check_stability pic_logger pic_logger proc~cc_check_stability->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Check for positive CC correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Type Bound cc_energy_t Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Calls proc~~cc_check_stability~~CallsGraph proc~cc_check_stability cc_energy_t%cc_check_stability warning warning proc~cc_check_stability->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine cc_check_stability ( this ) !! Check for positive CC correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( cc_energy_t ), intent ( in ) :: this if ( this % singles > 0.0_dp ) then call logger % warning ( \"CC singles correlation energy is positive - possible instability!\" ) end if if ( this % doubles > 0.0_dp ) then call logger % warning ( \"CC doubles correlation energy is positive - possible instability!\" ) end if if ( this % triples > 0.0_dp ) then call logger % warning ( \"CC triples correlation energy is positive - possible instability!\" ) end if end subroutine cc_check_stability","tags":"","url":"proc/cc_check_stability.html"},{"title":"cc_reset – metalquicha","text":"private  subroutine cc_reset(this) Reset all CC components to zero Type Bound cc_energy_t Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(inout) :: this Source Code subroutine cc_reset ( this ) !! Reset all CC components to zero class ( cc_energy_t ), intent ( inout ) :: this this % singles = 0.0_dp this % doubles = 0.0_dp this % triples = 0.0_dp end subroutine cc_reset","tags":"","url":"proc/cc_reset.html"},{"title":"energy_reset – metalquicha","text":"private  subroutine energy_reset(this) Reset all energy components to zero Type Bound energy_t Arguments Type Intent Optional Attributes Name class( energy_t ), intent(inout) :: this Calls proc~~energy_reset~~CallsGraph proc~energy_reset energy_t%energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~energy_reset~~CalledByGraph proc~energy_reset energy_t%energy_reset proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~energy_reset proc~result_reset calculation_result_t%result_reset proc~result_reset->proc~energy_reset interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~result_destroy calculation_result_t%result_destroy proc~result_destroy->proc~result_reset proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~result_destroy proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~result_destroy proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~result_destroy interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine energy_reset ( this ) !! Reset all energy components to zero class ( energy_t ), intent ( inout ) :: this this % scf = 0.0_dp call this % mp2 % reset () call this % cc % reset () end subroutine energy_reset","tags":"","url":"proc/energy_reset.html"},{"title":"mbe_result_allocate_dipole – metalquicha","text":"private  subroutine mbe_result_allocate_dipole(this) Allocate dipole array (always 3 components) Type Bound mbe_result_t Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this Called by proc~~mbe_result_allocate_dipole~~CalledByGraph proc~mbe_result_allocate_dipole mbe_result_t%mbe_result_allocate_dipole proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~mbe_result_allocate_dipole interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mbe_result_allocate_dipole ( this ) !! Allocate dipole array (always 3 components) class ( mbe_result_t ), intent ( inout ) :: this if ( allocated ( this % dipole )) deallocate ( this % dipole ) allocate ( this % dipole ( 3 )) this % dipole = 0.0_dp end subroutine mbe_result_allocate_dipole","tags":"","url":"proc/mbe_result_allocate_dipole.html"},{"title":"mbe_result_allocate_gradient – metalquicha","text":"private  subroutine mbe_result_allocate_gradient(this, total_atoms) Allocate gradient array for total_atoms Type Bound mbe_result_t Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this integer, intent(in) :: total_atoms Called by proc~~mbe_result_allocate_gradient~~CalledByGraph proc~mbe_result_allocate_gradient mbe_result_t%mbe_result_allocate_gradient proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~mbe_result_allocate_gradient interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mbe_result_allocate_gradient ( this , total_atoms ) !! Allocate gradient array for total_atoms class ( mbe_result_t ), intent ( inout ) :: this integer , intent ( in ) :: total_atoms if ( allocated ( this % gradient )) deallocate ( this % gradient ) allocate ( this % gradient ( 3 , total_atoms )) this % gradient = 0.0_dp end subroutine mbe_result_allocate_gradient","tags":"","url":"proc/mbe_result_allocate_gradient.html"},{"title":"mbe_result_allocate_hessian – metalquicha","text":"private  subroutine mbe_result_allocate_hessian(this, total_atoms) Allocate hessian array for total_atoms Type Bound mbe_result_t Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this integer, intent(in) :: total_atoms Called by proc~~mbe_result_allocate_hessian~~CalledByGraph proc~mbe_result_allocate_hessian mbe_result_t%mbe_result_allocate_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~mbe_result_allocate_hessian interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: hess_dim Source Code subroutine mbe_result_allocate_hessian ( this , total_atoms ) !! Allocate hessian array for total_atoms class ( mbe_result_t ), intent ( inout ) :: this integer , intent ( in ) :: total_atoms integer :: hess_dim hess_dim = 3 * total_atoms if ( allocated ( this % hessian )) deallocate ( this % hessian ) allocate ( this % hessian ( hess_dim , hess_dim )) this % hessian = 0.0_dp end subroutine mbe_result_allocate_hessian","tags":"","url":"proc/mbe_result_allocate_hessian.html"},{"title":"mbe_result_destroy – metalquicha","text":"private  subroutine mbe_result_destroy(this) Clean up allocated memory in mbe_result_t Type Bound mbe_result_t Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this Calls proc~~mbe_result_destroy~~CallsGraph proc~mbe_result_destroy mbe_result_t%mbe_result_destroy proc~mbe_result_reset mbe_result_t%mbe_result_reset proc~mbe_result_destroy->proc~mbe_result_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mbe_result_destroy ( this ) !! Clean up allocated memory in mbe_result_t class ( mbe_result_t ), intent ( inout ) :: this if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) if ( allocated ( this % dipole_derivatives )) deallocate ( this % dipole_derivatives ) call this % reset () end subroutine mbe_result_destroy","tags":"","url":"proc/mbe_result_destroy.html"},{"title":"mbe_result_reset – metalquicha","text":"private  subroutine mbe_result_reset(this) Reset all values and flags in mbe_result_t Type Bound mbe_result_t Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this Called by proc~~mbe_result_reset~~CalledByGraph proc~mbe_result_reset mbe_result_t%mbe_result_reset proc~mbe_result_destroy mbe_result_t%mbe_result_destroy proc~mbe_result_destroy->proc~mbe_result_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mbe_result_reset ( this ) !! Reset all values and flags in mbe_result_t class ( mbe_result_t ), intent ( inout ) :: this this % total_energy = 0.0_dp this % has_energy = . false . this % has_gradient = . false . this % has_hessian = . false . this % has_dipole = . false . this % has_dipole_derivatives = . false . end subroutine mbe_result_reset","tags":"","url":"proc/mbe_result_reset.html"},{"title":"mp2_check_stability – metalquicha","text":"private  subroutine mp2_check_stability(this) Uses pic_logger proc~~mp2_check_stability~~UsesGraph proc~mp2_check_stability mp2_energy_t%mp2_check_stability pic_logger pic_logger proc~mp2_check_stability->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Check for positive MP2 correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Calls proc~~mp2_check_stability~~CallsGraph proc~mp2_check_stability mp2_energy_t%mp2_check_stability warning warning proc~mp2_check_stability->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mp2_check_stability ( this ) !! Check for positive MP2 correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( mp2_energy_t ), intent ( in ) :: this if ( this % ss > 0.0_dp ) then call logger % warning ( \"MP2 same-spin correlation energy is positive - possible instability!\" ) end if if ( this % os > 0.0_dp ) then call logger % warning ( \"MP2 opposite-spin correlation energy is positive - possible instability!\" ) end if end subroutine mp2_check_stability","tags":"","url":"proc/mp2_check_stability.html"},{"title":"mp2_reset – metalquicha","text":"private  subroutine mp2_reset(this) Reset both MP2 components to zero Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(inout) :: this Called by proc~~mp2_reset~~CalledByGraph proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset energy_t%energy_reset proc~energy_reset->proc~mp2_reset proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~energy_reset proc~result_reset calculation_result_t%result_reset proc~result_reset->proc~energy_reset interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~result_destroy calculation_result_t%result_destroy proc~result_destroy->proc~result_reset proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~result_destroy proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~result_destroy proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~result_destroy interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mp2_reset ( this ) !! Reset both MP2 components to zero class ( mp2_energy_t ), intent ( inout ) :: this this % ss = 0.0_dp this % os = 0.0_dp end subroutine mp2_reset","tags":"","url":"proc/mp2_reset.html"},{"title":"result_destroy – metalquicha","text":"private  subroutine result_destroy(this) Clean up allocated memory in calculation_result_t Type Bound calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Calls proc~~result_destroy~~CallsGraph proc~result_destroy calculation_result_t%result_destroy proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_destroy~~CalledByGraph proc~result_destroy calculation_result_t%result_destroy proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~result_destroy proc~run_calculation run_calculation proc~compute_energy_and_forces->proc~run_calculation proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~result_destroy proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~result_destroy interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_destroy ( this ) !! Clean up allocated memory in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % sigma )) deallocate ( this % sigma ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) if ( allocated ( this % dipole_derivatives )) deallocate ( this % dipole_derivatives ) call this % reset () end subroutine result_destroy","tags":"","url":"proc/result_destroy.html"},{"title":"result_reset – metalquicha","text":"private  subroutine result_reset(this) Reset all values and flags in calculation_result_t Type Bound calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Calls proc~~result_reset~~CallsGraph proc~result_reset calculation_result_t%result_reset proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_reset~~CalledByGraph proc~result_reset calculation_result_t%result_reset proc~result_destroy calculation_result_t%result_destroy proc~result_destroy->proc~result_reset proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~result_destroy proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~result_destroy proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~result_destroy interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_reset ( this ) !! Reset all values and flags in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this call this % energy % reset () call this % error % clear () this % has_energy = . false . this % has_gradient = . false . this % has_sigma = . false . this % has_hessian = . false . this % has_dipole = . false . this % has_dipole_derivatives = . false . this % has_error = . false . end subroutine result_reset","tags":"","url":"proc/result_reset.html"},{"title":"parse_method_string – metalquicha","text":"private  function parse_method_string(method_str) result(method_type) Parse method string from input file (e.g., “XTB-GFN1” -> gfn1) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Return Value integer(kind=int32) Calls proc~~parse_method_string~~CallsGraph proc~parse_method_string parse_method_string proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_method_string~~CalledByGraph proc~parse_method_string parse_method_string proc~parse_model_section parse_model_section proc~parse_model_section->proc~parse_method_string proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_model_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: dash_pos integer, private :: i character(len=:), private, allocatable :: lower_str character(len=:), private, allocatable :: method_part Source Code function parse_method_string ( method_str ) result ( method_type ) !! Parse method string from input file (e.g., \"XTB-GFN1\" -> gfn1) character ( len =* ), intent ( in ) :: method_str integer ( int32 ) :: method_type character ( len = :), allocatable :: lower_str , method_part integer :: dash_pos , i ! Convert to lowercase allocate ( character ( len = len_trim ( method_str )) :: lower_str ) lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Handle \"XTB-GFN1\" format -> extract \"gfn1\" if ( index ( lower_str , 'xtb' ) > 0 ) then dash_pos = index ( lower_str , '-' ) if ( dash_pos > 0 ) then method_part = lower_str ( dash_pos + 1 :) else method_part = lower_str end if else method_part = lower_str end if method_type = method_type_from_string ( method_part ) end function parse_method_string","tags":"","url":"proc/parse_method_string.html"},{"title":"strip_comment – metalquicha","text":"private pure function strip_comment(line) result(stripped) Remove comments (! or #) from a line and trim result Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value character(len=:), allocatable Called by proc~~strip_comment~~CalledByGraph proc~strip_comment strip_comment proc~parse_aimd_section parse_aimd_section proc~parse_aimd_section->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~parse_driver_section parse_driver_section proc~parse_driver_section->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragment->proc~strip_comment proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~strip_comment proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~strip_comment proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_generic->proc~skip_to_end proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_generic->proc~strip_comment proc~parse_hessian_section parse_hessian_section proc~parse_hessian_section->proc~strip_comment proc~parse_model_section parse_model_section proc~parse_model_section->proc~strip_comment proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~strip_comment proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~skip_to_end proc~parse_scf_section parse_scf_section proc~parse_scf_section->proc~strip_comment proc~parse_schema_section parse_schema_section proc~parse_schema_section->proc~strip_comment proc~parse_single_molecule->proc~strip_comment proc~parse_single_molecule->proc~skip_to_end proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic parse_structure_generic proc~parse_structure_generic->proc~strip_comment proc~parse_system_section parse_system_section proc~parse_system_section->proc~strip_comment proc~parse_xtb_section parse_xtb_section proc~parse_xtb_section->proc~strip_comment proc~skip_to_end->proc~strip_comment proc~parse_connectivity_section parse_connectivity_section proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_section parse_geometry_section proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_structure_section parse_structure_section proc~parse_structure_section->proc~parse_structure_generic proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_aimd_section proc~read_mqc_file->proc~parse_driver_section proc~read_mqc_file->proc~parse_fragmentation_section proc~read_mqc_file->proc~parse_hessian_section proc~read_mqc_file->proc~parse_model_section proc~read_mqc_file->proc~parse_molecules_section proc~read_mqc_file->proc~parse_scf_section proc~read_mqc_file->proc~parse_schema_section proc~read_mqc_file->proc~parse_system_section proc~read_mqc_file->proc~parse_xtb_section proc~read_mqc_file->proc~skip_to_end proc~read_mqc_file->proc~parse_connectivity_section proc~read_mqc_file->proc~parse_fragments_section proc~read_mqc_file->proc~parse_geometry_section proc~read_mqc_file->proc~parse_structure_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: comment_pos Source Code pure function strip_comment ( line ) result ( stripped ) !! Remove comments (! or #) from a line and trim result character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: stripped integer :: comment_pos ! Find first occurrence of ! or # comment_pos = index ( line , '!' ) if ( comment_pos == 0 ) comment_pos = index ( line , '#' ) if ( comment_pos > 0 ) then ! Comment found - take everything before it stripped = trim ( adjustl ( line ( 1 : comment_pos - 1 ))) else ! No comment - use full line stripped = trim ( adjustl ( line )) end if end function strip_comment","tags":"","url":"proc/strip_comment.html"},{"title":"read_mqc_file – metalquicha","text":"public  subroutine read_mqc_file(filename, config, error) Read and parse a .mqc format input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( mqc_config_t ), intent(out) :: config type( error_t ), intent(out) :: error Calls proc~~read_mqc_file~~CallsGraph proc~read_mqc_file read_mqc_file proc~error_add_context error_t%error_add_context proc~read_mqc_file->proc~error_add_context proc~error_has_error error_t%error_has_error proc~read_mqc_file->proc~error_has_error proc~error_set error_t%error_set proc~read_mqc_file->proc~error_set proc~parse_aimd_section parse_aimd_section proc~read_mqc_file->proc~parse_aimd_section proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_driver_section parse_driver_section proc~read_mqc_file->proc~parse_driver_section proc~parse_fragmentation_section parse_fragmentation_section proc~read_mqc_file->proc~parse_fragmentation_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_geometry_section parse_geometry_section proc~read_mqc_file->proc~parse_geometry_section proc~parse_hessian_section parse_hessian_section proc~read_mqc_file->proc~parse_hessian_section proc~parse_model_section parse_model_section proc~read_mqc_file->proc~parse_model_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_scf_section parse_scf_section proc~read_mqc_file->proc~parse_scf_section proc~parse_schema_section parse_schema_section proc~read_mqc_file->proc~parse_schema_section proc~parse_structure_section parse_structure_section proc~read_mqc_file->proc~parse_structure_section proc~parse_system_section parse_system_section proc~read_mqc_file->proc~parse_system_section proc~parse_xtb_section parse_xtb_section proc~read_mqc_file->proc~parse_xtb_section proc~skip_to_end skip_to_end proc~read_mqc_file->proc~skip_to_end proc~parse_aimd_section->proc~error_set proc~strip_comment strip_comment proc~parse_aimd_section->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_driver_section->proc~error_set proc~calc_type_from_string calc_type_from_string proc~parse_driver_section->proc~calc_type_from_string proc~parse_driver_section->proc~strip_comment proc~parse_fragmentation_section->proc~error_add_context proc~parse_fragmentation_section->proc~error_has_error proc~parse_fragmentation_section->proc~error_set proc~parse_fragmentation_section->proc~strip_comment proc~validate_cutoffs validate_cutoffs proc~parse_fragmentation_section->proc~validate_cutoffs proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_hessian_section->proc~error_set proc~parse_hessian_section->proc~strip_comment proc~parse_model_section->proc~error_set proc~parse_method_string parse_method_string proc~parse_model_section->proc~parse_method_string proc~parse_model_section->proc~strip_comment proc~parse_molecules_section->proc~error_add_context proc~parse_molecules_section->proc~error_has_error proc~parse_molecules_section->proc~error_set proc~parse_molecules_section->proc~skip_to_end proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~strip_comment proc~parse_scf_section->proc~error_set proc~parse_scf_section->proc~strip_comment proc~parse_schema_section->proc~error_set proc~parse_schema_section->proc~strip_comment proc~parse_structure_generic parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~parse_system_section->proc~error_set proc~parse_system_section->proc~strip_comment proc~parse_xtb_section->proc~error_set proc~parse_xtb_section->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_add_context proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string proc~parse_single_molecule->proc~error_add_context proc~parse_single_molecule->proc~error_has_error proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_single_molecule->proc~strip_comment proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~validate_cutoffs->proc~error_set proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_mqc_file~~CalledByGraph proc~read_mqc_file read_mqc_file program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: file_exists integer, private :: io_stat character(len=MAX_LINE_LEN), private :: line type( error_t ), private :: parse_error integer, private :: unit Source Code subroutine read_mqc_file ( filename , config , error ) !! Read and parse a .mqc format input file character ( len =* ), intent ( in ) :: filename type ( mqc_config_t ), intent ( out ) :: config type ( error_t ), intent ( out ) :: error integer :: unit , io_stat character ( len = MAX_LINE_LEN ) :: line logical :: file_exists type ( error_t ) :: parse_error inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"Input file not found: \" // trim ( filename )) return end if open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening input file: \" // trim ( filename )) return end if ! Set defaults config % log_level = \"info\" ! Read file line by line and dispatch to section parsers do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for section start if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%schema' ) call parse_schema_section ( unit , config , parse_error ) case ( '%model' ) call parse_model_section ( unit , config , parse_error ) case ( '%driver' ) call parse_driver_section ( unit , config , parse_error ) case ( '%structure' ) call parse_structure_section ( unit , config , parse_error ) case ( '%geometry' ) call parse_geometry_section ( unit , config , parse_error ) case ( '%fragments' ) call parse_fragments_section ( unit , config , parse_error ) case ( '%connectivity' ) call parse_connectivity_section ( unit , config , parse_error ) case ( '%scf' ) call parse_scf_section ( unit , config , parse_error ) case ( '%xtb' ) call parse_xtb_section ( unit , config , parse_error ) case ( '%hessian' ) call parse_hessian_section ( unit , config , parse_error ) case ( '%aimd' ) call parse_aimd_section ( unit , config , parse_error ) case ( '%fragmentation' ) call parse_fragmentation_section ( unit , config , parse_error ) case ( '%system' ) call parse_system_section ( unit , config , parse_error ) case ( '%molecules' ) call parse_molecules_section ( unit , config , parse_error ) case default ! Skip unknown sections call skip_to_end ( unit , parse_error ) end select if ( parse_error % has_error ()) then error = parse_error call error % add_context ( \"mqc_config_parser:read_mqc_file\" ) close ( unit ) return end if end if end do close ( unit ) ! Validate required fields if (. not . allocated ( config % schema_name )) then call error % set ( ERROR_VALIDATION , \"Missing required section: %schema\" ) return end if ! Validate geometry: required for single-molecule mode, not for multi-molecule mode if ( config % nmol == 0 ) then ! Single molecule mode: require top-level geometry if (. not . allocated ( config % geometry % coords ) . or . config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"Missing required section: %geometry\" ) return end if else ! Multi-molecule mode: each molecule must have geometry (validated during parsing) ! No additional validation needed here end if end subroutine read_mqc_file","tags":"","url":"proc/read_mqc_file.html"},{"title":"config_destroy – metalquicha","text":"private  subroutine config_destroy(this) Clean up allocated memory in mqc_config_t Type Bound mqc_config_t Arguments Type Intent Optional Attributes Name class( mqc_config_t ), intent(inout) :: this Calls proc~~config_destroy~~CallsGraph proc~config_destroy mqc_config_t%config_destroy proc~geometry_destroy geometry_type%geometry_destroy proc~config_destroy->proc~geometry_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine config_destroy ( this ) !! Clean up allocated memory in mqc_config_t class ( mqc_config_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % schema_name )) deallocate ( this % schema_name ) if ( allocated ( this % schema_version )) deallocate ( this % schema_version ) if ( allocated ( this % units )) deallocate ( this % units ) if ( allocated ( this % basis )) deallocate ( this % basis ) if ( allocated ( this % aux_basis )) deallocate ( this % aux_basis ) if ( allocated ( this % log_level )) deallocate ( this % log_level ) if ( allocated ( this % frag_method )) deallocate ( this % frag_method ) if ( allocated ( this % embedding )) deallocate ( this % embedding ) if ( allocated ( this % cutoff_method )) deallocate ( this % cutoff_method ) if ( allocated ( this % distance_metric )) deallocate ( this % distance_metric ) if ( allocated ( this % fragment_cutoffs )) deallocate ( this % fragment_cutoffs ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) ! Clean up molecules array (multi-molecule mode) if ( allocated ( this % molecules )) then do i = 1 , size ( this % molecules ) call this % molecules ( i )% destroy () end do deallocate ( this % molecules ) end if end subroutine config_destroy","tags":"","url":"proc/config_destroy.html"},{"title":"input_fragment_destroy – metalquicha","text":"private  subroutine input_fragment_destroy(this) Clean up allocated memory in input_fragment_t Type Bound input_fragment_t Arguments Type Intent Optional Attributes Name class( input_fragment_t ), intent(inout) :: this Source Code subroutine input_fragment_destroy ( this ) !! Clean up allocated memory in input_fragment_t class ( input_fragment_t ), intent ( inout ) :: this if ( allocated ( this % indices )) deallocate ( this % indices ) end subroutine input_fragment_destroy","tags":"","url":"proc/input_fragment_destroy.html"},{"title":"molecule_destroy – metalquicha","text":"private  subroutine molecule_destroy(this) Clean up allocated memory in molecule_t Type Bound molecule_t Arguments Type Intent Optional Attributes Name class( molecule_t ), intent(inout) :: this Calls proc~~molecule_destroy~~CallsGraph proc~molecule_destroy molecule_t%molecule_destroy proc~geometry_destroy geometry_type%geometry_destroy proc~molecule_destroy->proc~geometry_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine molecule_destroy ( this ) !! Clean up allocated memory in molecule_t class ( molecule_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % name )) deallocate ( this % name ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) end subroutine molecule_destroy","tags":"","url":"proc/molecule_destroy.html"},{"title":"parse_aimd_section – metalquicha","text":"private  subroutine parse_aimd_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_aimd_section~~CallsGraph proc~parse_aimd_section parse_aimd_section proc~error_set error_t%error_set proc~parse_aimd_section->proc~error_set proc~strip_comment strip_comment proc~parse_aimd_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_aimd_section~~CalledByGraph proc~parse_aimd_section parse_aimd_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_aimd_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_aimd_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %aimd section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'dt' , 'timestep' ) read ( value , * , iostat = io_stat ) config % aimd_dt case ( 'nsteps' , 'steps' ) read ( value , * , iostat = io_stat ) config % aimd_nsteps case ( 'initial_temperature' , 'temperature' ) read ( value , * , iostat = io_stat ) config % aimd_initial_temperature case ( 'output_frequency' , 'output_freq' ) read ( value , * , iostat = io_stat ) config % aimd_output_frequency case default call error % set ( ERROR_PARSE , \"Unknown key in %aimd section: \" // trim ( key )) return end select end do end subroutine parse_aimd_section","tags":"","url":"proc/parse_aimd_section.html"},{"title":"parse_connectivity_generic – metalquicha","text":"private  subroutine parse_connectivity_generic(unit, nbonds, nbroken, bonds, error) Generic parser for %connectivity section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nbonds integer, intent(inout) :: nbroken type( bond_t ), intent(inout), allocatable :: bonds (:) type( error_t ), intent(out) :: error Calls proc~~parse_connectivity_generic~~CallsGraph proc~parse_connectivity_generic parse_connectivity_generic proc~error_set error_t%error_set proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_connectivity_generic~~CalledByGraph proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section parse_connectivity_section proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_connectivity proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_connectivity_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_i integer, private :: atom_j integer, private :: eq_pos integer, private :: ibond integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line integer, private :: nbonds_local integer, private :: order character(len=MAX_LINE_LEN), private :: status_str character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_connectivity_generic ( unit , nbonds , nbroken , bonds , error ) !! Generic parser for %connectivity section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nbonds , nbroken type ( bond_t ), allocatable , intent ( inout ) :: bonds (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value , status_str integer :: io_stat , eq_pos , nbonds_local , ibond integer :: atom_i , atom_j , order nbonds_local = 0 ! First pass: read nbonds do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %connectivity section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbonds' ) then read ( value , * , iostat = io_stat ) nbonds_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nbonds value\" ) return end if exit end if end if end do if ( nbonds_local == 0 ) then ! No bonds, just skip to end call skip_to_end ( unit , error ) return end if nbonds = nbonds_local allocate ( bonds ( nbonds )) ! Read bonds ibond = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for key=value pairs (like nbroken=9) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbroken' ) then read ( value , * , iostat = io_stat ) nbroken end if cycle end if if ( trim ( strip_comment ( line )) == 'end' ) exit ! Parse bond line: atom_i atom_j order broken/preserved read ( line , * , iostat = io_stat ) atom_i , atom_j , order , status_str if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid bond format in %connectivity section\" ) return end if ibond = ibond + 1 if ( ibond > nbonds ) then call error % set ( ERROR_PARSE , \"More bonds than declared nbonds\" ) return end if bonds ( ibond )% atom_i = atom_i bonds ( ibond )% atom_j = atom_j bonds ( ibond )% order = order bonds ( ibond )% is_broken = ( trim ( status_str ) == 'broken' ) end do end subroutine parse_connectivity_generic","tags":"","url":"proc/parse_connectivity_generic.html"},{"title":"parse_connectivity_section – metalquicha","text":"private  subroutine parse_connectivity_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_connectivity_section~~CallsGraph proc~parse_connectivity_section parse_connectivity_section proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section->proc~parse_connectivity_generic proc~error_set error_t%error_set proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_connectivity_section~~CalledByGraph proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_connectivity_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_connectivity_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , config % nbonds , config % nbroken , config % bonds , error ) end subroutine parse_connectivity_section","tags":"","url":"proc/parse_connectivity_section.html"},{"title":"parse_driver_section – metalquicha","text":"private  subroutine parse_driver_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_driver_section~~CallsGraph proc~parse_driver_section parse_driver_section proc~calc_type_from_string calc_type_from_string proc~parse_driver_section->proc~calc_type_from_string proc~error_set error_t%error_set proc~parse_driver_section->proc~error_set proc~strip_comment strip_comment proc~parse_driver_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_driver_section~~CalledByGraph proc~parse_driver_section parse_driver_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_driver_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_driver_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %driver section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'type' ) config % calc_type = calc_type_from_string ( trim ( value )) if ( config % calc_type == CALC_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid calc_type: \" // trim ( value )) return end if case default call error % set ( ERROR_PARSE , \"Unknown key in %driver section: \" // trim ( key )) return end select end do end subroutine parse_driver_section","tags":"","url":"proc/parse_driver_section.html"},{"title":"parse_fragment – metalquicha","text":"private  subroutine parse_fragment(unit, fragment, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error Calls proc~~parse_fragment~~CallsGraph proc~parse_fragment parse_fragment proc~error_add_context error_t%error_add_context proc~parse_fragment->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_fragment->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragment->proc~error_set proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~strip_comment strip_comment proc~parse_fragment->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragment~~CalledByGraph proc~parse_fragment parse_fragment proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments parse_molecule_fragments proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos logical, private :: in_indices integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_fragment ( unit , fragment , error ) integer , intent ( in ) :: unit type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_indices in_indices = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragment\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_indices ) then in_indices = . false . cycle else exit end if end if if ( trim ( line ) == '%indices' ) then in_indices = . true . cycle end if if ( in_indices ) then ! Read indices call parse_indices_line ( line , fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_single_fragment_section\" ) return end if else eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) fragment % charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) fragment % multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in fragment properties: \" // trim ( key )) return end select end if end if end do end subroutine parse_fragment","tags":"","url":"proc/parse_fragment.html"},{"title":"parse_fragmentation_section – metalquicha","text":"private  subroutine parse_fragmentation_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_fragmentation_section~~CallsGraph proc~parse_fragmentation_section parse_fragmentation_section proc~error_add_context error_t%error_add_context proc~parse_fragmentation_section->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_fragmentation_section->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragmentation_section->proc~error_set proc~strip_comment strip_comment proc~parse_fragmentation_section->proc~strip_comment proc~validate_cutoffs validate_cutoffs proc~parse_fragmentation_section->proc~validate_cutoffs proc~validate_cutoffs->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragmentation_section~~CalledByGraph proc~parse_fragmentation_section parse_fragmentation_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragmentation_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos logical, private :: in_cutoffs integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_fragmentation_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_cutoffs in_cutoffs = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragmentation section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_cutoffs ) then ! Validate cutoffs before leaving the cutoffs section call validate_cutoffs ( config , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_fragmentation_section\" ) return end if in_cutoffs = . false . cycle else exit end if end if if ( trim ( line ) == '%cutoffs' ) then in_cutoffs = . true . cycle end if eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( in_cutoffs ) then ! Parse cutoffs: numeric keys like \"2\", \"3\", \"4\", etc. ! representing n-mer level (2=dimer, 3=trimer, etc.) block integer :: nmer_level real ( dp ) :: cutoff_value ! Try to read the key as an integer (n-mer level) read ( key , * , iostat = io_stat ) nmer_level if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid n-mer level in cutoffs (expected integer): \" // trim ( key )) return end if ! Validate n-mer level if ( nmer_level < 2 ) then call error % set ( ERROR_PARSE , \"N-mer level must be >= 2 in cutoffs\" ) return end if if ( nmer_level > 10 ) then call error % set ( ERROR_PARSE , \"N-mer level too large in cutoffs (max 10 for decamer)\" ) return end if ! Read the cutoff value read ( value , * , iostat = io_stat ) cutoff_value if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid cutoff value: \" // trim ( value )) return end if ! Allocate array if not yet allocated (up to decamer = 10) if (. not . allocated ( config % fragment_cutoffs )) then allocate ( config % fragment_cutoffs ( 10 )) config % fragment_cutoffs = - 1.0_dp ! Initialize with sentinel value end if ! Store the cutoff value at the appropriate index config % fragment_cutoffs ( nmer_level ) = cutoff_value end block else select case ( trim ( key )) case ( 'method' ) config % frag_method = trim ( value ) case ( 'level' ) read ( value , * , iostat = io_stat ) config % frag_level if ( io_stat == 0 ) then if ( config % frag_level < 0 ) then call error % set ( ERROR_VALIDATION , \"Fragmentation level must be >= 0 (0 = unfragmented)\" ) return end if if ( config % frag_level > 10 ) then call error % set ( ERROR_VALIDATION , & \"Fragmentation level must be <= 10 (decamers). Higher levels not supported.\" ) return end if end if case ( 'allow_overlapping_fragments' ) config % allow_overlapping_fragments = ( trim ( value ) == 'true' ) case ( 'max_intersection_level' ) read ( value , * , iostat = io_stat ) config % max_intersection_level if ( io_stat == 0 ) then if ( config % max_intersection_level < 1 ) then call error % set ( ERROR_VALIDATION , \"max_intersection_level must be >= 1\" ) return end if if ( config % max_intersection_level > 10 ) then call error % set ( ERROR_VALIDATION , & \"max_intersection_level must be <= 10 (decamers). Higher levels not supported.\" ) return end if end if case ( 'embedding' ) config % embedding = trim ( value ) case ( 'cutoff_method' ) config % cutoff_method = trim ( value ) case ( 'distance_metric' ) config % distance_metric = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %fragmentation section: \" // trim ( key )) return end select end if end do end subroutine parse_fragmentation_section","tags":"","url":"proc/parse_fragmentation_section.html"},{"title":"parse_fragments_generic – metalquicha","text":"private  subroutine parse_fragments_generic(unit, nfrag, fragments, error) Generic parser for %fragments section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nfrag type( input_fragment_t ), intent(inout), allocatable :: fragments (:) type( error_t ), intent(out) :: error Calls proc~~parse_fragments_generic~~CallsGraph proc~parse_fragments_generic parse_fragments_generic proc~error_add_context error_t%error_add_context proc~parse_fragments_generic->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_fragments_generic->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragments_generic->proc~error_set proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~skip_to_end skip_to_end proc~parse_fragments_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragments_generic~~CalledByGraph proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments parse_molecule_fragments proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: ifrag integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=256), private :: msg integer, private :: nfrag_local character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_fragments_generic ( unit , nfrag , fragments , error ) !! Generic parser for %fragments section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nfrag type ( input_fragment_t ), allocatable , intent ( inout ) :: fragments (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nfrag_local , ifrag nfrag_local = 0 ! First pass: read nfrag do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragments section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nfrag' ) then read ( value , * , iostat = io_stat ) nfrag_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nfrag value\" ) return end if exit end if end if end do if ( nfrag_local == 0 ) then ! No fragments, just skip to end call skip_to_end ( unit , error ) return end if nfrag = nfrag_local allocate ( fragments ( nfrag )) ! Parse individual fragments ifrag = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%fragment' ) then ifrag = ifrag + 1 if ( ifrag > nfrag ) then call error % set ( ERROR_PARSE , \"More fragments than declared nfrag\" ) return end if call parse_fragment ( unit , fragments ( ifrag ), error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_molecule_fragments\" ) return end if end if end do if ( ifrag /= nfrag ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nfrag , \" fragments, found \" , ifrag call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_fragments_generic","tags":"","url":"proc/parse_fragments_generic.html"},{"title":"parse_fragments_section – metalquicha","text":"private  subroutine parse_fragments_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_fragments_section~~CallsGraph proc~parse_fragments_section parse_fragments_section proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~error_add_context error_t%error_add_context proc~parse_fragments_generic->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_fragments_generic->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragments_generic->proc~error_set proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~skip_to_end skip_to_end proc~parse_fragments_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragments_section~~CalledByGraph proc~parse_fragments_section parse_fragments_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_fragments_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , config % nfrag , config % fragments , error ) end subroutine parse_fragments_section","tags":"","url":"proc/parse_fragments_section.html"},{"title":"parse_geometry_generic – metalquicha","text":"private  subroutine parse_geometry_generic(unit, geom, error) Generic parser for %geometry section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( geometry_type ), intent(inout) :: geom type( error_t ), intent(out) :: error Calls proc~~parse_geometry_generic~~CallsGraph proc~parse_geometry_generic parse_geometry_generic proc~error_set error_t%error_set proc~parse_geometry_generic->proc~error_set proc~strip_comment strip_comment proc~parse_geometry_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_geometry_generic~~CalledByGraph proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section parse_geometry_section proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_molecule_geometry parse_molecule_geometry proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_geometry proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_geometry_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=MAX_LINE_LEN), private :: elem integer, private :: i integer, private :: io_stat character(len=MAX_LINE_LEN), private :: line integer, private :: natoms real(kind=dp), private :: x real(kind=dp), private :: y real(kind=dp), private :: z Source Code subroutine parse_geometry_generic ( unit , geom , error ) !! Generic parser for %geometry section (works for both config and molecule) integer , intent ( in ) :: unit type ( geometry_type ), intent ( inout ) :: geom type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , elem integer :: io_stat , natoms , i real ( dp ) :: x , y , z ! Read number of atoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading natoms in %geometry section\" ) return end if read ( line , * , iostat = io_stat ) natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid natoms in %geometry section\" ) return end if geom % natoms = natoms ! Read blank line (comment line in XYZ format) read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading comment line in %geometry section\" ) return end if geom % comment = trim ( line ) ! Allocate arrays allocate ( character ( len = 4 ) :: geom % elements ( natoms )) allocate ( geom % coords ( 3 , natoms )) ! Read coordinates do i = 1 , natoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry coordinates\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) then call error % set ( ERROR_PARSE , \"Unexpected 'end' while reading geometry\" ) return end if read ( line , * , iostat = io_stat ) elem , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid coordinate format in %geometry section\" ) return end if geom % elements ( i ) = trim ( elem ) geom % coords ( 1 , i ) = x geom % coords ( 2 , i ) = y geom % coords ( 3 , i ) = z end do ! Read 'end' marker read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_VALIDATION , \"Missing 'end' in %geometry section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) /= 'end' ) then call error % set ( ERROR_PARSE , \"Expected 'end' after geometry coordinates\" ) return end if end subroutine parse_geometry_generic","tags":"","url":"proc/parse_geometry_generic.html"},{"title":"parse_geometry_section – metalquicha","text":"private  subroutine parse_geometry_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_geometry_section~~CallsGraph proc~parse_geometry_section parse_geometry_section proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~error_set error_t%error_set proc~parse_geometry_generic->proc~error_set proc~strip_comment strip_comment proc~parse_geometry_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_geometry_section~~CalledByGraph proc~parse_geometry_section parse_geometry_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_geometry_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_geometry_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , config % geometry , error ) end subroutine parse_geometry_section","tags":"","url":"proc/parse_geometry_section.html"},{"title":"parse_hessian_section – metalquicha","text":"private  subroutine parse_hessian_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_hessian_section~~CallsGraph proc~parse_hessian_section parse_hessian_section proc~error_set error_t%error_set proc~parse_hessian_section->proc~error_set proc~strip_comment strip_comment proc~parse_hessian_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_hessian_section~~CalledByGraph proc~parse_hessian_section parse_hessian_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_hessian_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_hessian_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %hessian section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'finite_difference_displacement' , 'displacement' ) read ( value , * , iostat = io_stat ) config % hessian_displacement case ( 'temperature' ) read ( value , * , iostat = io_stat ) config % hessian_temperature if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid temperature value: \" // trim ( value )) return end if case ( 'pressure' ) read ( value , * , iostat = io_stat ) config % hessian_pressure if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid pressure value: \" // trim ( value )) return end if case default call error % set ( ERROR_PARSE , \"Unknown key in %hessian section: \" // trim ( key )) return end select end do end subroutine parse_hessian_section","tags":"","url":"proc/parse_hessian_section.html"},{"title":"parse_indices_line – metalquicha","text":"private  subroutine parse_indices_line(line, fragment, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error Calls proc~~parse_indices_line~~CallsGraph proc~parse_indices_line parse_indices_line proc~error_set error_t%error_set proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_indices_line~~CalledByGraph proc~parse_indices_line parse_indices_line proc~parse_fragment parse_fragment proc~parse_fragment->proc~parse_indices_line proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments parse_molecule_fragments proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: count integer, private :: i integer, private :: idx integer, private :: io_stat integer, private, allocatable :: new_indices (:) integer, private :: pos integer, private, allocatable :: temp_indices (:) character(len=MAX_LINE_LEN), private :: temp_line Source Code subroutine parse_indices_line ( line , fragment , error ) character ( len =* ), intent ( in ) :: line type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error integer :: io_stat , pos , count , i , idx character ( len = MAX_LINE_LEN ) :: temp_line integer , allocatable :: temp_indices (:), new_indices (:) temp_line = line ! Count how many integers count = 0 do read ( temp_line , * , iostat = io_stat ) idx if ( io_stat /= 0 ) exit count = count + 1 ! Remove the read integer from temp_line pos = scan ( temp_line , ' ' ) if ( pos == 0 ) exit temp_line = adjustl ( temp_line ( pos :)) end do if ( count == 0 ) return ! Allocate temporary array allocate ( temp_indices ( count )) ! Read the integers read ( line , * , iostat = io_stat ) temp_indices if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading fragment indices\" ) deallocate ( temp_indices ) return end if ! Append to existing indices if ( allocated ( fragment % indices )) then allocate ( new_indices ( size ( fragment % indices ) + count )) new_indices ( 1 : size ( fragment % indices )) = fragment % indices new_indices ( size ( fragment % indices ) + 1 :) = temp_indices call move_alloc ( new_indices , fragment % indices ) else call move_alloc ( temp_indices , fragment % indices ) end if end subroutine parse_indices_line","tags":"","url":"proc/parse_indices_line.html"},{"title":"parse_model_section – metalquicha","text":"private  subroutine parse_model_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_model_section~~CallsGraph proc~parse_model_section parse_model_section proc~error_set error_t%error_set proc~parse_model_section->proc~error_set proc~parse_method_string parse_method_string proc~parse_model_section->proc~parse_method_string proc~strip_comment strip_comment proc~parse_model_section->proc~strip_comment proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_model_section~~CalledByGraph proc~parse_model_section parse_model_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_model_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_model_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %model section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'method' ) ! Parse method string (e.g., \"XTB-GFN1\" -> \"gfn1\") config % method = parse_method_string ( trim ( value )) if ( config % method == METHOD_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid method: \" // trim ( value )) return end if case ( 'basis' ) config % basis = trim ( value ) case ( 'aux_basis' ) config % aux_basis = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %model section: \" // trim ( key )) return end select end do end subroutine parse_model_section","tags":"","url":"proc/parse_model_section.html"},{"title":"parse_molecule_connectivity – metalquicha","text":"private  subroutine parse_molecule_connectivity(unit, mol, error) Parse %connectivity section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_connectivity~~CallsGraph proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_connectivity_generic parse_connectivity_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~error_set error_t%error_set proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_connectivity~~CalledByGraph proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_connectivity ( unit , mol , error ) !! Parse %connectivity section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , mol % nbonds , mol % nbroken , mol % bonds , error ) end subroutine parse_molecule_connectivity","tags":"","url":"proc/parse_molecule_connectivity.html"},{"title":"parse_molecule_fragments – metalquicha","text":"private  subroutine parse_molecule_fragments(unit, mol, error) Parse %fragments section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_fragments~~CallsGraph proc~parse_molecule_fragments parse_molecule_fragments proc~parse_fragments_generic parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~error_add_context error_t%error_add_context proc~parse_fragments_generic->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_fragments_generic->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragments_generic->proc~error_set proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~skip_to_end skip_to_end proc~parse_fragments_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_fragments~~CalledByGraph proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_fragments ( unit , mol , error ) !! Parse %fragments section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , mol % nfrag , mol % fragments , error ) end subroutine parse_molecule_fragments","tags":"","url":"proc/parse_molecule_fragments.html"},{"title":"parse_molecule_geometry – metalquicha","text":"private  subroutine parse_molecule_geometry(unit, mol, error) Parse %geometry section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_geometry~~CallsGraph proc~parse_molecule_geometry parse_molecule_geometry proc~parse_geometry_generic parse_geometry_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~error_set error_t%error_set proc~parse_geometry_generic->proc~error_set proc~strip_comment strip_comment proc~parse_geometry_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_geometry~~CalledByGraph proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_geometry ( unit , mol , error ) !! Parse %geometry section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , mol % geometry , error ) end subroutine parse_molecule_geometry","tags":"","url":"proc/parse_molecule_geometry.html"},{"title":"parse_molecule_structure – metalquicha","text":"private  subroutine parse_molecule_structure(unit, mol, error) Parse %structure section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_structure~~CallsGraph proc~parse_molecule_structure parse_molecule_structure proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~error_set error_t%error_set proc~parse_structure_generic->proc~error_set proc~strip_comment strip_comment proc~parse_structure_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_structure~~CalledByGraph proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_structure ( unit , mol , error ) !! Parse %structure section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , mol % charge , mol % multiplicity , error ) end subroutine parse_molecule_structure","tags":"","url":"proc/parse_molecule_structure.html"},{"title":"parse_molecules_section – metalquicha","text":"private  subroutine parse_molecules_section(unit, config, error) Parse %molecules section containing multiple %molecule blocks Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_molecules_section~~CallsGraph proc~parse_molecules_section parse_molecules_section proc~error_add_context error_t%error_add_context proc~parse_molecules_section->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_molecules_section->proc~error_has_error proc~error_set error_t%error_set proc~parse_molecules_section->proc~error_set proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~skip_to_end skip_to_end proc~parse_molecules_section->proc~skip_to_end proc~strip_comment strip_comment proc~parse_molecules_section->proc~strip_comment proc~parse_single_molecule->proc~error_add_context proc~parse_single_molecule->proc~error_has_error proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_single_molecule->proc~strip_comment proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_fragments_generic parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_add_context proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecules_section~~CalledByGraph proc~parse_molecules_section parse_molecules_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: imol integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=256), private :: msg integer, private :: nmol character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_molecules_section ( unit , config , error ) !! Parse %molecules section containing multiple %molecule blocks integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nmol , imol nmol = 0 ! First pass: read nmol do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecules section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nmol' ) then read ( value , * , iostat = io_stat ) nmol if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nmol value\" ) return end if exit end if end if end do if ( nmol == 0 ) then ! No molecules, just skip to end call skip_to_end ( unit , error ) return end if config % nmol = nmol allocate ( config % molecules ( nmol )) ! Parse individual molecules imol = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%molecule' ) then imol = imol + 1 if ( imol > nmol ) then call error % set ( ERROR_PARSE , \"More molecules than declared nmol\" ) return end if call parse_single_molecule ( unit , config % molecules ( imol ), error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_molecules_section\" ) return end if end if end do if ( imol /= nmol ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nmol , \" molecules, found \" , imol call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_molecules_section","tags":"","url":"proc/parse_molecules_section.html"},{"title":"parse_scf_section – metalquicha","text":"private  subroutine parse_scf_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_scf_section~~CallsGraph proc~parse_scf_section parse_scf_section proc~error_set error_t%error_set proc~parse_scf_section->proc~error_set proc~strip_comment strip_comment proc~parse_scf_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_scf_section~~CalledByGraph proc~parse_scf_section parse_scf_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_scf_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_scf_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %scf section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'maxiter' ) read ( value , * , iostat = io_stat ) config % scf_maxiter case ( 'tolerance' ) read ( value , * , iostat = io_stat ) config % scf_tolerance case default call error % set ( ERROR_PARSE , \"Unknown key in %scf section: \" // trim ( key )) return end select end do end subroutine parse_scf_section","tags":"","url":"proc/parse_scf_section.html"},{"title":"parse_schema_section – metalquicha","text":"private  subroutine parse_schema_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_schema_section~~CallsGraph proc~parse_schema_section parse_schema_section proc~error_set error_t%error_set proc~parse_schema_section->proc~error_set proc~strip_comment strip_comment proc~parse_schema_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_schema_section~~CalledByGraph proc~parse_schema_section parse_schema_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_schema_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_schema_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Unexpected end of file in %schema section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'name' ) config % schema_name = trim ( value ) case ( 'version' ) config % schema_version = trim ( value ) case ( 'index_base' ) read ( value , * , iostat = io_stat ) config % index_base case ( 'units' ) config % units = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %schema section: \" // trim ( key )) return end select end do end subroutine parse_schema_section","tags":"","url":"proc/parse_schema_section.html"},{"title":"parse_single_molecule – metalquicha","text":"private  subroutine parse_single_molecule(unit, mol, error) Parse a single %molecule block with its sections Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_single_molecule~~CallsGraph proc~parse_single_molecule parse_single_molecule proc~error_add_context error_t%error_add_context proc~parse_single_molecule->proc~error_add_context proc~error_has_error error_t%error_has_error proc~parse_single_molecule->proc~error_has_error proc~error_set error_t%error_set proc~parse_single_molecule->proc~error_set proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~skip_to_end skip_to_end proc~parse_single_molecule->proc~skip_to_end proc~strip_comment strip_comment proc~parse_single_molecule->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_fragments_generic parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_add_context proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_single_molecule~~CalledByGraph proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_single_molecule ( unit , mol , error ) !! Parse a single %molecule block with its sections integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecule\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit ! Check for key=value pairs (like name) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'name' ) then mol % name = trim ( value ) cycle end if end if ! Check for subsections if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%structure' ) call parse_molecule_structure ( unit , mol , error ) case ( '%geometry' ) call parse_molecule_geometry ( unit , mol , error ) case ( '%fragments' ) call parse_molecule_fragments ( unit , mol , error ) case ( '%connectivity' ) call parse_molecule_connectivity ( unit , mol , error ) case default ! Skip unknown subsections call skip_to_end ( unit , error ) end select if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_single_molecule\" ) return end if end if end do end subroutine parse_single_molecule","tags":"","url":"proc/parse_single_molecule.html"},{"title":"parse_structure_generic – metalquicha","text":"private  subroutine parse_structure_generic(unit, charge, multiplicity, error) Generic parser for %structure section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: charge integer, intent(inout) :: multiplicity type( error_t ), intent(out) :: error Calls proc~~parse_structure_generic~~CallsGraph proc~parse_structure_generic parse_structure_generic proc~error_set error_t%error_set proc~parse_structure_generic->proc~error_set proc~strip_comment strip_comment proc~parse_structure_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_structure_generic~~CalledByGraph proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure parse_molecule_structure proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_structure_section parse_structure_section proc~parse_structure_section->proc~parse_structure_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_structure proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_structure_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_structure_generic ( unit , charge , multiplicity , error ) !! Generic parser for %structure section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: charge , multiplicity type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %structure section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in %structure section: \" // trim ( key )) return end select end do end subroutine parse_structure_generic","tags":"","url":"proc/parse_structure_generic.html"},{"title":"parse_structure_section – metalquicha","text":"private  subroutine parse_structure_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_structure_section~~CallsGraph proc~parse_structure_section parse_structure_section proc~parse_structure_generic parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~error_set error_t%error_set proc~parse_structure_generic->proc~error_set proc~strip_comment strip_comment proc~parse_structure_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_structure_section~~CalledByGraph proc~parse_structure_section parse_structure_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_structure_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_structure_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , config % charge , config % multiplicity , error ) end subroutine parse_structure_section","tags":"","url":"proc/parse_structure_section.html"},{"title":"parse_system_section – metalquicha","text":"private  subroutine parse_system_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_system_section~~CallsGraph proc~parse_system_section parse_system_section proc~error_set error_t%error_set proc~parse_system_section->proc~error_set proc~strip_comment strip_comment proc~parse_system_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_system_section~~CalledByGraph proc~parse_system_section parse_system_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_system_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_system_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %system section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'log_level' ) config % log_level = trim ( value ) case ( 'skip_json_output' ) config % skip_json_output = ( trim ( value ) == 'true' . or . trim ( value ) == '.true.' ) case default call error % set ( ERROR_PARSE , \"Unknown key in %system section: \" // trim ( key )) return end select end do end subroutine parse_system_section","tags":"","url":"proc/parse_system_section.html"},{"title":"parse_xtb_section – metalquicha","text":"private  subroutine parse_xtb_section(unit, config, error) Parse %xtb section for XTB-specific settings (solvation, etc.) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_xtb_section~~CallsGraph proc~parse_xtb_section parse_xtb_section proc~error_set error_t%error_set proc~parse_xtb_section->proc~error_set proc~strip_comment strip_comment proc~parse_xtb_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_xtb_section~~CalledByGraph proc~parse_xtb_section parse_xtb_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_xtb_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_xtb_section ( unit , config , error ) !! Parse %xtb section for XTB-specific settings (solvation, etc.) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %xtb section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'solvent' ) config % solvent = trim ( value ) case ( 'solvation_model' ) config % solvation_model = trim ( value ) case ( 'use_cds' ) config % use_cds = ( trim ( value ) == 'true' ) case ( 'use_shift' ) config % use_shift = ( trim ( value ) == 'true' ) case ( 'dielectric' ) read ( value , * , iostat = io_stat ) config % dielectric if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid dielectric value: \" // trim ( value )) return end if case ( 'cpcm_nang' ) read ( value , * , iostat = io_stat ) config % cpcm_nang if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid cpcm_nang value: \" // trim ( value )) return end if case ( 'cpcm_rscale' ) read ( value , * , iostat = io_stat ) config % cpcm_rscale if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid cpcm_rscale value: \" // trim ( value )) return end if case default call error % set ( ERROR_PARSE , \"Unknown key in %xtb section: \" // trim ( key )) return end select end do end subroutine parse_xtb_section","tags":"","url":"proc/parse_xtb_section.html"},{"title":"skip_to_end – metalquicha","text":"private  subroutine skip_to_end(unit, error) Skip lines until ‘end’ marker is found Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( error_t ), intent(out) :: error Calls proc~~skip_to_end~~CallsGraph proc~skip_to_end skip_to_end proc~error_set error_t%error_set proc~skip_to_end->proc~error_set proc~strip_comment strip_comment proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~skip_to_end~~CalledByGraph proc~skip_to_end skip_to_end proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_generic->proc~skip_to_end proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~skip_to_end proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~skip_to_end proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_single_molecule->proc~skip_to_end proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~skip_to_end proc~read_mqc_file->proc~parse_molecules_section proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: io_stat character(len=MAX_LINE_LEN), private :: line Source Code subroutine skip_to_end ( unit , error ) !! Skip lines until 'end' marker is found integer , intent ( in ) :: unit type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line integer :: io_stat do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file while skipping section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) exit end do end subroutine skip_to_end","tags":"","url":"proc/skip_to_end.html"},{"title":"validate_cutoffs – metalquicha","text":"private  subroutine validate_cutoffs(config, error) Validate that fragment cutoffs are monotonically decreasing\nFor n-mer level N, cutoff(N) must be <= cutoff(N-1) Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: config type( error_t ), intent(out) :: error Calls proc~~validate_cutoffs~~CallsGraph proc~validate_cutoffs validate_cutoffs proc~error_set error_t%error_set proc~validate_cutoffs->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~validate_cutoffs~~CalledByGraph proc~validate_cutoffs validate_cutoffs proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~validate_cutoffs proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragmentation_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: cutoff_high real(kind=dp), private :: cutoff_low integer, private :: i integer, private :: level_high integer, private :: level_low character(len=256), private :: msg Source Code subroutine validate_cutoffs ( config , error ) !! Validate that fragment cutoffs are monotonically decreasing !! For n-mer level N, cutoff(N) must be <= cutoff(N-1) type ( mqc_config_t ), intent ( in ) :: config type ( error_t ), intent ( out ) :: error integer :: i , level_low , level_high real ( dp ) :: cutoff_low , cutoff_high character ( len = 256 ) :: msg if (. not . allocated ( config % fragment_cutoffs )) return ! Check monotonicity for consecutive levels with defined cutoffs do i = 2 , size ( config % fragment_cutoffs ) level_low = i - 1 level_high = i cutoff_low = config % fragment_cutoffs ( level_low ) cutoff_high = config % fragment_cutoffs ( level_high ) ! Skip if either cutoff is not defined (negative or zero sentinel value) if ( cutoff_low <= 0.0_dp . or . cutoff_high <= 0.0_dp ) cycle ! Validate monotonic decreasing if ( cutoff_high > cutoff_low ) then write ( msg , '(a,i0,a,f0.2,a,i0,a,f0.2,a)' ) & \"Fragment cutoffs must be monotonically decreasing: \" , & level_high , \"-mer cutoff (\" , cutoff_high , \") cannot be larger than \" , & level_low , \"-mer cutoff (\" , cutoff_low , \"). Check %cutoffs section.\" call error % set ( ERROR_PARSE , trim ( msg )) return end if end do end subroutine validate_cutoffs","tags":"","url":"proc/validate_cutoffs.html"},{"title":"ends_with – metalquicha","text":"public  function ends_with(str, suffix) Check if string ends with suffix Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix Return Value logical Called by proc~~ends_with~~CalledByGraph proc~ends_with ends_with program~main main program~main->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: str_len integer, private :: suffix_len Source Code logical function ends_with ( str , suffix ) !! Check if string ends with suffix character ( len =* ), intent ( in ) :: str , suffix integer :: str_len , suffix_len str_len = len_trim ( str ) suffix_len = len_trim ( suffix ) if ( suffix_len > str_len ) then ends_with = . false . return end if ends_with = ( str ( str_len - suffix_len + 1 : str_len ) == suffix ) end function ends_with","tags":"","url":"proc/ends_with.html"},{"title":"get_basename – metalquicha","text":"public  function get_basename() result(basename) Get the base name without “output_” prefix and “.json” suffix\nExample: “output_w1.json” -> “w1” Arguments None Return Value character(len=256) Called by proc~~get_basename~~CalledByGraph proc~get_basename get_basename proc~write_gmbe_pie_json_impl write_gmbe_pie_json_impl proc~write_gmbe_pie_json_impl->proc~get_basename proc~write_mbe_breakdown_json_impl write_mbe_breakdown_json_impl proc~write_mbe_breakdown_json_impl->proc~get_basename proc~write_unfragmented_json_impl write_unfragmented_json_impl proc~write_unfragmented_json_impl->proc~get_basename proc~write_vibrational_json_impl write_vibrational_json_impl proc~write_vibrational_json_impl->proc~get_basename proc~write_json_output write_json_output proc~write_json_output->proc~write_gmbe_pie_json_impl proc~write_json_output->proc~write_mbe_breakdown_json_impl proc~write_json_output->proc~write_unfragmented_json_impl proc~write_json_output->proc~write_vibrational_json_impl proc~run_calculation run_calculation proc~run_calculation->proc~write_json_output proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: end_pos integer, private :: start_pos Source Code function get_basename () result ( basename ) !! Get the base name without \"output_\" prefix and \".json\" suffix !! Example: \"output_w1.json\" -> \"w1\" character ( len = 256 ) :: basename integer :: start_pos , end_pos ! Remove \"output_\" prefix (7 characters) start_pos = 8 ! Find \".json\" suffix end_pos = index ( output_json_filename , '.json' , back = . true .) - 1 if ( end_pos > start_pos ) then basename = output_json_filename ( start_pos : end_pos ) else basename = \"unknown\" end if end function get_basename","tags":"","url":"proc/get_basename.html"},{"title":"get_molecule_name – metalquicha","text":"public  function get_molecule_name(filename) result(name) Extract molecule name from filename\nExample: “output_multi_structure_molecule_1.json” -> “molecule_1” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value character(len=256) Called by proc~~get_molecule_name~~CalledByGraph proc~get_molecule_name get_molecule_name proc~read_json_content read_json_content proc~read_json_content->proc~get_molecule_name proc~merge_multi_molecule_json merge_multi_molecule_json proc~merge_multi_molecule_json->proc~read_json_content proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: end_pos integer, private :: start_pos Source Code function get_molecule_name ( filename ) result ( name ) !! Extract molecule name from filename !! Example: \"output_multi_structure_molecule_1.json\" -> \"molecule_1\" character ( len =* ), intent ( in ) :: filename character ( len = 256 ) :: name integer :: start_pos , end_pos ! Find \"_molecule_\" or similar pattern start_pos = index ( filename , '_molecule_' ) if ( start_pos == 0 ) start_pos = index ( filename , '_mol_' ) if ( start_pos > 0 ) then start_pos = start_pos + 1 ! Skip leading underscore end_pos = index ( filename , '.json' ) - 1 if ( end_pos > start_pos ) then name = filename ( start_pos : end_pos ) else name = \"unknown\" end if else name = \"unknown\" end if end function get_molecule_name","tags":"","url":"proc/get_molecule_name.html"},{"title":"get_output_json_filename – metalquicha","text":"public  function get_output_json_filename() result(filename) Get the current JSON output filename Arguments None Return Value character(len=256) Called by proc~~get_output_json_filename~~CalledByGraph proc~get_output_json_filename get_output_json_filename proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~get_output_json_filename proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~write_gmbe_pie_json_impl write_gmbe_pie_json_impl proc~write_gmbe_pie_json_impl->proc~get_output_json_filename proc~write_mbe_breakdown_json_impl write_mbe_breakdown_json_impl proc~write_mbe_breakdown_json_impl->proc~get_output_json_filename proc~write_unfragmented_json_impl write_unfragmented_json_impl proc~write_unfragmented_json_impl->proc~get_output_json_filename proc~write_vibrational_json_impl write_vibrational_json_impl proc~write_vibrational_json_impl->proc~get_output_json_filename proc~write_json_output write_json_output proc~write_json_output->proc~write_gmbe_pie_json_impl proc~write_json_output->proc~write_mbe_breakdown_json_impl proc~write_json_output->proc~write_unfragmented_json_impl proc~write_json_output->proc~write_vibrational_json_impl program~main main program~main->proc~run_multi_molecule_calculations program~main->proc~run_calculation proc~run_calculation->proc~write_json_output proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_output_json_filename () result ( filename ) !! Get the current JSON output filename character ( len = 256 ) :: filename filename = trim ( output_json_filename ) end function get_output_json_filename","tags":"","url":"proc/get_output_json_filename.html"},{"title":"set_molecule_suffix – metalquicha","text":"public  subroutine set_molecule_suffix(suffix) Append a suffix to the output filename (e.g., for multi-molecule mode)\nExample: suffix=”_mol1” -> “output_multi_structure_mol1.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: suffix Called by proc~~set_molecule_suffix~~CalledByGraph proc~set_molecule_suffix set_molecule_suffix proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~set_molecule_suffix program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine set_molecule_suffix ( suffix ) !! Append a suffix to the output filename (e.g., for multi-molecule mode) !! Example: suffix=\"_mol1\" -> \"output_multi_structure_mol1.json\" character ( len =* ), intent ( in ) :: suffix if ( len_trim ( current_basename ) > 0 ) then output_json_filename = \"output_\" // trim ( current_basename ) // trim ( suffix ) // \".json\" end if end subroutine set_molecule_suffix","tags":"","url":"proc/set_molecule_suffix.html"},{"title":"set_output_json_filename – metalquicha","text":"public  subroutine set_output_json_filename(input_filename) Set the JSON output filename based on input filename\nExample: “water.mqc” -> “output_water.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_filename Called by proc~~set_output_json_filename~~CalledByGraph proc~set_output_json_filename set_output_json_filename program~main main program~main->proc~set_output_json_filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename integer, private :: dot_pos integer, private :: slash_pos Source Code subroutine set_output_json_filename ( input_filename ) !! Set the JSON output filename based on input filename !! Example: \"water.mqc\" -> \"output_water.json\" character ( len =* ), intent ( in ) :: input_filename integer :: dot_pos , slash_pos character ( len = 256 ) :: basename ! Find last slash (if any) to extract basename slash_pos = index ( input_filename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = input_filename ( slash_pos + 1 :) else basename = input_filename end if ! Find last dot to remove extension dot_pos = index ( basename , '.' , back = . true .) if ( dot_pos > 0 ) then basename = basename ( 1 : dot_pos - 1 ) end if ! Store basename for later use current_basename = trim ( basename ) ! Construct output filename: output_<basename>.json output_json_filename = \"output_\" // trim ( basename ) // \".json\" end subroutine set_output_json_filename","tags":"","url":"proc/set_output_json_filename.html"},{"title":"print_logo – metalquicha","text":"public  subroutine print_logo() Print the PIC Chemistry ASCII sunflower logo Arguments None Called by proc~~print_logo~~CalledByGraph proc~print_logo print_logo program~main main program~main->proc~print_logo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine print_logo () !! Print the PIC Chemistry ASCII sunflower logo write ( * , '(A)' ) ' ' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                        __   __' write ( * , '(A)' ) '                     .-(  ''.''  )-.' write ( * , '(A)' ) '                    (   \\  |  /   )' write ( * , '(A)' ) '                   ( ''`-.;;;;;.-''` )' write ( * , '(A)' ) '                  ( :-==;;;;;;;==-: )' write ( * , '(A)' ) '                   (  .-'';;;;;''-.  )' write ( * , '(A)' ) '                    (``  /  |  \\  ``)' write ( * , '(A)' ) '                     ''-(__.''.__)-''' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                      (Art by jgs)' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '    ╔═══════════════════════════════════════════════╗' write ( * , '(A)' ) '    ║              Met\"al q\"uicha                   ║' write ( * , '(A)' ) '    ║                (Sunflower)                    ║' write ( * , '(A)' ) '    ║   A hastily put together Fortran code for     ║' write ( * , '(A)' ) '    ║     Fragmented Based Quantum Chemistry        ║' write ( * , '(A)' ) '    ║                                               ║' write ( * , '(A)' ) '    ║        Coded up by Jorge as a hobby           ║' write ( * , '(A)' ) '    ╚═══════════════════════════════════════════════╝' write ( * , '(A)' ) ' ' end subroutine print_logo","tags":"","url":"proc/print_logo.html"},{"title":"compute_electronic_entropy – metalquicha","text":"public  subroutine compute_electronic_entropy(spin_multiplicity, S_elec) Compute electronic entropy contribution. S_elec = R * ln(2S+1) where 2S+1 is the spin multiplicity.\nFor singlet (mult=1): S_elec = 0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: spin_multiplicity Electronic spin multiplicity (2S+1) real(kind=dp), intent(out) :: S_elec Electronic entropy in cal/(mol*K) Called by proc~~compute_electronic_entropy~~CalledByGraph proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry compute_thermochemistry proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_thermochemistry proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_thermochemistry proc~hessian_coordinator->proc~print_vibrational_analysis proc~print_vibrational_analysis->proc~compute_thermochemistry proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine compute_electronic_entropy ( spin_multiplicity , S_elec ) !! Compute electronic entropy contribution. !! !! S_elec = R * ln(2S+1) where 2S+1 is the spin multiplicity. !! For singlet (mult=1): S_elec = 0 integer , intent ( in ) :: spin_multiplicity !! Electronic spin multiplicity (2S+1) real ( dp ), intent ( out ) :: S_elec !! Electronic entropy in cal/(mol*K) S_elec = R_CALMOLK * log ( real ( spin_multiplicity , dp )) end subroutine compute_electronic_entropy","tags":"","url":"proc/compute_electronic_entropy.html"},{"title":"compute_moments_of_inertia – metalquicha","text":"public  subroutine compute_moments_of_inertia(coords, atomic_numbers, n_atoms, center_of_mass, moments, principal_axes, is_linear, total_mass) Compute the principal moments of inertia and detect linear molecules. Calculates the center of mass, inertia tensor, and diagonalizes to get\nprincipal moments. A molecule is considered linear if one moment is\nessentially zero (< LINEAR_THRESHOLD). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (:,:) Atomic coordinates (3, n_atoms) in Bohr integer, intent(in) :: atomic_numbers (:) Atomic numbers integer, intent(in) :: n_atoms Number of atoms real(kind=dp), intent(out) :: center_of_mass (3) Center of mass in Angstrom real(kind=dp), intent(out) :: moments (3) Principal moments in amu*Angstrom&#94;2 real(kind=dp), intent(out) :: principal_axes (3,3) Principal axis vectors (columns) logical, intent(out) :: is_linear True if molecule is linear real(kind=dp), intent(out) :: total_mass Total mass in amu Calls proc~~compute_moments_of_inertia~~CallsGraph proc~compute_moments_of_inertia compute_moments_of_inertia pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~element_mass element_mass proc~compute_moments_of_inertia->proc~element_mass to_char to_char proc~compute_moments_of_inertia->to_char warning warning proc~compute_moments_of_inertia->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_moments_of_inertia~~CalledByGraph proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry compute_thermochemistry proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_thermochemistry proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_thermochemistry proc~hessian_coordinator->proc~print_vibrational_analysis proc~print_vibrational_analysis->proc~compute_thermochemistry proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: coords_ang (3,n_atoms) integer, private :: i real(kind=dp), private :: inertia_tensor (3,3) integer, private :: info real(kind=dp), private :: mass_i real(kind=dp), private :: masses (n_atoms) real(kind=dp), private :: rel_coords (3,n_atoms) real(kind=dp), private :: x real(kind=dp), private :: y real(kind=dp), private :: z Source Code subroutine compute_moments_of_inertia ( coords , atomic_numbers , n_atoms , & center_of_mass , moments , principal_axes , is_linear , total_mass ) !! Compute the principal moments of inertia and detect linear molecules. !! !! Calculates the center of mass, inertia tensor, and diagonalizes to get !! principal moments. A molecule is considered linear if one moment is !! essentially zero (< LINEAR_THRESHOLD). real ( dp ), intent ( in ) :: coords (:, :) !! Atomic coordinates (3, n_atoms) in Bohr integer , intent ( in ) :: atomic_numbers (:) !! Atomic numbers integer , intent ( in ) :: n_atoms !! Number of atoms real ( dp ), intent ( out ) :: center_of_mass ( 3 ) !! Center of mass in Angstrom real ( dp ), intent ( out ) :: moments ( 3 ) !! Principal moments in amu*Angstrom&#94;2 real ( dp ), intent ( out ) :: principal_axes ( 3 , 3 ) !! Principal axis vectors (columns) logical , intent ( out ) :: is_linear !! True if molecule is linear real ( dp ), intent ( out ) :: total_mass !! Total mass in amu real ( dp ) :: coords_ang ( 3 , n_atoms ) real ( dp ) :: masses ( n_atoms ) real ( dp ) :: rel_coords ( 3 , n_atoms ) real ( dp ) :: inertia_tensor ( 3 , 3 ) integer :: i , info real ( dp ) :: mass_i , x , y , z ! Convert coordinates to Angstrom coords_ang = coords * BOHR_TO_ANGSTROM ! Get atomic masses total_mass = 0.0_dp do i = 1 , n_atoms masses ( i ) = element_mass ( atomic_numbers ( i )) total_mass = total_mass + masses ( i ) end do ! Compute center of mass center_of_mass = 0.0_dp do i = 1 , n_atoms center_of_mass (:) = center_of_mass (:) + masses ( i ) * coords_ang (:, i ) end do center_of_mass = center_of_mass / total_mass ! Compute coordinates relative to center of mass do i = 1 , n_atoms rel_coords (:, i ) = coords_ang (:, i ) - center_of_mass (:) end do ! Build inertia tensor inertia_tensor = 0.0_dp do i = 1 , n_atoms mass_i = masses ( i ) x = rel_coords ( 1 , i ) y = rel_coords ( 2 , i ) z = rel_coords ( 3 , i ) ! Diagonal elements: I_xx = sum(m * (y&#94;2 + z&#94;2)), etc. inertia_tensor ( 1 , 1 ) = inertia_tensor ( 1 , 1 ) + mass_i * ( y * y + z * z ) inertia_tensor ( 2 , 2 ) = inertia_tensor ( 2 , 2 ) + mass_i * ( x * x + z * z ) inertia_tensor ( 3 , 3 ) = inertia_tensor ( 3 , 3 ) + mass_i * ( x * x + y * y ) ! Off-diagonal elements: I_xy = -sum(m * x * y), etc. inertia_tensor ( 1 , 2 ) = inertia_tensor ( 1 , 2 ) - mass_i * x * y inertia_tensor ( 1 , 3 ) = inertia_tensor ( 1 , 3 ) - mass_i * x * z inertia_tensor ( 2 , 3 ) = inertia_tensor ( 2 , 3 ) - mass_i * y * z end do ! Symmetrize inertia_tensor ( 2 , 1 ) = inertia_tensor ( 1 , 2 ) inertia_tensor ( 3 , 1 ) = inertia_tensor ( 1 , 3 ) inertia_tensor ( 3 , 2 ) = inertia_tensor ( 2 , 3 ) ! Diagonalize to get principal moments principal_axes = inertia_tensor call pic_syev ( principal_axes , moments , 'V' , 'U' , info ) if ( info /= 0 ) then call logger % warning ( \"Failed to diagonalize inertia tensor, info = \" // & trim ( adjustl ( to_char ( info )))) moments = 0.0_dp is_linear = . false . return end if ! Check for linear molecule: one moment should be ~0 ! Moments are returned in ascending order is_linear = ( moments ( 1 ) < LINEAR_THRESHOLD ) end subroutine compute_moments_of_inertia","tags":"","url":"proc/compute_moments_of_inertia.html"},{"title":"compute_rotational_constants – metalquicha","text":"public  subroutine compute_rotational_constants(moments, is_linear, rot_const) Convert moments of inertia to rotational constants in GHz. B = h / (8 * pi&#94;2 * I) where I is in SI units.\nFor I in amu*Angstrom&#94;2: B(GHz) = 505379.07 / I Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: moments (3) Moments in amu*Angstrom&#94;2 logical, intent(in) :: is_linear True if linear molecule real(kind=dp), intent(out) :: rot_const (3) Rotational constants in GHz Called by proc~~compute_rotational_constants~~CalledByGraph proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry compute_thermochemistry proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_thermochemistry proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_thermochemistry proc~hessian_coordinator->proc~print_vibrational_analysis proc~print_vibrational_analysis->proc~compute_thermochemistry proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine compute_rotational_constants ( moments , is_linear , rot_const ) !! Convert moments of inertia to rotational constants in GHz. !! !! B = h / (8 * pi&#94;2 * I) where I is in SI units. !! For I in amu*Angstrom&#94;2: B(GHz) = 505379.07 / I real ( dp ), intent ( in ) :: moments ( 3 ) !! Moments in amu*Angstrom&#94;2 logical , intent ( in ) :: is_linear !! True if linear molecule real ( dp ), intent ( out ) :: rot_const ( 3 ) !! Rotational constants in GHz integer :: i rot_const = 0.0_dp if ( is_linear ) then ! For linear molecules, only one rotational constant matters ! Use the largest moment (moments are sorted ascending) if ( moments ( 3 ) > LINEAR_THRESHOLD ) then rot_const ( 1 ) = ROTCONST_AMUA2_TO_GHZ / moments ( 3 ) end if else ! For nonlinear molecules, compute all three do i = 1 , 3 if ( moments ( i ) > LINEAR_THRESHOLD ) then rot_const ( i ) = ROTCONST_AMUA2_TO_GHZ / moments ( i ) end if end do end if end subroutine compute_rotational_constants","tags":"","url":"proc/compute_rotational_constants.html"},{"title":"compute_rotational_thermo – metalquicha","text":"public  subroutine compute_rotational_thermo(moments, temperature, symmetry_number, is_linear, E, S, Cv) Compute rotational contributions to thermodynamic properties. Uses rigid rotor approximation (classical limit, high T).\nFor nonlinear: E = 3/2 RT, Cv = 3/2 R\nFor linear: E = RT, Cv = R Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: moments (3) Principal moments in amu*Angstrom&#94;2 real(kind=dp), intent(in) :: temperature Temperature in K integer, intent(in) :: symmetry_number Rotational symmetry number logical, intent(in) :: is_linear True if linear molecule real(kind=dp), intent(out) :: E Thermal energy in Hartree real(kind=dp), intent(out) :: S Entropy in cal/(mol*K) real(kind=dp), intent(out) :: Cv Heat capacity in cal/(mol*K) Called by proc~~compute_rotational_thermo~~CalledByGraph proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry compute_thermochemistry proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_thermochemistry proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_thermochemistry proc~hessian_coordinator->proc~print_vibrational_analysis proc~print_vibrational_analysis->proc~compute_thermochemistry proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: T integer, private :: i real(kind=dp), private :: qr real(kind=dp), private :: sigma real(kind=dp), private :: theta_rot (3) Source Code subroutine compute_rotational_thermo ( moments , temperature , symmetry_number , is_linear , E , S , Cv ) !! Compute rotational contributions to thermodynamic properties. !! !! Uses rigid rotor approximation (classical limit, high T). !! For nonlinear: E = 3/2 RT, Cv = 3/2 R !! For linear: E = RT, Cv = R real ( dp ), intent ( in ) :: moments ( 3 ) !! Principal moments in amu*Angstrom&#94;2 real ( dp ), intent ( in ) :: temperature !! Temperature in K integer , intent ( in ) :: symmetry_number !! Rotational symmetry number logical , intent ( in ) :: is_linear !! True if linear molecule real ( dp ), intent ( out ) :: E !! Thermal energy in Hartree real ( dp ), intent ( out ) :: S !! Entropy in cal/(mol*K) real ( dp ), intent ( out ) :: Cv !! Heat capacity in cal/(mol*K) real ( dp ) :: theta_rot ( 3 ) real ( dp ) :: T , sigma real ( dp ) :: qr integer :: i T = temperature sigma = real ( symmetry_number , dp ) ! Calculate rotational temperatures: theta_rot = h&#94;2 / (8*pi&#94;2*I*k_B) ! For I in amu*Angstrom&#94;2: !   I_SI = I * 1.66054e-47 kg*m&#94;2 !   theta_rot = h&#94;2 / (8*pi&#94;2 * I_SI * k_B) !             = (6.62607e-34)&#94;2 / (8 * pi&#94;2 * 1.66054e-47 * 1.38065e-23 * I) !             = ROTTEMP_AMUA2_TO_K / I  [K] do i = 1 , 3 if ( moments ( i ) > LINEAR_THRESHOLD ) then theta_rot ( i ) = ROTTEMP_AMUA2_TO_K / moments ( i ) else theta_rot ( i ) = 0.0_dp end if end do if ( is_linear ) then ! Linear molecule: 2 rotational degrees of freedom E = R_HARTREE * T Cv = R_CALMOLK ! S = R * [1 + ln(T / (sigma * theta_rot))] ! Use the average of the two non-zero theta values if ( theta_rot ( 3 ) > 0.0_dp ) then qr = T / ( sigma * theta_rot ( 3 )) S = R_CALMOLK * ( 1.0_dp + log ( qr )) else S = 0.0_dp end if else ! Nonlinear molecule: 3 rotational degrees of freedom E = 1.5_dp * R_HARTREE * T Cv = 1.5_dp * R_CALMOLK ! S = R * [3/2 + ln(sqrt(pi) * T&#94;(3/2) / (sigma * sqrt(theta_A*theta_B*theta_C)))] if ( theta_rot ( 1 ) > 0.0_dp . and . theta_rot ( 2 ) > 0.0_dp . and . theta_rot ( 3 ) > 0.0_dp ) then qr = sqrt ( PI ) * ( T ** 1.5_dp ) / ( sigma * sqrt ( theta_rot ( 1 ) * theta_rot ( 2 ) * theta_rot ( 3 ))) S = R_CALMOLK * ( 1.5_dp + log ( qr )) else S = 0.0_dp end if end if end subroutine compute_rotational_thermo","tags":"","url":"proc/compute_rotational_thermo.html"},{"title":"compute_thermochemistry – metalquicha","text":"public  subroutine compute_thermochemistry(coords, atomic_numbers, frequencies, n_atoms, n_freqs, result, temperature, pressure, symmetry_number, spin_multiplicity) Main driver for thermochemistry calculations. Computes all thermodynamic quantities from molecular geometry and vibrational frequencies. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (:,:) Coordinates (3, n_atoms) in Bohr integer, intent(in) :: atomic_numbers (:) Atomic numbers real(kind=dp), intent(in) :: frequencies (:) Frequencies in cm&#94;-1 integer, intent(in) :: n_atoms Number of atoms integer, intent(in) :: n_freqs Number of frequencies type( thermochemistry_result_t ), intent(out) :: result Output results real(kind=dp), intent(in), optional :: temperature Temperature in K (default 298.15) real(kind=dp), intent(in), optional :: pressure Pressure in atm (default 1.0) integer, intent(in), optional :: symmetry_number Symmetry number (default 1) integer, intent(in), optional :: spin_multiplicity Spin multiplicity (default 1) Calls proc~~compute_thermochemistry~~CallsGraph proc~compute_thermochemistry compute_thermochemistry proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~element_mass element_mass proc~compute_moments_of_inertia->proc~element_mass to_char to_char proc~compute_moments_of_inertia->to_char warning warning proc~compute_moments_of_inertia->warning proc~compute_zpe->to_char proc~compute_zpe->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_thermochemistry~~CalledByGraph proc~compute_thermochemistry compute_thermochemistry proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_thermochemistry proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_thermochemistry proc~hessian_coordinator->proc~print_vibrational_analysis proc~print_vibrational_analysis->proc~compute_thermochemistry proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: P real(kind=dp), private :: S_total real(kind=dp), private :: T real(kind=dp), private :: center_of_mass (3) integer, private :: mult real(kind=dp), private :: principal_axes (3,3) integer, private :: sigma Source Code subroutine compute_thermochemistry ( coords , atomic_numbers , frequencies , n_atoms , n_freqs , & result , temperature , pressure , symmetry_number , spin_multiplicity ) !! Main driver for thermochemistry calculations. !! !! Computes all thermodynamic quantities from molecular geometry and vibrational frequencies. real ( dp ), intent ( in ) :: coords (:, :) !! Coordinates (3, n_atoms) in Bohr integer , intent ( in ) :: atomic_numbers (:) !! Atomic numbers real ( dp ), intent ( in ) :: frequencies (:) !! Frequencies in cm&#94;-1 integer , intent ( in ) :: n_atoms !! Number of atoms integer , intent ( in ) :: n_freqs !! Number of frequencies type ( thermochemistry_result_t ), intent ( out ) :: result !! Output results real ( dp ), intent ( in ), optional :: temperature !! Temperature in K (default 298.15) real ( dp ), intent ( in ), optional :: pressure !! Pressure in atm (default 1.0) integer , intent ( in ), optional :: symmetry_number !! Symmetry number (default 1) integer , intent ( in ), optional :: spin_multiplicity !! Spin multiplicity (default 1) real ( dp ) :: center_of_mass ( 3 ) real ( dp ) :: principal_axes ( 3 , 3 ) real ( dp ) :: T , P integer :: sigma , mult real ( dp ) :: S_total ! Set parameters T = DEFAULT_TEMPERATURE P = DEFAULT_PRESSURE sigma = DEFAULT_SYMMETRY_NUMBER mult = DEFAULT_SPIN_MULTIPLICITY if ( present ( temperature )) T = temperature if ( present ( pressure )) P = pressure if ( present ( symmetry_number )) sigma = symmetry_number if ( present ( spin_multiplicity )) mult = spin_multiplicity result % temperature = T result % pressure = P result % symmetry_number = sigma result % spin_multiplicity = mult ! Compute moments of inertia call compute_moments_of_inertia ( coords , atomic_numbers , n_atoms , & center_of_mass , result % moments , principal_axes , & result % is_linear , result % total_mass ) ! Compute rotational constants call compute_rotational_constants ( result % moments , result % is_linear , result % rot_const ) ! Compute ZPE call compute_zpe ( frequencies , n_freqs , result % n_real_freqs , & result % zpe_hartree , result % zpe_kcalmol ) result % n_imag_freqs = n_freqs - result % n_real_freqs ! Compute translational contributions call compute_translational_thermo ( result % total_mass , T , P , & result % E_trans , result % S_trans , result % Cv_trans ) ! Compute rotational contributions call compute_rotational_thermo ( result % moments , T , sigma , result % is_linear , & result % E_rot , result % S_rot , result % Cv_rot ) ! Compute vibrational contributions (thermal, excluding ZPE) call compute_vibrational_thermo ( frequencies , n_freqs , T , & result % E_vib , result % S_vib , result % Cv_vib ) ! Compute electronic contributions result % E_elec = 0.0_dp ! Ground state only call compute_electronic_entropy ( mult , result % S_elec ) ! Compute partition functions call compute_partition_functions ( result % total_mass , result % moments , frequencies , n_freqs , & T , P , sigma , result % is_linear , & result % q_trans , result % q_rot , result % q_vib ) ! Compute summary quantities ! Thermal correction to energy = ZPE + E_trans + E_rot + E_vib + E_elec result % thermal_correction_energy = result % zpe_hartree + & result % E_trans + result % E_rot + result % E_vib + result % E_elec ! Thermal correction to enthalpy = E_tot + RT result % thermal_correction_enthalpy = result % thermal_correction_energy + R_HARTREE * T ! Total entropy in Hartree/K S_total = ( result % S_trans + result % S_rot + result % S_vib + result % S_elec ) / HARTREE_TO_CALMOL ! Thermal correction to Gibbs = H - TS result % thermal_correction_gibbs = result % thermal_correction_enthalpy - T * S_total end subroutine compute_thermochemistry","tags":"","url":"proc/compute_thermochemistry.html"},{"title":"compute_translational_thermo – metalquicha","text":"public  subroutine compute_translational_thermo(total_mass, temperature, pressure, E, S, Cv) Compute translational contributions to thermodynamic properties. Uses ideal gas partition function (Sackur-Tetrode equation for entropy).\nE_trans = 3/2 * R * T\nS_trans = R * [5/2 + ln((2 pi m k T/h&#94;2)&#94;(3/2) * k*T/P)]\nCv_trans = 3/2 * R Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_mass Total mass in amu real(kind=dp), intent(in) :: temperature Temperature in K real(kind=dp), intent(in) :: pressure Pressure in atm real(kind=dp), intent(out) :: E Thermal energy in Hartree real(kind=dp), intent(out) :: S Entropy in cal/(mol*K) real(kind=dp), intent(out) :: Cv Heat capacity in cal/(mol*K) Called by proc~~compute_translational_thermo~~CalledByGraph proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry compute_thermochemistry proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_thermochemistry proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_thermochemistry proc~hessian_coordinator->proc~print_vibrational_analysis proc~print_vibrational_analysis->proc~compute_thermochemistry proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: P_pa real(kind=dp), private :: T real(kind=dp), private :: V_molar real(kind=dp), private :: lambda_cubed real(kind=dp), private :: mass_kg real(kind=dp), private :: qt Source Code subroutine compute_translational_thermo ( total_mass , temperature , pressure , E , S , Cv ) !! Compute translational contributions to thermodynamic properties. !! !! Uses ideal gas partition function (Sackur-Tetrode equation for entropy). !! E_trans = 3/2 * R * T !! S_trans = R * [5/2 + ln((2*pi*m*k*T/h&#94;2)&#94;(3/2) * k*T/P)] !! Cv_trans = 3/2 * R real ( dp ), intent ( in ) :: total_mass !! Total mass in amu real ( dp ), intent ( in ) :: temperature !! Temperature in K real ( dp ), intent ( in ) :: pressure !! Pressure in atm real ( dp ), intent ( out ) :: E !! Thermal energy in Hartree real ( dp ), intent ( out ) :: S !! Entropy in cal/(mol*K) real ( dp ), intent ( out ) :: Cv !! Heat capacity in cal/(mol*K) real ( dp ) :: mass_kg , T , P_pa real ( dp ) :: lambda_cubed , V_molar , qt ! Convert inputs to SI mass_kg = total_mass * AMU_TO_KG T = temperature P_pa = pressure * ATM_TO_PA ! Thermal de Broglie wavelength cubed: lambda&#94;3 = (h&#94;2 / (2*pi*m*k*T))&#94;(3/2) lambda_cubed = ( H_SI * H_SI / ( 2.0_dp * PI * mass_kg * KB_SI * T )) ** 1.5_dp ! Molar volume at given T and P (ideal gas): V = R*T/P = k*T/P per molecule V_molar = KB_SI * T / P_pa ! m&#94;3 per molecule ! Translational partition function per molecule qt = V_molar / lambda_cubed ! Thermal energy: E = 3/2 * R * T E = 1.5_dp * R_HARTREE * temperature ! Entropy (Sackur-Tetrode): S = R * [5/2 + ln(qt)] S = R_CALMOLK * ( 2.5_dp + log ( qt )) ! Heat capacity: Cv = 3/2 * R Cv = 1.5_dp * R_CALMOLK end subroutine compute_translational_thermo","tags":"","url":"proc/compute_translational_thermo.html"},{"title":"compute_vibrational_thermo – metalquicha","text":"public  subroutine compute_vibrational_thermo(frequencies, n_freqs, temperature, E, S, Cv) Compute vibrational contributions to thermodynamic properties. Uses quantum harmonic oscillator partition function.\nE_vib = R * sum(theta_v * [1/(exp(u)-1)]) where u = theta_v/T\nS_vib = R * sum([u/(exp(u)-1) - ln(1-exp(-u))])\nCv_vib = R * sum(u&#94;2 * exp(u) / (exp(u)-1)&#94;2) Note: ZPE is NOT included here (computed separately). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frequencies (:) Frequencies in cm&#94;-1 integer, intent(in) :: n_freqs Number of frequencies real(kind=dp), intent(in) :: temperature Temperature in K real(kind=dp), intent(out) :: E Thermal energy in Hartree (excluding ZPE) real(kind=dp), intent(out) :: S Entropy in cal/(mol*K) real(kind=dp), intent(out) :: Cv Heat capacity in cal/(mol*K) Called by proc~~compute_vibrational_thermo~~CalledByGraph proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry compute_thermochemistry proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_thermochemistry proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_thermochemistry proc~hessian_coordinator->proc~print_vibrational_analysis proc~print_vibrational_analysis->proc~compute_thermochemistry proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: Cv_sum real(kind=dp), private :: E_sum real(kind=dp), private :: S_sum real(kind=dp), private :: T real(kind=dp), private :: exp_neg_u real(kind=dp), private :: exp_u real(kind=dp), private :: freq integer, private :: i real(kind=dp), private :: theta_v real(kind=dp), private :: u Source Code subroutine compute_vibrational_thermo ( frequencies , n_freqs , temperature , E , S , Cv ) !! Compute vibrational contributions to thermodynamic properties. !! !! Uses quantum harmonic oscillator partition function. !! E_vib = R * sum(theta_v * [1/(exp(u)-1)]) where u = theta_v/T !! S_vib = R * sum([u/(exp(u)-1) - ln(1-exp(-u))]) !! Cv_vib = R * sum(u&#94;2 * exp(u) / (exp(u)-1)&#94;2) !! !! Note: ZPE is NOT included here (computed separately). real ( dp ), intent ( in ) :: frequencies (:) !! Frequencies in cm&#94;-1 integer , intent ( in ) :: n_freqs !! Number of frequencies real ( dp ), intent ( in ) :: temperature !! Temperature in K real ( dp ), intent ( out ) :: E !! Thermal energy in Hartree (excluding ZPE) real ( dp ), intent ( out ) :: S !! Entropy in cal/(mol*K) real ( dp ), intent ( out ) :: Cv !! Heat capacity in cal/(mol*K) integer :: i real ( dp ) :: T , freq , theta_v , u real ( dp ) :: exp_u , exp_neg_u real ( dp ) :: E_sum , S_sum , Cv_sum T = temperature E_sum = 0.0_dp S_sum = 0.0_dp Cv_sum = 0.0_dp do i = 1 , n_freqs freq = frequencies ( i ) ! Skip imaginary and near-zero frequencies if ( freq <= IMAG_FREQ_THRESHOLD ) cycle if ( freq < 1 0.0_dp ) cycle ! Skip very low frequencies (likely trans/rot residuals) ! Vibrational temperature: theta_v = h*c*nu / k = 1.4388 * nu (cm&#94;-1) theta_v = CM1_TO_KELVIN * freq ! Reduced temperature ratio u = theta_v / T ! Avoid numerical issues for very large u (very low T or high freq) if ( u > VIB_CLASSICAL_LIMIT ) then ! Classical limit: modes are frozen out cycle end if exp_u = exp ( u ) exp_neg_u = exp ( - u ) ! Energy contribution (excluding ZPE): theta_v / (exp(u) - 1) E_sum = E_sum + theta_v / ( exp_u - 1.0_dp ) ! Entropy contribution: u/(exp(u)-1) - ln(1-exp(-u)) S_sum = S_sum + u / ( exp_u - 1.0_dp ) - log ( 1.0_dp - exp_neg_u ) ! Heat capacity contribution: u&#94;2 * exp(u) / (exp(u)-1)&#94;2 Cv_sum = Cv_sum + ( u * u * exp_u ) / (( exp_u - 1.0_dp ) ** 2 ) end do ! Convert to proper units E = KB_HARTREE * E_sum ! Hartree S = R_CALMOLK * S_sum ! cal/(mol*K) Cv = R_CALMOLK * Cv_sum ! cal/(mol*K) end subroutine compute_vibrational_thermo","tags":"","url":"proc/compute_vibrational_thermo.html"},{"title":"compute_zpe – metalquicha","text":"public  subroutine compute_zpe(frequencies, n_freqs, n_real, zpe_hartree, zpe_kcalmol) Compute zero-point vibrational energy from frequencies. ZPE = (1/2) * h * sum(nu_i) for all real frequencies.\nImaginary frequencies (negative values) are skipped with a warning. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frequencies (:) Vibrational frequencies in cm&#94;-1 integer, intent(in) :: n_freqs Total number of frequencies integer, intent(out) :: n_real Number of real (positive) frequencies used real(kind=dp), intent(out) :: zpe_hartree ZPE in Hartree real(kind=dp), intent(out) :: zpe_kcalmol ZPE in kcal/mol Calls proc~~compute_zpe~~CallsGraph proc~compute_zpe compute_zpe to_char to_char proc~compute_zpe->to_char warning warning proc~compute_zpe->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_zpe~~CalledByGraph proc~compute_zpe compute_zpe proc~compute_thermochemistry compute_thermochemistry proc~compute_thermochemistry->proc~compute_zpe proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_thermochemistry proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_thermochemistry proc~hessian_coordinator->proc~print_vibrational_analysis proc~print_vibrational_analysis->proc~compute_thermochemistry proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: freq_sum integer, private :: i integer, private :: n_imag Source Code subroutine compute_zpe ( frequencies , n_freqs , n_real , zpe_hartree , zpe_kcalmol ) !! Compute zero-point vibrational energy from frequencies. !! !! ZPE = (1/2) * h * sum(nu_i) for all real frequencies. !! Imaginary frequencies (negative values) are skipped with a warning. real ( dp ), intent ( in ) :: frequencies (:) !! Vibrational frequencies in cm&#94;-1 integer , intent ( in ) :: n_freqs !! Total number of frequencies integer , intent ( out ) :: n_real !! Number of real (positive) frequencies used real ( dp ), intent ( out ) :: zpe_hartree !! ZPE in Hartree real ( dp ), intent ( out ) :: zpe_kcalmol !! ZPE in kcal/mol integer :: i real ( dp ) :: freq_sum integer :: n_imag freq_sum = 0.0_dp n_real = 0 n_imag = 0 do i = 1 , n_freqs if ( frequencies ( i ) > IMAG_FREQ_THRESHOLD ) then freq_sum = freq_sum + frequencies ( i ) n_real = n_real + 1 else if ( frequencies ( i ) < IMAG_FREQ_THRESHOLD ) then n_imag = n_imag + 1 end if ! Frequencies exactly at threshold (typically trans/rot modes ~0) are skipped end do if ( n_imag > 0 ) then call logger % warning ( \"Thermochemistry: \" // trim ( adjustl ( to_char ( n_imag ))) // & \" imaginary frequency(ies) skipped\" ) end if ! ZPE = 0.5 * sum(h * c * nu) where nu is in cm&#94;-1 ! In atomic units: ZPE = 0.5 * sum(nu * CM1_TO_KELVIN * KB_HARTREE) ! Actually: h*c*nu [cm&#94;-1] = h*c*nu [J] = nu * CM1_TO_KELVIN * k_B [J] ! So ZPE [Hartree] = 0.5 * sum(nu) * CM1_TO_KELVIN * KB_HARTREE zpe_hartree = 0.5_dp * freq_sum * CM1_TO_KELVIN * KB_HARTREE zpe_kcalmol = zpe_hartree * HARTREE_TO_KCALMOL end subroutine compute_zpe","tags":"","url":"proc/compute_zpe.html"},{"title":"print_thermochemistry – metalquicha","text":"public  subroutine print_thermochemistry(result, electronic_energy, unit) Print thermochemistry results. Arguments Type Intent Optional Attributes Name type( thermochemistry_result_t ), intent(in) :: result real(kind=dp), intent(in) :: electronic_energy Electronic energy in Hartree integer, intent(in), optional :: unit Output unit (default: stdout) Calls proc~~print_thermochemistry~~CallsGraph proc~print_thermochemistry print_thermochemistry info info proc~print_thermochemistry->info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_thermochemistry~~CalledByGraph proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis print_vibrational_analysis proc~print_vibrational_analysis->proc~print_thermochemistry proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: Cv_total real(kind=dp), private :: G_T real(kind=dp), private :: H0_HT_PV real(kind=dp), private :: H_T real(kind=dp), private :: H_rot_cal real(kind=dp), private :: H_total_cal real(kind=dp), private :: H_trans_cal real(kind=dp), private :: H_vib_cal real(kind=dp), private :: S_total real(kind=dp), private :: S_total_J real(kind=dp), private :: TS character(len=512), private :: line real(kind=dp), private :: pV_cal real(kind=dp), private :: total_energy real(kind=dp), private :: total_enthalpy real(kind=dp), private :: total_free_energy Source Code subroutine print_thermochemistry ( result , electronic_energy , unit ) !! Print thermochemistry results. type ( thermochemistry_result_t ), intent ( in ) :: result real ( dp ), intent ( in ) :: electronic_energy !! Electronic energy in Hartree integer , intent ( in ), optional :: unit !! Output unit (default: stdout) real ( dp ) :: H_total_cal , Cv_total , S_total , S_total_J real ( dp ) :: H_vib_cal , H_rot_cal , H_trans_cal real ( dp ) :: H_T , TS , G_T real ( dp ) :: total_energy , total_enthalpy , total_free_energy real ( dp ) :: H0_HT_PV , pV_cal character ( len = 512 ) :: line ! pV term = RT for ideal gas (in cal/mol) pV_cal = R_CALMOLK * result % temperature ! Compute enthalpy contributions (what xtb shows in \"enthalpy\" column) ! VIB: thermal vibrational energy only (ZPE is reported separately) H_vib_cal = result % E_vib * HARTREE_TO_CALMOL ! ROT: just internal energy (3/2)RT for nonlinear, RT for linear - no pV term H_rot_cal = result % E_rot * HARTREE_TO_CALMOL ! TR: includes pV term, so (5/2)RT for translation enthalpy H_trans_cal = result % E_trans * HARTREE_TO_CALMOL + pV_cal ! TOT: sum of thermal contributions (VIB + ROT + TR), NOT including ZPE H_total_cal = H_vib_cal + H_rot_cal + H_trans_cal ! Use Cp for translation (Cv + R) as is standard for thermochemistry output Cv_total = ( result % Cv_trans + R_CALMOLK ) + result % Cv_rot + result % Cv_vib S_total = result % S_trans + result % S_rot + result % S_vib + result % S_elec S_total_J = S_total * CAL_TO_J ! cal to J ! Thermodynamic quantities in Hartree ! H(0)-H(T)+PV is the thermal correction WITHOUT ZPE (just E_trans + E_rot + E_vib + RT) H0_HT_PV = result % E_trans + result % E_rot + result % E_vib + R_HARTREE * result % temperature ! H(T) is full thermal correction including ZPE H_T = result % thermal_correction_enthalpy TS = result % thermal_correction_enthalpy - result % thermal_correction_gibbs G_T = result % thermal_correction_gibbs total_energy = electronic_energy total_enthalpy = electronic_energy + result % thermal_correction_enthalpy total_free_energy = electronic_energy + result % thermal_correction_gibbs ! Print header call logger % info ( \" \" ) call logger % info ( \"Thermochemistry (RRHO)\" ) call logger % info ( \"======================\" ) call logger % info ( \" \" ) ! Setup section - simple list write ( line , '(A,F10.4,A)' ) \"  Temperature:       \" , result % temperature , \" K\" call logger % info ( trim ( line )) write ( line , '(A,F10.4,A)' ) \"  Pressure:          \" , result % pressure , \" atm\" call logger % info ( trim ( line )) write ( line , '(A,F10.4,A)' ) \"  Molecular mass:    \" , result % total_mass , \" amu\" call logger % info ( trim ( line )) write ( line , '(A,I6)' ) \"  Vibrational modes: \" , result % n_real_freqs call logger % info ( trim ( line )) if ( result % n_imag_freqs > 0 ) then write ( line , '(A,I6,A)' ) \"  Imaginary freqs:   \" , result % n_imag_freqs , \" (skipped)\" call logger % info ( trim ( line )) end if if ( result % is_linear ) then call logger % info ( \"  Linear molecule:   yes\" ) else call logger % info ( \"  Linear molecule:   no\" ) end if write ( line , '(A,I6)' ) \"  Symmetry number:   \" , result % symmetry_number call logger % info ( trim ( line )) call logger % info ( \" \" ) ! Contribution table call logger % info ( \"  temp (K)       q        H(cal/mol)  Cp(cal/K/mol)  S(cal/K/mol)  S(J/K/mol)\" ) call logger % info ( \"  -------------------------------------------------------------------------\" ) write ( line , '(F8.2,A,ES10.3,F12.3,F14.3,F14.3,F12.3)' ) & result % temperature , \"  VIB\" , result % q_vib , H_vib_cal , result % Cv_vib , & result % S_vib , result % S_vib * CAL_TO_J call logger % info ( trim ( line )) write ( line , '(A,ES10.3,F12.3,F14.3,F14.3,F12.3)' ) & \"          ROT\" , result % q_rot , H_rot_cal , result % Cv_rot , & result % S_rot , result % S_rot * CAL_TO_J call logger % info ( trim ( line )) write ( line , '(A,ES10.3,F12.3,F14.3,F14.3,F12.3)' ) & \"          INT\" , result % q_rot * result % q_vib , H_vib_cal + H_rot_cal , & result % Cv_vib + result % Cv_rot , result % S_vib + result % S_rot , & ( result % S_vib + result % S_rot ) * CAL_TO_J call logger % info ( trim ( line )) ! For TR, report Cp = Cv + R (constant pressure heat capacity for ideal gas) write ( line , '(A,ES10.3,F12.3,F14.3,F14.3,F12.3)' ) & \"          TR \" , result % q_trans , H_trans_cal , result % Cv_trans + R_CALMOLK , & result % S_trans , result % S_trans * CAL_TO_J call logger % info ( trim ( line )) call logger % info ( \"  -------------------------------------------------------------------------\" ) write ( line , '(A,F12.3,F14.3,F14.3,F12.3)' ) & \"          TOT           \" , H_total_cal , Cv_total , S_total , S_total_J call logger % info ( trim ( line )) call logger % info ( \" \" ) ! Thermal corrections table call logger % info ( \" \" ) call logger % info ( \"Thermal Corrections (Hartree)\" ) call logger % info ( \"-----------------------------\" ) write ( line , '(A,F18.12)' ) \"  Zero-point energy:              \" , result % zpe_hartree call logger % info ( trim ( line )) write ( line , '(A,F18.12)' ) \"  Thermal correction to Energy:   \" , result % thermal_correction_energy call logger % info ( trim ( line )) write ( line , '(A,F18.12)' ) \"  Thermal correction to Enthalpy: \" , result % thermal_correction_enthalpy call logger % info ( trim ( line )) write ( line , '(A,F18.12)' ) \"  Thermal correction to Gibbs:    \" , result % thermal_correction_gibbs call logger % info ( trim ( line )) call logger % info ( \" \" ) ! Final totals call logger % info ( \"Total Energies (Hartree)\" ) call logger % info ( \"------------------------\" ) write ( line , '(A,F20.12)' ) \"  Electronic energy:            \" , total_energy call logger % info ( trim ( line )) write ( line , '(A,F20.12)' ) \"  Electronic + ZPE:             \" , total_energy + result % zpe_hartree call logger % info ( trim ( line )) write ( line , '(A,F20.12)' ) \"  Electronic + thermal (E):     \" , total_energy + result % thermal_correction_energy call logger % info ( trim ( line )) write ( line , '(A,F20.12)' ) \"  Electronic + thermal (H):     \" , total_enthalpy call logger % info ( trim ( line )) write ( line , '(A,F20.12)' ) \"  Electronic + thermal (G):     \" , total_free_energy call logger % info ( trim ( line )) call logger % info ( \" \" ) end subroutine print_thermochemistry","tags":"","url":"proc/print_thermochemistry.html"},{"title":"compute_partition_functions – metalquicha","text":"private  subroutine compute_partition_functions(total_mass, moments, frequencies, n_freqs, temperature, pressure, sigma, is_linear, q_trans, q_rot, q_vib) Compute partition functions for translation, rotation, and vibration. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_mass Total mass in amu real(kind=dp), intent(in) :: moments (3) Principal moments in amu*Angstrom&#94;2 real(kind=dp), intent(in) :: frequencies (:) Frequencies in cm&#94;-1 integer, intent(in) :: n_freqs Number of frequencies real(kind=dp), intent(in) :: temperature Temperature in K real(kind=dp), intent(in) :: pressure Pressure in atm integer, intent(in) :: sigma Symmetry number logical, intent(in) :: is_linear True if linear molecule real(kind=dp), intent(out) :: q_trans Translational partition function real(kind=dp), intent(out) :: q_rot Rotational partition function real(kind=dp), intent(out) :: q_vib Vibrational partition function Called by proc~~compute_partition_functions~~CalledByGraph proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry compute_thermochemistry proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_thermochemistry proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_thermochemistry proc~hessian_coordinator->proc~print_vibrational_analysis proc~print_vibrational_analysis->proc~compute_thermochemistry proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: P_pa real(kind=dp), private :: T real(kind=dp), private :: V_molar integer, private :: i real(kind=dp), private :: lambda real(kind=dp), private :: mass_kg real(kind=dp), private :: theta_rot (3) real(kind=dp), private :: u Source Code subroutine compute_partition_functions ( total_mass , moments , frequencies , n_freqs , & temperature , pressure , sigma , is_linear , & q_trans , q_rot , q_vib ) !! Compute partition functions for translation, rotation, and vibration. real ( dp ), intent ( in ) :: total_mass !! Total mass in amu real ( dp ), intent ( in ) :: moments ( 3 ) !! Principal moments in amu*Angstrom&#94;2 real ( dp ), intent ( in ) :: frequencies (:) !! Frequencies in cm&#94;-1 integer , intent ( in ) :: n_freqs !! Number of frequencies real ( dp ), intent ( in ) :: temperature !! Temperature in K real ( dp ), intent ( in ) :: pressure !! Pressure in atm integer , intent ( in ) :: sigma !! Symmetry number logical , intent ( in ) :: is_linear !! True if linear molecule real ( dp ), intent ( out ) :: q_trans !! Translational partition function real ( dp ), intent ( out ) :: q_rot !! Rotational partition function real ( dp ), intent ( out ) :: q_vib !! Vibrational partition function real ( dp ) :: mass_kg , T , P_pa real ( dp ) :: lambda , V_molar real ( dp ) :: theta_rot ( 3 ), u integer :: i T = temperature mass_kg = total_mass * AMU_TO_KG P_pa = pressure * ATM_TO_PA ! Translational partition function: q_trans = (2*pi*m*k*T/h&#94;2)&#94;(3/2) * V ! where V = kT/P for ideal gas (per molecule) lambda = H_SI / sqrt ( 2.0_dp * PI * mass_kg * KB_SI * T ) ! thermal de Broglie wavelength V_molar = KB_SI * T / P_pa ! volume per molecule q_trans = V_molar / ( lambda ** 3 ) ! Rotational partition function ! theta_rot = h&#94;2 / (8*pi&#94;2*I*k_B) = ROTTEMP_AMUA2_TO_K / I (for I in amu*Angstrom&#94;2) do i = 1 , 3 if ( moments ( i ) > 1.0e-6_dp ) then theta_rot ( i ) = ROTTEMP_AMUA2_TO_K / moments ( i ) else theta_rot ( i ) = 0.0_dp end if end do if ( is_linear ) then ! Linear: q_rot = T / (sigma * theta_rot) if ( theta_rot ( 3 ) > 0.0_dp ) then q_rot = T / ( real ( sigma , dp ) * theta_rot ( 3 )) else q_rot = 1.0_dp end if else ! Nonlinear: q_rot = sqrt(pi) * T&#94;(3/2) / (sigma * sqrt(theta_A * theta_B * theta_C)) if ( theta_rot ( 1 ) > 0.0_dp . and . theta_rot ( 2 ) > 0.0_dp . and . theta_rot ( 3 ) > 0.0_dp ) then q_rot = sqrt ( PI ) * ( T ** 1.5_dp ) / & ( real ( sigma , dp ) * sqrt ( theta_rot ( 1 ) * theta_rot ( 2 ) * theta_rot ( 3 ))) else q_rot = 1.0_dp end if end if ! Vibrational partition function: q_vib = Product_i [1 / (1 - exp(-u_i))] ! where u_i = h*nu/(k*T) = theta_vib/T = 1.4388 * nu(cm&#94;-1) / T q_vib = 1.0_dp do i = 1 , n_freqs if ( frequencies ( i ) > 1 0.0_dp ) then ! Skip near-zero frequencies u = CM1_TO_KELVIN * frequencies ( i ) / T if ( u < 10 0.0_dp ) then ! Avoid overflow q_vib = q_vib / ( 1.0_dp - exp ( - u )) end if end if end do end subroutine compute_partition_functions","tags":"","url":"proc/compute_partition_functions.html"},{"title":"send_fragment_to_node – metalquicha","text":"subroutine send_fragment_to_node(world_comm, fragment_idx, polymers, dest_rank) Send fragment data to remote node coordinator\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank Calls proc~~send_fragment_to_node~~CallsGraph proc~send_fragment_to_node send_fragment_to_node isend isend proc~send_fragment_to_node->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_fragment_to_node~~CalledByGraph proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator global_coordinator proc~global_coordinator->proc~send_fragment_to_node interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: fragment_idx_int64 integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size integer(kind=int32), private :: fragment_type type(request_t), private :: req (4) Source Code subroutine send_fragment_to_node ( world_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to remote node coordinator !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int64 ) :: fragment_idx_int64 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int64 = int ( fragment_idx , kind = int64 ) call isend ( world_comm , fragment_idx_int64 , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , fragment_size , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , fragment_indices , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_node","tags":"","url":"proc/send_fragment_to_node.html"},{"title":"send_fragment_to_worker – metalquicha","text":"subroutine send_fragment_to_worker(node_comm, fragment_idx, polymers, dest_rank) Send fragment data to local worker\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank Calls proc~~send_fragment_to_worker~~CallsGraph proc~send_fragment_to_worker send_fragment_to_worker isend isend proc~send_fragment_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_fragment_to_worker~~CalledByGraph proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator global_coordinator proc~global_coordinator->proc~send_fragment_to_worker interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: fragment_idx_int64 integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size integer(kind=int32), private :: fragment_type type(request_t), private :: req (4) Source Code subroutine send_fragment_to_worker ( node_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to local worker !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int64 ) :: fragment_idx_int64 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int64 = int ( fragment_idx , kind = int64 ) call isend ( node_comm , fragment_idx_int64 , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , fragment_size , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , fragment_indices , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_worker","tags":"","url":"proc/send_fragment_to_worker.html"},{"title":"binomial – metalquicha","text":"public pure function binomial(n, r) result(c) Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) Calculates “n choose r” using iterative algorithm to avoid\nfactorial overflow for large numbers.\nUses int64 to handle large combinatorial values that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n Total number of items integer(kind=default_int), intent(in) :: r Number of items to choose Return Value integer(kind=int64) Binomial coefficient result Called by proc~~binomial~~CalledByGraph proc~binomial binomial proc~get_nfrags get_nfrags proc~get_nfrags->proc~binomial proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~binomial proc~run_fragmented_calculation->proc~get_nfrags proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i Loop counter Source Code pure function binomial ( n , r ) result ( c ) !! Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) !! !! Calculates \"n choose r\" using iterative algorithm to avoid !! factorial overflow for large numbers. !! Uses int64 to handle large combinatorial values that overflow int32. integer ( default_int ), intent ( in ) :: n !! Total number of items integer ( default_int ), intent ( in ) :: r !! Number of items to choose integer ( int64 ) :: c !! Binomial coefficient result integer ( default_int ) :: i !! Loop counter if ( r == 0 . or . r == n ) then c = 1_int64 else if ( r > n ) then c = 0_int64 else c = 1_int64 do i = 1 , r c = c * int ( n - i + 1 , int64 ) / int ( i , int64 ) end do end if end function binomial","tags":"","url":"proc/binomial.html"},{"title":"get_nfrags – metalquicha","text":"public pure function get_nfrags(n_monomers, max_level) result(n_expected_fragments) Calculate total number of fragments for given system size and max level Computes the sum of binomial coefficients C(n,k) for k=1 to max_level,\nrepresenting all possible fragments from monomers to max_level-mers.\nUses int64 to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n_monomers Number of monomers in system integer(kind=default_int), intent(in) :: max_level Maximum fragment size Return Value integer(kind=int64) Total fragment count Calls proc~~get_nfrags~~CallsGraph proc~get_nfrags get_nfrags proc~binomial binomial proc~get_nfrags->proc~binomial Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nfrags~~CalledByGraph proc~get_nfrags get_nfrags proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~get_nfrags proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i Loop counter Source Code pure function get_nfrags ( n_monomers , max_level ) result ( n_expected_fragments ) !! Calculate total number of fragments for given system size and max level !! !! Computes the sum of binomial coefficients C(n,k) for k=1 to max_level, !! representing all possible fragments from monomers to max_level-mers. !! Uses int64 to handle large fragment counts that overflow int32. integer ( default_int ), intent ( in ) :: n_monomers !! Number of monomers in system integer ( default_int ), intent ( in ) :: max_level !! Maximum fragment size integer ( int64 ) :: n_expected_fragments !! Total fragment count integer ( default_int ) :: i !! Loop counter n_expected_fragments = 0_int64 do i = 1 , max_level n_expected_fragments = n_expected_fragments + binomial ( n_monomers , i ) end do end function get_nfrags","tags":"","url":"proc/get_nfrags.html"},{"title":"next_combination – metalquicha","text":"public  function next_combination(combination, k, n) result(has_next) Generate next combination in lexicographic order\nReturns .true. if there’s a next combination, .false. if we’ve exhausted all Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k integer, intent(in) :: n Return Value logical Called by proc~~next_combination~~CalledByGraph proc~next_combination next_combination proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->proc~next_combination proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_k_way_intersections_from_lists->proc~next_combination proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code function next_combination ( combination , k , n ) result ( has_next ) !! Generate next combination in lexicographic order !! Returns .true. if there's a next combination, .false. if we've exhausted all integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k , n logical :: has_next integer :: i has_next = . true . ! Find the rightmost element that can be incremented i = k do while ( i >= 1 ) if ( combination ( i ) < n - k + i ) then combination ( i ) = combination ( i ) + 1 ! Reset all elements to the right do while ( i < k ) i = i + 1 combination ( i ) = combination ( i - 1 ) + 1 end do return end if i = i - 1 end do ! No more combinations has_next = . false . end function next_combination","tags":"","url":"proc/next_combination.html"},{"title":"calculate_fragment_distances – metalquicha","text":"public  subroutine calculate_fragment_distances(polymers, fragment_count, sys_geom, distances) Uses mqc_physical_fragment pic_types proc~~calculate_fragment_distances~~UsesGraph proc~calculate_fragment_distances calculate_fragment_distances module~mqc_physical_fragment mqc_physical_fragment proc~calculate_fragment_distances->module~mqc_physical_fragment pic_types pic_types proc~calculate_fragment_distances->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calculate minimal atomic distance for each fragment\nFor monomers (1-body), distance is 0.0\nFor n-mers (n >= 2), distance is the minimum distance between atoms\nin different constituent monomers Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: distances (:) Calls proc~~calculate_fragment_distances~~CallsGraph proc~calculate_fragment_distances calculate_fragment_distances proc~to_angstrom to_angstrom proc~calculate_fragment_distances->proc~to_angstrom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_end_i integer, private :: atom_end_j integer, private :: atom_start_i integer, private :: atom_start_j real(kind=dp), private :: dist real(kind=dp), private :: dx real(kind=dp), private :: dy real(kind=dp), private :: dz integer, private :: fragment_size integer, private :: i integer, private :: iatom integer(kind=int64), private :: ifrag logical, private :: is_variable_size integer, private :: j integer, private :: jatom integer, private :: k real(kind=dp), private :: min_dist integer, private :: mon_i integer, private :: mon_j Source Code subroutine calculate_fragment_distances ( polymers , fragment_count , sys_geom , distances ) !! Calculate minimal atomic distance for each fragment !! For monomers (1-body), distance is 0.0 !! For n-mers (n >= 2), distance is the minimum distance between atoms !! in different constituent monomers use pic_types , only : dp use mqc_physical_fragment , only : system_geometry_t , to_angstrom integer ( default_int ), intent ( in ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: fragment_count type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: distances (:) integer ( int64 ) :: ifrag integer :: fragment_size , i , j , iatom , jatom integer :: mon_i , mon_j integer :: atom_start_i , atom_end_i , atom_start_j , atom_end_j integer :: k real ( dp ) :: dist , min_dist real ( dp ) :: dx , dy , dz logical :: is_variable_size ! Check if we have variable-sized fragments is_variable_size = allocated ( sys_geom % fragment_sizes ) do ifrag = 1_int64 , fragment_count fragment_size = count ( polymers ( ifrag , :) > 0 ) if ( fragment_size == 1 ) then ! Monomers have distance 0 distances ( ifrag ) = 0.0_dp else ! For n-mers, calculate minimal distance between atoms in different monomers min_dist = huge ( 1.0_dp ) ! Loop over all pairs of monomers in this fragment do i = 1 , fragment_size - 1 mon_i = polymers ( ifrag , i ) do j = i + 1 , fragment_size mon_j = polymers ( ifrag , j ) if ( is_variable_size ) then ! Variable-sized fragments: use fragment_atoms to get atom indices ! Count atoms in this fragment do iatom = 1 , sys_geom % fragment_sizes ( mon_i ) atom_start_i = sys_geom % fragment_atoms ( iatom , mon_i ) + 1 ! Convert to 1-indexed do jatom = 1 , sys_geom % fragment_sizes ( mon_j ) atom_start_j = sys_geom % fragment_atoms ( jatom , mon_j ) + 1 ! Convert to 1-indexed ! Calculate distance dx = sys_geom % coordinates ( 1 , atom_start_i ) - sys_geom % coordinates ( 1 , atom_start_j ) dy = sys_geom % coordinates ( 2 , atom_start_i ) - sys_geom % coordinates ( 2 , atom_start_j ) dz = sys_geom % coordinates ( 3 , atom_start_i ) - sys_geom % coordinates ( 3 , atom_start_j ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_dist ) min_dist = dist end do end do else ! Fixed-sized monomers: calculate atom range directly atom_start_i = ( mon_i - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_i = mon_i * sys_geom % atoms_per_monomer atom_start_j = ( mon_j - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_j = mon_j * sys_geom % atoms_per_monomer ! Loop over all atoms in monomer i do iatom = atom_start_i , atom_end_i ! Loop over all atoms in monomer j do jatom = atom_start_j , atom_end_j ! Calculate distance (coordinates are in Bohr) dx = sys_geom % coordinates ( 1 , iatom ) - sys_geom % coordinates ( 1 , jatom ) dy = sys_geom % coordinates ( 2 , iatom ) - sys_geom % coordinates ( 2 , jatom ) dz = sys_geom % coordinates ( 3 , iatom ) - sys_geom % coordinates ( 3 , jatom ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_dist ) min_dist = dist end do end do end if end do end do ! Convert from Bohr to Angstrom distances ( ifrag ) = to_angstrom ( min_dist ) end if end do end subroutine calculate_fragment_distances","tags":"","url":"proc/calculate_fragment_distances.html"},{"title":"combine – metalquicha","text":"public recursive subroutine combine(arr, n, r, out_array, count) Generate all combinations of size r from array arr of size n\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count Calls proc~~combine~~CallsGraph proc~combine combine proc~combine_util combine_util proc~combine->proc~combine_util proc~combine_util->proc~combine_util Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~combine~~CalledByGraph proc~combine combine proc~generate_fragment_list generate_fragment_list proc~generate_fragment_list->proc~combine proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~combine proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: data (r) Source Code recursive subroutine combine ( arr , n , r , out_array , count ) !! Generate all combinations of size r from array arr of size n !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:) integer ( default_int ), intent ( in ) :: n , r integer ( default_int ), intent ( inout ) :: out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: data ( r ) call combine_util ( arr , n , r , 1 , data , 1 , out_array , count ) end subroutine combine","tags":"","url":"proc/combine.html"},{"title":"create_monomer_list – metalquicha","text":"public pure subroutine create_monomer_list(monomers) Generate a list of monomer indices from 1 to N Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(inout), allocatable :: monomers (:) Called by proc~~create_monomer_list~~CalledByGraph proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~create_monomer_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: length Source Code pure subroutine create_monomer_list ( monomers ) !! Generate a list of monomer indices from 1 to N integer ( default_int ), allocatable , intent ( inout ) :: monomers (:) integer ( default_int ) :: i , length length = size ( monomers , 1 ) do i = 1 , length monomers ( i ) = i end do end subroutine create_monomer_list","tags":"","url":"proc/create_monomer_list.html"},{"title":"generate_fragment_list – metalquicha","text":"public recursive subroutine generate_fragment_list(monomers, max_level, polymers, count) Generate all possible fragments (combinations of monomers) up to max_level\nUses int64 for count to handle large numbers of fragments that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: monomers (:) integer(kind=default_int), intent(in) :: max_level integer(kind=default_int), intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: count Calls proc~~generate_fragment_list~~CallsGraph proc~generate_fragment_list generate_fragment_list proc~combine combine proc~generate_fragment_list->proc~combine proc~combine_util combine_util proc~combine->proc~combine_util proc~combine_util->proc~combine_util Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_fragment_list~~CalledByGraph proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: n integer(kind=default_int), private :: r Source Code recursive subroutine generate_fragment_list ( monomers , max_level , polymers , count ) !! Generate all possible fragments (combinations of monomers) up to max_level !! Uses int64 for count to handle large numbers of fragments that overflow int32. integer ( default_int ), intent ( in ) :: monomers (:), max_level integer ( default_int ), intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: r , n n = size ( monomers , 1 ) do r = 2 , max_level call combine ( monomers , n , r , polymers , count ) end do end subroutine generate_fragment_list","tags":"","url":"proc/generate_fragment_list.html"},{"title":"get_next_combination – metalquicha","text":"public pure subroutine get_next_combination(indices, k, n, has_next) Generate next combination (updates indices in place)\nhas_next = .true. if there’s a next combination Arguments Type Intent Optional Attributes Name integer, intent(inout) :: indices (:) integer, intent(in) :: k integer, intent(in) :: n logical, intent(out) :: has_next Called by proc~~get_next_combination~~CalledByGraph proc~get_next_combination get_next_combination proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe_dipole->proc~get_next_combination proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~get_next_combination proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~get_next_combination proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->proc~get_next_combination proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->proc~fragment_should_be_screened proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe->proc~compute_mbe_dipole proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~apply_distance_screening interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine get_next_combination ( indices , k , n , has_next ) !! Generate next combination (updates indices in place) !! has_next = .true. if there's a next combination integer , intent ( inout ) :: indices (:) integer , intent ( in ) :: k , n logical , intent ( out ) :: has_next integer :: i has_next = . true . i = k do while ( i >= 1 ) if ( indices ( i ) < n - k + i ) then indices ( i ) = indices ( i ) + 1 do while ( i < k ) i = i + 1 indices ( i ) = indices ( i - 1 ) + 1 end do return end if i = i - 1 end do has_next = . false . end subroutine get_next_combination","tags":"","url":"proc/get_next_combination.html"},{"title":"next_combination_init – metalquicha","text":"public  subroutine next_combination_init(combination, k) Initialize combination to [1, 2, …, k] Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k Called by proc~~next_combination_init~~CalledByGraph proc~next_combination_init next_combination_init proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->proc~next_combination_init proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_k_way_intersections_from_lists->proc~next_combination_init proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine next_combination_init ( combination , k ) !! Initialize combination to [1, 2, ..., k] integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k integer :: i do i = 1 , k combination ( i ) = i end do end subroutine next_combination_init","tags":"","url":"proc/next_combination_init.html"},{"title":"print_combos – metalquicha","text":"public  subroutine print_combos(out_array, count, max_len) Print combinations stored in out_array\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: out_array (:,:) integer(kind=int64), intent(in) :: count integer(kind=default_int), intent(in) :: max_len Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: i integer(kind=default_int), private :: j Source Code subroutine print_combos ( out_array , count , max_len ) !! Print combinations stored in out_array !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: out_array (:, :), max_len integer ( int64 ), intent ( in ) :: count integer ( int64 ) :: i integer ( default_int ) :: j do i = 1_int64 , count do j = 1 , max_len if ( out_array ( i , j ) == 0 ) exit write ( * , '(I0)' , advance = 'no' ) out_array ( i , j ) if ( j < max_len . and . out_array ( i , j + 1 ) /= 0 ) then write ( * , '(A)' , advance = 'no' ) \":\" end if end do write ( * , * ) ! newline end do end subroutine print_combos","tags":"","url":"proc/print_combos.html"},{"title":"combine_util – metalquicha","text":"private recursive subroutine combine_util(arr, n, r, index, data, i, out_array, count) Utility for generating combinations recursively\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(in) :: index integer(kind=default_int), intent(inout) :: data (:) integer(kind=default_int), intent(in) :: i integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count Called by proc~~combine_util~~CalledByGraph proc~combine_util combine_util proc~combine_util->proc~combine_util proc~combine combine proc~combine->proc~combine_util proc~generate_fragment_list generate_fragment_list proc~generate_fragment_list->proc~combine proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~combine proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: j Source Code recursive subroutine combine_util ( arr , n , r , index , data , i , out_array , count ) !! Utility for generating combinations recursively !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:), n , r , index , i integer ( default_int ), intent ( inout ) :: data (:), out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: j if ( index > r ) then count = count + 1_int64 out_array ( count , 1 : r ) = data ( 1 : r ) return end if do j = i , n data ( index ) = arr ( j ) call combine_util ( arr , n , r , index + 1 , data , j + 1 , out_array , count ) end do end subroutine combine_util","tags":"","url":"proc/combine_util.html"},{"title":"atomic_basis_num_basis_functions – metalquicha","text":"private pure function atomic_basis_num_basis_functions(self) result(nbf) Get total number of basis functions for an atom Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer Calls proc~~atomic_basis_num_basis_functions~~CallsGraph proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~atomic_basis_num_basis_functions~~CalledByGraph proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ishell Source Code pure function atomic_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for an atom class ( atomic_basis_type ), intent ( in ) :: self integer :: nbf integer :: ishell nbf = 0 do ishell = 1 , self % nshells nbf = nbf + self % shells ( ishell )% num_basis_functions () end do end function atomic_basis_num_basis_functions","tags":"","url":"proc/atomic_basis_num_basis_functions.html"},{"title":"cgto_num_basis_functions – metalquicha","text":"private pure function cgto_num_basis_functions(self) result(nbf) Get number of basis functions in a shell (Cartesian) Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer Called by proc~~cgto_num_basis_functions~~CalledByGraph proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function cgto_num_basis_functions ( self ) result ( nbf ) !! Get number of basis functions in a shell (Cartesian) class ( cgto_type ), intent ( in ) :: self integer :: nbf ! Cartesian: (ang_mom+1)*(ang_mom+2)/2 nbf = ( self % ang_mom + 1 ) * ( self % ang_mom + 2 ) / 2 end function cgto_num_basis_functions","tags":"","url":"proc/cgto_num_basis_functions.html"},{"title":"molecular_basis_num_basis_functions – metalquicha","text":"private pure function molecular_basis_num_basis_functions(self) result(nbf) Get total number of basis functions for the molecule Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Calls proc~~molecular_basis_num_basis_functions~~CallsGraph proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom Source Code pure function molecular_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for the molecule class ( molecular_basis_type ), intent ( in ) :: self integer :: nbf integer :: iatom nbf = 0 do iatom = 1 , self % nelements nbf = nbf + self % elements ( iatom )% num_basis_functions () end do end function molecular_basis_num_basis_functions","tags":"","url":"proc/molecular_basis_num_basis_functions.html"},{"title":"allocate_basis_shells – metalquicha","text":"private pure subroutine allocate_basis_shells(self, nshells) Allocate array of shells in an atomic basis Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells Called by proc~~allocate_basis_shells~~CalledByGraph proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis copy_atomic_basis proc~copy_atomic_basis->proc~allocate_basis_shells proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~allocate_basis_shells proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine allocate_basis_shells ( self , nshells ) !! Allocate array of shells in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nshells self % nshells = nshells allocate ( self % shells ( nshells )) end subroutine allocate_basis_shells","tags":"","url":"proc/allocate_basis_shells.html"},{"title":"atomic_basis_destroy – metalquicha","text":"private pure subroutine atomic_basis_destroy(self) Clean up allocated memory in an atomic basis Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self Calls proc~~atomic_basis_destroy~~CallsGraph proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~atomic_basis_destroy~~CalledByGraph proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~atomic_basis_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~fragment_destroy proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~process_intersection_derivatives->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine atomic_basis_destroy ( self ) !! Clean up allocated memory in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % shells )) then do i = 1 , self % nshells call self % shells ( i )% destroy () end do deallocate ( self % shells ) end if if ( allocated ( self % element )) deallocate ( self % element ) self % nshells = 0 end subroutine atomic_basis_destroy","tags":"","url":"proc/atomic_basis_destroy.html"},{"title":"basis_set_allocate_elements – metalquicha","text":"private pure subroutine basis_set_allocate_elements(self, nelements) Allocate array of atomic basis elements in a molecular basis set Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements Called by proc~~basis_set_allocate_elements~~CalledByGraph proc~basis_set_allocate_elements molecular_basis_type%basis_set_allocate_elements proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~basis_set_allocate_elements Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine basis_set_allocate_elements ( self , nelements ) !! Allocate array of atomic basis elements in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nelements self % nelements = nelements allocate ( self % elements ( nelements )) end subroutine basis_set_allocate_elements","tags":"","url":"proc/basis_set_allocate_elements.html"},{"title":"basis_set_destroy – metalquicha","text":"private pure subroutine basis_set_destroy(self) Clean up allocated memory in a molecular basis set Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self Calls proc~~basis_set_destroy~~CallsGraph proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_set_destroy~~CalledByGraph proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~fragment_destroy proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~process_intersection_derivatives->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine basis_set_destroy ( self ) !! Clean up allocated memory in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % elements )) then do i = 1 , self % nelements call self % elements ( i )% destroy () end do deallocate ( self % elements ) end if self % nelements = 0 end subroutine basis_set_destroy","tags":"","url":"proc/basis_set_destroy.html"},{"title":"cgto_allocate_arrays – metalquicha","text":"private pure subroutine cgto_allocate_arrays(self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc Called by proc~~cgto_allocate_arrays~~CalledByGraph proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis copy_atomic_basis proc~copy_atomic_basis->proc~cgto_allocate_arrays proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~cgto_allocate_arrays proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~parse_element_basis->proc~fill_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine cgto_allocate_arrays ( self , nfunc ) !! Allocate arrays for exponents and coefficients in a CGTO class ( cgto_type ), intent ( inout ) :: self integer , intent ( in ) :: nfunc self % nfunc = nfunc allocate ( self % exponents ( nfunc )) allocate ( self % coefficients ( nfunc )) end subroutine cgto_allocate_arrays","tags":"","url":"proc/cgto_allocate_arrays.html"},{"title":"cgto_destroy – metalquicha","text":"private pure subroutine cgto_destroy(self) Clean up allocated memory in a CGTO Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self Called by proc~~cgto_destroy~~CalledByGraph proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~atomic_basis_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~fragment_destroy proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~process_intersection_derivatives->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine cgto_destroy ( self ) !! Clean up allocated memory in a CGTO class ( cgto_type ), intent ( inout ) :: self if ( allocated ( self % exponents )) deallocate ( self % exponents ) if ( allocated ( self % coefficients )) deallocate ( self % coefficients ) self % nfunc = 0 self % ang_mom = 0 end subroutine cgto_destroy","tags":"","url":"proc/cgto_destroy.html"},{"title":"method_type_from_string – metalquicha","text":"public pure function method_type_from_string(method_str) result(method_type) Convert method type string to integer constant Performs case-insensitive comparison and returns appropriate constant.\nReturns METHOD_TYPE_UNKNOWN for unrecognized strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Input string (e.g., “gfn1”, “gfn2”, “hf”) Return Value integer(kind=int32) Output integer constant Called by proc~~method_type_from_string~~CalledByGraph proc~method_type_from_string method_type_from_string proc~parse_method_string parse_method_string proc~parse_method_string->proc~method_type_from_string proc~parse_model_section parse_model_section proc~parse_model_section->proc~parse_method_string proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_model_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=len_trim), private :: lower_str Source Code pure function method_type_from_string ( method_str ) result ( method_type ) !! Convert method type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns METHOD_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: method_str !! Input string (e.g., \"gfn1\", \"gfn2\", \"hf\") integer ( int32 ) :: method_type !! Output integer constant character ( len = len_trim ( method_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) ! Semi-empirical case ( 'gfn1' , 'gfn1-xtb' ) method_type = METHOD_TYPE_GFN1 case ( 'gfn2' , 'gfn2-xtb' ) method_type = METHOD_TYPE_GFN2 ! SCF methods case ( 'hf' , 'rhf' , 'uhf' , 'hartree-fock' ) method_type = METHOD_TYPE_HF case ( 'dft' , 'ks' , 'kohn-sham' ) method_type = METHOD_TYPE_DFT ! Multi-reference case ( 'mcscf' , 'casscf' , 'casci' ) method_type = METHOD_TYPE_MCSCF ! Perturbation theory case ( 'mp2' , 'ri-mp2' , 'df-mp2' , 'scs-mp2' , 'sos-mp2' ) method_type = METHOD_TYPE_MP2 case ( 'mp2-f12' , 'ri-mp2-f12' , 'df-mp2-f12' ) method_type = METHOD_TYPE_MP2_F12 ! Coupled cluster case ( 'ccsd' , 'ri-ccsd' , 'df-ccsd' ) method_type = METHOD_TYPE_CCSD case ( 'ccsd(t)' , 'ri-ccsd(t)' , 'df-ccsd(t)' ) method_type = METHOD_TYPE_CCSD_T case ( 'ccsd-f12' , 'ri-ccsd-f12' ) method_type = METHOD_TYPE_CCSD_F12 case ( 'ccsd(t)-f12' , 'ri-ccsd(t)-f12' ) method_type = METHOD_TYPE_CCSD_T_F12 case default method_type = METHOD_TYPE_UNKNOWN end select end function method_type_from_string","tags":"","url":"proc/method_type_from_string.html"},{"title":"method_type_to_string – metalquicha","text":"public pure function method_type_to_string(method_type) result(method_str) Convert method type integer constant to string Provides human-readable string representation of method type. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: method_type Input integer constant Return Value character(len=:), allocatable Output string representation Called by proc~~method_type_to_string~~CalledByGraph proc~method_type_to_string method_type_to_string proc~configure_xtb configure_xtb proc~configure_xtb->proc~method_type_to_string proc~factory_create method_factory_t%factory_create proc~factory_create->proc~configure_xtb proc~create_method create_method proc~create_method->proc~factory_create proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~create_method proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~create_method proc~hessian_worker hessian_worker proc~hessian_worker->proc~create_method interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function method_type_to_string ( method_type ) result ( method_str ) !! Convert method type integer constant to string !! !! Provides human-readable string representation of method type. integer ( int32 ), intent ( in ) :: method_type !! Input integer constant character ( len = :), allocatable :: method_str !! Output string representation select case ( method_type ) ! Semi-empirical case ( METHOD_TYPE_GFN1 ) method_str = \"gfn1\" case ( METHOD_TYPE_GFN2 ) method_str = \"gfn2\" ! SCF methods case ( METHOD_TYPE_HF ) method_str = \"hf\" case ( METHOD_TYPE_DFT ) method_str = \"dft\" ! Multi-reference case ( METHOD_TYPE_MCSCF ) method_str = \"mcscf\" ! Perturbation theory case ( METHOD_TYPE_MP2 ) method_str = \"mp2\" case ( METHOD_TYPE_MP2_F12 ) method_str = \"mp2-f12\" ! Coupled cluster case ( METHOD_TYPE_CCSD ) method_str = \"ccsd\" case ( METHOD_TYPE_CCSD_T ) method_str = \"ccsd(t)\" case ( METHOD_TYPE_CCSD_F12 ) method_str = \"ccsd-f12\" case ( METHOD_TYPE_CCSD_T_F12 ) method_str = \"ccsd(t)-f12\" case default method_str = \"unknown\" end select end function method_type_to_string","tags":"","url":"proc/method_type_to_string.html"},{"title":"element_mass – metalquicha","text":"public pure function element_mass(atomic_number) result(mass) Return atomic mass in atomic mass units (amu) for a given atomic number\nUses standard atomic weights from IUPAC Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value real(kind=dp) Called by proc~~element_mass~~CalledByGraph proc~element_mass element_mass proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities compute_ir_intensities proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses compute_reduced_masses proc~compute_reduced_masses->proc~element_mass proc~mass_weight_hessian mass_weight_hessian proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation project_translation_rotation proc~project_translation_rotation->proc~element_mass proc~compute_thermochemistry compute_thermochemistry proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~print_vibrational_analysis print_vibrational_analysis proc~compute_gmbe->proc~print_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_thermochemistry proc~compute_mbe->proc~compute_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_thermochemistry proc~hessian_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~hessian_coordinator->proc~print_vibrational_analysis proc~print_vibrational_analysis->proc~compute_thermochemistry proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function element_mass ( atomic_number ) result ( mass ) !! Return atomic mass in atomic mass units (amu) for a given atomic number !! Uses standard atomic weights from IUPAC integer , intent ( in ) :: atomic_number real ( dp ) :: mass select case ( atomic_number ) case ( 1 : 118 ) mass = element_masses ( atomic_number ) case default mass = 0.0_dp ! Unknown element end select end function element_mass","tags":"","url":"proc/element_mass.html"},{"title":"element_number_to_symbol – metalquicha","text":"public pure function element_number_to_symbol(atomic_number) result(symbol) Convert atomic number to element symbol\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value character(len=2) Called by proc~~element_number_to_symbol~~CalledByGraph proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms check_duplicate_atoms proc~check_duplicate_atoms->proc~element_number_to_symbol proc~print_fragment_xyz print_fragment_xyz proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_vibrational_analysis print_vibrational_analysis proc~print_vibrational_analysis->proc~element_number_to_symbol proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_vibrational_analysis proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~print_vibrational_analysis proc~unfragmented_calculation->interface~do_fragment_work interface~do_fragment_work->proc~do_fragment_work interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~node_worker->interface~do_fragment_work proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~serial_fragment_processor->interface~do_fragment_work interface~global_coordinator->proc~global_coordinator interface~node_worker->proc~node_worker interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function element_number_to_symbol ( atomic_number ) result ( symbol ) !! Convert atomic number to element symbol !! Covers the complete periodic table (elements 1-118) integer , intent ( in ) :: atomic_number character ( len = 2 ) :: symbol select case ( atomic_number ) case ( 1 : 118 ) symbol = element_symbols ( atomic_number ) case default symbol = 'Xx' ! Unknown end select end function element_number_to_symbol","tags":"","url":"proc/element_number_to_symbol.html"},{"title":"element_symbol_to_number – metalquicha","text":"public pure function element_symbol_to_number(symbol) result(atomic_number) Convert element symbol to atomic number\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Return Value integer Calls proc~~element_symbol_to_number~~CallsGraph proc~element_symbol_to_number element_symbol_to_number to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~element_symbol_to_number~~CalledByGraph proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~element_symbol_to_number proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=2), private :: sym Source Code pure function element_symbol_to_number ( symbol ) result ( atomic_number ) !! Convert element symbol to atomic number !! Covers the complete periodic table (elements 1-118) character ( len =* ), intent ( in ) :: symbol integer :: atomic_number character ( len = 2 ) :: sym ! Normalize: uppercase first letter, lowercase second sym = adjustl ( symbol ) if ( len_trim ( sym ) >= 1 ) sym ( 1 : 1 ) = to_upper ( sym ( 1 : 1 )) if ( len_trim ( sym ) >= 2 ) sym ( 2 : 2 ) = to_lower ( sym ( 2 : 2 )) ! Search for symbol in table atomic_number = findloc ( element_symbols , sym , dim = 1 ) end function element_symbol_to_number","tags":"","url":"proc/element_symbol_to_number.html"},{"title":"merge_multi_molecule_json – metalquicha","text":"public  subroutine merge_multi_molecule_json(individual_files, nmol) Uses mqc_io_helpers proc~~merge_multi_molecule_json~~UsesGraph proc~merge_multi_molecule_json merge_multi_molecule_json module~mqc_io_helpers mqc_io_helpers proc~merge_multi_molecule_json->module~mqc_io_helpers Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Merge individual molecule JSON files into a single combined file Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: individual_files (:) integer, intent(in) :: nmol Calls proc~~merge_multi_molecule_json~~CallsGraph proc~merge_multi_molecule_json merge_multi_molecule_json error error proc~merge_multi_molecule_json->error info info proc~merge_multi_molecule_json->info proc~read_json_content read_json_content proc~merge_multi_molecule_json->proc~read_json_content to_char to_char proc~merge_multi_molecule_json->to_char proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~merge_multi_molecule_json~~CalledByGraph proc~merge_multi_molecule_json merge_multi_molecule_json proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename integer, private :: dot_pos logical, private :: file_exists integer, private :: imol integer, private :: io_stat character(len=10000), private :: line character(len=256), private :: output_file integer, private :: slash_pos integer, private :: unit_in integer, private :: unit_out Source Code subroutine merge_multi_molecule_json ( individual_files , nmol ) !! Merge individual molecule JSON files into a single combined file use mqc_io_helpers , only : get_molecule_name character ( len = 256 ), intent ( in ) :: individual_files (:) integer , intent ( in ) :: nmol integer :: imol , unit_in , unit_out , io_stat , slash_pos , dot_pos character ( len = 10000 ) :: line character ( len = 256 ) :: output_file , basename logical :: file_exists ! Determine combined output filename from first individual file ! Example: \"output_multi_structure_molecule_1.json\" -> \"output_multi_structure.json\" basename = individual_files ( 1 ) slash_pos = index ( basename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = basename ( slash_pos + 1 :) end if ! Remove \"_molecule_1\" or similar suffix dot_pos = index ( basename , '_molecule_' ) if ( dot_pos > 0 ) then output_file = basename ( 1 : dot_pos - 1 ) // \".json\" else output_file = \"output_combined.json\" end if ! Open combined output file open ( newunit = unit_out , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Merging \" // to_char ( nmol ) // \" molecule JSON files into \" // trim ( output_file )) ! Write opening brace and top-level key (basename without \"output_\" and \".json\") dot_pos = index ( output_file , '.json' ) if ( dot_pos > 0 ) then basename = output_file ( 8 : dot_pos - 1 ) ! Skip \"output_\" else basename = \"combined\" end if write ( unit_out , '(a)' ) \"{\" write ( unit_out , '(a)' ) '  \"' // trim ( basename ) // '\": {' ! Process each individual JSON file do imol = 1 , nmol inquire ( file = trim ( individual_files ( imol )), exist = file_exists ) if (. not . file_exists ) cycle open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) cycle ! Read all lines from the individual JSON file call read_json_content ( unit_in , imol , unit_out , individual_files ( imol )) close ( unit_in ) ! Delete individual file open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'readwrite' ) close ( unit_in , status = 'delete' ) end do ! Close last molecule write ( unit_out , '(a)' ) '    }' ! Close top-level key and file write ( unit_out , '(a)' ) '  }' write ( unit_out , '(a)' ) '}' close ( unit_out ) call logger % info ( \"Combined JSON written to \" // trim ( output_file )) end subroutine merge_multi_molecule_json","tags":"","url":"proc/merge_multi_molecule_json.html"},{"title":"read_json_content – metalquicha","text":"private  subroutine read_json_content(unit_in, mol_index, unit_out, filename) Uses mqc_io_helpers proc~~read_json_content~~UsesGraph proc~read_json_content read_json_content module~mqc_io_helpers mqc_io_helpers proc~read_json_content->module~mqc_io_helpers Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Read and write JSON content from an individual molecule file\nProperly handles nested structures from fragmented calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit_in integer, intent(in) :: mol_index integer, intent(in) :: unit_out character(len=*), intent(in) :: filename Calls proc~~read_json_content~~CallsGraph proc~read_json_content read_json_content error error proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_json_content~~CalledByGraph proc~read_json_content read_json_content proc~merge_multi_molecule_json merge_multi_molecule_json proc~merge_multi_molecule_json->proc~read_json_content proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=10000), private, allocatable :: all_lines (:) integer, private :: i integer, private :: io_stat character(len=10000), private :: line integer, private :: nlines Source Code subroutine read_json_content ( unit_in , mol_index , unit_out , filename ) !! Read and write JSON content from an individual molecule file !! Properly handles nested structures from fragmented calculations use mqc_io_helpers , only : get_molecule_name integer , intent ( in ) :: unit_in , mol_index , unit_out character ( len =* ), intent ( in ) :: filename character ( len = 10000 ), allocatable :: all_lines (:) character ( len = 10000 ) :: line integer :: io_stat , nlines , i ! Read all lines into memory allocate ( all_lines ( 1000 )) ! Reasonable size for most JSON files nlines = 0 do read ( unit_in , '(a)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit nlines = nlines + 1 if ( nlines > size ( all_lines )) then ! Reallocate if needed call logger % error ( \"JSON file too large: \" // trim ( filename )) return end if all_lines ( nlines ) = line end do ! Lines structure: ! 1: \"{\" ! 2: '  \"molecule_name\": {' ! 3..(n-2): content ! n-1: \"  }\" ! n: \"}\" if ( nlines < 3 ) then call logger % error ( \"Invalid JSON structure: \" // trim ( filename )) return end if ! Write molecule key (extracted from filename) if ( mol_index > 1 ) write ( unit_out , '(a)' ) '    },' write ( unit_out , '(a)' ) '    \"' // trim ( get_molecule_name ( filename )) // '\" : {' ! Write all content lines (from line 3 to line n-2) do i = 3 , nlines - 2 write ( unit_out , '(a)' ) '  ' // trim ( all_lines ( i )) ! Add 2 spaces for proper indentation end do deallocate ( all_lines ) end subroutine read_json_content","tags":"","url":"proc/read_json_content.html"},{"title":"calculate_monomer_distance – metalquicha","text":"public pure function calculate_monomer_distance(sys_geom, monomer_indices) result(min_distance) Calculate minimal atomic distance between monomers in a fragment\nFor single monomer (size 1), returns 0.0\nFor multi-monomer fragments, returns minimal distance between atoms in different monomers\nResult is in Angstrom Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) Return Value real(kind=dp) Calls proc~~calculate_monomer_distance~~CallsGraph proc~calculate_monomer_distance calculate_monomer_distance proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calculate_monomer_distance~~CalledByGraph proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->proc~calculate_monomer_distance proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->proc~fragment_should_be_screened proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_indices proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~apply_distance_screening proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_end_i integer, private :: atom_end_j integer, private :: atom_start_i integer, private :: atom_start_j real(kind=dp), private :: dist real(kind=dp), private :: dx real(kind=dp), private :: dy real(kind=dp), private :: dz integer, private :: i integer, private :: iatom logical, private :: is_variable_size integer, private :: j integer, private :: jatom integer, private :: mon_i integer, private :: mon_j integer, private :: n_monomers Source Code pure function calculate_monomer_distance ( sys_geom , monomer_indices ) result ( min_distance ) !! Calculate minimal atomic distance between monomers in a fragment !! For single monomer (size 1), returns 0.0 !! For multi-monomer fragments, returns minimal distance between atoms in different monomers !! Result is in Angstrom type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) real ( dp ) :: min_distance integer :: n_monomers , i , j , iatom , jatom integer :: mon_i , mon_j integer :: atom_start_i , atom_end_i , atom_start_j , atom_end_j real ( dp ) :: dist , dx , dy , dz logical :: is_variable_size n_monomers = size ( monomer_indices ) ! Monomers have distance 0 if ( n_monomers == 1 ) then min_distance = 0.0_dp return end if ! Check if we have variable-sized fragments is_variable_size = allocated ( sys_geom % fragment_sizes ) ! Initialize with huge value min_distance = huge ( 1.0_dp ) ! Loop over all pairs of monomers do i = 1 , n_monomers - 1 mon_i = monomer_indices ( i ) do j = i + 1 , n_monomers mon_j = monomer_indices ( j ) if ( is_variable_size ) then ! Variable-sized fragments do iatom = 1 , sys_geom % fragment_sizes ( mon_i ) atom_start_i = sys_geom % fragment_atoms ( iatom , mon_i ) + 1 ! Convert to 1-indexed do jatom = 1 , sys_geom % fragment_sizes ( mon_j ) atom_start_j = sys_geom % fragment_atoms ( jatom , mon_j ) + 1 ! Convert to 1-indexed ! Calculate distance (coordinates in Bohr) dx = sys_geom % coordinates ( 1 , atom_start_i ) - sys_geom % coordinates ( 1 , atom_start_j ) dy = sys_geom % coordinates ( 2 , atom_start_i ) - sys_geom % coordinates ( 2 , atom_start_j ) dz = sys_geom % coordinates ( 3 , atom_start_i ) - sys_geom % coordinates ( 3 , atom_start_j ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_distance ) min_distance = dist end do end do else ! Fixed-sized monomers atom_start_i = ( mon_i - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_i = mon_i * sys_geom % atoms_per_monomer atom_start_j = ( mon_j - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_j = mon_j * sys_geom % atoms_per_monomer ! Loop over all atom pairs do iatom = atom_start_i , atom_end_i do jatom = atom_start_j , atom_end_j ! Calculate distance (coordinates in Bohr) dx = sys_geom % coordinates ( 1 , iatom ) - sys_geom % coordinates ( 1 , jatom ) dy = sys_geom % coordinates ( 2 , iatom ) - sys_geom % coordinates ( 2 , jatom ) dz = sys_geom % coordinates ( 3 , iatom ) - sys_geom % coordinates ( 3 , jatom ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_distance ) min_distance = dist end do end do end if end do end do ! Convert from Bohr to Angstrom min_distance = to_angstrom ( min_distance ) end function calculate_monomer_distance","tags":"","url":"proc/calculate_monomer_distance.html"},{"title":"to_angstrom – metalquicha","text":"public pure elemental function to_angstrom(bohr_value) result(angstrom_value) Convert coordinate from Bohr to Angstrom Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: bohr_value Return Value real(kind=dp) Called by proc~~to_angstrom~~CalledByGraph proc~to_angstrom to_angstrom proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->proc~to_angstrom proc~calculate_monomer_distance calculate_monomer_distance proc~calculate_monomer_distance->proc~to_angstrom proc~print_fragment_xyz print_fragment_xyz proc~print_fragment_xyz->proc~to_angstrom proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->proc~calculate_monomer_distance interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->proc~fragment_should_be_screened proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_indices proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->interface~do_fragment_work proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~apply_distance_screening proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental function to_angstrom ( bohr_value ) result ( angstrom_value ) !! Convert coordinate from Bohr to Angstrom real ( dp ), intent ( in ) :: bohr_value real ( dp ) :: angstrom_value angstrom_value = bohr_value * BOHR_TO_ANGSTROM end function to_angstrom","tags":"","url":"proc/to_angstrom.html"},{"title":"to_bohr – metalquicha","text":"public pure elemental function to_bohr(angstrom_value) result(bohr_value) Convert coordinate from Angstrom to Bohr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: angstrom_value Return Value real(kind=dp) Called by proc~~to_bohr~~CalledByGraph proc~to_bohr to_bohr proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~geometry_to_system_unfragmented->proc~to_bohr proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~to_bohr proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~to_bohr proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental function to_bohr ( angstrom_value ) result ( bohr_value ) !! Convert coordinate from Angstrom to Bohr real ( dp ), intent ( in ) :: angstrom_value real ( dp ) :: bohr_value bohr_value = angstrom_value * ANGSTROM_TO_BOHR end function to_bohr","tags":"","url":"proc/to_bohr.html"},{"title":"build_fragment_from_atom_list – metalquicha","text":"public  subroutine build_fragment_from_atom_list(sys_geom, atom_indices, n_atoms, fragment, error, bonds) Build a fragment from explicit atom list (for GMBE intersection fragments) Similar to build_fragment_from_indices but takes atom indices directly instead of\nmonomer indices. Used for building intersection fragments in GMBE calculations.\nIntersection fragments are ALWAYS NEUTRAL (charge=0, multiplicity=1). Example: atom_indices = [3, 4, 5] builds fragment from atoms 3, 4, 5 of the system Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: atom_indices (:) 0-indexed atom indices integer, intent(in) :: n_atoms Number of atoms in list type( physical_fragment_t ), intent(out) :: fragment type( error_t ), intent(out) :: error type( bond_t ), intent(in), optional :: bonds (:) Connectivity for capping Calls proc~~build_fragment_from_atom_list~~CallsGraph proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_atom_list->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_fragment_from_atom_list~~CalledByGraph proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker node_worker interface~node_worker->proc~node_worker proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~process_intersection_derivatives proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_global_idx integer, private :: frag_atom_idx integer, private :: i integer, private :: n_caps Source Code subroutine build_fragment_from_atom_list ( sys_geom , atom_indices , n_atoms , fragment , error , bonds ) !! Build a fragment from explicit atom list (for GMBE intersection fragments) !! !! Similar to build_fragment_from_indices but takes atom indices directly instead of !! monomer indices. Used for building intersection fragments in GMBE calculations. !! Intersection fragments are ALWAYS NEUTRAL (charge=0, multiplicity=1). !! !! Example: atom_indices = [3, 4, 5] builds fragment from atoms 3, 4, 5 of the system type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: atom_indices (:) !! 0-indexed atom indices integer , intent ( in ) :: n_atoms !! Number of atoms in list type ( physical_fragment_t ), intent ( out ) :: fragment type ( error_t ), intent ( out ) :: error type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity for capping integer :: i , frag_atom_idx , atom_global_idx integer :: n_caps ! Count how many caps we need call count_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping (atom_indices are 0-indexed, add 1 for Fortran arrays) do i = 1 , n_atoms atom_global_idx = atom_indices ( i ) + 1 ! Convert to 1-indexed fragment % element_numbers ( i ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, i ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( i ) = atom_global_idx ! Store 1-indexed global position end do ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , sys_geom , fragment , n_atoms ) end if ! Intersection fragments are ALWAYS NEUTRAL ! Rationale: For polypeptides, intersections are backbone atoms; ! charged side chains are in non-overlapping regions fragment % charge = 0 fragment % multiplicity = 1 call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:build_fragment_from_atom_list\" ) return end if end subroutine build_fragment_from_atom_list","tags":"","url":"proc/build_fragment_from_atom_list.html"},{"title":"build_fragment_from_indices – metalquicha","text":"public  subroutine build_fragment_from_indices(sys_geom, monomer_indices, fragment, error, bonds) Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds Extracts atoms from specified monomers and adds hydrogen caps where bonds are broken.\nCaps are always added at the end of the atom list.\nSupports both fixed-size (identical monomers) and variable-sized fragments. Example: monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5\n         If connectivity shows broken bonds, hydrogens are capped at positions of missing atoms Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) type( physical_fragment_t ), intent(out) :: fragment type( error_t ), intent(out) :: error type( bond_t ), intent(in), optional :: bonds (:) Connectivity information for capping Calls proc~~build_fragment_from_indices~~CallsGraph proc~build_fragment_from_indices build_fragment_from_indices proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_fragment_from_indices->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_fragment_from_indices~~CalledByGraph proc~build_fragment_from_indices build_fragment_from_indices proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_indices proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~global_coordinator->proc~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_end integer, private :: atom_global_idx integer, private :: atom_i integer, private :: atom_j integer, private :: atom_start integer, private, allocatable :: atoms_in_fragment (:) List of all atom indices in this fragment integer, private :: atoms_per_monomer integer, private :: frag_atom_idx integer, private :: i integer, private :: iatom integer, private :: j integer, private :: mono_idx integer, private :: n_atoms_no_caps integer, private :: n_caps integer, private :: n_monomers_in_frag logical, private :: use_explicit_fragments Source Code subroutine build_fragment_from_indices ( sys_geom , monomer_indices , fragment , error , bonds ) !! Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds !! !! Extracts atoms from specified monomers and adds hydrogen caps where bonds are broken. !! Caps are always added at the end of the atom list. !! Supports both fixed-size (identical monomers) and variable-sized fragments. !! !! Example: monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5 !!          If connectivity shows broken bonds, hydrogens are capped at positions of missing atoms type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) type ( physical_fragment_t ), intent ( out ) :: fragment type ( error_t ), intent ( out ) :: error type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity information for capping integer :: n_monomers_in_frag , atoms_per_monomer , n_atoms_no_caps integer :: i , j , mono_idx , atom_start , atom_end , frag_atom_idx integer :: atom_i , atom_j , n_caps integer , allocatable :: atoms_in_fragment (:) !! List of all atom indices in this fragment integer :: iatom , atom_global_idx logical :: use_explicit_fragments n_monomers_in_frag = size ( monomer_indices ) ! Determine if we're using explicit fragment definitions or regular monomer-based use_explicit_fragments = allocated ( sys_geom % fragment_atoms ) if ( use_explicit_fragments ) then ! Variable-sized fragments: count total atoms from fragment definitions n_atoms_no_caps = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) n_atoms_no_caps = n_atoms_no_caps + sys_geom % fragment_sizes ( mono_idx ) end do ! Build list of atom indices (0-indexed) from explicit fragment definitions allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) iatom = iatom + 1 atoms_in_fragment ( iatom ) = sys_geom % fragment_atoms ( j , mono_idx ) end do end do else ! Fixed-size monomers: use atoms_per_monomer atoms_per_monomer = sys_geom % atoms_per_monomer n_atoms_no_caps = n_monomers_in_frag * atoms_per_monomer ! Build list of atom indices in this fragment (0-indexed to match bond indices) allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer do atom_i = 0 , atoms_per_monomer - 1 iatom = iatom + 1 atoms_in_fragment ( iatom ) = atom_start + atom_i end do end do end if ! Count how many caps we need call count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms_no_caps + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms_no_caps )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping frag_atom_idx = 0 if ( use_explicit_fragments ) then ! Variable-sized: copy atoms based on explicit fragment definitions do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) frag_atom_idx = frag_atom_idx + 1 ! fragment_atoms is 0-indexed, so +1 for Fortran arrays atom_global_idx = sys_geom % fragment_atoms ( j , mono_idx ) + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( frag_atom_idx ) = atom_global_idx ! Store 1-indexed global position end do end do else ! Fixed-size: use atoms_per_monomer do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer + 1 atom_end = mono_idx * atoms_per_monomer ! Copy coordinates and elements do atom_i = atom_start , atom_end frag_atom_idx = frag_atom_idx + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_i ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_i ) fragment % local_to_global ( frag_atom_idx ) = atom_i ! Store 1-indexed global position end do end do end if ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , n_atoms_no_caps ) end if ! Set electronic structure properties from system geometry if ( use_explicit_fragments . and . allocated ( sys_geom % fragment_charges ) . and . & allocated ( sys_geom % fragment_multiplicities )) then ! Explicit fragments: sum charges and multiplicities from constituent fragments fragment % charge = 0 fragment % multiplicity = 1 ! Start with singlet assumption do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) fragment % charge = fragment % charge + sys_geom % fragment_charges ( mono_idx ) end do ! For single fragment, use its specific multiplicity if ( n_monomers_in_frag == 1 ) then fragment % multiplicity = sys_geom % fragment_multiplicities ( monomer_indices ( 1 )) else ! For multi-fragment composites, multiplicity needs careful treatment ! For now, default to system multiplicity (this may need refinement) fragment % multiplicity = sys_geom % multiplicity end if else ! Fixed-size monomers: use system defaults fragment % charge = sys_geom % charge fragment % multiplicity = sys_geom % multiplicity end if call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:build_fragment_from_indices\" ) return end if ! Calculate minimal distance between monomers in this fragment fragment % distance = calculate_monomer_distance ( sys_geom , monomer_indices ) deallocate ( atoms_in_fragment ) end subroutine build_fragment_from_indices","tags":"","url":"proc/build_fragment_from_indices.html"},{"title":"check_duplicate_atoms – metalquicha","text":"public  subroutine check_duplicate_atoms(fragment, error) Uses pic_logger pic_io proc~~check_duplicate_atoms~~UsesGraph proc~check_duplicate_atoms check_duplicate_atoms pic_io pic_io proc~check_duplicate_atoms->pic_io pic_logger pic_logger proc~check_duplicate_atoms->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Validate that fragment has no spatially overlapping atoms\nChecks if any two atoms are too close together (< 0.01 Bohr)\nThis catches bugs in geometry construction or fragment building Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment type( error_t ), intent(out) :: error Calls proc~~check_duplicate_atoms~~CallsGraph proc~check_duplicate_atoms check_duplicate_atoms error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set to_char to_char proc~check_duplicate_atoms->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_duplicate_atoms~~CalledByGraph proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~check_duplicate_atoms interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: MIN_ATOM_DISTANCE = 0.01_dp Bohr - atoms closer than this are overlapping real(kind=dp), private :: distance real(kind=dp), private :: dx real(kind=dp), private :: dy real(kind=dp), private :: dz integer, private :: i integer, private :: j integer, private :: n_atoms Source Code subroutine check_duplicate_atoms ( fragment , error ) !! Validate that fragment has no spatially overlapping atoms !! Checks if any two atoms are too close together (< 0.01 Bohr) !! This catches bugs in geometry construction or fragment building use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( physical_fragment_t ), intent ( in ) :: fragment type ( error_t ), intent ( out ) :: error integer :: i , j , n_atoms real ( dp ) :: distance , dx , dy , dz real ( dp ), parameter :: MIN_ATOM_DISTANCE = 0.01_dp !! Bohr - atoms closer than this are overlapping ! Only check non-cap atoms (caps can be close to replaced atoms) n_atoms = fragment % n_atoms - fragment % n_caps if ( n_atoms < 2 ) return do i = 1 , n_atoms - 1 do j = i + 1 , n_atoms dx = fragment % coordinates ( 1 , i ) - fragment % coordinates ( 1 , j ) dy = fragment % coordinates ( 2 , i ) - fragment % coordinates ( 2 , j ) dz = fragment % coordinates ( 3 , i ) - fragment % coordinates ( 3 , j ) distance = sqrt ( dx * dx + dy * dy + dz * dz ) if ( distance < MIN_ATOM_DISTANCE ) then ! Build detailed error message call error % set ( ERROR_VALIDATION , & \"Fragment contains overlapping atoms \" // to_char ( i ) // \" and \" // to_char ( j ) // & \" (distance: \" // to_char ( distance ) // \" Bohr). \" // & \"This indicates bad input geometry or a bug in fragment construction.\" ) ! Log detailed information for debugging call logger % error ( \"ERROR: Fragment contains overlapping atoms!\" ) call logger % error ( \"  Atoms \" // to_char ( i ) // \" and \" // to_char ( j ) // \" are too close together\" ) call logger % error ( \"  Distance: \" // to_char ( distance ) // \" Bohr (\" // & to_char ( distance * 0.529177_dp ) // \" Angstrom)\" ) call logger % error ( \"  Atom \" // to_char ( i ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( i )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , i )) // \", \" // & to_char ( fragment % coordinates ( 2 , i )) // \", \" // & to_char ( fragment % coordinates ( 3 , i )) // \") Bohr\" ) call logger % error ( \"  Atom \" // to_char ( j ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( j )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , j )) // \", \" // & to_char ( fragment % coordinates ( 2 , j )) // \", \" // & to_char ( fragment % coordinates ( 3 , j )) // \") Bohr\" ) return end if end do end do end subroutine check_duplicate_atoms","tags":"","url":"proc/check_duplicate_atoms.html"},{"title":"initialize_system_geometry – metalquicha","text":"public  subroutine initialize_system_geometry(full_geom_file, monomer_file, sys_geom, error) Read full geometry and monomer template, initialize system_geometry_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full_geom_file character(len=*), intent(in) :: monomer_file type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error Calls proc~~initialize_system_geometry~~CallsGraph proc~initialize_system_geometry initialize_system_geometry proc~element_symbol_to_number element_symbol_to_number proc~initialize_system_geometry->proc~element_symbol_to_number proc~error_add_context error_t%error_add_context proc~initialize_system_geometry->proc~error_add_context proc~error_has_error error_t%error_has_error proc~initialize_system_geometry->proc~error_has_error proc~error_set error_t%error_set proc~initialize_system_geometry->proc~error_set proc~geometry_destroy geometry_type%geometry_destroy proc~initialize_system_geometry->proc~geometry_destroy proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~to_bohr to_bohr proc~initialize_system_geometry->proc~to_bohr to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~read_xyz_file->proc~error_add_context proc~read_xyz_file->proc~error_has_error proc~read_xyz_file->proc~error_set proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~read_xyz_string->proc~error_set proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( geometry_type ), private :: full_geom integer, private :: i type( geometry_type ), private :: monomer_geom Source Code subroutine initialize_system_geometry ( full_geom_file , monomer_file , sys_geom , error ) !! Read full geometry and monomer template, initialize system_geometry_t character ( len =* ), intent ( in ) :: full_geom_file , monomer_file type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error type ( geometry_type ) :: full_geom , monomer_geom integer :: i call read_xyz_file ( full_geom_file , full_geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:initialize_system_geometry\" ) return end if ! Read monomer template ! this will be changed once we have a proper input file parsing call read_xyz_file ( monomer_file , monomer_geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:initialize_system_geometry\" ) call full_geom % destroy () return end if ! Validate that full geometry is a multiple of monomer size sys_geom % atoms_per_monomer = monomer_geom % natoms sys_geom % total_atoms = full_geom % natoms if ( mod ( sys_geom % total_atoms , sys_geom % atoms_per_monomer ) /= 0 ) then call error % set ( ERROR_VALIDATION , \"Full geometry atoms not a multiple of monomer atoms\" ) call full_geom % destroy () call monomer_geom % destroy () return end if sys_geom % n_monomers = sys_geom % total_atoms / sys_geom % atoms_per_monomer ! TODO JORGE: this can be a sys_geom%allocate() allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( full_geom % elements ( i )) end do ! Store coordinates in Bohr (convert from Angstroms) ! TODO JORGE: need a way to handle units sys_geom % coordinates = to_bohr ( full_geom % coords ) call full_geom % destroy () call monomer_geom % destroy () end subroutine initialize_system_geometry","tags":"","url":"proc/initialize_system_geometry.html"},{"title":"redistribute_cap_dipole_derivatives – metalquicha","text":"public  subroutine redistribute_cap_dipole_derivatives(fragment, fragment_dipole_derivs, system_dipole_derivs) Redistribute hydrogen cap dipole derivatives to original atoms Dipole derivatives have shape (3, 3*N_atoms) where each column corresponds to\nthe derivative of the 3 dipole components w.r.t. one Cartesian coordinate.\nThe mapping is similar to the column dimension of the Hessian. Algorithm:\n  1. For real atoms: accumulate to system using local_to_global mapping\n  2. For hydrogen caps: add to the original atom the cap replaces Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_dipole_derivs (:,:) (3, 3*n_atoms_fragment) real(kind=dp), intent(inout) :: system_dipole_derivs (:,:) (3, 3*n_atoms_system) Called by proc~~redistribute_cap_dipole_derivatives~~CalledByGraph proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~redistribute_cap_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~redistribute_cap_dipole_derivatives proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~redistribute_cap_dipole_derivatives proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: global_i integer, private :: global_original_idx integer, private :: i integer, private :: i_cap integer, private :: icart integer, private :: local_cap_idx integer, private :: local_i integer, private :: n_real_atoms Source Code subroutine redistribute_cap_dipole_derivatives ( fragment , fragment_dipole_derivs , system_dipole_derivs ) !! Redistribute hydrogen cap dipole derivatives to original atoms !! !! Dipole derivatives have shape (3, 3*N_atoms) where each column corresponds to !! the derivative of the 3 dipole components w.r.t. one Cartesian coordinate. !! The mapping is similar to the column dimension of the Hessian. !! !! Algorithm: !!   1. For real atoms: accumulate to system using local_to_global mapping !!   2. For hydrogen caps: add to the original atom the cap replaces type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_dipole_derivs (:, :) !! (3, 3*n_atoms_fragment) real ( dp ), intent ( inout ) :: system_dipole_derivs (:, :) !! (3, 3*n_atoms_system) integer :: i , local_i , global_i , icart integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate dipole derivative columns for real atoms do i = 1 , n_real_atoms local_i = i global_i = fragment % local_to_global ( local_i ) if ( global_i <= 0 ) cycle do icart = 1 , 3 system_dipole_derivs (:, ( global_i - 1 ) * 3 + icart ) = & system_dipole_derivs (:, ( global_i - 1 ) * 3 + icart ) + & fragment_dipole_derivs (:, ( local_i - 1 ) * 3 + icart ) end do end do ! Redistribute cap contributions to their original atoms if ( fragment % n_caps > 0 . and . allocated ( fragment % cap_replaces_atom )) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap ! cap_replaces_atom is 0-indexed, add 1 for Fortran arrays global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 do icart = 1 , 3 system_dipole_derivs (:, ( global_original_idx - 1 ) * 3 + icart ) = & system_dipole_derivs (:, ( global_original_idx - 1 ) * 3 + icart ) + & fragment_dipole_derivs (:, ( local_cap_idx - 1 ) * 3 + icart ) end do end do end if end subroutine redistribute_cap_dipole_derivatives","tags":"","url":"proc/redistribute_cap_dipole_derivatives.html"},{"title":"redistribute_cap_gradients – metalquicha","text":"public  subroutine redistribute_cap_gradients(fragment, fragment_gradient, system_gradient) Redistribute hydrogen cap gradients to original atoms This subroutine handles gradient redistribution for fragments with hydrogen caps.\nHydrogen caps are virtual atoms added at broken bonds - their gradients represent\nforces at the bond breakpoint and must be transferred to the original atoms they replace. Algorithm:\n  1. For real atoms (indices 1 to n_atoms - n_caps):\n     Accumulate gradient to system using local_to_global mapping\n  2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms):\n     Add cap gradient to the original atom it replaces (from cap_replaces_atom) Example:\n  Fragment: [C, C, H_cap] where H_cap replaces atom 5 in system\n  Fragment gradient: [(3,1), (3,2), (3,3)]\n  - Atoms 1,2: accumulate to system using local_to_global\n  - Atom 3 (cap): add gradient to system atom 5 (cap_replaces_atom(1) + 1) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_gradient (:,:) (3, n_atoms_fragment) real(kind=dp), intent(inout) :: system_gradient (:,:) (3, n_atoms_system) Called by proc~~redistribute_cap_gradients~~CalledByGraph proc~redistribute_cap_gradients redistribute_cap_gradients proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~redistribute_cap_gradients proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~process_intersection_derivatives->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: global_idx integer, private :: global_original_idx integer, private :: i integer, private :: i_cap integer, private :: local_cap_idx integer, private :: local_idx integer, private :: n_real_atoms Source Code subroutine redistribute_cap_gradients ( fragment , fragment_gradient , system_gradient ) !! Redistribute hydrogen cap gradients to original atoms !! !! This subroutine handles gradient redistribution for fragments with hydrogen caps. !! Hydrogen caps are virtual atoms added at broken bonds - their gradients represent !! forces at the bond breakpoint and must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate gradient to system using local_to_global mapping !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap gradient to the original atom it replaces (from cap_replaces_atom) !! !! Example: !!   Fragment: [C, C, H_cap] where H_cap replaces atom 5 in system !!   Fragment gradient: [(3,1), (3,2), (3,3)] !!   - Atoms 1,2: accumulate to system using local_to_global !!   - Atom 3 (cap): add gradient to system atom 5 (cap_replaces_atom(1) + 1) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_gradient (:, :) !! (3, n_atoms_fragment) real ( dp ), intent ( inout ) :: system_gradient (:, :) !! (3, n_atoms_system) integer :: i , local_idx , global_idx integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate gradients for real atoms using local→global mapping do i = 1 , n_real_atoms global_idx = fragment % local_to_global ( i ) system_gradient (:, global_idx ) = system_gradient (:, global_idx ) + fragment_gradient (:, i ) end do ! Redistribute cap gradients to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap ! cap_replaces_atom is 0-indexed, add 1 for Fortran arrays global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Add cap gradient to the atom it replaces system_gradient (:, global_original_idx ) = system_gradient (:, global_original_idx ) + & fragment_gradient (:, local_cap_idx ) end do end if end subroutine redistribute_cap_gradients","tags":"","url":"proc/redistribute_cap_gradients.html"},{"title":"redistribute_cap_hessian – metalquicha","text":"public  subroutine redistribute_cap_hessian(fragment, fragment_hessian, system_hessian) Redistribute hydrogen cap Hessian to original atoms This subroutine handles Hessian redistribution for fragments with hydrogen caps.\nThe Hessian is a rank-2 tensor (3N × 3N) representing second derivatives of energy\nwith respect to atomic coordinates. Similar to gradient redistribution, cap contributions\nmust be transferred to the original atoms they replace. Algorithm:\n  1. For real atoms (indices 1 to n_atoms - n_caps):\n     Accumulate Hessian blocks to system using local_to_global mapping for both dimensions\n  2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms):\n     Add cap Hessian blocks (row and column) to the original atom it replaces Note: Hessian is stored as a flattened 2D array (3 n_atoms, 3 n_atoms)\n      where rows and columns are grouped by atoms (x,y,z for atom 1, then x,y,z for atom 2, etc.) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_hessian (:,:) (3 n_atoms_fragment, 3 n_atoms_fragment) real(kind=dp), intent(inout) :: system_hessian (:,:) (3 n_atoms_system, 3 n_atoms_system) Called by proc~~redistribute_cap_hessian~~CalledByGraph proc~redistribute_cap_hessian redistribute_cap_hessian proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~redistribute_cap_hessian proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~process_intersection_derivatives->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~compute_mbe compute_mbe proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: global_i integer, private :: global_j integer, private :: global_original_idx integer, private :: global_original_idx_2 integer, private :: i integer, private :: i_cap integer, private :: i_cap_2 integer, private :: icart integer, private :: j integer, private :: jcart integer, private :: local_cap_idx integer, private :: local_cap_idx_2 integer, private :: local_i integer, private :: local_j integer, private :: n_real_atoms Source Code subroutine redistribute_cap_hessian ( fragment , fragment_hessian , system_hessian ) !! Redistribute hydrogen cap Hessian to original atoms !! !! This subroutine handles Hessian redistribution for fragments with hydrogen caps. !! The Hessian is a rank-2 tensor (3N × 3N) representing second derivatives of energy !! with respect to atomic coordinates. Similar to gradient redistribution, cap contributions !! must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate Hessian blocks to system using local_to_global mapping for both dimensions !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap Hessian blocks (row and column) to the original atom it replaces !! !! Note: Hessian is stored as a flattened 2D array (3*n_atoms, 3*n_atoms) !!       where rows and columns are grouped by atoms (x,y,z for atom 1, then x,y,z for atom 2, etc.) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_hessian (:, :) !! (3*n_atoms_fragment, 3*n_atoms_fragment) real ( dp ), intent ( inout ) :: system_hessian (:, :) !! (3*n_atoms_system, 3*n_atoms_system) integer :: i , j , local_i , local_j , global_i , global_j integer :: icart , jcart integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms integer :: i_cap_2 , local_cap_idx_2 , global_original_idx_2 n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate Hessian blocks for real atoms using local→global mapping ! Both row (i) and column (j) dimensions need mapping do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) ! Copy 3×3 block for atom pair (i,j) do icart = 0 , 2 ! x, y, z for atom i do jcart = 0 , 2 ! x, y, z for atom j system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do end do ! Redistribute cap Hessian blocks to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Cap rows: redistribute to original atom (cap derivatives w.r.t. all other atoms) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do ! Cap columns: redistribute to original atom (all other atoms' derivatives w.r.t. cap) do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( local_cap_idx - 1 ) + jcart + 1 ) end do end do end do ! Cap-cap blocks: redistribute to original atom diagonal block do i_cap_2 = 1 , fragment % n_caps local_cap_idx_2 = n_real_atoms + i_cap_2 global_original_idx_2 = fragment % cap_replaces_atom ( i_cap_2 ) + 1 do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( local_cap_idx_2 - 1 ) + jcart + 1 ) end do end do end do end do end if end subroutine redistribute_cap_hessian","tags":"","url":"proc/redistribute_cap_hessian.html"},{"title":"add_hydrogen_caps – metalquicha","text":"private  subroutine add_hydrogen_caps(atoms_in_fragment, bonds, sys_geom, fragment, base_atom_count) Add hydrogen caps to fragment for broken bonds\nCaps are placed at the position of the atom outside the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in) :: bonds (:) type( system_geometry_t ), intent(in) :: sys_geom type( physical_fragment_t ), intent(inout) :: fragment integer, intent(in) :: base_atom_count Number of non-cap atoms Called by proc~~add_hydrogen_caps~~CalledByGraph proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: atom_i_in_frag logical, private :: atom_j_in_frag integer, private :: cap_idx integer, private :: ibond Source Code subroutine add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , base_atom_count ) !! Add hydrogen caps to fragment for broken bonds !! Caps are placed at the position of the atom outside the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ) :: bonds (:) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( physical_fragment_t ), intent ( inout ) :: fragment integer , intent ( in ) :: base_atom_count !! Number of non-cap atoms integer :: ibond , cap_idx logical :: atom_i_in_frag , atom_j_in_frag if ( fragment % n_caps == 0 ) return cap_idx = 0 do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) if ( atom_i_in_frag . and . . not . atom_j_in_frag ) then ! atom_i is in fragment, atom_j is not → cap at position of atom_j cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_j (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_j + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_j else if ( atom_j_in_frag . and . . not . atom_i_in_frag ) then ! atom_j is in fragment, atom_i is not → cap at position of atom_i cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_i (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_i + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_i end if end do end subroutine add_hydrogen_caps","tags":"","url":"proc/add_hydrogen_caps.html"},{"title":"count_hydrogen_caps – metalquicha","text":"private  subroutine count_hydrogen_caps(atoms_in_fragment, bonds, n_caps) Count how many hydrogen caps are needed for a fragment\nA cap is needed when exactly one atom of a broken bond is in the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in), optional :: bonds (:) integer, intent(out) :: n_caps Called by proc~~count_hydrogen_caps~~CalledByGraph proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: atom_i_in_frag logical, private :: atom_j_in_frag integer, private :: ibond Source Code subroutine count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) !! Count how many hydrogen caps are needed for a fragment !! A cap is needed when exactly one atom of a broken bond is in the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ), optional :: bonds (:) integer , intent ( out ) :: n_caps integer :: ibond logical :: atom_i_in_frag , atom_j_in_frag n_caps = 0 if (. not . present ( bonds )) return do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle ! Check if exactly one atom of this bond is in the fragment atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) ! Add cap only if one atom in fragment, other not (XOR condition) if (( atom_i_in_frag . and . . not . atom_j_in_frag ) . or . & (. not . atom_i_in_frag . and . atom_j_in_frag )) then n_caps = n_caps + 1 end if end do end subroutine count_hydrogen_caps","tags":"","url":"proc/count_hydrogen_caps.html"},{"title":"fragment_compute_nelec – metalquicha","text":"private  subroutine fragment_compute_nelec(this) Compute number of electrons from atomic numbers and charge Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this Called by proc~~fragment_compute_nelec~~CalledByGraph proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~fragment_compute_nelec proc~hessian_worker hessian_worker proc~hessian_worker->proc~fragment_compute_nelec proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~fragment_compute_nelec interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~build_fragment_from_indices proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~process_intersection_derivatives->proc~build_fragment_from_atom_list proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: nuclear_charge Source Code subroutine fragment_compute_nelec ( this ) !! Compute number of electrons from atomic numbers and charge class ( physical_fragment_t ), intent ( inout ) :: this integer :: nuclear_charge nuclear_charge = sum ( this % element_numbers ) this % nelec = nuclear_charge - this % charge end subroutine fragment_compute_nelec","tags":"","url":"proc/fragment_compute_nelec.html"},{"title":"fragment_destroy – metalquicha","text":"private  subroutine fragment_destroy(this) Clean up allocated memory in physical_fragment_t Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this Calls proc~~fragment_destroy~~CallsGraph proc~fragment_destroy physical_fragment_t%fragment_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_destroy~~CalledByGraph proc~fragment_destroy physical_fragment_t%fragment_destroy proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~fragment_destroy proc~process_intersection_derivatives process_intersection_derivatives proc~compute_gmbe->proc~process_intersection_derivatives proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~process_intersection_derivatives->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_hessian proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation interface~global_coordinator->proc~global_coordinator proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fragment_destroy ( this ) !! Clean up allocated memory in physical_fragment_t class ( physical_fragment_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % cap_replaces_atom )) deallocate ( this % cap_replaces_atom ) if ( allocated ( this % local_to_global )) deallocate ( this % local_to_global ) if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if this % n_atoms = 0 this % charge = 0 this % multiplicity = 1 this % nelec = 0 this % n_caps = 0 end subroutine fragment_destroy","tags":"","url":"proc/fragment_destroy.html"},{"title":"fragment_set_basis – metalquicha","text":"private  subroutine fragment_set_basis(this, basis) Set the basis set for this fragment Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis Calls proc~~fragment_set_basis~~CallsGraph proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_set_basis->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fragment_set_basis ( this , basis ) !! Set the basis set for this fragment class ( physical_fragment_t ), intent ( inout ) :: this type ( molecular_basis_type ), intent ( in ) :: basis if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if allocate ( this % basis ) this % basis = basis end subroutine fragment_set_basis","tags":"","url":"proc/fragment_set_basis.html"},{"title":"system_destroy – metalquicha","text":"private  subroutine system_destroy(this) Clean up allocated memory in system_geometry_t Type Bound system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this Called by proc~~system_destroy~~CalledByGraph proc~system_destroy system_geometry_t%system_destroy proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~system_destroy program~main main program~main->proc~system_destroy program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine system_destroy ( this ) !! Clean up allocated memory in system_geometry_t class ( system_geometry_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % fragment_sizes )) deallocate ( this % fragment_sizes ) if ( allocated ( this % fragment_atoms )) deallocate ( this % fragment_atoms ) if ( allocated ( this % fragment_charges )) deallocate ( this % fragment_charges ) if ( allocated ( this % fragment_multiplicities )) deallocate ( this % fragment_multiplicities ) this % n_monomers = 0 this % atoms_per_monomer = 0 this % total_atoms = 0 end subroutine system_destroy","tags":"","url":"proc/system_destroy.html"},{"title":"compute_cartesian_displacements – metalquicha","text":"public  subroutine compute_cartesian_displacements(eigenvectors, element_numbers, cartesian_displacements, normalize_max) Convert mass-weighted eigenvectors to Cartesian displacements. The Cartesian displacement for coordinate i in mode k is:\n  x_{i,k} = L_mw_{i,k} / √(m_i) The output can be normalized in two ways:\n- normalize_max=.true. (default): normalize so max|x| = 1 for each mode (Gaussian convention)\n- normalize_max=.false.: normalize so Σ_i x²_{i,k} = 1 Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvectors (:,:) Mass-weighted eigenvectors (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N), columns are modes logical, intent(in), optional :: normalize_max If true, normalize so max displacement = 1 (default: true) Calls proc~~compute_cartesian_displacements~~CallsGraph proc~compute_cartesian_displacements compute_cartesian_displacements proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_cartesian_displacements~~CalledByGraph proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom integer, private :: icoord integer, private :: idx real(kind=dp), private :: inv_sqrt_mass integer, private :: k real(kind=dp), private :: mass real(kind=dp), private :: max_disp integer, private :: n_atoms integer, private :: n_coords real(kind=dp), private :: norm logical, private :: use_max_norm Source Code subroutine compute_cartesian_displacements ( eigenvectors , element_numbers , & cartesian_displacements , normalize_max ) !! Convert mass-weighted eigenvectors to Cartesian displacements. !! !! The Cartesian displacement for coordinate i in mode k is: !!   x_{i,k} = L_mw_{i,k} / √(m_i) !! !! The output can be normalized in two ways: !! - normalize_max=.true. (default): normalize so max|x| = 1 for each mode (Gaussian convention) !! - normalize_max=.false.: normalize so Σ_i x²_{i,k} = 1 real ( dp ), intent ( in ) :: eigenvectors (:, :) !! Mass-weighted eigenvectors (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N), columns are modes logical , intent ( in ), optional :: normalize_max !! If true, normalize so max displacement = 1 (default: true) integer :: n_atoms , n_coords , iatom , icoord , k , idx real ( dp ) :: mass , inv_sqrt_mass , norm , max_disp logical :: use_max_norm n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms use_max_norm = . true . if ( present ( normalize_max )) use_max_norm = normalize_max allocate ( cartesian_displacements ( n_coords , n_coords )) ! Convert from mass-weighted to Cartesian: x = L_mw / √m do k = 1 , n_coords do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) inv_sqrt_mass = 1.0_dp / sqrt ( mass ) do icoord = 1 , 3 idx = 3 * ( iatom - 1 ) + icoord cartesian_displacements ( idx , k ) = eigenvectors ( idx , k ) * inv_sqrt_mass end do end do end do ! Normalize each mode do k = 1 , n_coords if ( use_max_norm ) then ! Gaussian convention: normalize so max |displacement| = 1 max_disp = maxval ( abs ( cartesian_displacements (:, k ))) if ( max_disp > 1.0e-14_dp ) then cartesian_displacements (:, k ) = cartesian_displacements (:, k ) / max_disp end if else ! Standard normalization: Σ_i x²_{i,k} = 1 norm = sqrt ( sum ( cartesian_displacements (:, k ) ** 2 )) if ( norm > 1.0e-14_dp ) then cartesian_displacements (:, k ) = cartesian_displacements (:, k ) / norm end if end if end do end subroutine compute_cartesian_displacements","tags":"","url":"proc/compute_cartesian_displacements.html"},{"title":"compute_force_constants – metalquicha","text":"public  subroutine compute_force_constants(eigenvalues, reduced_masses, force_constants, force_constants_mdyne) Compute force constants for each normal mode. From the harmonic oscillator relation:\n  ω² = k/μ  →  k = ω² × μ = eigenvalue × μ Returns force constants in both atomic units (Hartree/Bohr²) and mdyne/Å. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvalues (:) Eigenvalues from mass-weighted Hessian diagonalization (1/amu) real(kind=dp), intent(in) :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(out), allocatable :: force_constants (:) Force constants in atomic units (Hartree/Bohr²) real(kind=dp), intent(out), optional, allocatable :: force_constants_mdyne (:) Force constants in mdyne/Å (common experimental unit) Called by proc~~compute_force_constants~~CalledByGraph proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: k integer, private :: n_modes Source Code subroutine compute_force_constants ( eigenvalues , reduced_masses , force_constants , & force_constants_mdyne ) !! Compute force constants for each normal mode. !! !! From the harmonic oscillator relation: !!   ω² = k/μ  →  k = ω² × μ = eigenvalue × μ !! !! Returns force constants in both atomic units (Hartree/Bohr²) and mdyne/Å. real ( dp ), intent ( in ) :: eigenvalues (:) !! Eigenvalues from mass-weighted Hessian diagonalization (1/amu) real ( dp ), intent ( in ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), allocatable , intent ( out ) :: force_constants (:) !! Force constants in atomic units (Hartree/Bohr²) real ( dp ), allocatable , intent ( out ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å (common experimental unit) integer :: n_modes , k n_modes = size ( eigenvalues ) allocate ( force_constants ( n_modes )) ! k = eigenvalue × μ (eigenvalue has units Hartree/(Bohr²·amu), μ in amu) ! So force_constant has units Hartree/Bohr² do k = 1 , n_modes if ( eigenvalues ( k ) >= 0.0_dp ) then force_constants ( k ) = eigenvalues ( k ) * reduced_masses ( k ) else ! Imaginary frequency mode - report absolute value force_constants ( k ) = - abs ( eigenvalues ( k )) * reduced_masses ( k ) end if end do ! Optionally convert to mdyne/Å if ( present ( force_constants_mdyne )) then allocate ( force_constants_mdyne ( n_modes )) force_constants_mdyne = force_constants * AU_TO_MDYNE_ANG end if end subroutine compute_force_constants","tags":"","url":"proc/compute_force_constants.html"},{"title":"compute_ir_intensities – metalquicha","text":"public  subroutine compute_ir_intensities(dipole_derivatives, eigenvectors, element_numbers, ir_intensities) Compute IR intensities from dipole derivatives and normal modes. IR intensities are computed by transforming Cartesian dipole derivatives\nto normal mode coordinates and computing the squared magnitude. For each normal mode i:\n  trdip(k) = Σ_j dipd(k,j) * L(j,i) * 1/√m_j\n  IR(i) = AU_TO_KMMOL * (trdip(1)² + trdip(2)² + trdip(3)²) where:\n  dipd(k,j) = ∂μ_k/∂x_j (Cartesian dipole derivative)\n  L(j,i) = mass-weighted eigenvector component\n  m_j = atomic mass for coordinate j Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dipole_derivatives (:,:) Cartesian dipole derivatives (3, 3*N) in atomic units real(kind=dp), intent(in) :: eigenvectors (:,:) Mass-weighted eigenvectors from Hessian diagonalization (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: ir_intensities (:) IR intensities in km/mol (one per mode) Calls proc~~compute_ir_intensities~~CallsGraph proc~compute_ir_intensities compute_ir_intensities proc~element_mass element_mass proc~compute_ir_intensities->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_ir_intensities~~CalledByGraph proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: iatom real(kind=dp), private :: inv_sqrt_mass integer, private :: j integer, private :: k real(kind=dp), private :: mass integer, private :: n_atoms integer, private :: n_coords real(kind=dp), private :: trdip (3) Source Code subroutine compute_ir_intensities ( dipole_derivatives , eigenvectors , element_numbers , ir_intensities ) !! Compute IR intensities from dipole derivatives and normal modes. !! !! IR intensities are computed by transforming Cartesian dipole derivatives !! to normal mode coordinates and computing the squared magnitude. !! !! For each normal mode i: !!   trdip(k) = Σ_j dipd(k,j) * L(j,i) * 1/√m_j !!   IR(i) = AU_TO_KMMOL * (trdip(1)² + trdip(2)² + trdip(3)²) !! !! where: !!   dipd(k,j) = ∂μ_k/∂x_j (Cartesian dipole derivative) !!   L(j,i) = mass-weighted eigenvector component !!   m_j = atomic mass for coordinate j !! real ( dp ), intent ( in ) :: dipole_derivatives (:, :) !! Cartesian dipole derivatives (3, 3*N) in atomic units real ( dp ), intent ( in ) :: eigenvectors (:, :) !! Mass-weighted eigenvectors from Hessian diagonalization (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: ir_intensities (:) !! IR intensities in km/mol (one per mode) integer :: n_atoms , n_coords , iatom , i , j , k real ( dp ) :: mass , inv_sqrt_mass , trdip ( 3 ) n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms allocate ( ir_intensities ( n_coords )) ! For each normal mode i do i = 1 , n_coords trdip = 0.0_dp ! Transform dipole derivative from Cartesian to normal mode coordinates ! trdip(k) = Σ_j dipd(k,j) * L(j,i) * amass_au(j) ! where amass_au(j) = 1/√(m_j in atomic units) = 1/√(m_amu * AMU_TO_AU) ! This matches xtb's formula in hessian.F90 lines 526-535 do j = 1 , n_coords iatom = ( j - 1 ) / 3 + 1 mass = element_mass ( element_numbers ( iatom )) ! Convert mass to atomic units (electron masses) before taking sqrt inv_sqrt_mass = 1.0_dp / sqrt ( mass * AMU_TO_AU ) do k = 1 , 3 ! x, y, z components of dipole trdip ( k ) = trdip ( k ) + dipole_derivatives ( k , j ) * eigenvectors ( j , i ) * inv_sqrt_mass end do end do ! IR intensity = |dμ/dQ|² * conversion factor ir_intensities ( i ) = AU_TO_KMMOL * ( trdip ( 1 ) ** 2 + trdip ( 2 ) ** 2 + trdip ( 3 ) ** 2 ) end do end subroutine compute_ir_intensities","tags":"","url":"proc/compute_ir_intensities.html"},{"title":"compute_reduced_masses – metalquicha","text":"public  subroutine compute_reduced_masses(eigenvectors, element_numbers, reduced_masses) Compute reduced masses for each normal mode. The reduced mass μ_k for mode k is defined as:\n  μ_k = 1 / Σ_i (L_mw_{i,k}² / m_i) where L_mw is the mass-weighted eigenvector (normalized to 1).\nThis formula arises from the relationship Q_k = Σ_i √m_i * x_i * L_mw_{i,k}\nand ensures that the harmonic oscillator relation ω² = k/μ holds. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvectors (:,:) Mass-weighted eigenvectors from diagonalization (3 N x 3 N)\nColumns are normal modes, assumed normalized (Σ_i L²_{i,k} = 1) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: reduced_masses (:) Reduced masses in amu (one per mode) Calls proc~~compute_reduced_masses~~CallsGraph proc~compute_reduced_masses compute_reduced_masses proc~element_mass element_mass proc~compute_reduced_masses->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_reduced_masses~~CalledByGraph proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom integer, private :: icoord integer, private :: idx integer, private :: k real(kind=dp), private :: mass integer, private :: n_atoms integer, private :: n_coords real(kind=dp), private :: sum_over_mass Source Code subroutine compute_reduced_masses ( eigenvectors , element_numbers , reduced_masses ) !! Compute reduced masses for each normal mode. !! !! The reduced mass μ_k for mode k is defined as: !!   μ_k = 1 / Σ_i (L_mw_{i,k}² / m_i) !! !! where L_mw is the mass-weighted eigenvector (normalized to 1). !! This formula arises from the relationship Q_k = Σ_i √m_i * x_i * L_mw_{i,k} !! and ensures that the harmonic oscillator relation ω² = k/μ holds. real ( dp ), intent ( in ) :: eigenvectors (:, :) !! Mass-weighted eigenvectors from diagonalization (3*N x 3*N) !! Columns are normal modes, assumed normalized (Σ_i L²_{i,k} = 1) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: reduced_masses (:) !! Reduced masses in amu (one per mode) integer :: n_atoms , n_coords , iatom , icoord , k , idx real ( dp ) :: mass , sum_over_mass n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms allocate ( reduced_masses ( n_coords )) ! For each normal mode k do k = 1 , n_coords sum_over_mass = 0.0_dp ! Sum over all 3N coordinates: Σ_i (L²_{i,k} / m_i) do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) do icoord = 1 , 3 idx = 3 * ( iatom - 1 ) + icoord sum_over_mass = sum_over_mass + eigenvectors ( idx , k ) ** 2 / mass end do end do ! μ_k = 1 / Σ_i (L²_{i,k} / m_i) if ( sum_over_mass > 1.0e-14_dp ) then reduced_masses ( k ) = 1.0_dp / sum_over_mass else ! Near-zero contribution (e.g., trans/rot mode) - assign a large mass reduced_masses ( k ) = 1.0e10_dp end if end do end subroutine compute_reduced_masses","tags":"","url":"proc/compute_reduced_masses.html"},{"title":"compute_vibrational_analysis – metalquicha","text":"public  subroutine compute_vibrational_analysis(hessian, element_numbers, frequencies, reduced_masses, force_constants, cartesian_displacements, eigenvalues_out, eigenvectors_out, coordinates, project_trans_rot, force_constants_mdyne, dipole_derivatives, ir_intensities) Perform complete vibrational analysis from Hessian matrix. This is a convenience wrapper that computes:\n- Vibrational frequencies in cm⁻¹\n- Reduced masses in amu\n- Force constants in Hartree/Bohr² (and optionally mdyne/Å)\n- Cartesian displacement vectors (normalized)\n- IR intensities in km/mol (if dipole_derivatives provided) Optionally projects out translation/rotation modes. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Hessian matrix in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: frequencies (:) Vibrational frequencies in cm⁻¹ real(kind=dp), intent(out), allocatable :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(out), allocatable :: force_constants (:) Force constants in Hartree/Bohr² real(kind=dp), intent(out), allocatable :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N) real(kind=dp), intent(out), optional, allocatable :: eigenvalues_out (:) Raw eigenvalues from diagonalization real(kind=dp), intent(out), optional, allocatable :: eigenvectors_out (:,:) Mass-weighted eigenvectors real(kind=dp), intent(in), optional :: coordinates (:,:) Atomic coordinates in Bohr (3, N) - required for projection logical, intent(in), optional :: project_trans_rot If true, project out translation/rotation modes real(kind=dp), intent(out), optional, allocatable :: force_constants_mdyne (:) Force constants in mdyne/Å real(kind=dp), intent(in), optional :: dipole_derivatives (:,:) Cartesian dipole derivatives (3, 3*N) in a.u. for IR intensities real(kind=dp), intent(out), optional, allocatable :: ir_intensities (:) IR intensities in km/mol Calls proc~~compute_vibrational_analysis~~CallsGraph proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_reduced_masses->proc~element_mass error error proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_vibrational_analysis~~CalledByGraph proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: eigenvalues (:) real(kind=dp), private, allocatable :: eigenvectors (:,:) Source Code subroutine compute_vibrational_analysis ( hessian , element_numbers , frequencies , & reduced_masses , force_constants , & cartesian_displacements , & eigenvalues_out , eigenvectors_out , & coordinates , project_trans_rot , & force_constants_mdyne , & dipole_derivatives , ir_intensities ) !! Perform complete vibrational analysis from Hessian matrix. !! !! This is a convenience wrapper that computes: !! - Vibrational frequencies in cm⁻¹ !! - Reduced masses in amu !! - Force constants in Hartree/Bohr² (and optionally mdyne/Å) !! - Cartesian displacement vectors (normalized) !! - IR intensities in km/mol (if dipole_derivatives provided) !! !! Optionally projects out translation/rotation modes. real ( dp ), intent ( in ) :: hessian (:, :) !! Hessian matrix in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ real ( dp ), allocatable , intent ( out ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), allocatable , intent ( out ) :: force_constants (:) !! Force constants in Hartree/Bohr² real ( dp ), allocatable , intent ( out ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N) real ( dp ), allocatable , intent ( out ), optional :: eigenvalues_out (:) !! Raw eigenvalues from diagonalization real ( dp ), allocatable , intent ( out ), optional :: eigenvectors_out (:, :) !! Mass-weighted eigenvectors real ( dp ), intent ( in ), optional :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) - required for projection logical , intent ( in ), optional :: project_trans_rot !! If true, project out translation/rotation modes real ( dp ), allocatable , intent ( out ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å real ( dp ), intent ( in ), optional :: dipole_derivatives (:, :) !! Cartesian dipole derivatives (3, 3*N) in a.u. for IR intensities real ( dp ), allocatable , intent ( out ), optional :: ir_intensities (:) !! IR intensities in km/mol real ( dp ), allocatable :: eigenvalues (:) real ( dp ), allocatable :: eigenvectors (:, :) ! First compute frequencies and eigenvectors call compute_vibrational_frequencies ( hessian , element_numbers , frequencies , & eigenvalues_out = eigenvalues , & eigenvectors = eigenvectors , & coordinates = coordinates , & project_trans_rot = project_trans_rot ) ! Compute reduced masses from eigenvectors call compute_reduced_masses ( eigenvectors , element_numbers , reduced_masses ) ! Compute force constants from eigenvalues and reduced masses call compute_force_constants ( eigenvalues , reduced_masses , force_constants , & force_constants_mdyne ) ! Compute Cartesian displacements from eigenvectors call compute_cartesian_displacements ( eigenvectors , element_numbers , & cartesian_displacements ) ! Compute IR intensities if dipole derivatives are provided if ( present ( dipole_derivatives ) . and . present ( ir_intensities )) then call compute_ir_intensities ( dipole_derivatives , eigenvectors , element_numbers , & ir_intensities ) end if ! Optionally return eigenvalues and eigenvectors if ( present ( eigenvalues_out )) then allocate ( eigenvalues_out ( size ( eigenvalues ))) eigenvalues_out = eigenvalues end if if ( present ( eigenvectors_out )) then allocate ( eigenvectors_out ( size ( eigenvectors , 1 ), size ( eigenvectors , 2 ))) eigenvectors_out = eigenvectors end if deallocate ( eigenvalues , eigenvectors ) end subroutine compute_vibrational_analysis","tags":"","url":"proc/compute_vibrational_analysis.html"},{"title":"compute_vibrational_frequencies – metalquicha","text":"public  subroutine compute_vibrational_frequencies(hessian, element_numbers, frequencies, eigenvalues_out, eigenvectors, coordinates, project_trans_rot, projected_hessian_out) Compute vibrational frequencies from the Hessian matrix. Algorithm:\n1. Mass-weight the Hessian: H_mw = M&#94;{-1/2} * H * M&#94;{-1/2}\n2. Optionally project out translation/rotation modes\n3. Diagonalize H_mw to get eigenvalues\n4. Convert eigenvalues to frequencies in cm⁻¹ Negative eigenvalues produce negative frequencies (imaginary modes,\nindicating transition states or saddle points). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Hessian matrix in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: frequencies (:) Vibrational frequencies in cm⁻¹ (3 N modes, or 3 N-6 if projected) real(kind=dp), intent(out), optional, allocatable :: eigenvalues_out (:) Raw eigenvalues from diagonalization (Hartree/Bohr²/amu) real(kind=dp), intent(out), optional, allocatable :: eigenvectors (:,:) Normal mode eigenvectors (3 N x 3 N), columns are modes real(kind=dp), intent(in), optional :: coordinates (:,:) Atomic coordinates in Bohr (3, N) - required for projection logical, intent(in), optional :: project_trans_rot If true, project out translation/rotation modes (requires coordinates) real(kind=dp), intent(out), optional, allocatable :: projected_hessian_out (:,:) Mass-weighted Hessian after trans/rot projection (before diagonalization) Calls proc~~compute_vibrational_frequencies~~CallsGraph proc~compute_vibrational_frequencies compute_vibrational_frequencies error error proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~element_mass element_mass proc~mass_weight_hessian->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_vibrational_frequencies~~CalledByGraph proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: do_projection real(kind=dp), private, allocatable :: eigenvalues (:) integer, private :: i integer, private :: info real(kind=dp), private, allocatable :: mw_hessian (:,:) integer, private :: n_coords Source Code subroutine compute_vibrational_frequencies ( hessian , element_numbers , frequencies , & eigenvalues_out , eigenvectors , & coordinates , project_trans_rot , & projected_hessian_out ) !! Compute vibrational frequencies from the Hessian matrix. !! !! Algorithm: !! 1. Mass-weight the Hessian: H_mw = M&#94;{-1/2} * H * M&#94;{-1/2} !! 2. Optionally project out translation/rotation modes !! 3. Diagonalize H_mw to get eigenvalues !! 4. Convert eigenvalues to frequencies in cm⁻¹ !! !! Negative eigenvalues produce negative frequencies (imaginary modes, !! indicating transition states or saddle points). real ( dp ), intent ( in ) :: hessian (:, :) !! Hessian matrix in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ (3*N modes, or 3*N-6 if projected) real ( dp ), allocatable , intent ( out ), optional :: eigenvalues_out (:) !! Raw eigenvalues from diagonalization (Hartree/Bohr²/amu) real ( dp ), allocatable , intent ( out ), optional :: eigenvectors (:, :) !! Normal mode eigenvectors (3*N x 3*N), columns are modes real ( dp ), intent ( in ), optional :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) - required for projection logical , intent ( in ), optional :: project_trans_rot !! If true, project out translation/rotation modes (requires coordinates) real ( dp ), allocatable , intent ( out ), optional :: projected_hessian_out (:, :) !! Mass-weighted Hessian after trans/rot projection (before diagonalization) real ( dp ), allocatable :: mw_hessian (:, :) real ( dp ), allocatable :: eigenvalues (:) integer :: n_coords , info , i logical :: do_projection n_coords = size ( hessian , 1 ) ! Check if projection is requested do_projection = . false . if ( present ( project_trans_rot )) then if ( project_trans_rot ) then if (. not . present ( coordinates )) then ! Cannot project without coordinates - fall back to no projection call logger % warning ( \"Missing coordinates, not projecting out tran/rot motions\" ) do_projection = . false . else do_projection = . true . end if end if end if ! Mass-weight the Hessian call mass_weight_hessian ( hessian , element_numbers , mw_hessian ) ! Optionally project out translation/rotation modes if ( do_projection ) then call project_translation_rotation ( mw_hessian , coordinates , element_numbers ) end if ! Return projected Hessian if requested (before diagonalization destroys it) if ( present ( projected_hessian_out )) then allocate ( projected_hessian_out ( n_coords , n_coords )) projected_hessian_out = mw_hessian end if ! Allocate eigenvalue storage allocate ( eigenvalues ( n_coords )) ! Diagonalize the mass-weighted Hessian ! pic_syev overwrites mw_hessian with eigenvectors (if jobz='V', default) call pic_syev ( mw_hessian , eigenvalues , info = info ) if ( info /= 0 ) then ! Eigenvalue decomposition failed call logger % error ( \"Eigenvalue decomposition in vibrational frequencies failed\" ) allocate ( frequencies ( n_coords )) frequencies = 0.0_dp return end if ! Convert eigenvalues to frequencies in cm⁻¹ allocate ( frequencies ( n_coords )) do i = 1 , n_coords if ( eigenvalues ( i ) >= 0.0_dp ) then ! Real frequency frequencies ( i ) = sqrt ( eigenvalues ( i ) * AU_TO_CM1 ) else ! Imaginary frequency (negative eigenvalue) - report as negative frequencies ( i ) = - sqrt ( abs ( eigenvalues ( i )) * AU_TO_CM1 ) end if end do ! Return eigenvalues if requested if ( present ( eigenvalues_out )) then allocate ( eigenvalues_out ( n_coords )) eigenvalues_out = eigenvalues end if ! Return eigenvectors if requested if ( present ( eigenvectors )) then allocate ( eigenvectors ( n_coords , n_coords )) eigenvectors = mw_hessian end if deallocate ( eigenvalues , mw_hessian ) end subroutine compute_vibrational_frequencies","tags":"","url":"proc/compute_vibrational_frequencies.html"},{"title":"mass_weight_hessian – metalquicha","text":"public  subroutine mass_weight_hessian(hessian, element_numbers, mw_hessian) Apply mass weighting to Hessian matrix. H_mw(i,j) = H(i,j) / sqrt(m_i * m_j) where m_i is the mass of the atom corresponding to coordinate i.\nEach atom contributes 3 coordinates (x, y, z). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Input Hessian in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: mw_hessian (:,:) Mass-weighted Hessian (3 N x 3 N) Calls proc~~mass_weight_hessian~~CallsGraph proc~mass_weight_hessian mass_weight_hessian proc~element_mass element_mass proc~mass_weight_hessian->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mass_weight_hessian~~CalledByGraph proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: iatom integer, private :: icoord real(kind=dp), private, allocatable :: inv_sqrt_mass (:) integer, private :: j real(kind=dp), private :: mass integer, private :: n_atoms integer, private :: n_coords Source Code subroutine mass_weight_hessian ( hessian , element_numbers , mw_hessian ) !! Apply mass weighting to Hessian matrix. !! !! H_mw(i,j) = H(i,j) / sqrt(m_i * m_j) !! !! where m_i is the mass of the atom corresponding to coordinate i. !! Each atom contributes 3 coordinates (x, y, z). real ( dp ), intent ( in ) :: hessian (:, :) !! Input Hessian in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: mw_hessian (:, :) !! Mass-weighted Hessian (3*N x 3*N) real ( dp ), allocatable :: inv_sqrt_mass (:) integer :: n_atoms , n_coords , iatom , icoord , i , j real ( dp ) :: mass n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms ! Build inverse square root mass vector (each mass repeated 3x for x,y,z) allocate ( inv_sqrt_mass ( n_coords )) do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) do icoord = 1 , 3 inv_sqrt_mass ( 3 * ( iatom - 1 ) + icoord ) = 1.0_dp / sqrt ( mass ) end do end do ! Apply mass weighting: H_mw(i,j) = H(i,j) * inv_sqrt_mass(i) * inv_sqrt_mass(j) allocate ( mw_hessian ( n_coords , n_coords )) do j = 1 , n_coords do i = 1 , n_coords mw_hessian ( i , j ) = hessian ( i , j ) * inv_sqrt_mass ( i ) * inv_sqrt_mass ( j ) end do end do deallocate ( inv_sqrt_mass ) end subroutine mass_weight_hessian","tags":"","url":"proc/mass_weight_hessian.html"},{"title":"print_vibrational_analysis – metalquicha","text":"public  subroutine print_vibrational_analysis(frequencies, reduced_masses, force_constants, cartesian_displacements, element_numbers, force_constants_mdyne, print_displacements, n_atoms, ir_intensities, coordinates, electronic_energy, temperature, pressure) Print vibrational analysis results in a formatted table. Output format is similar to Gaussian, with frequencies grouped in columns.\nOptionally prints Cartesian displacement vectors for each mode.\nIf coordinates and electronic_energy are provided, also computes and prints\nthermochemistry using the RRHO approximation. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frequencies (:) Vibrational frequencies in cm⁻¹ real(kind=dp), intent(in) :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(in) :: force_constants (:) Force constants in Hartree/Bohr² (or mdyne/Å if force_constants_mdyne provided) real(kind=dp), intent(in) :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom real(kind=dp), intent(in), optional :: force_constants_mdyne (:) Force constants in mdyne/Å (if provided, these are printed instead) logical, intent(in), optional :: print_displacements If true, print Cartesian displacement vectors (default: true) integer, intent(in), optional :: n_atoms Number of atoms (if not provided, derived from size of element_numbers) real(kind=dp), intent(in), optional :: ir_intensities (:) IR intensities in km/mol real(kind=dp), intent(in), optional :: coordinates (:,:) Atomic coordinates (3, n_atoms) in Bohr - needed for thermochemistry real(kind=dp), intent(in), optional :: electronic_energy Electronic energy in Hartree - needed for thermochemistry real(kind=dp), intent(in), optional :: temperature Temperature for thermochemistry in K (default: 298.15) real(kind=dp), intent(in), optional :: pressure Pressure for thermochemistry in atm (default: 1.0) Calls proc~~print_vibrational_analysis~~CallsGraph proc~print_vibrational_analysis print_vibrational_analysis info info proc~print_vibrational_analysis->info proc~compute_thermochemistry compute_thermochemistry proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry warning warning proc~print_vibrational_analysis->warning proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~print_thermochemistry->info proc~compute_moments_of_inertia->warning pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~element_mass element_mass proc~compute_moments_of_inertia->proc~element_mass to_char to_char proc~compute_moments_of_inertia->to_char proc~compute_zpe->warning proc~compute_zpe->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vibrational_analysis~~CalledByGraph proc~print_vibrational_analysis print_vibrational_analysis proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~print_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~print_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~print_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor->proc~serial_fragment_processor proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=3), private :: coord_label logical, private :: do_print_disp character(len=2), private :: elem_sym character(len=16), private :: fc_str real(kind=dp), private :: fc_value character(len=16), private :: freq_str integer, private :: iatom integer, private :: icoord integer, private :: igroup integer, private :: imode character(len=16), private :: ir_str integer, private :: k character(len=512), private :: line character(len=16), private :: mass_str integer, private :: mode_end integer, private :: mode_start integer, private :: modes_in_group integer, private :: n_at integer, private :: n_groups integer, private :: n_modes Source Code subroutine print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cartesian_displacements , element_numbers , & force_constants_mdyne , print_displacements , & n_atoms , ir_intensities , & coordinates , electronic_energy , & temperature , pressure ) !! Print vibrational analysis results in a formatted table. !! !! Output format is similar to Gaussian, with frequencies grouped in columns. !! Optionally prints Cartesian displacement vectors for each mode. !! If coordinates and electronic_energy are provided, also computes and prints !! thermochemistry using the RRHO approximation. real ( dp ), intent ( in ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ real ( dp ), intent ( in ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), intent ( in ) :: force_constants (:) !! Force constants in Hartree/Bohr² (or mdyne/Å if force_constants_mdyne provided) real ( dp ), intent ( in ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom real ( dp ), intent ( in ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å (if provided, these are printed instead) logical , intent ( in ), optional :: print_displacements !! If true, print Cartesian displacement vectors (default: true) integer , intent ( in ), optional :: n_atoms !! Number of atoms (if not provided, derived from size of element_numbers) real ( dp ), intent ( in ), optional :: ir_intensities (:) !! IR intensities in km/mol real ( dp ), intent ( in ), optional :: coordinates (:, :) !! Atomic coordinates (3, n_atoms) in Bohr - needed for thermochemistry real ( dp ), intent ( in ), optional :: electronic_energy !! Electronic energy in Hartree - needed for thermochemistry real ( dp ), intent ( in ), optional :: temperature !! Temperature for thermochemistry in K (default: 298.15) real ( dp ), intent ( in ), optional :: pressure !! Pressure for thermochemistry in atm (default: 1.0) integer :: n_modes , n_at , n_groups , igroup , imode , iatom , icoord , k integer :: mode_start , mode_end , modes_in_group logical :: do_print_disp character ( len = 512 ) :: line character ( len = 16 ) :: freq_str , mass_str , fc_str , ir_str character ( len = 2 ) :: elem_sym character ( len = 3 ) :: coord_label real ( dp ) :: fc_value n_modes = size ( frequencies ) if ( present ( n_atoms )) then n_at = n_atoms else n_at = size ( element_numbers ) end if do_print_disp = . true . if ( present ( print_displacements )) do_print_disp = print_displacements call logger % info ( \" \" ) call logger % info ( \"============================================================\" ) call logger % info ( \"                  VIBRATIONAL ANALYSIS\" ) call logger % info ( \"============================================================\" ) call logger % info ( \" \" ) ! Print in groups of 3 modes (like Gaussian) n_groups = ( n_modes + 2 ) / 3 do igroup = 1 , n_groups mode_start = ( igroup - 1 ) * 3 + 1 mode_end = min ( igroup * 3 , n_modes ) modes_in_group = mode_end - mode_start + 1 ! Mode numbers header line = \"                    \" do k = mode_start , mode_end write ( freq_str , '(i12)' ) k line = trim ( line ) // freq_str end do call logger % info ( trim ( line )) ! Frequencies (show \"i\" only for significant imaginary frequencies) line = \" Frequencies --  \" do k = mode_start , mode_end if ( frequencies ( k ) < 0.0_dp . and . abs ( frequencies ( k )) > 1 0.0_dp ) then ! Significant imaginary frequency - show with \"i\" write ( freq_str , '(f12.4,a)' ) abs ( frequencies ( k )), \"i\" else ! Real or near-zero frequency write ( freq_str , '(f12.4)' ) abs ( frequencies ( k )) end if line = trim ( line ) // freq_str end do call logger % info ( trim ( line )) ! Reduced masses line = \" Red. masses --  \" do k = mode_start , mode_end write ( mass_str , '(f12.4)' ) reduced_masses ( k ) line = trim ( line ) // mass_str end do call logger % info ( trim ( line )) ! Force constants if ( present ( force_constants_mdyne )) then line = \" Frc consts  --  \" do k = mode_start , mode_end write ( fc_str , '(f12.4)' ) force_constants_mdyne ( k ) line = trim ( line ) // fc_str end do else line = \" Frc consts  --  \" do k = mode_start , mode_end write ( fc_str , '(f12.6)' ) force_constants ( k ) line = trim ( line ) // fc_str end do end if call logger % info ( trim ( line )) ! IR intensities (if provided) if ( present ( ir_intensities )) then line = \" IR Intens  --  \" do k = mode_start , mode_end write ( ir_str , '(f12.4)' ) ir_intensities ( k ) line = trim ( line ) // ir_str end do call logger % info ( trim ( line )) end if ! Cartesian displacements if ( do_print_disp ) then call logger % info ( \" Atom          X         Y         Z       X         Y         Z       X         Y         Z\" ) do iatom = 1 , n_at elem_sym = element_number_to_symbol ( element_numbers ( iatom )) ! Build line with atom info and displacements for each mode write ( line , '(i4,1x,a2)' ) iatom , elem_sym do k = mode_start , mode_end do icoord = 1 , 3 write ( freq_str , '(f10.5)' ) cartesian_displacements ( 3 * ( iatom - 1 ) + icoord , k ) line = trim ( line ) // freq_str end do end do call logger % info ( trim ( line )) end do end if call logger % info ( \" \" ) end do ! Summary statistics call logger % info ( \"------------------------------------------------------------\" ) call logger % info ( \" Summary:\" ) ! Count real vs imaginary frequencies block integer :: n_real , n_imag , n_zero real ( dp ) :: zero_thresh zero_thresh = 1 0.0_dp ! frequencies below 10 cm⁻¹ considered \"zero\" n_real = 0 n_imag = 0 n_zero = 0 do k = 1 , n_modes if ( abs ( frequencies ( k )) < zero_thresh ) then n_zero = n_zero + 1 else if ( frequencies ( k ) < 0.0_dp ) then n_imag = n_imag + 1 else n_real = n_real + 1 end if end do write ( line , '(a,i5)' ) \"   Total modes:              \" , n_modes call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Real frequencies:         \" , n_real call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Imaginary frequencies:    \" , n_imag call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Near-zero (trans/rot):    \" , n_zero call logger % info ( trim ( line )) if ( n_imag > 0 ) then call logger % warning ( \"System has imaginary frequencies - may be a transition state\" ) end if end block call logger % info ( \"============================================================\" ) call logger % info ( \" \" ) ! Compute and print thermochemistry if coordinates and energy are provided if ( present ( coordinates ) . and . present ( electronic_energy )) then block type ( thermochemistry_result_t ) :: thermo_result call compute_thermochemistry ( coordinates , element_numbers , frequencies , & n_at , n_modes , thermo_result , & temperature = temperature , pressure = pressure ) call print_thermochemistry ( thermo_result , electronic_energy ) end block end if end subroutine print_vibrational_analysis","tags":"","url":"proc/print_vibrational_analysis.html"},{"title":"project_translation_rotation – metalquicha","text":"public  subroutine project_translation_rotation(mw_hessian, coordinates, element_numbers) Project out translation and rotation modes from mass-weighted Hessian. Builds 6 vectors (3 translation + 3 rotation) in mass-weighted coordinates,\northonormalizes them using SVD, then projects them out:\n  H_proj = (I - D @ D&#94;T) @ H @ (I - D @ D&#94;T) This sets the 6 translation/rotation eigenvalues to exactly zero. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: mw_hessian (:,:) Mass-weighted Hessian (modified in place) real(kind=dp), intent(in) :: coordinates (:,:) Atomic coordinates in Bohr (3, N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) Calls proc~~project_translation_rotation~~CallsGraph proc~project_translation_rotation project_translation_rotation pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~element_mass element_mass proc~project_translation_rotation->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~project_translation_rotation~~CalledByGraph proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_analysis interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~compute_gmbe compute_gmbe proc~compute_gmbe->proc~compute_vibrational_analysis proc~compute_mbe compute_mbe proc~compute_mbe->proc~compute_vibrational_analysis proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: D (:,:) real(kind=dp), private, allocatable :: D_orth (:,:) real(kind=dp), private, allocatable :: S (:) real(kind=dp), private, allocatable :: U (:,:) real(kind=dp), private, allocatable :: VT (:,:) real(kind=dp), private, allocatable :: com (:) integer, private :: i integer, private :: iatom integer, private :: idx integer, private :: info integer, private :: j integer, private :: k real(kind=dp), private :: mass integer, private :: n_atoms integer, private :: n_coords integer, private :: n_modes real(kind=dp), private :: norm real(kind=dp), private, allocatable :: proj (:,:) real(kind=dp), private, allocatable :: r (:,:) real(kind=dp), private, allocatable :: sqrt_mass (:) real(kind=dp), private, allocatable :: temp (:,:) real(kind=dp), private :: total_mass Source Code subroutine project_translation_rotation ( mw_hessian , coordinates , element_numbers ) !! Project out translation and rotation modes from mass-weighted Hessian. !! !! Builds 6 vectors (3 translation + 3 rotation) in mass-weighted coordinates, !! orthonormalizes them using SVD, then projects them out: !!   H_proj = (I - D @ D&#94;T) @ H @ (I - D @ D&#94;T) !! !! This sets the 6 translation/rotation eigenvalues to exactly zero. real ( dp ), intent ( inout ) :: mw_hessian (:, :) !! Mass-weighted Hessian (modified in place) real ( dp ), intent ( in ) :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable :: D (:, :) ! Translation/rotation vectors (3N, 6) real ( dp ), allocatable :: com (:) ! Center of mass real ( dp ), allocatable :: r (:, :) ! Coordinates relative to COM real ( dp ), allocatable :: sqrt_mass (:) ! sqrt(mass) for each atom real ( dp ), allocatable :: S (:) ! Singular values real ( dp ), allocatable :: U (:, :) ! Left singular vectors real ( dp ), allocatable :: VT (:, :) ! Right singular vectors (transposed) real ( dp ), allocatable :: D_orth (:, :) ! Orthonormalized D vectors real ( dp ), allocatable :: proj (:, :) ! Projector matrix real ( dp ), allocatable :: temp (:, :) ! Temporary matrix real ( dp ) :: total_mass , mass , norm integer :: n_atoms , n_coords , iatom , i , j , k , n_modes , info integer :: idx n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms ! Allocate arrays allocate ( D ( n_coords , 6 )) allocate ( com ( 3 )) allocate ( r ( 3 , n_atoms )) allocate ( sqrt_mass ( n_atoms )) ! Compute sqrt(mass) for each atom and total mass total_mass = 0.0_dp do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) sqrt_mass ( iatom ) = sqrt ( mass ) total_mass = total_mass + mass end do ! Compute center of mass com = 0.0_dp do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) com (:) = com (:) + mass * coordinates (:, iatom ) end do com = com / total_mass ! Compute coordinates relative to center of mass do iatom = 1 , n_atoms r (:, iatom ) = coordinates (:, iatom ) - com (:) end do ! Initialize D to zero D = 0.0_dp ! Build translation vectors (mass-weighted) ! D_trans_k: displacement along axis k, weighted by sqrt(mass) do iatom = 1 , n_atoms idx = 3 * ( iatom - 1 ) ! Translation along x D ( idx + 1 , 1 ) = sqrt_mass ( iatom ) ! Translation along y D ( idx + 2 , 2 ) = sqrt_mass ( iatom ) ! Translation along z D ( idx + 3 , 3 ) = sqrt_mass ( iatom ) end do ! Build rotation vectors (mass-weighted) ! D_rot_k: rotation around axis k, proportional to r × e_k, weighted by sqrt(mass) do iatom = 1 , n_atoms idx = 3 * ( iatom - 1 ) ! Rotation around x-axis: r × e_x = (0, r_z, -r_y) D ( idx + 2 , 4 ) = sqrt_mass ( iatom ) * r ( 3 , iatom ) D ( idx + 3 , 4 ) = - sqrt_mass ( iatom ) * r ( 2 , iatom ) ! Rotation around y-axis: r × e_y = (-r_z, 0, r_x) D ( idx + 1 , 5 ) = - sqrt_mass ( iatom ) * r ( 3 , iatom ) D ( idx + 3 , 5 ) = sqrt_mass ( iatom ) * r ( 1 , iatom ) ! Rotation around z-axis: r × e_z = (r_y, -r_x, 0) D ( idx + 1 , 6 ) = sqrt_mass ( iatom ) * r ( 2 , iatom ) D ( idx + 2 , 6 ) = - sqrt_mass ( iatom ) * r ( 1 , iatom ) end do ! Normalize each column of D do k = 1 , 6 norm = sqrt ( sum ( D (:, k ) ** 2 )) if ( norm > 1.0e-10_dp ) then D (:, k ) = D (:, k ) / norm end if end do ! Orthonormalize D using SVD: D = U @ S @ VT ! The orthonormal basis is given by the columns of U corresponding to non-zero singular values allocate ( S ( 6 )) allocate ( U ( n_coords , 6 )) allocate ( VT ( 6 , 6 )) ! pic_gesvd(A, S, U, VT, info) - A is input, U and VT are separate outputs call pic_gesvd ( D , S , U , VT , info = info ) ! Count non-zero singular values (determines number of modes to project) n_modes = 0 do k = 1 , 6 if ( S ( k ) > 1.0e-10_dp ) n_modes = n_modes + 1 end do ! Build orthonormalized D matrix from U (columns with non-zero singular values) allocate ( D_orth ( n_coords , n_modes )) j = 0 do k = 1 , 6 if ( S ( k ) > 1.0e-10_dp ) then j = j + 1 D_orth (:, j ) = U (:, k ) end if end do ! Build projector: P = I - D_orth @ D_orth&#94;T allocate ( proj ( n_coords , n_coords )) proj = 0.0_dp do i = 1 , n_coords proj ( i , i ) = 1.0_dp end do ! Subtract D_orth @ D_orth&#94;T do i = 1 , n_coords do j = 1 , n_coords do k = 1 , n_modes proj ( i , j ) = proj ( i , j ) - D_orth ( i , k ) * D_orth ( j , k ) end do end do end do ! Apply projection: H_proj = P @ H @ P allocate ( temp ( n_coords , n_coords )) ! temp = H @ P do i = 1 , n_coords do j = 1 , n_coords temp ( i , j ) = 0.0_dp do k = 1 , n_coords temp ( i , j ) = temp ( i , j ) + mw_hessian ( i , k ) * proj ( k , j ) end do end do end do ! H_proj = P @ temp do i = 1 , n_coords do j = 1 , n_coords mw_hessian ( i , j ) = 0.0_dp do k = 1 , n_coords mw_hessian ( i , j ) = mw_hessian ( i , j ) + proj ( i , k ) * temp ( k , j ) end do end do end do ! Cleanup deallocate ( D , com , r , sqrt_mass , S , U , VT , D_orth , proj , temp ) end subroutine project_translation_rotation","tags":"","url":"proc/project_translation_rotation.html"},{"title":"dft_calc_energy – metalquicha","text":"private  subroutine dft_calc_energy(this, fragment, result) Calculate electronic energy using Kohn-Sham DFT TODO: Implementation requires:\n1. Build basis set from fragment geometry\n2. Compute one-electron integrals (S, T, V)\n3. Set up integration grid for XC\n4. Initial density guess (SAD or core Hamiltonian)\n5. SCF iterations:\n   a. Build Coulomb matrix J\n   b. Evaluate XC energy and potential on grid\n   c. Build Fock matrix F = H + J + Vxc\n   d. Apply DIIS if enabled\n   e. Diagonalize F -> new density\n   f. Check convergence\n6. Compute final energy Type Bound dft_method_t Arguments Type Intent Optional Attributes Name class( dft_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~dft_calc_energy~~CallsGraph proc~dft_calc_energy dft_method_t%dft_calc_energy proc~energy_total energy_t%energy_total proc~dft_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dft_calc_energy~~CalledByGraph proc~dft_calc_energy dft_method_t%dft_calc_energy proc~dft_calc_gradient dft_method_t%dft_calc_gradient proc~dft_calc_gradient->proc~dft_calc_energy proc~dft_calc_hessian dft_method_t%dft_calc_hessian proc~dft_calc_hessian->proc~dft_calc_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dft_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Kohn-Sham DFT !! !! TODO: Implementation requires: !! 1. Build basis set from fragment geometry !! 2. Compute one-electron integrals (S, T, V) !! 3. Set up integration grid for XC !! 4. Initial density guess (SAD or core Hamiltonian) !! 5. SCF iterations: !!    a. Build Coulomb matrix J !!    b. Evaluate XC energy and potential on grid !!    c. Build Fock matrix F = H + J + Vxc !!    d. Apply DIIS if enabled !!    e. Diagonalize F -> new density !!    f. Check convergence !! 6. Compute final energy class ( dft_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result if ( this % options % verbose ) then print * , \"DFT: Calculating energy using \" , trim ( this % options % functional ) print * , \"DFT: Basis set: \" , trim ( this % options % basis_set ) print * , \"DFT: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"DFT: nelec =\" , fragment % nelec print * , \"DFT: charge =\" , fragment % charge print * , \"DFT: Grid type: \" , trim ( this % options % grid_type ) if ( this % options % use_density_fitting ) then print * , \"DFT: Using density fitting (RI-J)\" end if if ( this % options % use_dispersion ) then print * , \"DFT: Dispersion correction: \" , trim ( this % options % dispersion_type ) end if end if ! Placeholder: Return dummy energy ! TODO: Implement actual DFT calculation result % energy % scf = - 1.0_dp * fragment % n_atoms ! Placeholder result % has_energy = . true . if ( this % options % verbose ) then print * , \"DFT: [STUB] Energy =\" , result % energy % total () end if end subroutine dft_calc_energy","tags":"","url":"proc/dft_calc_energy.html"},{"title":"dft_calc_gradient – metalquicha","text":"private  subroutine dft_calc_gradient(this, fragment, result) Calculate energy gradient using Kohn-Sham DFT TODO: Implementation requires:\n1. Converged SCF (call calc_energy to get density)\n2. Compute gradient contributions:\n   a. One-electron integral derivatives\n   b. Two-electron integral derivatives (or RI-J)\n   c. XC potential derivatives (grid-based)\n   d. Overlap derivative (Pulay force)\n3. Optional: dispersion gradient Type Bound dft_method_t Arguments Type Intent Optional Attributes Name class( dft_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~dft_calc_gradient~~CallsGraph proc~dft_calc_gradient dft_method_t%dft_calc_gradient proc~dft_calc_energy dft_method_t%dft_calc_energy proc~dft_calc_gradient->proc~dft_calc_energy proc~energy_total energy_t%energy_total proc~dft_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dft_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Kohn-Sham DFT !! !! TODO: Implementation requires: !! 1. Converged SCF (call calc_energy to get density) !! 2. Compute gradient contributions: !!    a. One-electron integral derivatives !!    b. Two-electron integral derivatives (or RI-J) !!    c. XC potential derivatives (grid-based) !!    d. Overlap derivative (Pulay force) !! 3. Optional: dispersion gradient class ( dft_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result if ( this % options % verbose ) then print * , \"DFT: Calculating gradient using \" , trim ( this % options % functional ) end if ! First get energy (and converged density) call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . if ( this % options % verbose ) then print * , \"DFT: [STUB] Gradient computed\" end if end subroutine dft_calc_gradient","tags":"","url":"proc/dft_calc_gradient.html"},{"title":"dft_calc_hessian – metalquicha","text":"private  subroutine dft_calc_hessian(this, fragment, result) Calculate energy Hessian using Kohn-Sham DFT TODO: Analytical Hessian requires:\n1. Converged SCF and gradient\n2. Coupled-perturbed Kohn-Sham (CPKS) equations\n3. Second derivatives of integrals\n4. XC kernel contributions\nAlternative: Use finite difference of gradients (via driver) Type Bound dft_method_t Arguments Type Intent Optional Attributes Name class( dft_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~dft_calc_hessian~~CallsGraph proc~dft_calc_hessian dft_method_t%dft_calc_hessian proc~dft_calc_energy dft_method_t%dft_calc_energy proc~dft_calc_hessian->proc~dft_calc_energy proc~energy_total energy_t%energy_total proc~dft_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dft_calc_hessian ( this , fragment , result ) !! Calculate energy Hessian using Kohn-Sham DFT !! !! TODO: Analytical Hessian requires: !! 1. Converged SCF and gradient !! 2. Coupled-perturbed Kohn-Sham (CPKS) equations !! 3. Second derivatives of integrals !! 4. XC kernel contributions !! Alternative: Use finite difference of gradients (via driver) class ( dft_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result if ( this % options % verbose ) then print * , \"DFT: Analytical Hessian not yet implemented\" print * , \"DFT: Use finite difference of gradients instead\" end if ! For now, just compute energy call this % calc_energy ( fragment , result ) result % has_hessian = . false . end subroutine dft_calc_hessian","tags":"","url":"proc/dft_calc_hessian.html"},{"title":"distributed_unfragmented_hessian – metalquicha","text":"module subroutine distributed_unfragmented_hessian(world_comm, sys_geom, method_config, driver_config, json_data) Interface → Uses mqc_finite_differences mqc_config_adapter mqc_json_output_types proc~~distributed_unfragmented_hessian~~UsesGraph proc~distributed_unfragmented_hessian distributed_unfragmented_hessian module~mqc_config_adapter mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_config_adapter module~mqc_finite_differences mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_finite_differences module~mqc_json_output_types mqc_json_output_types proc~distributed_unfragmented_hessian->module~mqc_json_output_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment pic_logger pic_logger module~mqc_config_adapter->pic_logger pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_finite_differences->pic_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_json_output_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_thermochemistry->module~mqc_physical_constants pic_io pic_io module~mqc_thermochemistry->pic_io pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute Hessian for unfragmented system using MPI distribution Uses a dynamic work queue approach: workers request displacement indices\nfrom rank 0, compute gradients, and send results back. This provides\nbetter load balancing than static work distribution. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration type( driver_config_t ), intent(in), optional :: driver_config Driver configuration type( json_output_data_t ), intent(out), optional :: json_data JSON output data Calls proc~~distributed_unfragmented_hessian~~CallsGraph proc~distributed_unfragmented_hessian distributed_unfragmented_hessian barrier barrier proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker calc_gradient calc_gradient proc~hessian_coordinator->calc_gradient cart_disp cart_disp proc~hessian_coordinator->cart_disp configuration configuration proc~hessian_coordinator->configuration fc_mdyne fc_mdyne proc~hessian_coordinator->fc_mdyne force_constants force_constants proc~hessian_coordinator->force_constants get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time info info proc~hessian_coordinator->info iprobe iprobe proc~hessian_coordinator->iprobe ir_intensities ir_intensities proc~hessian_coordinator->ir_intensities irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~compute_thermochemistry compute_thermochemistry proc~hessian_coordinator->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~create_method create_method proc~hessian_coordinator->proc~create_method proc~energy_total energy_t%energy_total proc~hessian_coordinator->proc~energy_total proc~finite_diff_dipole_derivatives finite_diff_dipole_derivatives proc~hessian_coordinator->proc~finite_diff_dipole_derivatives proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_coordinator->proc~fragment_compute_nelec proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~hessian_coordinator->proc~populate_unfragmented_json_data proc~populate_vibrational_json_data populate_vibrational_json_data proc~hessian_coordinator->proc~populate_vibrational_json_data proc~print_vibrational_analysis print_vibrational_analysis proc~hessian_coordinator->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~hessian_coordinator->proc~result_destroy recv recv proc~hessian_coordinator->recv reduced_masses reduced_masses proc~hessian_coordinator->reduced_masses start start proc~hessian_coordinator->start to_char to_char proc~hessian_coordinator->to_char vib_freqs vib_freqs proc~hessian_coordinator->vib_freqs abort_comm abort_comm proc~hessian_worker->abort_comm proc~hessian_worker->calc_gradient error error proc~hessian_worker->error proc~hessian_worker->irecv proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~hessian_worker->proc~create_method proc~error_get_message error_t%error_get_message proc~hessian_worker->proc~error_get_message proc~hessian_worker->proc~fragment_compute_nelec proc~hessian_worker->proc~result_destroy send send proc~hessian_worker->send proc~hessian_worker->to_char proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~populate_unfragmented_json_data->proc~energy_total proc~populate_vibrational_json_data->proc~energy_total proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->warning proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_zpe->to_char proc~compute_zpe->warning proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb proc~mass_weight_hessian->proc~element_mass proc~print_thermochemistry->info pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~distributed_unfragmented_hessian~~CalledByGraph proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: displacement integer, private :: my_rank integer, private :: n_ranks real(kind=dp), private :: pressure real(kind=dp), private :: temperature Source Code module subroutine distributed_unfragmented_hessian ( world_comm , sys_geom , method_config , driver_config , json_data ) !! Compute Hessian for unfragmented system using MPI distribution !! !! Uses a dynamic work queue approach: workers request displacement indices !! from rank 0, compute gradients, and send results back. This provides !! better load balancing than static work distribution. use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT , & copy_and_displace_geometry use mqc_config_adapter , only : driver_config_t use mqc_json_output_types , only : json_output_data_t type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration type ( driver_config_t ), intent ( in ), optional :: driver_config !! Driver configuration type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data integer :: my_rank , n_ranks real ( dp ) :: displacement real ( dp ) :: temperature , pressure my_rank = world_comm % rank () n_ranks = world_comm % size () ! Use provided settings or defaults if ( present ( driver_config )) then displacement = driver_config % hessian % displacement temperature = driver_config % hessian % temperature pressure = driver_config % hessian % pressure else displacement = DEFAULT_DISPLACEMENT temperature = 29 8.15_dp pressure = 1.0_dp end if if ( my_rank == 0 ) then ! Rank 0 is the coordinator if ( present ( json_data )) then call hessian_coordinator ( world_comm , sys_geom , method_config , displacement , temperature , pressure , json_data ) else call hessian_coordinator ( world_comm , sys_geom , method_config , displacement , temperature , pressure ) end if else ! Other ranks are workers call hessian_worker ( world_comm , sys_geom , method_config , displacement ) end if ! Synchronize all ranks before returning call world_comm % barrier () end subroutine distributed_unfragmented_hessian","tags":"","url":"proc/distributed_unfragmented_hessian.html"},{"title":"hessian_coordinator – metalquicha","text":"module subroutine hessian_coordinator(world_comm, sys_geom, method_config, displacement, temperature, pressure, json_data) Interface → Uses mqc_thermochemistry mqc_json_output_types mqc_method_factory mqc_vibrational_analysis mqc_method_base mqc_finite_differences proc~~hessian_coordinator~~UsesGraph proc~hessian_coordinator hessian_coordinator module~mqc_finite_differences mqc_finite_differences proc~hessian_coordinator->module~mqc_finite_differences module~mqc_json_output_types mqc_json_output_types proc~hessian_coordinator->module~mqc_json_output_types module~mqc_method_base mqc_method_base proc~hessian_coordinator->module~mqc_method_base module~mqc_method_factory mqc_method_factory proc~hessian_coordinator->module~mqc_method_factory module~mqc_thermochemistry mqc_thermochemistry proc~hessian_coordinator->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis proc~hessian_coordinator->module~mqc_vibrational_analysis module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_json_output_types->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_method_factory->module~mqc_method_base mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_config mqc_method_config module~mqc_method_factory->module~mqc_method_config module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_types mqc_method_types module~mqc_method_factory->module~mqc_method_types module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_method_factory->pic_types module~mqc_elements mqc_elements module~mqc_thermochemistry->module~mqc_elements module~mqc_physical_constants mqc_physical_constants module~mqc_thermochemistry->module~mqc_physical_constants pic_io pic_io module~mqc_thermochemistry->pic_io pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces pic_logger pic_logger module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_method_config->module~mqc_method_types module~mqc_method_config->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->pic_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->pic_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->pic_types module~mqc_method_types->pic_types module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->mctc_env module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_logger module~mqc_method_xtb->pic_types mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_error mqc_error module~mqc_method_xtb->module~mqc_error pic_timer pic_timer module~mqc_method_xtb->pic_timer tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_physical_constants->pic_types module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Coordinator for distributed Hessian calculation\nDistributes displacement work and collects gradient results Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr) real(kind=dp), intent(in) :: temperature Temperature for thermochemistry (K) real(kind=dp), intent(in) :: pressure Pressure for thermochemistry (atm) type( json_output_data_t ), intent(out), optional :: json_data JSON output data Calls proc~~hessian_coordinator~~CallsGraph proc~hessian_coordinator hessian_coordinator calc_gradient calc_gradient proc~hessian_coordinator->calc_gradient cart_disp cart_disp proc~hessian_coordinator->cart_disp configuration configuration proc~hessian_coordinator->configuration fc_mdyne fc_mdyne proc~hessian_coordinator->fc_mdyne force_constants force_constants proc~hessian_coordinator->force_constants get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time info info proc~hessian_coordinator->info iprobe iprobe proc~hessian_coordinator->iprobe ir_intensities ir_intensities proc~hessian_coordinator->ir_intensities irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~compute_thermochemistry compute_thermochemistry proc~hessian_coordinator->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~hessian_coordinator->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~hessian_coordinator->proc~compute_vibrational_frequencies proc~create_method create_method proc~hessian_coordinator->proc~create_method proc~energy_total energy_t%energy_total proc~hessian_coordinator->proc~energy_total proc~finite_diff_dipole_derivatives finite_diff_dipole_derivatives proc~hessian_coordinator->proc~finite_diff_dipole_derivatives proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_coordinator->proc~fragment_compute_nelec proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~hessian_coordinator->proc~populate_unfragmented_json_data proc~populate_vibrational_json_data populate_vibrational_json_data proc~hessian_coordinator->proc~populate_vibrational_json_data proc~print_vibrational_analysis print_vibrational_analysis proc~hessian_coordinator->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~hessian_coordinator->proc~result_destroy recv recv proc~hessian_coordinator->recv reduced_masses reduced_masses proc~hessian_coordinator->reduced_masses start start proc~hessian_coordinator->start to_char to_char proc~hessian_coordinator->to_char vib_freqs vib_freqs proc~hessian_coordinator->vib_freqs proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses error error proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~populate_unfragmented_json_data->proc~energy_total proc~populate_vibrational_json_data->proc~energy_total proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->warning proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_zpe->to_char proc~compute_zpe->warning proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb proc~mass_weight_hessian->proc~element_mass proc~print_thermochemistry->info pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear state_weights state_weights proc~configure_mcscf->state_weights proc~method_type_to_string method_type_to_string proc~configure_xtb->proc~method_type_to_string proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~configure_xtb->proc~xtb_has_solvation proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hessian_coordinator~~CalledByGraph proc~hessian_coordinator hessian_coordinator interface~hessian_coordinator hessian_coordinator interface~hessian_coordinator->proc~hessian_coordinator proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: backward_dipoles (:,:) real(kind=dp), private, allocatable :: backward_gradients (:,:,:) class( qc_method_t ), private, allocatable :: calculator Polymorphic calculator logical, private :: compute_dipole_derivs type(timer_type), private :: coord_timer integer, private :: current_disp integer, private :: current_log_level real(kind=dp), private, allocatable :: dipole_buffer (:) integer, private :: disp_idx integer, private :: dummy_msg real(kind=dp), private, allocatable :: eigenvalues (:) integer, private :: finished_workers real(kind=dp), private, allocatable :: forward_dipoles (:,:) real(kind=dp), private, allocatable :: forward_gradients (:,:,:) real(kind=dp), private, allocatable :: frequencies (:) type( physical_fragment_t ), private :: full_system real(kind=dp), private, allocatable :: grad_buffer (:,:) integer, private :: gradient_type logical, private :: has_dipole_flag logical, private :: has_pending real(kind=dp), private :: hess_norm real(kind=dp), private, allocatable :: hessian (:,:) integer, private :: i logical, private :: is_verbose integer, private :: j type( method_config_t ), private :: local_config Local copy for verbose override integer, private :: n_atoms integer, private :: n_displacements integer, private :: n_ranks real(kind=dp), private, allocatable :: projected_hessian (:,:) type(request_t), private :: req type( calculation_result_t ), private :: result character(len=2048), private :: result_line type(MPI_Status), private :: status integer, private :: worker_rank Source Code module subroutine hessian_coordinator ( world_comm , sys_geom , method_config , displacement , temperature , pressure , json_data ) !! Coordinator for distributed Hessian calculation !! Distributes displacement work and collects gradient results use mqc_finite_differences , only : finite_diff_hessian_from_gradients , finite_diff_dipole_derivatives use mqc_vibrational_analysis , only : compute_vibrational_frequencies , & compute_vibrational_analysis , print_vibrational_analysis use mqc_thermochemistry , only : thermochemistry_result_t , compute_thermochemistry use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_UNFRAGMENTED use mqc_method_base , only : qc_method_t use mqc_method_factory , only : create_method type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) real ( dp ), intent ( in ) :: temperature !! Temperature for thermochemistry (K) real ( dp ), intent ( in ) :: pressure !! Pressure for thermochemistry (atm) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data type ( physical_fragment_t ) :: full_system type ( timer_type ) :: coord_timer real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: forward_dipoles (:, :) ! (n_displacements, 3) for IR intensities real ( dp ), allocatable :: backward_dipoles (:, :) ! (n_displacements, 3) for IR intensities real ( dp ), allocatable :: dipole_buffer (:) ! (3) real ( dp ), allocatable :: hessian (:, :) real ( dp ), allocatable :: grad_buffer (:, :) logical :: has_dipole_flag , compute_dipole_derivs type ( calculation_result_t ) :: result integer :: n_atoms , n_displacements , n_ranks integer :: current_disp , finished_workers , dummy_msg , worker_rank integer :: disp_idx , gradient_type ! gradient_type: 1=forward, 2=backward type ( MPI_Status ) :: status logical :: has_pending type ( request_t ) :: req integer :: current_log_level logical :: is_verbose character ( len = 2048 ) :: result_line ! Large buffer for Hessian matrix rows real ( dp ) :: hess_norm integer :: i , j real ( dp ), allocatable :: frequencies (:) real ( dp ), allocatable :: eigenvalues (:) real ( dp ), allocatable :: projected_hessian (:, :) class ( qc_method_t ), allocatable :: calculator !! Polymorphic calculator type ( method_config_t ) :: local_config !! Local copy for verbose override n_ranks = world_comm % size () n_atoms = sys_geom % total_atoms n_displacements = 3 * n_atoms call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) call logger % info ( \"============================================\" ) call logger % info ( \"Distributed unfragmented Hessian calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) call logger % info ( \"  Finite difference step size: \" // to_char ( displacement ) // \" Bohr\" ) call logger % info ( \"  MPI ranks: \" // to_char ( n_ranks )) call logger % info ( \"  Work distribution: Dynamic queue\" ) call logger % info ( \"============================================\" ) ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Allocate storage for all gradients allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) allocate ( grad_buffer ( 3 , n_atoms )) ! Allocate storage for dipoles (for IR intensities) allocate ( forward_dipoles ( n_displacements , 3 )) allocate ( backward_dipoles ( n_displacements , 3 )) allocate ( dipole_buffer ( 3 )) forward_dipoles = 0.0_dp backward_dipoles = 0.0_dp compute_dipole_derivs = . true . ! Will be set false if any dipole is missing current_disp = 1 finished_workers = 0 ! Process work requests and collect results call coord_timer % start () do while ( finished_workers < n_ranks - 1 ) ! Check for incoming gradient results call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE ! Receive: displacement index, gradient type (1=forward, 2=backward), gradient data, dipole call irecv ( world_comm , disp_idx , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call irecv ( world_comm , gradient_type , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call recv ( world_comm , grad_buffer , worker_rank , TAG_WORKER_SCALAR_RESULT , status ) ! Receive dipole flag and data call recv ( world_comm , has_dipole_flag , worker_rank , TAG_WORKER_SCALAR_RESULT , status ) if ( has_dipole_flag ) then call recv ( world_comm , dipole_buffer , worker_rank , TAG_WORKER_SCALAR_RESULT , status ) else compute_dipole_derivs = . false . end if ! Store gradient and dipole in appropriate arrays if ( gradient_type == 1 ) then forward_gradients ( disp_idx , :, :) = grad_buffer if ( has_dipole_flag ) forward_dipoles ( disp_idx , :) = dipole_buffer else backward_gradients ( disp_idx , :, :) = grad_buffer if ( has_dipole_flag ) backward_dipoles ( disp_idx , :) = dipole_buffer end if ! Log progress every 10% or at completion (count both forward and backward) if ( gradient_type == 2 ) then ! Only log after backward gradient to count complete displacements if ( mod ( disp_idx , max ( 1 , n_displacements / 10 )) == 0 . or . disp_idx == n_displacements ) then call logger % info ( \"  Completed \" // to_char ( disp_idx ) // \"/\" // to_char ( n_displacements ) // & \" displacement pairs in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end if end if end if ! Check for work requests from workers call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE call irecv ( world_comm , dummy_msg , worker_rank , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_disp <= n_displacements ) then ! Send next displacement index to worker call isend ( world_comm , current_disp , worker_rank , TAG_WORKER_FRAGMENT , req ) call wait ( req ) current_disp = current_disp + 1 else ! No more work - tell worker to finish call isend ( world_comm , - 1 , worker_rank , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end do deallocate ( grad_buffer ) call coord_timer % stop () call logger % info ( \"All gradient calculations completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Assemble Hessian from finite differences call logger % info ( \"  Assembling Hessian matrix...\" ) call coord_timer % start () call finite_diff_hessian_from_gradients ( full_system , forward_gradients , backward_gradients , & displacement , hessian ) call coord_timer % stop () call logger % info ( \"Hessian assembly completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Compute energy and gradient at reference geometry call logger % info ( \"  Computing reference energy and gradient...\" ) local_config = method_config local_config % verbose = is_verbose calculator = create_method ( local_config ) call calculator % calc_gradient ( full_system , result ) deallocate ( calculator ) ! Store Hessian in result if ( allocated ( result % hessian )) deallocate ( result % hessian ) allocate ( result % hessian ( size ( hessian , 1 ), size ( hessian , 2 ))) result % hessian = hessian result % has_hessian = . true . ! Compute dipole derivatives for IR intensities if all dipoles were received if ( compute_dipole_derivs ) then call logger % info ( \"  Computing dipole derivatives for IR intensities...\" ) call finite_diff_dipole_derivatives ( n_atoms , forward_dipoles , backward_dipoles , & displacement , result % dipole_derivatives ) result % has_dipole_derivatives = . true . end if ! Compute vibrational frequencies from the Hessian (with trans/rot projection) call logger % info ( \"  Computing vibrational frequencies (projecting trans/rot modes)...\" ) call compute_vibrational_frequencies ( result % hessian , sys_geom % element_numbers , frequencies , eigenvalues , & coordinates = sys_geom % coordinates , project_trans_rot = . true ., & projected_hessian_out = projected_hessian ) ! Print results call logger % info ( \"============================================\" ) call logger % info ( \"Distributed Hessian calculation completed\" ) write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) end if if ( result % has_hessian ) then hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) if ( is_verbose . and . n_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * n_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * n_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) ! Print projected mass-weighted Hessian if ( allocated ( projected_hessian )) then call logger % info ( \"Mass-weighted Hessian after trans/rot projection (a.u.):\" ) do i = 1 , 3 * n_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( projected_hessian ( i , j ), j = 1 , 3 * n_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if end if ! Compute and print full vibrational analysis with thermochemistry if ( allocated ( frequencies )) then block real ( dp ), allocatable :: vib_freqs (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:), ir_intensities (:) type ( thermochemistry_result_t ) :: thermo_result integer :: n_at , n_modes if ( result % has_dipole_derivatives ) then call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , vib_freqs , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne , & dipole_derivatives = result % dipole_derivatives , & ir_intensities = ir_intensities ) else call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , vib_freqs , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) end if if ( allocated ( vib_freqs )) then ! Compute thermochemistry n_at = size ( sys_geom % element_numbers ) n_modes = size ( vib_freqs ) call compute_thermochemistry ( sys_geom % coordinates , sys_geom % element_numbers , & vib_freqs , n_at , n_modes , thermo_result , & temperature = temperature , pressure = pressure ) ! Print vibrational analysis to log if ( allocated ( ir_intensities )) then call print_vibrational_analysis ( vib_freqs , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & ir_intensities = ir_intensities , & coordinates = sys_geom % coordinates , & electronic_energy = result % energy % total (), & temperature = temperature , pressure = pressure ) ! Populate json_data if ( present ( json_data )) then call populate_vibrational_json_data ( json_data , result , vib_freqs , reduced_masses , & fc_mdyne , thermo_result , ir_intensities ) end if deallocate ( ir_intensities ) else call print_vibrational_analysis ( vib_freqs , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & coordinates = sys_geom % coordinates , & electronic_energy = result % energy % total (), & temperature = temperature , pressure = pressure ) ! Populate json_data if ( present ( json_data )) then call populate_vibrational_json_data ( json_data , result , vib_freqs , reduced_masses , & fc_mdyne , thermo_result ) end if end if deallocate ( vib_freqs , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block else ! No Hessian/frequencies - populate basic unfragmented data if ( present ( json_data )) then call populate_unfragmented_json_data ( json_data , result ) end if end if ! Cleanup call result % destroy () deallocate ( forward_gradients , backward_gradients ) deallocate ( forward_dipoles , backward_dipoles , dipole_buffer ) if ( allocated ( hessian )) deallocate ( hessian ) if ( allocated ( frequencies )) deallocate ( frequencies ) if ( allocated ( eigenvalues )) deallocate ( eigenvalues ) if ( allocated ( projected_hessian )) deallocate ( projected_hessian ) end subroutine hessian_coordinator","tags":"","url":"proc/hessian_coordinator.html"},{"title":"hessian_worker – metalquicha","text":"module subroutine hessian_worker(world_comm, sys_geom, method_config, displacement) Interface → Uses mqc_finite_differences mqc_method_factory mqc_method_base proc~~hessian_worker~~UsesGraph proc~hessian_worker hessian_worker module~mqc_finite_differences mqc_finite_differences proc~hessian_worker->module~mqc_finite_differences module~mqc_method_base mqc_method_base proc~hessian_worker->module~mqc_method_base module~mqc_method_factory mqc_method_factory proc~hessian_worker->module~mqc_method_factory module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_method_factory->module~mqc_method_base mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_config mqc_method_config module~mqc_method_factory->module~mqc_method_config module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_types mqc_method_types module~mqc_method_factory->module~mqc_method_types module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_method_factory->pic_types module~mqc_method_config->module~mqc_method_types module~mqc_method_config->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->pic_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->pic_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->pic_types module~mqc_method_types->pic_types module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->mctc_env module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_types mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_error mqc_error module~mqc_method_xtb->module~mqc_error pic_logger pic_logger module~mqc_method_xtb->pic_logger pic_timer pic_timer module~mqc_method_xtb->pic_timer tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Worker for distributed Hessian calculation\nRequests displacement indices, computes gradients, and sends results back Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr) Calls proc~~hessian_worker~~CallsGraph proc~hessian_worker hessian_worker abort_comm abort_comm proc~hessian_worker->abort_comm calc_gradient calc_gradient proc~hessian_worker->calc_gradient error error proc~hessian_worker->error irecv irecv proc~hessian_worker->irecv isend isend proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~create_method create_method proc~hessian_worker->proc~create_method proc~error_get_message error_t%error_get_message proc~hessian_worker->proc~error_get_message proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_worker->proc~fragment_compute_nelec proc~result_destroy calculation_result_t%result_destroy proc~hessian_worker->proc~result_destroy send send proc~hessian_worker->send to_char to_char proc~hessian_worker->to_char proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear state_weights state_weights proc~configure_mcscf->state_weights proc~method_type_to_string method_type_to_string proc~configure_xtb->proc~method_type_to_string proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~configure_xtb->proc~xtb_has_solvation proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hessian_worker~~CalledByGraph proc~hessian_worker hessian_worker interface~hessian_worker hessian_worker interface~hessian_worker->proc~hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->interface~hessian_worker interface~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_idx class( qc_method_t ), private, allocatable :: calculator Polymorphic calculator integer, private :: coord integer, private :: disp_idx type( physical_fragment_t ), private :: displaced_geom integer, private :: dummy_msg type( physical_fragment_t ), private :: full_system type( calculation_result_t ), private :: grad_result integer, private :: gradient_type type( method_config_t ), private :: local_config Local copy for verbose override integer, private :: n_atoms type(request_t), private :: req type(MPI_Status), private :: status Source Code module subroutine hessian_worker ( world_comm , sys_geom , method_config , displacement ) !! Worker for distributed Hessian calculation !! Requests displacement indices, computes gradients, and sends results back use mqc_finite_differences , only : copy_and_displace_geometry use mqc_method_base , only : qc_method_t use mqc_method_factory , only : create_method type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) type ( physical_fragment_t ) :: full_system , displaced_geom type ( calculation_result_t ) :: grad_result integer :: n_atoms , disp_idx , atom_idx , coord , gradient_type , dummy_msg type ( MPI_Status ) :: status type ( request_t ) :: req class ( qc_method_t ), allocatable :: calculator !! Polymorphic calculator type ( method_config_t ) :: local_config !! Local copy for verbose override n_atoms = sys_geom % total_atoms ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Create calculator using factory local_config = method_config local_config % verbose = . false . calculator = create_method ( local_config ) dummy_msg = 0 do ! Request work from coordinator call isend ( world_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( world_comm , disp_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) if ( status % MPI_TAG == TAG_WORKER_FINISH ) exit ! Compute displacement index to atom and coordinate atom_idx = ( disp_idx - 1 ) / 3 + 1 coord = mod ( disp_idx - 1 , 3 ) + 1 ! Compute FORWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , displacement , displaced_geom ) call calculator % calc_gradient ( displaced_geom , grad_result ) if ( grad_result % has_error ) then call logger % error ( \"Worker gradient calculation error for forward displacement \" // & to_char ( disp_idx ) // \": \" // grad_result % error % get_message ()) call abort_comm ( world_comm , 1 ) end if if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for forward displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (1=forward), gradient data, dipole flag, dipole gradient_type = 1 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call send ( world_comm , grad_result % has_dipole , 0 , TAG_WORKER_SCALAR_RESULT ) if ( grad_result % has_dipole ) then call send ( world_comm , grad_result % dipole , 0 , TAG_WORKER_SCALAR_RESULT ) end if call grad_result % destroy () call displaced_geom % destroy () ! Compute BACKWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , - displacement , displaced_geom ) call calculator % calc_gradient ( displaced_geom , grad_result ) if ( grad_result % has_error ) then call logger % error ( \"Worker gradient calculation error for backward displacement \" // & to_char ( disp_idx ) // \": \" // grad_result % error % get_message ()) call abort_comm ( world_comm , 1 ) end if if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for backward displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (2=backward), gradient data, dipole flag, dipole gradient_type = 2 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call send ( world_comm , grad_result % has_dipole , 0 , TAG_WORKER_SCALAR_RESULT ) if ( grad_result % has_dipole ) then call send ( world_comm , grad_result % dipole , 0 , TAG_WORKER_SCALAR_RESULT ) end if call grad_result % destroy () call displaced_geom % destroy () end do ! Cleanup deallocate ( calculator ) end subroutine hessian_worker","tags":"","url":"proc/hessian_worker.html"},{"title":"unfragmented_calculation – metalquicha","text":"module subroutine unfragmented_calculation(sys_geom, method_config, calc_type, bonds, result_out, temperature, pressure, json_data) Interface → Uses mqc_json_output_types mqc_thermochemistry mqc_error mqc_vibrational_analysis proc~~unfragmented_calculation~~UsesGraph proc~unfragmented_calculation unfragmented_calculation module~mqc_error mqc_error proc~unfragmented_calculation->module~mqc_error module~mqc_json_output_types mqc_json_output_types proc~unfragmented_calculation->module~mqc_json_output_types module~mqc_thermochemistry mqc_thermochemistry proc~unfragmented_calculation->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis proc~unfragmented_calculation->module~mqc_vibrational_analysis module~mqc_json_output_types->module~mqc_thermochemistry pic_types pic_types module~mqc_json_output_types->pic_types module~mqc_elements mqc_elements module~mqc_thermochemistry->module~mqc_elements module~mqc_physical_constants mqc_physical_constants module~mqc_thermochemistry->module~mqc_physical_constants pic_io pic_io module~mqc_thermochemistry->pic_io pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces pic_logger pic_logger module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_constants->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Run unfragmented calculation on the entire system (nlevel=0)\nThis is a simple single-process calculation without MPI distribution\nIf result_out is present, returns result instead of writing JSON and destroying it\nIf json_data is present, populates it for centralized JSON output Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( calculation_result_t ), intent(out), optional :: result_out real(kind=dp), intent(in), optional :: temperature Temperature for thermochemistry (K) real(kind=dp), intent(in), optional :: pressure Pressure for thermochemistry (atm) type( json_output_data_t ), intent(out), optional :: json_data Calls proc~~unfragmented_calculation~~CallsGraph proc~unfragmented_calculation unfragmented_calculation cart_disp cart_disp proc~unfragmented_calculation->cart_disp configuration configuration proc~unfragmented_calculation->configuration eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues error error proc~unfragmented_calculation->error fc_mdyne fc_mdyne proc~unfragmented_calculation->fc_mdyne force_constants force_constants proc~unfragmented_calculation->force_constants frequencies frequencies proc~unfragmented_calculation->frequencies info info proc~unfragmented_calculation->info interface~do_fragment_work do_fragment_work proc~unfragmented_calculation->interface~do_fragment_work ir_intensities ir_intensities proc~unfragmented_calculation->ir_intensities proc~check_duplicate_atoms check_duplicate_atoms proc~unfragmented_calculation->proc~check_duplicate_atoms proc~compute_thermochemistry compute_thermochemistry proc~unfragmented_calculation->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~energy_total energy_t%energy_total proc~unfragmented_calculation->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~unfragmented_calculation->proc~error_get_full_trace proc~error_get_message error_t%error_get_message proc~unfragmented_calculation->proc~error_get_message proc~error_has_error error_t%error_has_error proc~unfragmented_calculation->proc~error_has_error proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_vibrational_analysis print_vibrational_analysis proc~unfragmented_calculation->proc~print_vibrational_analysis proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian reduced_masses reduced_masses proc~unfragmented_calculation->reduced_masses to_char to_char proc~unfragmented_calculation->to_char proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies->error pic_syev pic_syev proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation warning warning proc~compute_vibrational_frequencies->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~print_vibrational_analysis->warning proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->warning proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_zpe->to_char proc~compute_zpe->warning proc~do_fragment_work->configuration proc~do_fragment_work->to_char proc~do_fragment_work->proc~error_set calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~error_add_context error_t%error_add_context proc~do_fragment_work->proc~error_add_context proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~mass_weight_hessian->proc~element_mass proc~print_thermochemistry->info pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd proc~project_translation_rotation->proc~element_mass proc~result_reset->proc~energy_reset proc~error_clear error_t%error_clear proc~result_reset->proc~error_clear proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unfragmented_calculation~~CalledByGraph proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( error_t ), private :: error type( physical_fragment_t ), private :: full_system integer, private :: i type( calculation_result_t ), private :: result integer, private :: total_atoms Source Code module subroutine unfragmented_calculation ( sys_geom , method_config , calc_type , bonds , result_out , & temperature , pressure , json_data ) !! Run unfragmented calculation on the entire system (nlevel=0) !! This is a simple single-process calculation without MPI distribution !! If result_out is present, returns result instead of writing JSON and destroying it !! If json_data is present, populates it for centralized JSON output use mqc_error , only : error_t use mqc_vibrational_analysis , only : compute_vibrational_frequencies , & compute_vibrational_analysis , print_vibrational_analysis use mqc_thermochemistry , only : thermochemistry_result_t , compute_thermochemistry use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_UNFRAGMENTED type ( system_geometry_t ), intent ( in ), optional :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ), intent ( out ), optional :: result_out real ( dp ), intent ( in ), optional :: temperature !! Temperature for thermochemistry (K) real ( dp ), intent ( in ), optional :: pressure !! Pressure for thermochemistry (atm) type ( json_output_data_t ), intent ( out ), optional :: json_data type ( calculation_result_t ) :: result integer :: total_atoms type ( physical_fragment_t ) :: full_system type ( error_t ) :: error integer :: i if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for unfragmented calculation\" ) error stop \"Missing geometry in unfragmented_calculation\" end if total_atoms = sys_geom % total_atoms call logger % info ( \"============================================\" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( total_atoms )) call logger % info ( \"============================================\" ) ! Build the full system as a single fragment ! For overlapping fragments, we use the full system directly (not concatenating fragments) full_system % n_atoms = total_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( total_atoms )) allocate ( full_system % coordinates ( 3 , total_atoms )) ! Copy all atoms from system geometry full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates ! Set charge and multiplicity from system full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Validate geometry (check for spatially overlapping atoms) call check_duplicate_atoms ( full_system , error ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Overlapping atoms in unfragmented system\" end if ! Process the full system call do_fragment_work ( 0_int64 , result , method_config , phys_frag = full_system , calc_type = calc_type ) ! Check for calculation errors if ( result % has_error ) then call logger % error ( \"Unfragmented calculation failed: \" // result % error % get_message ()) if ( present ( result_out )) then result_out = result return else error stop \"Unfragmented calculation failed\" end if end if call logger % info ( \"============================================\" ) call logger % info ( \"Unfragmented calculation completed\" ) block character ( len = 2048 ) :: result_line ! Large buffer for Hessian matrix rows integer :: current_log_level , iatom , i , j real ( dp ) :: hess_norm write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_dipole ) then write ( result_line , '(a,3f15.8)' ) \"  Dipole (e*Bohr): \" , result % dipole call logger % info ( trim ( result_line )) write ( result_line , '(a,f15.8)' ) \"  Dipole magnitude (Debye): \" , norm2 ( result % dipole ) * 2.541746_dp call logger % info ( trim ( result_line )) end if if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) ! Print full gradient if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Gradient (Hartree/Bohr):\" ) do iatom = 1 , total_atoms write ( result_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & result % gradient ( 1 , iatom ), result % gradient ( 2 , iatom ), result % gradient ( 3 , iatom ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if if ( result % has_hessian ) then ! Compute Frobenius norm of Hessian hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) ! Print full Hessian if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * total_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * total_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if ! Compute and print vibrational analysis block real ( dp ), allocatable :: frequencies (:), eigenvalues (:), projected_hessian (:, :) real ( dp ), allocatable :: reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:), ir_intensities (:) integer :: ii , jj ! First get projected Hessian for verbose output call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_frequencies ( result % hessian , sys_geom % element_numbers , frequencies , eigenvalues , & coordinates = sys_geom % coordinates , project_trans_rot = . true ., & projected_hessian_out = projected_hessian ) ! Print projected mass-weighted Hessian if verbose and small system if ( current_log_level >= verbose_level . and . total_atoms < 20 ) then if ( allocated ( projected_hessian )) then call logger % info ( \" \" ) call logger % info ( \"Mass-weighted Hessian after trans/rot projection (a.u.):\" ) do ii = 1 , 3 * total_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , ii , \": \" , & ( projected_hessian ( ii , jj ), jj = 1 , 3 * total_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if ! Compute full vibrational analysis and print (with IR intensities if available) if ( result % has_dipole_derivatives ) then call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne , & dipole_derivatives = result % dipole_derivatives , & ir_intensities = ir_intensities ) else call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) end if if ( allocated ( frequencies )) then ! Compute thermochemistry for JSON output block type ( thermochemistry_result_t ) :: thermo_result integer :: n_modes , n_at n_at = size ( sys_geom % element_numbers ) n_modes = size ( frequencies ) call compute_thermochemistry ( sys_geom % coordinates , sys_geom % element_numbers , & frequencies , n_at , n_modes , thermo_result , & temperature = temperature , pressure = pressure ) ! Print vibrational analysis to log if ( allocated ( ir_intensities )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & ir_intensities = ir_intensities , & coordinates = sys_geom % coordinates , & electronic_energy = result % energy % total (), & temperature = temperature , pressure = pressure ) else call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & coordinates = sys_geom % coordinates , & electronic_energy = result % energy % total (), & temperature = temperature , pressure = pressure ) end if ! Populate json_data if present (for centralized JSON output) if ( present ( json_data )) then json_data % output_mode = OUTPUT_MODE_UNFRAGMENTED json_data % total_energy = result % energy % total () json_data % has_energy = result % has_energy json_data % has_vibrational = . true . ! Copy vibrational data allocate ( json_data % frequencies ( n_modes )) allocate ( json_data % reduced_masses ( n_modes )) allocate ( json_data % force_constants ( n_modes )) json_data % frequencies = frequencies json_data % reduced_masses = reduced_masses json_data % force_constants = fc_mdyne json_data % thermo = thermo_result if ( allocated ( ir_intensities )) then allocate ( json_data % ir_intensities ( n_modes )) json_data % ir_intensities = ir_intensities json_data % has_ir_intensities = . true . end if ! Copy dipole if available if ( result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = result % dipole json_data % has_dipole = . true . end if ! Copy gradient if available if ( result % has_gradient ) then allocate ( json_data % gradient ( 3 , total_atoms )) json_data % gradient = result % gradient json_data % has_gradient = . true . end if ! Copy hessian if available if ( result % has_hessian ) then allocate ( json_data % hessian ( 3 * total_atoms , 3 * total_atoms )) json_data % hessian = result % hessian json_data % has_hessian = . true . end if end if if ( allocated ( ir_intensities )) deallocate ( ir_intensities ) end block deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if if ( allocated ( eigenvalues )) deallocate ( eigenvalues ) if ( allocated ( projected_hessian )) deallocate ( projected_hessian ) end block end if end block call logger % info ( \"============================================\" ) ! Return result to caller or handle json_data if ( present ( result_out )) then ! Transfer result to output (for dynamics/optimization) result_out = result else ! Populate json_data for non-Hessian case if present ! (Hessian case already handled above in the vibrational block) if ( present ( json_data ) . and . . not . result % has_hessian ) then json_data % output_mode = OUTPUT_MODE_UNFRAGMENTED json_data % total_energy = result % energy % total () json_data % has_energy = result % has_energy if ( result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = result % dipole json_data % has_dipole = . true . end if if ( result % has_gradient ) then allocate ( json_data % gradient ( 3 , total_atoms )) json_data % gradient = result % gradient json_data % has_gradient = . true . end if end if call result % destroy () end if end subroutine unfragmented_calculation","tags":"","url":"proc/unfragmented_calculation.html"},{"title":"do_fragment_work – metalquicha","text":"module subroutine do_fragment_work(fragment_idx, result, method_config, phys_frag, calc_type, world_comm) Interface → Uses pic_logger proc~~do_fragment_work~~UsesGraph proc~do_fragment_work do_fragment_work pic_logger pic_logger proc~do_fragment_work->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Process a single fragment for quantum chemistry calculation Performs energy and gradient calculation on a molecular fragment using\nthe factory pattern to create a calculator from the provided method_config.\nVerbosity is controlled by the global logger level. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Fragment index for identification type( calculation_result_t ), intent(out) :: result Computation results type( method_config_t ), intent(in) :: method_config Method configuration type( physical_fragment_t ), intent(in), optional :: phys_frag Fragment geometry integer(kind=int32), intent(in) :: calc_type Calculation type type(comm_t), intent(in), optional :: world_comm MPI communicator for abort Calls proc~~do_fragment_work~~CallsGraph proc~do_fragment_work do_fragment_work calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian configuration configuration proc~do_fragment_work->configuration proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~error_add_context error_t%error_add_context proc~do_fragment_work->proc~error_add_context proc~error_set error_t%error_set proc~do_fragment_work->proc~error_set proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz to_char to_char proc~do_fragment_work->to_char proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->to_char info info proc~print_fragment_xyz->info proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb state_weights state_weights proc~configure_mcscf->state_weights proc~method_type_to_string method_type_to_string proc~configure_xtb->proc~method_type_to_string proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~configure_xtb->proc~xtb_has_solvation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~do_fragment_work~~CalledByGraph proc~do_fragment_work do_fragment_work interface~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~node_worker node_worker proc~node_worker->interface~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->interface~do_fragment_work interface~node_worker node_worker interface~node_worker->proc~node_worker interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor interface~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->interface~node_worker proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: calc_type_local Local copy of calc_type class( qc_method_t ), private, allocatable :: calculator Polymorphic calculator instance integer, private :: current_log_level Current logger verbosity level logical, private :: is_verbose Whether verbose output is enabled type( method_config_t ), private :: local_config Local copy for verbose override Source Code module subroutine do_fragment_work ( fragment_idx , result , method_config , phys_frag , calc_type , world_comm ) !! Process a single fragment for quantum chemistry calculation !! !! Performs energy and gradient calculation on a molecular fragment using !! the factory pattern to create a calculator from the provided method_config. !! Verbosity is controlled by the global logger level. use pic_logger , only : verbose_level integer ( int64 ), intent ( in ) :: fragment_idx !! Fragment index for identification type ( calculation_result_t ), intent ( out ) :: result !! Computation results type ( method_config_t ), intent ( in ) :: method_config !! Method configuration type ( physical_fragment_t ), intent ( in ), optional :: phys_frag !! Fragment geometry integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort integer :: current_log_level !! Current logger verbosity level logical :: is_verbose !! Whether verbose output is enabled integer ( int32 ) :: calc_type_local !! Local copy of calc_type type ( method_config_t ) :: local_config !! Local copy for verbose override class ( qc_method_t ), allocatable :: calculator !! Polymorphic calculator instance calc_type_local = calc_type ! Query logger to determine verbosity call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) ! Print fragment geometry if provided and verbose mode is enabled if ( present ( phys_frag )) then if ( is_verbose ) then call print_fragment_xyz ( fragment_idx , phys_frag ) end if ! Copy config and override verbose based on logger level local_config = method_config local_config % verbose = is_verbose ! Create calculator using factory calculator = create_method ( local_config ) ! Run the calculation using polymorphic dispatch select case ( calc_type_local ) case ( CALC_TYPE_ENERGY ) call calculator % calc_energy ( phys_frag , result ) case ( CALC_TYPE_GRADIENT ) call calculator % calc_gradient ( phys_frag , result ) case ( CALC_TYPE_HESSIAN ) call calculator % calc_hessian ( phys_frag , result ) case default call result % error % set ( ERROR_VALIDATION , \"Unknown calc_type: \" // calc_type_to_string ( calc_type_local )) result % has_error = . true . return end select ! Check for calculation errors if ( result % has_error ) then call result % error % add_context ( \"do_fragment_work:fragment_\" // to_char ( fragment_idx )) return end if ! Copy fragment distance to result for JSON output result % distance = phys_frag % distance ! Cleanup deallocate ( calculator ) else ! For empty fragments, set energy to zero call result % energy % reset () result % has_energy = . true . end if end subroutine do_fragment_work","tags":"","url":"proc/do_fragment_work.html"},{"title":"global_coordinator – metalquicha","text":"module subroutine global_coordinator(resources, total_fragments, polymers, max_level, node_leader_ranks, num_nodes, sys_geom, method_config, calc_type, bonds, json_data) Interface → Uses mqc_result_types mqc_json_output_types proc~~global_coordinator~~UsesGraph proc~global_coordinator global_coordinator module~mqc_json_output_types mqc_json_output_types proc~global_coordinator->module~mqc_json_output_types module~mqc_result_types mqc_result_types proc~global_coordinator->module~mqc_result_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry pic_types pic_types module~mqc_json_output_types->pic_types module~mqc_error mqc_error module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_thermochemistry->pic_types module~mqc_elements mqc_elements module~mqc_thermochemistry->module~mqc_elements module~mqc_physical_constants mqc_physical_constants module~mqc_thermochemistry->module~mqc_physical_constants pic_io pic_io module~mqc_thermochemistry->pic_io pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces pic_logger pic_logger module~mqc_thermochemistry->pic_logger module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_constants->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Global coordinator for distributing fragments to node coordinators\nwill act as a node coordinator for a single node calculation\nUses int64 for total_fragments to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data Calls proc~~global_coordinator~~CallsGraph proc~global_coordinator global_coordinator abort_comm abort_comm proc~global_coordinator->abort_comm allocate_dipole allocate_dipole proc~global_coordinator->allocate_dipole allocate_gradient allocate_gradient proc~global_coordinator->allocate_gradient allocate_hessian allocate_hessian proc~global_coordinator->allocate_hessian debug debug proc~global_coordinator->debug destroy destroy proc~global_coordinator->destroy error error proc~global_coordinator->error get_elapsed_time get_elapsed_time proc~global_coordinator->get_elapsed_time info info proc~global_coordinator->info iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~error_get_message error_t%error_get_message proc~global_coordinator->proc~error_get_message proc~result_irecv result_irecv proc~global_coordinator->proc~result_irecv proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker start start proc~global_coordinator->start to_char to_char proc~global_coordinator->to_char verbose verbose proc~global_coordinator->verbose proc~compute_mbe->abort_comm proc~compute_mbe->error proc~compute_mbe->info proc~compute_mbe->to_char cart_disp cart_disp proc~compute_mbe->cart_disp configuration configuration proc~compute_mbe->configuration fc_mdyne fc_mdyne proc~compute_mbe->fc_mdyne force_constants force_constants proc~compute_mbe->force_constants frequencies frequencies proc~compute_mbe->frequencies get_message get_message proc~compute_mbe->get_message has_error has_error proc~compute_mbe->has_error proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe->proc~compute_mbe_dipole proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_thermochemistry compute_thermochemistry proc~compute_mbe->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_mbe->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~compute_mbe->proc~energy_total proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis reduced_masses reduced_masses proc~compute_mbe->reduced_masses warning warning proc~compute_mbe->warning proc~result_irecv->irecv recv recv proc~result_irecv->recv proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~build_mbe_lookup_table->debug proc~build_mbe_lookup_table->get_elapsed_time proc~build_mbe_lookup_table->start proc~build_mbe_lookup_table->to_char proc~error_add_context error_t%error_add_context proc~build_mbe_lookup_table->proc~error_add_context proc~error_has_error error_t%error_has_error proc~build_mbe_lookup_table->proc~error_has_error proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~compute_mbe_delta->abort_comm proc~compute_mbe_delta->error proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_dipole->abort_comm proc~compute_mbe_dipole->error proc~compute_mbe_dipole->proc~fragment_lookup_find proc~compute_mbe_dipole->proc~get_next_combination proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~fragment_lookup_find proc~compute_mbe_dipole_derivatives->proc~get_next_combination proc~compute_mbe_gradient->abort_comm proc~compute_mbe_gradient->error proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~redistribute_cap_dipole_derivatives proc~map_fragment_to_system_gradient->abort_comm proc~map_fragment_to_system_gradient->debug proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_has_error proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->verbose proc~print_detailed_breakdown->warning header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~print_vibrational_analysis->warning proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~build_fragment_from_indices->proc~error_add_context proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->warning pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_zpe->to_char proc~compute_zpe->warning proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal proc~fragment_lookup_insert->fnv_1a_hash proc~error_set error_t%error_set proc~fragment_lookup_insert->proc~error_set proc~fragment_lookup_insert->sort proc~print_thermochemistry->info proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->proc~element_number_to_symbol proc~check_duplicate_atoms->proc~error_set proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~global_coordinator~~CalledByGraph proc~global_coordinator global_coordinator interface~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: calc_type_local type(timer_type), private :: coord_timer integer(kind=int64), private :: current_fragment integer, private :: dummy_msg integer, private :: finished_nodes integer(kind=int64), private :: fragment_idx logical, private :: handling_local_workers logical, private :: has_pending integer, private :: local_dummy integer, private :: local_finished_workers type(MPI_Status), private :: local_status type(request_t), private :: req integer, private :: request_source type( calculation_result_t ), private, allocatable :: results (:) integer(kind=int64), private :: results_received type(MPI_Status), private :: status integer(kind=int64), private :: worker_fragment_map (resources%mpi_comms%node_comm%size()) integer, private :: worker_source Source Code module subroutine global_coordinator ( resources , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , method_config , calc_type , bonds , json_data ) !! Global coordinator for distributing fragments to node coordinators !! will act as a node coordinator for a single node calculation !! Uses int64 for total_fragments to handle large fragment counts that overflow int32. use mqc_json_output_types , only : json_output_data_t type ( resources_t ), intent ( in ) :: resources integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level , num_nodes integer , intent ( in ) :: polymers (:, :), node_leader_ranks (:) type ( system_geometry_t ), intent ( in ), optional :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data type ( timer_type ) :: coord_timer integer ( int64 ) :: current_fragment , results_received integer :: finished_nodes integer :: request_source , dummy_msg integer ( int64 ) :: fragment_idx type ( MPI_Status ) :: status , local_status logical :: handling_local_workers logical :: has_pending integer ( int32 ) :: calc_type_local ! For local workers integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer ( int64 ) :: worker_fragment_map ( resources % mpi_comms % node_comm % size ()) integer :: worker_source ! MPI request handles for non-blocking operations type ( request_t ) :: req calc_type_local = calc_type current_fragment = total_fragments finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( resources % mpi_comms % node_comm % size () > 1 ) results_received = 0_int64 ! Allocate storage for results allocate ( results ( total_fragments )) worker_fragment_map = 0 call logger % verbose ( \"Global coordinator starting with \" // to_char ( total_fragments ) // & \" fragments for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers ! This MUST be checked before sending new work to avoid race conditions if ( handling_local_workers ) then ! Keep checking for results until there are none pending do call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Receive result and store it using the fragment index for this worker call result_irecv ( results ( worker_fragment_map ( worker_source )), resources % mpi_comms % node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Check for calculation errors from worker if ( results ( worker_fragment_map ( worker_source ))% has_error ) then call logger % error ( \"Fragment \" // to_char ( worker_fragment_map ( worker_source )) // & \" calculation failed: \" // & results ( worker_fragment_map ( worker_source ))% error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Clear the mapping since we've received the result worker_fragment_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( resources % mpi_comms % world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit ! Receive fragment index and result from node coordinator ! TODO: serialize the data for better performance call irecv ( resources % mpi_comms % world_comm , fragment_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( fragment_idx ), resources % mpi_comms % world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) ! Check for calculation errors from node coordinator if ( results ( fragment_idx )% has_error ) then call logger % error ( \"Fragment \" // to_char ( fragment_idx ) // \" calculation failed: \" // & results ( fragment_idx )% error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( resources % mpi_comms % world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( resources % mpi_comms % world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_fragment >= 1 ) then call send_fragment_to_node ( resources % mpi_comms % world_comm , current_fragment , polymers , request_source ) current_fragment = current_fragment - 1 else call isend ( resources % mpi_comms % world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < resources % mpi_comms % node_comm % size () - 1 ) then call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( resources % mpi_comms % node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_fragment >= 1 ) then call send_fragment_to_worker ( resources % mpi_comms % node_comm , current_fragment , polymers , & local_status % MPI_SOURCE ) ! Track which fragment was sent to this worker worker_fragment_map ( local_status % MPI_SOURCE ) = current_fragment current_fragment = current_fragment - 1 else call isend ( resources % mpi_comms % node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if ! If worker still has pending results, skip the work request ! It will be processed on the next iteration after results are received end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= resources % mpi_comms % node_comm % size () - 1 & . and . results_received >= total_fragments ) then handling_local_workers = . false . if ( num_nodes == 1 ) then finished_nodes = finished_nodes + 1 call logger % debug ( \"Manually incremented finished_nodes for self\" ) else finished_nodes = finished_nodes + 1 call logger % verbose ( \"Global coordinator finished local workers\" ) end if end if end do call logger % verbose ( \"Global coordinator finished all fragments\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) block use mqc_result_types , only : mbe_result_t type ( mbe_result_t ) :: mbe_result ! Compute the many-body expansion call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Allocate mbe_result components based on calc_type call mbe_result % allocate_dipole () ! Always compute dipole if ( calc_type_local == CALC_TYPE_HESSIAN ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for Hessian calculation in global_coordinator\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if call mbe_result % allocate_gradient ( sys_geom % total_atoms ) call mbe_result % allocate_hessian ( sys_geom % total_atoms ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for gradient calculation in global_coordinator\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if call mbe_result % allocate_gradient ( sys_geom % total_atoms ) end if call compute_mbe ( polymers , total_fragments , max_level , results , mbe_result , & sys_geom , bonds , resources % mpi_comms % world_comm , json_data ) call mbe_result % destroy () call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end block ! Cleanup deallocate ( results ) end subroutine global_coordinator","tags":"","url":"proc/global_coordinator.html"},{"title":"node_coordinator – metalquicha","text":"module subroutine node_coordinator(resources, method_config, calc_type) Interface → Node coordinator for distributing fragments to local workers\nHandles work requests and result collection from local workers Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources type( method_config_t ), intent(in) :: method_config Method configuration (passed through to workers) integer(kind=int32), intent(in) :: calc_type Calls proc~~node_coordinator~~CallsGraph proc~node_coordinator node_coordinator abort_comm abort_comm proc~node_coordinator->abort_comm error error proc~node_coordinator->error iprobe iprobe proc~node_coordinator->iprobe irecv irecv proc~node_coordinator->irecv isend isend proc~node_coordinator->isend proc~error_get_message error_t%error_get_message proc~node_coordinator->proc~error_get_message proc~result_irecv result_irecv proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv to_char to_char proc~node_coordinator->to_char proc~result_irecv->irecv proc~result_irecv->recv proc~result_isend->isend send send proc~result_isend->send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~node_coordinator~~CalledByGraph proc~node_coordinator node_coordinator interface~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: dummy_msg integer(kind=int32), private :: finished_workers integer(kind=int64), private :: fragment_idx integer(kind=int32), private, allocatable :: fragment_indices (:) integer(kind=int32), private :: fragment_size integer(kind=int32), private :: fragment_type type(MPI_Status), private :: global_status logical, private :: has_result integer(kind=int32), private :: local_dummy logical, private :: local_message_pending logical, private :: more_fragments type(request_t), private :: req type(MPI_Status), private :: status integer(kind=int64), private :: worker_fragment_map (resources%mpi_comms%node_comm%size()) type( calculation_result_t ), private :: worker_result integer(kind=int32), private :: worker_source Source Code module subroutine node_coordinator ( resources , method_config , calc_type ) !! Node coordinator for distributing fragments to local workers !! Handles work requests and result collection from local workers type ( resources_t ), intent ( in ) :: resources type ( method_config_t ), intent ( in ) :: method_config !! Method configuration (passed through to workers) integer ( int32 ), intent ( in ) :: calc_type integer ( int64 ) :: fragment_idx integer ( int32 ) :: fragment_size , fragment_type , dummy_msg integer ( int32 ) :: finished_workers integer ( int32 ), allocatable :: fragment_indices (:) type ( MPI_Status ) :: status , global_status logical :: local_message_pending , more_fragments , has_result integer ( int32 ) :: local_dummy ! For tracking worker-fragment mapping and collecting results integer ( int64 ) :: worker_fragment_map ( resources % mpi_comms % node_comm % size ()) integer ( int32 ) :: worker_source type ( calculation_result_t ) :: worker_result ! MPI request handles for non-blocking operations type ( request_t ) :: req finished_workers = 0 more_fragments = . true . dummy_msg = 0 worker_fragment_map = 0 do while ( finished_workers < resources % mpi_comms % node_comm % size () - 1 ) ! PRIORITY 1: Check for incoming results from local workers call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_result , status ) if ( has_result ) then worker_source = status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Node coordinator received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Receive result from worker call result_irecv ( worker_result , resources % mpi_comms % node_comm , worker_source , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Check for calculation errors before forwarding if ( worker_result % has_error ) then call logger % error ( \"Fragment \" // to_char ( worker_fragment_map ( worker_source )) // & \" calculation failed on worker \" // to_char ( worker_source ) // \": \" // & worker_result % error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Forward results to global coordinator with fragment index call isend ( resources % mpi_comms % world_comm , worker_fragment_map ( worker_source ), 0 , TAG_NODE_SCALAR_RESULT , req ) ! fragment_idx call wait ( req ) call result_isend ( worker_result , resources % mpi_comms % world_comm , 0 , TAG_NODE_SCALAR_RESULT , req ) ! result call wait ( req ) ! Clear the mapping worker_fragment_map ( worker_source ) = 0 end if ! PRIORITY 2: Check for work requests from local workers call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , local_message_pending , status ) if ( local_message_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( status % MPI_SOURCE ) == 0 ) then call irecv ( resources % mpi_comms % node_comm , local_dummy , status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( more_fragments ) then call isend ( resources % mpi_comms % world_comm , dummy_msg , 0 , TAG_NODE_REQUEST , req ) call wait ( req ) call irecv ( resources % mpi_comms % world_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , global_status ) if ( global_status % MPI_TAG == TAG_NODE_FRAGMENT ) then ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( resources % mpi_comms % world_comm , fragment_type , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) call irecv ( resources % mpi_comms % world_comm , fragment_size , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( resources % mpi_comms % world_comm , fragment_indices , 0 , TAG_NODE_FRAGMENT , global_status ) ! Forward to worker call isend ( resources % mpi_comms % node_comm , fragment_idx , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( resources % mpi_comms % node_comm , fragment_type , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( resources % mpi_comms % node_comm , fragment_size , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( resources % mpi_comms % node_comm , fragment_indices , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Track which fragment was sent to this worker worker_fragment_map ( status % MPI_SOURCE ) = fragment_idx deallocate ( fragment_indices ) else call isend ( resources % mpi_comms % node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 more_fragments = . false . end if else call isend ( resources % mpi_comms % node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end if end do end subroutine node_coordinator","tags":"","url":"proc/node_coordinator.html"},{"title":"node_worker – metalquicha","text":"module subroutine node_worker(resources, sys_geom, method_config, calc_type, bonds) Interface → Uses mqc_error proc~~node_worker~~UsesGraph proc~node_worker node_worker module~mqc_error mqc_error proc~node_worker->module~mqc_error Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Node worker for processing fragments assigned by node coordinator Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~node_worker~~CallsGraph proc~node_worker node_worker abort_comm abort_comm proc~node_worker->abort_comm error error proc~node_worker->error interface~do_fragment_work do_fragment_work proc~node_worker->interface~do_fragment_work irecv irecv proc~node_worker->irecv isend isend proc~node_worker->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_atom_list proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~error_get_full_trace error_t%error_get_full_trace proc~node_worker->proc~error_get_full_trace proc~error_has_error error_t%error_has_error proc~node_worker->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~node_worker->proc~fragment_destroy proc~result_isend result_isend proc~node_worker->proc~result_isend recv recv proc~node_worker->recv to_char to_char proc~node_worker->to_char proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_atom_list->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~build_fragment_from_indices->proc~error_has_error proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~error_add_context proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~result_isend->isend send send proc~result_isend->send proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~do_fragment_work->to_char proc~do_fragment_work->proc~error_add_context calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian configuration configuration proc~do_fragment_work->configuration proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~do_fragment_work->proc~error_set proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_fragment_xyz->proc~to_angstrom info info proc~print_fragment_xyz->info proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~node_worker~~CalledByGraph proc~node_worker node_worker interface~node_worker node_worker interface~node_worker->proc~node_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~node_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: dummy_msg type( error_t ), private :: error integer(kind=int64), private :: fragment_idx integer(kind=int32), private, allocatable :: fragment_indices (:) integer(kind=int32), private :: fragment_size integer(kind=int32), private :: fragment_type 0 = monomer (indices), 1 = intersection (atom list) type( physical_fragment_t ), private :: phys_frag type(request_t), private :: req type( calculation_result_t ), private :: result type(MPI_Status), private :: status Source Code module subroutine node_worker ( resources , sys_geom , method_config , calc_type , bonds ) !! Node worker for processing fragments assigned by node coordinator use mqc_error , only : error_t type ( resources_t ), intent ( in ) :: resources type ( system_geometry_t ), intent ( in ), optional :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int64 ) :: fragment_idx integer ( int32 ) :: fragment_size , dummy_msg integer ( int32 ) :: fragment_type !! 0 = monomer (indices), 1 = intersection (atom list) integer ( int32 ), allocatable :: fragment_indices (:) type ( calculation_result_t ) :: result type ( MPI_Status ) :: status type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error ! MPI request handles for non-blocking operations type ( request_t ) :: req dummy_msg = 0 do call isend ( resources % mpi_comms % node_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( resources % mpi_comms % node_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) select case ( status % MPI_TAG ) case ( TAG_WORKER_FRAGMENT ) ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( resources % mpi_comms % node_comm , fragment_type , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call irecv ( resources % mpi_comms % node_comm , fragment_size , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( resources % mpi_comms % node_comm , fragment_indices , 0 , TAG_WORKER_FRAGMENT , status ) ! Build physical fragment based on type if ( present ( sys_geom )) then if ( fragment_type == 0 ) then ! Monomer: fragment_indices are monomer indices call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , error , bonds ) else ! Intersection: fragment_indices are atom indices call build_fragment_from_atom_list ( sys_geom , fragment_indices , fragment_size , phys_frag , error , bonds ) end if if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Process the chemistry fragment with physical geometry call do_fragment_work ( fragment_idx , result , method_config , phys_frag , calc_type , resources % mpi_comms % world_comm ) call phys_frag % destroy () else ! Process without physical geometry (old behavior) call do_fragment_work ( fragment_idx , result , method_config , & calc_type = calc_type , world_comm = resources % mpi_comms % world_comm ) end if ! Send result back to coordinator call result_isend ( result , resources % mpi_comms % node_comm , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clean up result call result % destroy () deallocate ( fragment_indices ) case ( TAG_WORKER_FINISH ) exit case default ! Unexpected MPI tag - this should not happen in normal operation call logger % error ( \"Worker received unexpected MPI tag: \" // to_char ( status % MPI_TAG )) call logger % error ( \"Expected TAG_WORKER_FRAGMENT or TAG_WORKER_FINISH\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end select end do end subroutine node_worker","tags":"","url":"proc/node_worker.html"},{"title":"serial_fragment_processor – metalquicha","text":"module subroutine serial_fragment_processor(total_fragments, polymers, max_level, sys_geom, method_config, calc_type, bonds, json_data) Interface → Uses mqc_json_output_types mqc_result_types mqc_error proc~~serial_fragment_processor~~UsesGraph proc~serial_fragment_processor serial_fragment_processor module~mqc_error mqc_error proc~serial_fragment_processor->module~mqc_error module~mqc_json_output_types mqc_json_output_types proc~serial_fragment_processor->module~mqc_json_output_types module~mqc_result_types mqc_result_types proc~serial_fragment_processor->module~mqc_result_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry pic_types pic_types module~mqc_json_output_types->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_thermochemistry->pic_types module~mqc_elements mqc_elements module~mqc_thermochemistry->module~mqc_elements module~mqc_physical_constants mqc_physical_constants module~mqc_thermochemistry->module~mqc_physical_constants pic_io pic_io module~mqc_thermochemistry->pic_io pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces pic_logger pic_logger module~mqc_thermochemistry->pic_logger module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_constants->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Process all fragments serially in single-rank mode\nThis is used when running with only 1 MPI rank Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data Calls proc~~serial_fragment_processor~~CallsGraph proc~serial_fragment_processor serial_fragment_processor configuration configuration proc~serial_fragment_processor->configuration error error proc~serial_fragment_processor->error get_elapsed_time get_elapsed_time proc~serial_fragment_processor->get_elapsed_time info info proc~serial_fragment_processor->info interface~do_fragment_work do_fragment_work proc~serial_fragment_processor->interface~do_fragment_work omp_get_max_threads omp_get_max_threads proc~serial_fragment_processor->omp_get_max_threads omp_set_num_threads omp_set_num_threads proc~serial_fragment_processor->omp_set_num_threads proc~build_fragment_from_indices build_fragment_from_indices proc~serial_fragment_processor->proc~build_fragment_from_indices proc~calc_type_to_string calc_type_to_string proc~serial_fragment_processor->proc~calc_type_to_string proc~compute_mbe compute_mbe proc~serial_fragment_processor->proc~compute_mbe proc~energy_total energy_t%energy_total proc~serial_fragment_processor->proc~energy_total proc~error_get_full_trace error_t%error_get_full_trace proc~serial_fragment_processor->proc~error_get_full_trace proc~error_get_message error_t%error_get_message proc~serial_fragment_processor->proc~error_get_message proc~error_has_error error_t%error_has_error proc~serial_fragment_processor->proc~error_has_error proc~fragment_destroy physical_fragment_t%fragment_destroy proc~serial_fragment_processor->proc~fragment_destroy proc~mbe_result_allocate_dipole mbe_result_t%mbe_result_allocate_dipole proc~serial_fragment_processor->proc~mbe_result_allocate_dipole proc~mbe_result_allocate_gradient mbe_result_t%mbe_result_allocate_gradient proc~serial_fragment_processor->proc~mbe_result_allocate_gradient proc~mbe_result_allocate_hessian mbe_result_t%mbe_result_allocate_hessian proc~serial_fragment_processor->proc~mbe_result_allocate_hessian start start proc~serial_fragment_processor->start to_char to_char proc~serial_fragment_processor->to_char verbose verbose proc~serial_fragment_processor->verbose proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_indices->proc~error_has_error proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~calculate_monomer_distance calculate_monomer_distance proc~build_fragment_from_indices->proc~calculate_monomer_distance proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~error_add_context error_t%error_add_context proc~build_fragment_from_indices->proc~error_add_context proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~compute_mbe->configuration proc~compute_mbe->error proc~compute_mbe->info proc~compute_mbe->proc~energy_total proc~compute_mbe->to_char abort_comm abort_comm proc~compute_mbe->abort_comm cart_disp cart_disp proc~compute_mbe->cart_disp fc_mdyne fc_mdyne proc~compute_mbe->fc_mdyne force_constants force_constants proc~compute_mbe->force_constants frequencies frequencies proc~compute_mbe->frequencies get_message get_message proc~compute_mbe->get_message has_error has_error proc~compute_mbe->has_error proc~build_mbe_lookup_table build_mbe_lookup_table proc~compute_mbe->proc~build_mbe_lookup_table proc~compute_mbe_delta compute_mbe_delta proc~compute_mbe->proc~compute_mbe_delta proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe->proc~compute_mbe_dipole proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe->proc~compute_mbe_dipole_derivatives proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe->proc~compute_mbe_hessian proc~compute_thermochemistry compute_thermochemistry proc~compute_mbe->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~compute_mbe->proc~compute_vibrational_analysis proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe->proc~fragment_lookup_destroy proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~compute_mbe->proc~map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe->proc~print_detailed_breakdown proc~print_mbe_energy_breakdown print_mbe_energy_breakdown proc~compute_mbe->proc~print_mbe_energy_breakdown proc~print_mbe_gradient_info print_mbe_gradient_info proc~compute_mbe->proc~print_mbe_gradient_info proc~print_vibrational_analysis print_vibrational_analysis proc~compute_mbe->proc~print_vibrational_analysis reduced_masses reduced_masses proc~compute_mbe->reduced_masses warning warning proc~compute_mbe->warning proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~error_get_full_trace->proc~error_has_error proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_mbe_lookup_table->get_elapsed_time proc~build_mbe_lookup_table->proc~error_has_error proc~build_mbe_lookup_table->start proc~build_mbe_lookup_table->to_char proc~build_mbe_lookup_table->proc~error_add_context debug debug proc~build_mbe_lookup_table->debug proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~build_mbe_lookup_table->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~build_mbe_lookup_table->proc~fragment_lookup_insert proc~to_angstrom to_angstrom proc~calculate_monomer_distance->proc~to_angstrom proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~error_set error_t%error_set proc~check_duplicate_atoms->proc~error_set proc~compute_mbe_delta->error proc~compute_mbe_delta->abort_comm proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_delta->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_delta->proc~get_next_combination proc~compute_mbe_dipole->error proc~compute_mbe_dipole->abort_comm proc~compute_mbe_dipole->proc~fragment_lookup_find proc~compute_mbe_dipole->proc~get_next_combination proc~compute_mbe_dipole_derivatives->proc~map_fragment_to_system_dipole_derivatives proc~compute_mbe_dipole_derivatives->proc~fragment_lookup_find proc~compute_mbe_dipole_derivatives->proc~get_next_combination proc~compute_mbe_gradient->error proc~compute_mbe_gradient->abort_comm proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~do_fragment_work->configuration proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->to_char proc~do_fragment_work->proc~error_add_context calc_energy calc_energy proc~do_fragment_work->calc_energy calc_gradient calc_gradient proc~do_fragment_work->calc_gradient calc_hessian calc_hessian proc~do_fragment_work->calc_hessian proc~create_method create_method proc~do_fragment_work->proc~create_method proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~do_fragment_work->proc~error_set proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~map_fragment_to_system_dipole_derivatives->proc~build_fragment_from_indices proc~map_fragment_to_system_dipole_derivatives->proc~fragment_destroy proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->proc~redistribute_cap_dipole_derivatives proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->error proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~error_get_full_trace proc~map_fragment_to_system_gradient->proc~error_has_error proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_gradient->abort_comm proc~map_fragment_to_system_gradient->debug proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->verbose proc~print_detailed_breakdown->warning header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name proc~print_mbe_energy_breakdown->info proc~print_mbe_gradient_info->info proc~print_mbe_gradient_info->to_char proc~print_vibrational_analysis->info proc~print_vibrational_analysis->proc~compute_thermochemistry proc~print_vibrational_analysis->warning proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~element_mass element_mass proc~compute_cartesian_displacements->proc~element_mass proc~compute_ir_intensities->proc~element_mass proc~compute_moments_of_inertia->to_char proc~compute_moments_of_inertia->warning pic_syev pic_syev proc~compute_moments_of_inertia->pic_syev proc~compute_moments_of_inertia->proc~element_mass proc~compute_reduced_masses->proc~element_mass proc~compute_vibrational_frequencies->error proc~compute_vibrational_frequencies->warning proc~compute_vibrational_frequencies->pic_syev proc~mass_weight_hessian mass_weight_hessian proc~compute_vibrational_frequencies->proc~mass_weight_hessian proc~project_translation_rotation project_translation_rotation proc~compute_vibrational_frequencies->proc~project_translation_rotation proc~compute_zpe->to_char proc~compute_zpe->warning proc~factory_create method_factory_t%factory_create proc~create_method->proc~factory_create proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal proc~fragment_lookup_insert->proc~error_set proc~fragment_lookup_insert->fnv_1a_hash proc~fragment_lookup_insert->sort proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~print_fragment_xyz->proc~to_angstrom proc~print_thermochemistry->info proc~configure_dft configure_dft proc~factory_create->proc~configure_dft proc~configure_hf configure_hf proc~factory_create->proc~configure_hf proc~configure_mcscf configure_mcscf proc~factory_create->proc~configure_mcscf proc~configure_xtb configure_xtb proc~factory_create->proc~configure_xtb proc~mass_weight_hessian->proc~element_mass proc~project_translation_rotation->proc~element_mass pic_gesvd pic_gesvd proc~project_translation_rotation->pic_gesvd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~serial_fragment_processor~~CalledByGraph proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->interface~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: calc_type_local type(timer_type), private :: coord_timer integer, private :: current_log_level type( error_t ), private :: error integer(kind=int64), private :: frag_idx integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size integer, private :: iatom type( mbe_result_t ), private :: mbe_result type( physical_fragment_t ), private :: phys_frag type( calculation_result_t ), private, allocatable :: results (:) Source Code module subroutine serial_fragment_processor ( total_fragments , polymers , max_level , & sys_geom , method_config , calc_type , bonds , json_data ) !! Process all fragments serially in single-rank mode !! This is used when running with only 1 MPI rank use mqc_error , only : error_t use mqc_result_types , only : mbe_result_t use mqc_json_output_types , only : json_output_data_t integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: polymers (:, :), max_level type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data integer ( int64 ) :: frag_idx integer :: fragment_size , current_log_level , iatom integer , allocatable :: fragment_indices (:) type ( calculation_result_t ), allocatable :: results (:) type ( mbe_result_t ) :: mbe_result type ( physical_fragment_t ) :: phys_frag type ( timer_type ) :: coord_timer integer ( int32 ) :: calc_type_local type ( error_t ) :: error calc_type_local = calc_type call logger % info ( \"Processing \" // to_char ( total_fragments ) // \" fragments serially...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type_local )) allocate ( results ( total_fragments )) call omp_set_num_threads ( 1 ) call coord_timer % start () do frag_idx = 1_int64 , total_fragments fragment_size = count ( polymers ( frag_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( frag_idx , 1 : fragment_size ) call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build fragment in serial processing\" end if call do_fragment_work ( frag_idx , results ( frag_idx ), method_config , phys_frag , calc_type = calc_type_local ) ! Check for calculation errors if ( results ( frag_idx )% has_error ) then call logger % error ( \"Fragment \" // to_char ( frag_idx ) // \" calculation failed: \" // & results ( frag_idx )% error % get_message ()) error stop \"Fragment calculation failed in serial processing\" end if ! Debug output for gradients if ( calc_type_local == CALC_TYPE_GRADIENT . and . results ( frag_idx )% has_gradient ) then call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level ) then block character ( len = 512 ) :: debug_line integer :: iatom_local write ( debug_line , '(a,i0,a,*(i0,1x))' ) \"Fragment \" , frag_idx , \" monomers: \" , fragment_indices call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Energy: \" , results ( frag_idx )% energy % total () call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( results ( frag_idx )% gradient ** 2 )) call logger % verbose ( trim ( debug_line )) if ( size ( results ( frag_idx )% gradient , 2 ) <= 20 ) then call logger % verbose ( \"  Fragment gradient:\" ) do iatom_local = 1 , size ( results ( frag_idx )% gradient , 2 ) write ( debug_line , '(a,i3,a,3f20.12)' ) \"    Atom \" , iatom_local , \": \" , & results ( frag_idx )% gradient ( 1 , iatom_local ), & results ( frag_idx )% gradient ( 2 , iatom_local ), & results ( frag_idx )% gradient ( 3 , iatom_local ) call logger % verbose ( trim ( debug_line )) end do end if end block end if end if call phys_frag % destroy () deallocate ( fragment_indices ) if ( mod ( frag_idx , max ( 1_int64 , total_fragments / 10 )) == 0 . or . frag_idx == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( frag_idx ) // \"/\" // to_char ( total_fragments ) // & \" fragments [\" // to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call omp_set_num_threads ( omp_get_max_threads ()) call logger % info ( \"All fragments processed\" ) call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Allocate mbe_result components based on calc_type call mbe_result % allocate_dipole () ! Always compute dipole if ( calc_type_local == CALC_TYPE_HESSIAN ) then call mbe_result % allocate_gradient ( sys_geom % total_atoms ) call mbe_result % allocate_hessian ( sys_geom % total_atoms ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then call mbe_result % allocate_gradient ( sys_geom % total_atoms ) end if call compute_mbe ( polymers , total_fragments , max_level , results , mbe_result , sys_geom , bonds , json_data = json_data ) call mbe_result % destroy () call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) deallocate ( results ) end subroutine serial_fragment_processor","tags":"","url":"proc/serial_fragment_processor.html"},{"title":"mqc_method_config – metalquicha","text":"Provides configuration types for all quantum chemistry methods.\nUses composition pattern: method_config_t contains nested config types\nfor each method family. The factory reads from the appropriate nested type. Uses mqc_method_types pic_types module~~mqc_method_config~~UsesGraph module~mqc_method_config mqc_method_config module~mqc_method_types mqc_method_types module~mqc_method_config->module~mqc_method_types pic_types pic_types module~mqc_method_config->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_config~~UsedByGraph module~mqc_method_config mqc_method_config module~mqc_driver mqc_driver module~mqc_driver->module~mqc_method_config module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_method_factory->module~mqc_method_config module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_factory program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: cc_config_t Coupled-cluster specific settings (CCSD, CCSD(T), CC2, CC3, etc.) Components Type Visibility Attributes Name Initial real(kind=dp), public :: amplitude_convergence = 1.0e-7_dp T-amplitude convergence threshold integer, public :: diis_size = 8 DIIS subspace size character(len=8), public :: eom_type = 'ee' EOM type: “ee” (excitation), “ip” (ionization), “ea” (attachment) logical, public :: include_triples = .false. Include (T) triples correction integer, public :: max_iter = 100 Maximum CC iterations integer, public :: n_roots = 0 Number of EOM-CC roots (0 = ground state only) logical, public :: perturbative_triples = .true. Use perturbative (T) vs full CCSDT logical, public :: use_diis = .true. Use DIIS for amplitude equations type, public :: correlation_config_t Shared settings for all post-HF correlation methods Components Type Visibility Attributes Name Initial character(len=32), public :: aux_basis = '' Auxiliary basis for RI (e.g., “cc-pvdz-ri”, “cc-pvtz-ri”) real(kind=dp), public :: energy_convergence = 1.0e-8_dp Correlation energy convergence threshold logical, public :: freeze_core = .true. Whether to freeze core orbitals character(len=16), public :: local_type = 'dlpno' Local correlation type: “pno”, “dlpno”, “lmp2”, “lno” integer, public :: n_frozen_core = -1 Number of frozen core orbitals (-1 = auto from elements) real(kind=dp), public :: pno_threshold = 1.0e-7_dp PNO occupation threshold for truncation real(kind=dp), public :: scs_os = 1.2_dp Opposite-spin scaling factor (default: 6/5 for SCS-MP2) real(kind=dp), public :: scs_ss = 1.0_dp/3.0_dp Same-spin scaling factor (default: 1/3 for SCS-MP2) logical, public :: use_df = .true. Use density fitting (RI) for correlation integrals logical, public :: use_local = .false. Use local correlation approximation logical, public :: use_scs = .false. Use spin-component scaled MP2 type, public :: dft_config_t Configuration for Kohn-Sham DFT method\nNote: SCF settings (convergence, DIIS) come from scf_config_t Components Type Visibility Attributes Name Initial integer, public :: angular_points = 302 Angular grid points (Lebedev) character(len=32), public :: aux_basis_set = '' Auxiliary basis for density fitting character(len=8), public :: dispersion_type = 'd3bj' Dispersion type: “d3”, “d3bj”, “d4” character(len=32), public :: functional = 'b3lyp' XC functional: “lda”, “pbe”, “b3lyp”, “m06-2x”, etc. character(len=16), public :: grid_type = 'medium' Grid quality: “coarse”, “medium”, “fine”, “ultrafine” integer, public :: radial_points = 75 Radial grid points per atom logical, public :: use_density_fitting = .false. Use RI-J approximation logical, public :: use_dispersion = .false. Add empirical dispersion type, public :: f12_config_t Settings for explicitly correlated F12 methods (MP2-F12, CCSD-F12, etc.) Components Type Visibility Attributes Name Initial character(len=8), public :: ansatz = '3c' F12 ansatz: “3c”, “3c(fix)”, “2b”, “2a” character(len=32), public :: cabs_basis = '' Complementary auxiliary basis (CABS) for RI real(kind=dp), public :: geminal_exponent = 1.0_dp Slater-type geminal exponent (beta) character(len=32), public :: optri_basis = '' Optional RI basis for F12 intermediates logical, public :: scale_triples = .true. Apply F12 scaling to (T) correction logical, public :: use_exponent_fit = .false. Fit geminal exponent to basis set type, public :: mcscf_config_t Configuration for MCSCF/CASSCF method Components Type Visibility Attributes Name Initial real(kind=dp), public :: ci_convergence = 1.0e-8_dp CI energy threshold real(kind=dp), public :: imaginary_shift = 0.0_dp Imaginary shift for intruder states real(kind=dp), public :: ipea_shift = 0.25_dp IPEA shift for CASPT2 integer, public :: max_macro_iter = 100 Maximum orbital optimization iterations integer, public :: max_micro_iter = 50 Maximum CI iterations per macro integer, public :: n_active_electrons = 0 Number of active electrons integer, public :: n_active_orbitals = 0 Number of active orbitals integer, public :: n_inactive_orbitals = -1 Inactive orbitals (-1 = auto from nelec) integer, public :: n_states = 1 Number of states for SA-CASSCF real(kind=dp), public :: orbital_convergence = 1.0e-6_dp Orbital gradient threshold character(len=16), public :: pt2_type = 'nevpt2' PT2 flavor: “caspt2”, “nevpt2” real(kind=dp), public, allocatable :: state_weights (:) State weights (must sum to 1) logical, public :: use_pt2 = .false. Apply CASPT2/NEVPT2 after CASSCF type, public :: method_config_t Master configuration containing all method-specific configs Read more… Components Type Visibility Attributes Name Initial character(len=32), public :: basis_set = 'sto-3g' Basis set name (HF, DFT, MCSCF) type( cc_config_t ), public :: cc Coupled-cluster specific settings (CCSD, CCSD(T), etc.) type( correlation_config_t ), public :: corr Shared correlation settings (used by MP2, CC, etc.) type( dft_config_t ), public :: dft DFT-specific settings (functional, grid, dispersion) type( f12_config_t ), public :: f12 F12 explicitly correlated settings type( mcscf_config_t ), public :: mcscf MCSCF/CASSCF settings integer(kind=int32), public :: method_type = METHOD_TYPE_UNKNOWN Method type constant type( scf_config_t ), public :: scf Shared SCF settings (used by HF and DFT) logical, public :: use_spherical = .true. Spherical vs Cartesian basis functions logical, public :: verbose = .false. Enable verbose output type( xtb_config_t ), public :: xtb XTB settings (GFN1, GFN2) Type-Bound Procedures procedure, public :: reset => config_reset type, public :: scf_config_t Shared SCF settings for HF and DFT methods Components Type Visibility Attributes Name Initial real(kind=dp), public :: density_convergence = 1.0e-6_dp Density matrix convergence threshold integer, public :: diis_size = 8 Number of Fock matrices for DIIS real(kind=dp), public :: energy_convergence = 1.0e-8_dp Energy convergence threshold (Hartree) integer, public :: max_iter = 100 Maximum SCF iterations logical, public :: use_diis = .true. Use DIIS acceleration type, public :: xtb_config_t Configuration for semi-empirical xTB methods Components Type Visibility Attributes Name Initial real(kind=dp), public :: accuracy = 0.01_dp Numerical accuracy parameter integer, public :: cpcm_nang = 110 Angular grid points for CPCM real(kind=dp), public :: cpcm_rscale = 1.0_dp Radii scaling for CPCM real(kind=dp), public :: dielectric = -1.0_dp Dielectric constant (-1 = use solvent table) real(kind=dp), public :: electronic_temp = 300.0_dp Electronic temperature in Kelvin (Fermi smearing) character(len=16), public :: solvation_model = '' Solvation model: “alpb”, “gbsa”, “cpcm” character(len=32), public :: solvent = '' Solvent name: “water”, “ethanol”, etc. Empty for gas phase logical, public :: use_cds = .true. Include non-polar CDS terms logical, public :: use_shift = .true. Include solution state shift Type-Bound Procedures procedure, public :: has_solvation => xtb_has_solvation Functions private pure function xtb_has_solvation (this) Check if solvation is configured for XTB Arguments Type Intent Optional Attributes Name class( xtb_config_t ), intent(in) :: this Return Value logical Subroutines private  subroutine config_reset (this) Reset all configuration values to defaults Arguments Type Intent Optional Attributes Name class( method_config_t ), intent(inout) :: this","tags":"","url":"module/mqc_method_config.html"},{"title":"mqc_mbe – metalquicha","text":"Implements hierarchical many-body expansion for fragment-based quantum chemistry\ncalculations with MPI parallelization and energy/gradient computation.\nMBE energy with optional gradient and hessian\nGMBE energy with optional gradient and hessian Uses mqc_thermochemistry mqc_frag_utils mqc_physical_fragment pic_timer mqc_mbe_io pic_io mqc_json_output_types mqc_vibrational_analysis mqc_program_limits pic_types pic_logger mqc_mpi_tags pic_mpi_lib module~~mqc_mbe~~UsesGraph module~mqc_mbe mqc_mbe module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_json_output_types mqc_json_output_types module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe->module~mqc_physical_fragment module~mqc_program_limits mqc_program_limits module~mqc_mbe->module~mqc_program_limits module~mqc_thermochemistry mqc_thermochemistry module~mqc_mbe->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis pic_io pic_io module~mqc_mbe->pic_io pic_logger pic_logger module~mqc_mbe->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe->pic_mpi_lib pic_timer pic_timer module~mqc_mbe->pic_timer pic_types pic_types module~mqc_mbe->pic_types module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_json_output_types->pic_types module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_program_limits->pic_types module~mqc_thermochemistry->pic_io module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->module~mqc_physical_constants pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_fragment_lookup->pic_types module~mqc_fragment_lookup->module~mqc_error pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_geometry->pic_types module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_gmbe_utils->module~mqc_error module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mbe~~UsedByGraph module~mqc_mbe mqc_mbe module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function compute_mbe_delta (fragment_idx, fragment, lookup, energies, delta_energies, n, world_comm) result(delta_E) Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas)\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all subset deltaE values\nAll subsets must have been computed already (guaranteed by processing fragments in order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Index of this fragment (already known) integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup Pre-built hash table for lookups real(kind=dp), intent(in) :: energies (:) Pre-computed delta values real(kind=dp), intent(in) :: delta_energies (:) Pre-computed delta values integer, intent(in) :: n type(comm_t), intent(in), optional :: world_comm MPI communicator for abort Return Value real(kind=dp) Subroutines public  subroutine compute_gmbe (monomers, n_monomers, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, total_energy, sys_geom, total_gradient, total_hessian, bonds, world_comm) Compute generalized many-body expansion (GMBE) energy with optional gradient and/or hessian Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers type( calculation_result_t ), intent(in) :: monomer_results (:) integer, intent(in) :: n_intersections type( calculation_result_t ), intent(in), optional :: intersection_results (:) integer, intent(in), optional :: intersection_sets (:,:) integer, intent(in), optional :: intersection_levels (:) real(kind=dp), intent(out) :: total_energy type( system_geometry_t ), intent(in), optional :: sys_geom real(kind=dp), intent(out), optional :: total_gradient (:,:) real(kind=dp), intent(out), optional :: total_hessian (:,:) type( bond_t ), intent(in), optional :: bonds (:) type(comm_t), intent(in), optional :: world_comm public  subroutine compute_mbe (polymers, fragment_count, max_level, results, mbe_result, sys_geom, bonds, world_comm, json_data) Compute many-body expansion (MBE) energy with optional gradient, hessian, and dipole Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( calculation_result_t ), intent(in) :: results (:) type( mbe_result_t ), intent(inout) :: mbe_result Pre-allocated by caller type( system_geometry_t ), intent(in), optional :: sys_geom Required for gradient/hessian type( bond_t ), intent(in), optional :: bonds (:) Bond info for H-cap handling type(comm_t), intent(in), optional :: world_comm MPI communicator for abort type( json_output_data_t ), intent(out), optional :: json_data JSON output data private  subroutine build_mbe_lookup_table (polymers, fragment_count, max_level, lookup, error) Build hash table for fast fragment lookups Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( fragment_lookup_t ), intent(inout) :: lookup type( error_t ), intent(out), optional :: error private  subroutine compute_mbe_dipole (fragment_idx, fragment, lookup, results, delta_dipoles, n, world_comm) Bottom-up computation of n-body dipole correction\nExactly mirrors the energy MBE logic: deltaDipole = Dipole - sum(all subset deltaDipoles)\nDipoles are additive vectors in the system frame, no coordinate mapping needed Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_dipoles (:,:) (3, fragment_count) integer, intent(in) :: n type(comm_t), intent(in), optional :: world_comm MPI communicator for abort private  subroutine compute_mbe_dipole_derivatives (fragment_idx, fragment, lookup, results, delta_dipole_derivs, n, sys_geom, bonds) Bottom-up computation of n-body dipole derivative correction\nMirrors MBE Hessian logic but for dipole derivatives Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_dipole_derivs (:,:,:) (3, 3*total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) private  subroutine compute_mbe_gradient (fragment_idx, fragment, lookup, results, delta_gradients, n, sys_geom, bonds, world_comm) Bottom-up computation of n-body gradient correction\nExactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs)\nAll gradients are in system coordinates, so subtraction is simple Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_gradients (:,:,:) (3, total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps type(comm_t), intent(in), optional :: world_comm MPI communicator for abort private  subroutine compute_mbe_hessian (fragment_idx, fragment, lookup, results, delta_hessians, n, sys_geom, bonds) Bottom-up computation of n-body Hessian correction\nMirrors MBE gradient logic but for second derivatives Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_hessians (:,:,:) (3 total_atoms, 3 total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) private  subroutine get_monomer_atom_list (sys_geom, monomer_idx, atom_list, n_atoms) Build 0-indexed atom list for a monomer, handling fixed or variable-sized fragments. Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_idx integer, intent(out), allocatable :: atom_list (:) integer, intent(out) :: n_atoms private  subroutine map_fragment_to_system_dipole_derivatives (frag_dipole_derivs, monomers, sys_geom, sys_dipole_derivs, bonds) Map fragment dipole derivatives to system coordinates with hydrogen cap redistribution Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_dipole_derivs (:,:) (3, 3*natoms_frag) integer, intent(in) :: monomers (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_dipole_derivs (:,:) (3, 3*total_atoms) type( bond_t ), intent(in), optional :: bonds (:) private  subroutine map_fragment_to_system_gradient (frag_grad, monomers, sys_geom, sys_grad, bonds, world_comm) Map fragment gradient to system gradient coordinates with hydrogen cap redistribution Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_grad (:,:) (3, natoms_frag) integer, intent(in) :: monomers (:) Monomer indices in fragment type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_grad (:,:) (3, total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps type(comm_t), intent(in), optional :: world_comm MPI communicator for abort private  subroutine map_fragment_to_system_hessian (frag_hess, monomers, sys_geom, sys_hess, bonds) Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_hess (:,:) (3 natoms_frag, 3 natoms_frag) integer, intent(in) :: monomers (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_hess (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) private  subroutine print_gmbe_energy_breakdown (monomer_energy, n_monomers, level_energies, level_counts, max_level, total_energy, has_intersections) Print GMBE energy breakdown using inclusion-exclusion principle Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: monomer_energy integer, intent(in) :: n_monomers real(kind=dp), intent(in), optional :: level_energies (:) integer, intent(in), optional :: level_counts (:) integer, intent(in) :: max_level real(kind=dp), intent(in) :: total_energy logical, intent(in) :: has_intersections private  subroutine print_gmbe_gradient_info (total_gradient, sys_geom, current_log_level) Print GMBE gradient information Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_gradient (:,:) type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: current_log_level private  subroutine print_gmbe_intersection_debug (n_intersections, n_monomers, intersection_sets, intersection_levels, intersection_results) Print debug information about GMBE intersections Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_intersections integer, intent(in) :: n_monomers integer, intent(in) :: intersection_sets (:,:) integer, intent(in) :: intersection_levels (:) type( calculation_result_t ), intent(in) :: intersection_results (:) private  subroutine print_mbe_energy_breakdown (sum_by_level, max_level, total_energy) Print MBE energy breakdown to logger Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: sum_by_level (:) integer, intent(in) :: max_level real(kind=dp), intent(in) :: total_energy private  subroutine print_mbe_gradient_info (total_gradient, sys_geom, current_log_level) Print MBE gradient information Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_gradient (:,:) type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: current_log_level private  subroutine process_intersection_derivatives (inter_idx, k, sign_factor, intersection_results, intersection_sets, sys_geom, total_gradient, total_hessian, bonds, compute_grad, compute_hess, hess_dim, world_comm) Process derivatives for a single intersection fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: inter_idx integer, intent(in) :: k real(kind=dp), intent(in) :: sign_factor type( calculation_result_t ), intent(in) :: intersection_results (:) integer, intent(in) :: intersection_sets (:,:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: total_gradient (:,:) real(kind=dp), intent(inout), optional :: total_hessian (:,:) type( bond_t ), intent(in), optional :: bonds (:) logical, intent(in) :: compute_grad logical, intent(in) :: compute_hess integer, intent(in) :: hess_dim type(comm_t), intent(in), optional :: world_comm","tags":"","url":"module/mqc_mbe.html"},{"title":"mqc_method_xtb – metalquicha","text":"Provides GFN1-xTB and GFN2-xTB methods via the tblite library,\nimplementing the abstract method interface for energy and gradient calculations.\nXTB method implementation type Uses mqc_error tblite_xtb_gfn2 tblite_xtb_gfn1 pic_timer mqc_result_types tblite_solvation tblite_xtb_singlepoint mctc_io mqc_method_base tblite_container tblite_context_type tblite_wavefunction pic_types pic_logger tblite_xtb_calculator mqc_physical_fragment mctc_env module~~mqc_method_xtb~~UsesGraph module~mqc_method_xtb mqc_method_xtb mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_error mqc_error module~mqc_method_xtb->module~mqc_error module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_xtb->module~mqc_result_types pic_logger pic_logger module~mqc_method_xtb->pic_logger pic_timer pic_timer module~mqc_method_xtb->pic_timer pic_types pic_types module~mqc_method_xtb->pic_types tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->module~mqc_error module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_xtb~~UsedByGraph module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory mqc_method_factory module~mqc_method_factory->module~mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_factory module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( qc_method_t ) :: xtb_method_t Extended Tight-Binding (xTB) method implementation Read more… Components Type Visibility Attributes Name Initial real(kind=wp), public :: accuracy = 0.01_wp Numerical accuracy parameter integer, public :: cpcm_nang = 110 Number of angular points for CPCM cavity real(kind=wp), public :: cpcm_rscale = 1.0_wp Radii scaling for CPCM cavity real(kind=wp), public :: dielectric = -1.0_wp Direct dielectric constant (-1 = use solvent lookup) real(kind=wp), public :: kt = 300.0_wp*3.166808578545117e-06_wp Electronic temperature (300 K) character(len=:), public, allocatable :: solvation_model “alpb” (default), “gbsa”, or “cpcm” character(len=:), public, allocatable :: solvent Solvent name: “water”, “ethanol”, etc. logical, public :: use_cds = .true. Include non-polar CDS terms (not for CPCM) logical, public :: use_shift = .true. Include solution state shift (not for CPCM) character(len=:), public, allocatable :: variant XTB variant: “gfn1” or “gfn2” logical, public :: verbose = .false. Print calculation details Type-Bound Procedures procedure, public :: calc_energy => xtb_calc_energy Energy-only calculation procedure, public :: calc_gradient => xtb_calc_gradient Energy + gradient calculation procedure, public :: calc_hessian => xtb_calc_hessian Placeholder for Hessian calculation Functions private pure function get_solvent_dielectric (solvent_name) result(eps) Get dielectric constant for a named solvent Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: solvent_name Return Value real(kind=wp) Subroutines private  subroutine add_solvation_to_calc (calc, mol, solvent, solvation_model, method, use_cds, use_shift, dielectric, cpcm_nang, cpcm_rscale, error) Add implicit solvation model to XTB calculator Read more… Arguments Type Intent Optional Attributes Name type(xtb_calculator), intent(inout) :: calc type(structure_type), intent(in) :: mol character(len=*), intent(in) :: solvent Solvent name (can be empty if dielectric > 0) character(len=*), intent(in) :: solvation_model “alpb”, “gbsa”, or “cpcm” character(len=*), intent(in) :: method “gfn1” or “gfn2” logical, intent(in) :: use_cds logical, intent(in) :: use_shift real(kind=wp), intent(in) :: dielectric Direct dielectric constant (-1 = use solvent lookup) integer, intent(in) :: cpcm_nang Angular grid points for CPCM real(kind=wp), intent(in) :: cpcm_rscale Radii scaling for CPCM type(error_type), intent(out), allocatable :: error private  subroutine xtb_calc_energy (this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine xtb_calc_gradient (this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine xtb_calc_hessian (this, fragment, result) Calculate Hessian using finite differences of gradients Read more… Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result","tags":"","url":"module/mqc_method_xtb.html"},{"title":"mqc_basis_reader – metalquicha","text":"Gaussian basis set parser and molecular basis construction Provides utilities for parsing Gaussian-type orbital basis sets\nfrom text files and building molecular basis sets for quantum calculations.\nDetermine basis file line type\nParse basis for single element\nBuild complete molecular basis\nConvert angular momentum character to integer\nConvert angular momentum integer to character Uses mqc_error mqc_basis_file_reader mqc_cgto pic_types module~~mqc_basis_reader~~UsesGraph module~mqc_basis_reader mqc_basis_reader module~mqc_basis_file_reader mqc_basis_file_reader module~mqc_basis_reader->module~mqc_basis_file_reader module~mqc_cgto mqc_cgto module~mqc_basis_reader->module~mqc_cgto module~mqc_error mqc_error module~mqc_basis_reader->module~mqc_error pic_types pic_types module~mqc_basis_reader->pic_types module~mqc_basis_file_reader->module~mqc_error module~mqc_basis_file_reader->pic_types module~mqc_cgto->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: LINE_ATOM = 1 Element specification line integer, public, parameter :: LINE_FUNCTION = 3 Basis function coefficient line integer, public, parameter :: LINE_SHELL = 2 Shell definition line integer, public, parameter :: LINE_UNKNOWN = 0 Unrecognized line type Functions public pure function ang_mom_char_to_int (ang_mom_char) result(ang_mom) Convert angular momentum character to integer Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ang_mom_char Angular momentum symbol Return Value integer Corresponding integer value public pure function ang_mom_int_to_char (ang_mom) result(ang_mom_char) Convert angular momentum integer to character Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ang_mom Angular momentum quantum number Return Value character(len=1) Corresponding symbol character public pure function classify_line (line) result(line_type) Classify a line from a gamess formatted basis set file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer private pure function is_blank_or_control (line) result(res) Check if a line is blank or a control line (starts with ‘$’) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical private pure function is_function_line (line) result(res) Check if a line is a function coefficient line (starts with a number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical private pure function is_shell_header (line) result(res) Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Subroutines public  subroutine build_molecular_basis (basis_string, element_names, mol_basis, error) Build molecular basis from geometry and basis file\nOnly parses unique elements, then copies basis data to atoms Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_names (:) Element for each atom in geometry order type( molecular_basis_type ), intent(out) :: mol_basis type( error_t ), intent(out) :: error public pure subroutine parse_element_basis (basis_string, element_name, atom_basis, error) Parse basis set for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(out) :: atom_basis type( error_t ), intent(out) :: error private pure subroutine copy_atomic_basis (source, dest) Deep copy of atomic basis data from source to dest Arguments Type Intent Optional Attributes Name type( atomic_basis_type ), intent(in) :: source type( atomic_basis_type ), intent(out) :: dest private pure subroutine count_shells_for_element (basis_string, element_name, nshells, error) Count the number of shells for a specific element in a GAMESS formatted basis string, Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name integer, intent(out) :: nshells type( error_t ), intent(out) :: error private pure subroutine fill_element_basis (basis_string, element_name, atom_basis, error) Fill in the shell data for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(inout) :: atom_basis type( error_t ), intent(out) :: error private pure subroutine find_unique_strings (input_array, unique_array, nunique) Find unique strings in an array\nReturns array of unique strings and count Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_array (:) character(len=:), intent(out), allocatable :: unique_array (:) integer, intent(out) :: nunique private pure subroutine get_next_line (string, line_start, line, line_end) Extract the next line from a string starting at line_start Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: line_start character(len=*), intent(out) :: line integer, intent(out) :: line_end private pure subroutine parse_function_line (line, func_num, exponent, coeff_s, coeff_p, has_p, stat) Parse function line (e.g., “1 1.0 2.0” or “1 1.0 2.0 3.0” for L shells) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(out) :: func_num real(kind=dp), intent(out) :: exponent real(kind=dp), intent(out) :: coeff_s real(kind=dp), intent(out), optional :: coeff_p logical, intent(out) :: has_p integer, intent(out) :: stat private pure subroutine parse_shell_header (line, ang_mom, nfunc, stat) Parse shell header line (e.g., “S 2” or “L 3”) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(out) :: ang_mom integer, intent(out) :: nfunc integer, intent(out) :: stat","tags":"","url":"module/mqc_basis_reader.html"},{"title":"mqc_program_limits – metalquicha","text":"Contains compile-time limits and default values for the metalquicha program.\nThese are tunable parameter that control memory allocation and algorithm behavior. Uses pic_types module~~mqc_program_limits~~UsesGraph module~mqc_program_limits mqc_program_limits pic_types pic_types module~mqc_program_limits->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_program_limits~~UsedByGraph module~mqc_program_limits mqc_program_limits module~mqc_json_writer mqc_json_writer module~mqc_json_writer->module~mqc_program_limits module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_program_limits module~mqc_driver mqc_driver module~mqc_driver->module~mqc_json_writer module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: DEFAULT_FD_DISPLACEMENT = 0.005_dp Default step size for finite difference calculations (Bohr)\n~0.005 Bohr = ~0.0026 Angstrom, suitable for Hessian/gradient FD character(len=*), public, parameter :: JSON_REAL_FORMAT = 'ES' JSON output format for real numbers (scientific notation)\nValid values: ‘G’, ‘E’, ‘EN’, ‘ES’ (json-fortran uses machine precision) integer, public, parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 Maximum length for element symbols (e.g., “He”, “Uue”) integer, public, parameter :: MAX_LINE_LENGTH = 1024 Maximum length for input file lines integer, public, parameter :: MAX_MBE_LEVEL = 10 Maximum MBE truncation order (1-body, 2-body, …, N-body)\nHigher orders require factorial growth in fragment combinations real(kind=dp), public, parameter :: MIN_ATOM_DISTANCE = 0.01_dp Minimum allowed distance between atoms (Bohr)\nAtoms closer than this are considered overlapping (error condition)","tags":"","url":"module/mqc_program_limits.html"},{"title":"mqc_method_factory – metalquicha","text":"Provides centralized creation of quantum chemistry method instances.\nThe factory pattern encapsulates method instantiation and configuration,\nmaking it easy to add new methods without modifying calling code.\nConvenience function Uses mqc_method_hf mqc_method_config mqc_method_types mqc_method_mcscf mqc_method_dft mqc_method_base pic_types mqc_method_xtb mctc_env module~~mqc_method_factory~~UsesGraph module~mqc_method_factory mqc_method_factory mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_base mqc_method_base module~mqc_method_factory->module~mqc_method_base module~mqc_method_config mqc_method_config module~mqc_method_factory->module~mqc_method_config module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_types mqc_method_types module~mqc_method_factory->module~mqc_method_types module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb pic_types pic_types module~mqc_method_factory->pic_types module~mqc_method_base->pic_types module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_base->module~mqc_result_types module~mqc_method_config->module~mqc_method_types module~mqc_method_config->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_dft->pic_types module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_hf->pic_types module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_mcscf->pic_types module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_types->pic_types module~mqc_method_xtb->mctc_env module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->pic_types mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_error mqc_error module~mqc_method_xtb->module~mqc_error module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types pic_logger pic_logger module~mqc_method_xtb->pic_logger pic_timer pic_timer module~mqc_method_xtb->pic_timer tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_physical_fragment->pic_types module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_factory~~UsedByGraph module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_factory module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: method_factory_t Factory for creating quantum chemistry method instances Read more… Type-Bound Procedures procedure, public :: create => factory_create Functions public  function create_method (config) result(method) Convenience function to create a method without instantiating factory Read more… Arguments Type Intent Optional Attributes Name type( method_config_t ), intent(in) :: config Return Value class( qc_method_t ), allocatable private  function factory_create (this, config) result(method) Create a quantum chemistry method instance from configuration Read more… Arguments Type Intent Optional Attributes Name class( method_factory_t ), intent(in) :: this type( method_config_t ), intent(in) :: config Return Value class( qc_method_t ), allocatable Subroutines private  subroutine configure_dft (method, config) Configure a DFT method instance from config%scf (shared) and config%dft (DFT-specific) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(inout) :: method type( method_config_t ), intent(in) :: config private  subroutine configure_hf (method, config) Configure a Hartree-Fock method instance from config%scf (shared SCF settings) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(inout) :: method type( method_config_t ), intent(in) :: config private  subroutine configure_mcscf (method, config) Configure a MCSCF method instance from config%mcscf Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(inout) :: method type( method_config_t ), intent(in) :: config private  subroutine configure_xtb (method, config) Configure an XTB method instance from config%xtb Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(inout) :: method type( method_config_t ), intent(in) :: config","tags":"","url":"module/mqc_method_factory.html"},{"title":"mqc_frag_utils – metalquicha","text":"Provides combinatorial functions and algorithms for generating molecular\nfragments, managing fragment lists, and performing many-body expansion calculations. This module re-exports functionality from specialized modules:\n- mqc_combinatorics: Pure combinatorial mathematics\n- mqc_fragment_lookup: Hash-based fragment index lookup\n- mqc_gmbe_utils: GMBE intersection and PIE enumeration Uses mqc_gmbe_utils mqc_fragment_lookup mqc_combinatorics pic_io pic_types pic_logger mqc_physical_fragment module~~mqc_frag_utils~~UsesGraph module~mqc_frag_utils mqc_frag_utils module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_physical_fragment mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment pic_io pic_io module~mqc_frag_utils->pic_io pic_logger pic_logger module~mqc_frag_utils->pic_logger pic_types pic_types module~mqc_frag_utils->pic_types module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types module~mqc_error mqc_error module~mqc_fragment_lookup->module~mqc_error pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_frag_utils~~UsedByGraph module~mqc_frag_utils mqc_frag_utils module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function fragment_should_be_screened (fragment, n, sys_geom, driver_config) result(should_screen) Check if a fragment should be screened out based on distance cutoffs.\nReturns true if the fragment itself OR any of its k-subsets (k >= 2) exceeds\nthe corresponding k-mer cutoff. This ensures MBE subset consistency. Arguments Type Intent Optional Attributes Name integer, intent(in) :: fragment (:) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( driver_config_t ), intent(in) :: driver_config Return Value logical Subroutines public  subroutine apply_distance_screening (polymers, total_fragments, sys_geom, driver_config, max_level) Apply distance-based screening to filter out fragments that exceed cutoff distances\nModifies polymers array in-place and updates total_fragments count Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: total_fragments type( system_geometry_t ), intent(in) :: sys_geom type( driver_config_t ), intent(in) :: driver_config integer, intent(in) :: max_level public  subroutine sort_fragments_by_size (polymers, total_fragments, max_level) Sort fragments by size (largest first) for better load balancing\nUses in-place sorting to reorder the polymers array\nLarger fragments (e.g., tetramers) are computed before smaller ones (e.g., dimers) Arguments Type Intent Optional Attributes Name integer, intent(inout) :: polymers (:,:) integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: max_level","tags":"","url":"module/mqc_frag_utils.html"},{"title":"mqc_config_adapter – metalquicha","text":"Provides conversion utilities from mqc_config_t to driver-compatible structures\nMinimal config for driver\nConvert log level string to integer\nCheck for overlapping fragments (for testing) Runtime configuration for driver (internal use only) Uses mqc_error mqc_elements mqc_config_parser mqc_calculation_keywords pic_types pic_logger mqc_physical_fragment module~~mqc_config_adapter~~UsesGraph module~mqc_config_adapter mqc_config_adapter module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment pic_logger pic_logger module~mqc_config_adapter->pic_logger pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_calculation_keywords->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_config_adapter~~UsedByGraph module~mqc_config_adapter mqc_config_adapter module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_config_adapter proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: driver_config_t Components Type Visibility Attributes Name Initial type( aimd_keywords_t ), public :: aimd AIMD calculation keywords logical, public :: allow_overlapping_fragments = .false. Enable GMBE for overlapping fragments integer(kind=int32), public :: calc_type Calculation type constant integer, public :: cpcm_nang = 110 Number of angular grid points for CPCM real(kind=dp), public :: cpcm_rscale = 1.0_dp Radii scaling factor for CPCM real(kind=dp), public :: dielectric = -1.0_dp Direct dielectric constant (-1 = use solvent lookup) real(kind=dp), public, allocatable :: fragment_cutoffs (:) Distance cutoffs for n-mer screening (Angstrom) type( hessian_keywords_t ), public :: hessian Hessian calculation keywords integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method QC method constant integer, public :: nlevel = 0 Fragmentation level (0 = unfragmented) type( scf_keywords_t ), public :: scf SCF calculation keywords logical, public :: skip_json_output = .false. Skip JSON output for large calculations character(len=:), public, allocatable :: solvation_model “alpb” (default), “gbsa”, or “cpcm” character(len=:), public, allocatable :: solvent Solvent name or empty for gas phase logical, public :: use_cds = .true. Include CDS non-polar terms (not for CPCM) logical, public :: use_shift = .true. Include solution state shift (not for CPCM) Functions public  function get_logger_level (level_string) result(level_int) Convert string log level to integer value\nThis function uses the pic_logger constants Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: level_string Return Value integer Subroutines public  subroutine check_fragment_overlap (fragments, nfrag, error) Check if any atoms appear in multiple fragments\nThis is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes Arguments Type Intent Optional Attributes Name type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: nfrag type( error_t ), intent(out) :: error public  subroutine config_to_driver (mqc_config, driver_config, molecule_index) Convert mqc_config_t to minimal driver_config_t\nExtracts only the fields needed by the driver\nIf molecule_index is provided, uses that molecule’s fragment count Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( driver_config_t ), intent(out) :: driver_config integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) public  subroutine config_to_system_geometry (mqc_config, sys_geom, error, molecule_index) Convert mqc_config_t geometry to system_geometry_t\nFor unfragmented calculations (nfrag=0), treats entire system as single unit\nFor fragmented calculations, currently assumes monomer-based fragmentation\nIf molecule_index is provided, uses that specific molecule from multi-molecule mode Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) private  subroutine geometry_to_system_fragmented (mqc_config, sys_geom, use_angstrom, error) Convert geometry to system_geometry_t for fragmented calculation\nSupports both identical and variable-sized fragments Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom type( error_t ), intent(out) :: error private  subroutine geometry_to_system_unfragmented (geom, sys_geom, use_angstrom) Convert geometry to system_geometry_t for unfragmented calculation\nTreats entire system as a single monomer Arguments Type Intent Optional Attributes Name type( geometry_type ), intent(in) :: geom type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom private  subroutine initialize_fragmented_system (nfrag, geom, fragments, charge, multiplicity, allow_overlapping, use_angstrom, sys_geom, error) Shared helper to initialize system_geometry_t for fragmented calculations\nHandles fragment allocation, size checking, and overlap validation Arguments Type Intent Optional Attributes Name integer, intent(in) :: nfrag type( geometry_type ), intent(in) :: geom type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: charge integer, intent(in) :: multiplicity logical, intent(in) :: allow_overlapping logical, intent(in) :: use_angstrom type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error private  subroutine molecule_to_system_geometry (mol, sys_geom, use_angstrom, allow_overlapping, error) Convert a molecule_t to system_geometry_t\nHandles both unfragmented (nfrag=0) and fragmented molecules Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: mol type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom logical, intent(in) :: allow_overlapping type( error_t ), intent(out) :: error","tags":"","url":"module/mqc_config_adapter.html"},{"title":"mqc_json_output_types – metalquicha","text":"Uses mqc_thermochemistry pic_types module~~mqc_json_output_types~~UsesGraph module~mqc_json_output_types mqc_json_output_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry pic_types pic_types module~mqc_json_output_types->pic_types module~mqc_thermochemistry->pic_types module~mqc_elements mqc_elements module~mqc_thermochemistry->module~mqc_elements module~mqc_physical_constants mqc_physical_constants module~mqc_thermochemistry->module~mqc_physical_constants pic_io pic_io module~mqc_thermochemistry->pic_io pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces pic_logger pic_logger module~mqc_thermochemistry->pic_logger module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_constants->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_json_output_types~~UsedByGraph module~mqc_json_output_types mqc_json_output_types module~mqc_driver mqc_driver module~mqc_driver->module~mqc_json_output_types module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer->module~mqc_json_output_types module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_json_output_types proc~global_coordinator global_coordinator proc~global_coordinator->module~mqc_json_output_types proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_json_output_types proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~populate_unfragmented_json_data->module~mqc_json_output_types proc~populate_vibrational_json_data populate_vibrational_json_data proc~populate_vibrational_json_data->module~mqc_json_output_types proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->module~mqc_json_output_types proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->module~mqc_json_output_types module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: OUTPUT_MODE_GMBE_PIE = 3 integer, public, parameter :: OUTPUT_MODE_MBE = 2 integer, public, parameter :: OUTPUT_MODE_NONE = 0 integer, public, parameter :: OUTPUT_MODE_UNFRAGMENTED = 1 Derived Types type, public :: json_output_data_t Unified container for all JSON output data Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: delta_energies (:) MBE delta corrections real(kind=dp), public, allocatable :: dipole (:) (3) real(kind=dp), public, allocatable :: force_constants (:) mdyne/Angstrom integer(kind=int64), public :: fragment_count = 0 real(kind=dp), public, allocatable :: fragment_distances (:) Per-fragment min distances (Angstrom) real(kind=dp), public, allocatable :: fragment_energies (:) Per-fragment total energies real(kind=dp), public, allocatable :: frequencies (:) cm&#94;-1 real(kind=dp), public, allocatable :: gradient (:,:) (3, natoms) logical, public :: has_dipole = .false. logical, public :: has_energy = .false. logical, public :: has_gradient = .false. logical, public :: has_hessian = .false. logical, public :: has_ir_intensities = .false. logical, public :: has_vibrational = .false. real(kind=dp), public, allocatable :: hessian (:,:) (3 natoms, 3 natoms) real(kind=dp), public, allocatable :: ir_intensities (:) km/mol integer, public :: max_level = 0 integer(kind=int64), public :: n_pie_terms = 0 integer, public :: output_mode = OUTPUT_MODE_NONE OUTPUT_MODE_* constant integer, public, allocatable :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_terms) integer, public, allocatable :: pie_coefficients (:) PIE coefficients real(kind=dp), public, allocatable :: pie_energies (:) Per-term energies integer, public, allocatable :: polymers (:,:) Fragment composition (n_fragments, max_level) real(kind=dp), public, allocatable :: reduced_masses (:) amu real(kind=dp), public, allocatable :: sum_by_level (:) Energy sum per level type( thermochemistry_result_t ), public :: thermo real(kind=dp), public :: total_energy = 0.0_dp Type-Bound Procedures procedure, public :: destroy => json_output_data_destroy procedure, public :: reset => json_output_data_reset Subroutines private  subroutine json_output_data_destroy (this) Clean up all allocated memory Arguments Type Intent Optional Attributes Name class( json_output_data_t ), intent(inout) :: this private  subroutine json_output_data_reset (this) Reset all flags and scalar values to defaults Arguments Type Intent Optional Attributes Name class( json_output_data_t ), intent(inout) :: this","tags":"","url":"module/mqc_json_output_types.html"},{"title":"mqc_fragment_lookup – metalquicha","text":"Provides O(1) hash table for mapping monomer combinations to fragment indices\nHash-based lookup table type Uses pic_hash_32bit mqc_error pic_sorting pic_types module~~mqc_fragment_lookup~~UsesGraph module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_error mqc_error module~mqc_fragment_lookup->module~mqc_error pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting pic_types pic_types module~mqc_fragment_lookup->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_fragment_lookup~~UsedByGraph module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils mqc_frag_utils module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: fragment_lookup_t Hash-based lookup table for O(1) fragment index retrieval Components Type Visibility Attributes Name Initial logical, public :: initialized = .false. integer(kind=int64), public :: n_entries = 0 type( hash_entry_t ), public, allocatable :: table (:) integer, public :: table_size = 0 Type-Bound Procedures procedure, public :: destroy => fragment_lookup_destroy procedure, public :: find => fragment_lookup_find procedure, public :: init => fragment_lookup_init procedure, public :: insert => fragment_lookup_insert type, private :: hash_entry_t Single entry in hash table (private helper type) Components Type Visibility Attributes Name Initial integer, public, allocatable :: key (:) Sorted monomer indices type( hash_entry_t ), public, pointer :: next => null() Chain for collisions integer(kind=int64), public :: value Fragment index Functions private pure function arrays_equal_internal (a, b, n) result(equal) Check if two arrays are equal Arguments Type Intent Optional Attributes Name integer, intent(in) :: a (:) integer, intent(in) :: b (:) integer, intent(in) :: n Return Value logical private  function fragment_lookup_find (this, monomers, n) result(idx) Find fragment index for given monomer combination Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) private pure function next_prime_internal (n) result(p) Find next prime number >= n (simple implementation) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer Subroutines private pure subroutine fragment_lookup_destroy (this) Clean up hash table and all chains Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this private pure subroutine fragment_lookup_init (this, estimated_entries) Initialize hash table with estimated size Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries private  subroutine fragment_lookup_insert (this, monomers, n, fragment_idx, error) Insert a monomer combination -> fragment index mapping Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx type( error_t ), intent(out), optional :: error","tags":"","url":"module/mqc_fragment_lookup.html"},{"title":"mqc_mbe_io – metalquicha","text":"Non-JSON I/O utilities for MBE calculations\nJSON output has been centralized in mqc_json_writer module Uses mqc_elements pic_io pic_types pic_logger mqc_physical_fragment module~~mqc_mbe_io~~UsesGraph module~mqc_mbe_io mqc_mbe_io module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_io->module~mqc_physical_fragment pic_io pic_io module~mqc_mbe_io->pic_io pic_logger pic_logger module~mqc_mbe_io->pic_logger pic_types pic_types module~mqc_mbe_io->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mbe_io~~UsedByGraph module~mqc_mbe_io mqc_mbe_io module~mqc_json_writer mqc_json_writer module~mqc_json_writer->module~mqc_mbe_io module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_json_writer module~mqc_driver->module~mqc_mbe module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function get_frag_level_name (frag_level) result(level_name) Map body level (n-mer) to descriptive name\nSupports up to decamers (10-mers), then falls back to “N-mers” format Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag_level Return Value character(len=32) Subroutines public  subroutine print_detailed_breakdown (polymers, fragment_count, max_level, energies, delta_energies) Print detailed energy breakdown for each fragment\nShows full energy and deltaE correction for all monomers, dimers, trimers, etc.\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) public  subroutine print_fragment_xyz (fragment_idx, phys_frag) Print fragment geometry in XYZ format Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx type( physical_fragment_t ), intent(in) :: phys_frag","tags":"","url":"module/mqc_mbe_io.html"},{"title":"mqc_libcint_interface – metalquicha","text":"Provides Fortran interface to the Libcint library for integral calculations","tags":"","url":"module/mqc_libcint_interface.html"},{"title":"mqc_method_hf – metalquicha","text":"Implements the Hartree-Fock quantum chemistry method\nProvides energy and gradient calculations using a basic SCF procedure. Uses mqc_method_base mqc_result_types mqc_physical_fragment pic_types module~~mqc_method_hf~~UsesGraph module~mqc_method_hf mqc_method_hf module~mqc_method_base mqc_method_base module~mqc_method_hf->module~mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_hf->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_hf->module~mqc_result_types pic_types pic_types module~mqc_method_hf->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_hf~~UsedByGraph module~mqc_method_hf mqc_method_hf module~mqc_method_factory mqc_method_factory module~mqc_method_factory->module~mqc_method_hf module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_factory module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( qc_method_t ) :: hf_method_t Hartree-Fock method implementation Components Type Visibility Attributes Name Initial type( hf_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => hf_calc_energy procedure, public :: calc_gradient => hf_calc_gradient procedure, public :: calc_hessian => null_hessian Placeholder for Hessian calculation type, public :: hf_options_t Hartree-Fock calculation options Components Type Visibility Attributes Name Initial character(len=32), public :: basis_set = 'sto-3g' Basis set name real(kind=dp), public :: conv_tol = 1.0e-8_dp Energy convergence threshold real(kind=dp), public :: density_tol = 1.0e-6_dp Density matrix convergence threshold integer, public :: diis_size = 8 Number of Fock matrices for DIIS integer, public :: max_iter = 100 Maximum SCF iterations logical, public :: spherical = .true. Use spherical (true) or Cartesian (false) basis logical, public :: use_diis = .true. Use DIIS acceleration logical, public :: verbose = .false. Print SCF iterations Subroutines private  subroutine hf_calc_energy (this, fragment, result) Calculate electronic energy using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine hf_calc_gradient (this, fragment, result) Calculate energy gradient using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine null_hessian (this, fragment, result) Placeholder for Hessian calculation Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result","tags":"","url":"module/mqc_method_hf.html"},{"title":"mqc_json_writer – metalquicha","text":"Single entry point for all JSON output Uses mqc_io_helpers mqc_json_output_types mqc_program_limits mqc_physical_constants json_module pic_types pic_logger mqc_mbe_io module~~mqc_json_writer~~UsesGraph module~mqc_json_writer mqc_json_writer json_module json_module module~mqc_json_writer->json_module module~mqc_io_helpers mqc_io_helpers module~mqc_json_writer->module~mqc_io_helpers module~mqc_json_output_types mqc_json_output_types module~mqc_json_writer->module~mqc_json_output_types module~mqc_mbe_io mqc_mbe_io module~mqc_json_writer->module~mqc_mbe_io module~mqc_physical_constants mqc_physical_constants module~mqc_json_writer->module~mqc_physical_constants module~mqc_program_limits mqc_program_limits module~mqc_json_writer->module~mqc_program_limits pic_logger pic_logger module~mqc_json_writer->pic_logger pic_types pic_types module~mqc_json_writer->pic_types module~mqc_json_output_types->pic_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_io->module~mqc_physical_fragment pic_io pic_io module~mqc_mbe_io->pic_io module~mqc_physical_constants->pic_types module~mqc_program_limits->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_physical_fragment->pic_types module~mqc_physical_fragment->module~mqc_elements module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_thermochemistry->module~mqc_physical_constants module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->pic_io pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_json_writer~~UsedByGraph module~mqc_json_writer mqc_json_writer module~mqc_driver mqc_driver module~mqc_driver->module~mqc_json_writer proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine write_json_output (output_data) THE single entry point for all JSON output Read more… Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(in) :: output_data private  subroutine write_gmbe_pie_json_impl (data) Write GMBE PIE calculation results to output JSON file Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(in) :: data private  subroutine write_mbe_breakdown_json_impl (data) Write detailed MBE energy breakdown to JSON file Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(in) :: data private  subroutine write_unfragmented_json_impl (data) Write unfragmented calculation results to output JSON file Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(in) :: data private  subroutine write_vibrational_json_impl (data) Write vibrational analysis and thermochemistry results to JSON file Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(in) :: data","tags":"","url":"module/mqc_json_writer.html"},{"title":"mqc_calculation_interface – metalquicha","text":"Provides a clean interface for computing energies and forces\nthat can be used by optimization algorithms, MD integrators, and MC samplers Uses pic_logger mqc_resources mqc_result_types mqc_config_parser pic_types pic_mpi_lib mqc_physical_fragment mqc_calc_types module~~mqc_calculation_interface~~UsesGraph module~mqc_calculation_interface mqc_calculation_interface module~mqc_calc_types mqc_calc_types module~mqc_calculation_interface->module~mqc_calc_types module~mqc_config_parser mqc_config_parser module~mqc_calculation_interface->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_resources mqc_resources module~mqc_calculation_interface->module~mqc_resources module~mqc_result_types mqc_result_types module~mqc_calculation_interface->module~mqc_result_types pic_logger pic_logger module~mqc_calculation_interface->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_calculation_interface->pic_mpi_lib pic_types pic_types module~mqc_calculation_interface->pic_types module~mqc_calc_types->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->pic_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_mpi_comms->pic_mpi_lib module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine compute_energy_and_forces (sys_geom, driver_config, resources, energy, gradient, hessian, bonds) Compute energy and forces for current geometry\nThis is the main interface for optimization/dynamics codes Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(inout) :: sys_geom type( driver_config_t ), intent(in) :: driver_config type( resources_t ), intent(in) :: resources real(kind=dp), intent(out) :: energy real(kind=dp), intent(out), optional :: gradient (:,:) (3, total_atoms) real(kind=dp), intent(out), optional :: hessian (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) public  subroutine sync_geometry_to_workers (sys_geom, comm) Synchronize geometry coordinates from master rank to all worker ranks\nThis is needed when master rank updates coordinates for optimization/dynamics Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(inout) :: sys_geom type(comm_t), intent(in) :: comm","tags":"","url":"module/mqc_calculation_interface.html"},{"title":"mqc_driver – metalquicha","text":"Handles both fragmented (many-body expansion) and unfragmented calculations\nwith MPI parallelization and node-based work distribution.\nMain entry point for all calculations\nMulti-molecule calculation dispatcher Uses mqc_io_helpers mqc_json_writer pic_io omp_lib mqc_physical_fragment mqc_mbe_fragment_distribution_scheme mqc_resources mqc_error mqc_json_output_types pic_types pic_mpi_lib mqc_config_adapter mqc_frag_utils mqc_method_config mqc_method_types mqc_result_types mqc_mbe mqc_gmbe_fragment_distribution_scheme mqc_calc_types mqc_json mqc_config_parser pic_logger module~~mqc_driver~~UsesGraph module~mqc_driver mqc_driver module~mqc_calc_types mqc_calc_types module~mqc_driver->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_driver->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_driver->module~mqc_config_parser module~mqc_error mqc_error module~mqc_driver->module~mqc_error module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_io_helpers mqc_io_helpers module~mqc_driver->module~mqc_io_helpers module~mqc_json mqc_json module~mqc_driver->module~mqc_json module~mqc_json_output_types mqc_json_output_types module~mqc_driver->module~mqc_json_output_types module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_method_config mqc_method_config module~mqc_driver->module~mqc_method_config module~mqc_method_types mqc_method_types module~mqc_driver->module~mqc_method_types module~mqc_physical_fragment mqc_physical_fragment module~mqc_driver->module~mqc_physical_fragment module~mqc_resources mqc_resources module~mqc_driver->module~mqc_resources module~mqc_result_types mqc_result_types module~mqc_driver->module~mqc_result_types omp_lib omp_lib module~mqc_driver->omp_lib pic_io pic_io module~mqc_driver->pic_io pic_logger pic_logger module~mqc_driver->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_driver->pic_mpi_lib pic_types pic_types module~mqc_driver->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_error module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->pic_io module~mqc_gmbe_fragment_distribution_scheme->pic_logger module~mqc_gmbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_gmbe_fragment_distribution_scheme->pic_types module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_thermochemistry mqc_thermochemistry module~mqc_gmbe_fragment_distribution_scheme->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis pic_timer pic_timer module~mqc_gmbe_fragment_distribution_scheme->pic_timer module~mqc_json->pic_io module~mqc_json->pic_logger module~mqc_json_output_types->pic_types module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_json_writer->module~mqc_io_helpers module~mqc_json_writer->module~mqc_json_output_types module~mqc_json_writer->pic_logger module~mqc_json_writer->pic_types json_module json_module module~mqc_json_writer->json_module module~mqc_mbe_io mqc_mbe_io module~mqc_json_writer->module~mqc_mbe_io module~mqc_physical_constants mqc_physical_constants module~mqc_json_writer->module~mqc_physical_constants module~mqc_program_limits mqc_program_limits module~mqc_json_writer->module~mqc_program_limits module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_program_limits module~mqc_mbe->module~mqc_thermochemistry module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe->pic_timer module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_resources module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme->omp_lib module~mqc_mbe_fragment_distribution_scheme->pic_io module~mqc_mbe_fragment_distribution_scheme->pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_timer module~mqc_method_config->module~mqc_method_types module~mqc_method_config->pic_types module~mqc_method_types->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms module~mqc_result_types->module~mqc_error module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_fragment_lookup->module~mqc_error module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_geometry->pic_types module~mqc_gmbe_utils->module~mqc_error module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_method_factory->module~mqc_method_config module~mqc_method_factory->module~mqc_method_types module~mqc_method_factory->pic_types module~mqc_method_factory->module~mqc_method_base mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_mpi_comms->pic_mpi_lib module~mqc_mpi_tags->pic_types module~mqc_physical_constants->pic_types module~mqc_program_limits->pic_types module~mqc_thermochemistry->pic_io module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->module~mqc_physical_constants pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->pic_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->pic_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb->module~mqc_error module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_logger module~mqc_method_xtb->pic_types module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->pic_timer module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_driver~~UsedByGraph module~mqc_driver mqc_driver proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine run_calculation (resources, config, sys_geom, bonds, result_out, all_ranks_write_json) Main calculation dispatcher - routes to fragmented or unfragmented calculation Read more… Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources Resources container (MPI comms, etc.) type( driver_config_t ), intent(in) :: config Driver configuration type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( calculation_result_t ), intent(out), optional :: result_out Optional result output logical, intent(in), optional :: all_ranks_write_json If true, all ranks write JSON (for multi-molecule) public  subroutine run_multi_molecule_calculations (resources, mqc_config) Run calculations for multiple molecules with MPI parallelization\nEach molecule is independent, so assign one molecule per rank Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources type( mqc_config_t ), intent(in) :: mqc_config private  subroutine run_fragmented_calculation (resources, method_config, calc_type, sys_geom, max_level, allow_overlapping_fragments, max_intersection_level, bonds, driver_config, json_data) Handle fragmented calculation (nlevel > 0) Read more… Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources Resources container (MPI comms, etc.) type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type Calculation type type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info integer, intent(in) :: max_level Maximum fragment level for MBE logical, intent(in) :: allow_overlapping_fragments Use GMBE for overlapping fragments integer, intent(in) :: max_intersection_level Maximum k-way intersection depth for GMBE type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( driver_config_t ), intent(in) :: driver_config Driver configuration with cutoffs type( json_output_data_t ), intent(out), optional :: json_data JSON output data private  subroutine run_unfragmented_calculation (world_comm, sys_geom, method_config, calc_type, bonds, driver_config, result_out, json_data) Handle unfragmented calculation (nlevel=0) Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type( system_geometry_t ), intent(in) :: sys_geom Complete system geometry type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type Calculation type type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information type( driver_config_t ), intent(in), optional :: driver_config Driver configuration type( calculation_result_t ), intent(out), optional :: result_out Optional result output type( json_output_data_t ), intent(out), optional :: json_data JSON output data","tags":"","url":"module/mqc_driver.html"},{"title":"mqc_basis_utils – metalquicha","text":"Provides utilities for normalizing basis set names and locating basis set files Normalization rules:\n  * -> s   (e.g., 6-31G* -> 6-31Gs)\n  + -> p   (e.g., 6-31+G -> 6-31pG)\n  (d,p) -> dp (remove parentheses and commas) Uses mqc_error module~~mqc_basis_utils~~UsesGraph module~mqc_basis_utils mqc_basis_utils module~mqc_error mqc_error module~mqc_basis_utils->module~mqc_error Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_basis_utils~~UsedByGraph module~mqc_basis_utils mqc_basis_utils module~mqc_cli_parser mqc_cli_parser module~mqc_cli_parser->module~mqc_basis_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public pure function normalize_basis_name (basis_name) result(normalized) Normalize basis set name to filename-safe format Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name Return Value character(len=:), allocatable Subroutines public  subroutine find_basis_file (basis_name, filename, error) Find basis set file using normalized name Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name character(len=:), intent(out), allocatable :: filename type( error_t ), intent(out) :: error","tags":"","url":"module/mqc_basis_utils.html"},{"title":"mqc_geometry – metalquicha","text":"Defines the geometry data structure for molecular systems Uses pic_types module~~mqc_geometry~~UsesGraph module~mqc_geometry mqc_geometry pic_types pic_types module~mqc_geometry->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_geometry~~UsedByGraph module~mqc_geometry mqc_geometry module~mqc_config_parser mqc_config_parser module~mqc_config_parser->module~mqc_geometry module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_fragment->module~mqc_config_parser module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_xyz_reader->module~mqc_geometry proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~geometry_to_system_unfragmented->module~mqc_geometry proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_geometry proc~initialize_fragmented_system->module~mqc_config_parser module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_config_parser module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_dft mqc_method_dft module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_physical_fragment proc~apply_distance_screening->module~mqc_config_adapter proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_config_parser proc~compute_gmbe->module~mqc_physical_fragment proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_config_parser proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->module~mqc_config_parser proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_physical_fragment proc~fragment_should_be_screened->module~mqc_config_adapter proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->module~mqc_config_parser proc~map_fragment_to_system_dipole_derivatives->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_config_parser proc~process_intersection_derivatives->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_config_parser program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer->module~mqc_mbe_io module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_dft module~mqc_method_factory->module~mqc_method_hf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_factory->module~mqc_method_xtb module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_base proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_base proc~hessian_worker->module~mqc_method_factory proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 Derived Types type, public :: geometry_type Molecular geometry data structure Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: comment real(kind=dp), public, allocatable :: coords (:,:) character(len=:), public, allocatable :: elements (:) integer, public :: natoms Type-Bound Procedures procedure, public :: destroy => geometry_destroy Subroutines private  subroutine geometry_destroy (this) Clean up allocated memory in geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this","tags":"","url":"module/mqc_geometry.html"},{"title":"mqc_basis_file_reader – metalquicha","text":"Module for reading and parsing GAMESS formatted basis set files Uses mqc_error pic_types module~~mqc_basis_file_reader~~UsesGraph module~mqc_basis_file_reader mqc_basis_file_reader module~mqc_error mqc_error module~mqc_basis_file_reader->module~mqc_error pic_types pic_types module~mqc_basis_file_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_basis_file_reader~~UsedByGraph module~mqc_basis_file_reader mqc_basis_file_reader module~mqc_basis_reader mqc_basis_reader module~mqc_basis_reader->module~mqc_basis_file_reader Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: basis_file_t Container for basis set file contents Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: data_section character(len=:), public, allocatable :: full_content Functions public pure function strings_equal (str1, str2) result(equal) Compare two strings after trimming and adjusting (removing leading/trailing whitespace)\nCompare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical private pure function is_letter (c) result(is_alpha) Check if character is a letter (A-Z or a-z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical private pure function is_uppercase_letter (c) result(is_upper) Check if character is an uppercase letter (A-Z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical private pure function uppercase (str) result(upper) Convert a string to uppercase, should use pic_ascii! Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:), allocatable Subroutines public  subroutine extract_element (basis_file, element, element_content, error) Extract the basis set data for a specific element from the basis file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(in) :: basis_file character(len=*), intent(in) :: element character(len=:), intent(out), allocatable :: element_content type( error_t ), intent(out) :: error public  subroutine open_basis_file (basis_file, filename, error) Open and read a GAMESS formatted basis set file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(out) :: basis_file character(len=*), intent(in) :: filename type( error_t ), intent(out) :: error","tags":"","url":"module/mqc_basis_file_reader.html"},{"title":"mqc_mbe_fragment_distribution_scheme – metalquicha","text":"Implements hierarchical many-body expansion for fragment-based quantum chemistry\ncalculations with MPI parallelization and energy/gradient computation. Uses pic_io mqc_physical_fragment omp_lib mqc_resources mqc_json_output_types mqc_method_factory mqc_method_base pic_types pic_mpi_lib mqc_config_adapter mqc_mpi_tags mqc_method_config mqc_method_types mqc_result_types mqc_mbe mqc_calc_types pic_timer pic_blas_interfaces mqc_config_parser pic_logger mqc_mbe_io module~~mqc_mbe_fragment_distribution_scheme~~UsesGraph module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_calc_types mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_json_output_types mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_config mqc_method_config module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_method_types mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_resources mqc_resources module~mqc_mbe_fragment_distribution_scheme->module~mqc_resources module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_json_output_types->pic_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_program_limits mqc_program_limits module~mqc_mbe->module~mqc_program_limits module~mqc_mbe->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_method_config->module~mqc_method_types module~mqc_method_config->pic_types module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_config module~mqc_method_factory->module~mqc_method_types module~mqc_method_factory->pic_types mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_method_types->pic_types module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->pic_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->pic_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->pic_types module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_logger module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types module~mqc_method_xtb->mctc_env module~mqc_method_xtb->module~mqc_error mctc_io mctc_io module~mqc_method_xtb->mctc_io tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_comms->pic_mpi_lib module~mqc_physical_constants->pic_types module~mqc_program_limits->pic_types module~mqc_thermochemistry->pic_io module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->module~mqc_physical_constants pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types module~mqc_fragment_lookup->module~mqc_error pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_error module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: mpi_fragment_work_smod mqc_hessian_distribution_scheme mqc_serial_fragment_processor mqc_unfragmented_workflow module~~mqc_mbe_fragment_distribution_scheme~~UsedByGraph module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface public module subroutine distributed_unfragmented_hessian(world_comm, sys_geom, method_config, driver_config, json_data) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration type( driver_config_t ), intent(in), optional :: driver_config Driver configuration type( json_output_data_t ), intent(out), optional :: json_data JSON output data interface public module subroutine do_fragment_work(fragment_idx, result, method_config, phys_frag, calc_type, world_comm) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx type( calculation_result_t ), intent(out) :: result type( method_config_t ), intent(in) :: method_config Method configuration type( physical_fragment_t ), intent(in), optional :: phys_frag integer(kind=int32), intent(in) :: calc_type type(comm_t), intent(in), optional :: world_comm interface public module subroutine global_coordinator(resources, total_fragments, polymers, max_level, node_leader_ranks, num_nodes, sys_geom, method_config, calc_type, bonds, json_data) Implementation → Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data interface public module subroutine node_coordinator(resources, method_config, calc_type) Implementation → Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type interface public module subroutine node_worker(resources, sys_geom, method_config, calc_type, bonds) Implementation → Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) interface public module subroutine serial_fragment_processor(total_fragments, polymers, max_level, sys_geom, method_config, calc_type, bonds, json_data) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data interface public module subroutine unfragmented_calculation(sys_geom, method_config, calc_type, bonds, result_out, temperature, pressure, json_data) Implementation → Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( calculation_result_t ), intent(out), optional :: result_out real(kind=dp), intent(in), optional :: temperature real(kind=dp), intent(in), optional :: pressure type( json_output_data_t ), intent(out), optional :: json_data interface private module subroutine hessian_coordinator(world_comm, sys_geom, method_config, displacement, temperature, pressure, json_data) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr) real(kind=dp), intent(in) :: temperature Temperature for thermochemistry (K) real(kind=dp), intent(in) :: pressure Pressure for thermochemistry (atm) type( json_output_data_t ), intent(out), optional :: json_data JSON output data interface private module subroutine hessian_worker(world_comm, sys_geom, method_config, displacement) Implementation → Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr)","tags":"","url":"module/mqc_mbe_fragment_distribution_scheme.html"},{"title":"mqc_cli_parser – metalquicha","text":"Handles parsing of command line options including geometry files,\nbasis set specifications, and help/usage display.\nParsed command line arguments container\nMain argument parsing routine\nDisplay program usage information\nStandardize basis set names\nLocate basis set files Uses mqc_basis_utils mqc_error module~~mqc_cli_parser~~UsesGraph module~mqc_cli_parser mqc_cli_parser module~mqc_basis_utils mqc_basis_utils module~mqc_cli_parser->module~mqc_basis_utils module~mqc_error mqc_error module~mqc_cli_parser->module~mqc_error module~mqc_basis_utils->module~mqc_error Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: cli_args_type Container for parsed command line arguments Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: basis_name Basis set name (e.g., “6-31G”) character(len=:), public, allocatable :: xyz_file Input XYZ geometry file path Type-Bound Procedures procedure, public :: destroy => cli_args_destroy Memory cleanup Subroutines public  subroutine parse_command_line (args, error) Parse command line arguments for geometry file and basis set Read more… Arguments Type Intent Optional Attributes Name type( cli_args_type ), intent(out) :: args Parsed argument container type( error_t ), intent(out) :: error Error object public  subroutine print_usage () Print usage information Arguments None private  subroutine cli_args_destroy (this) Clean up CLI args Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this","tags":"","url":"module/mqc_cli_parser.html"},{"title":"mqc_method_mcscf – metalquicha","text":"Implements CASSCF/CASCI quantum chemistry methods\nProvides energy and gradient calculations using complete active space\nwith optional perturbative corrections (CASPT2/NEVPT2). Uses mqc_method_base mqc_result_types mqc_physical_fragment pic_types module~~mqc_method_mcscf~~UsesGraph module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_base mqc_method_base module~mqc_method_mcscf->module~mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_mcscf->module~mqc_result_types pic_types pic_types module~mqc_method_mcscf->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_mcscf~~UsedByGraph module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory mqc_method_factory module~mqc_method_factory->module~mqc_method_mcscf module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_factory module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( qc_method_t ) :: mcscf_method_t MCSCF/CASSCF method implementation Read more… Components Type Visibility Attributes Name Initial type( mcscf_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => mcscf_calc_energy procedure, public :: calc_gradient => mcscf_calc_gradient procedure, public :: calc_hessian => mcscf_calc_hessian type, public :: mcscf_options_t MCSCF/CASSCF calculation options Components Type Visibility Attributes Name Initial character(len=32), public :: basis_set = 'sto-3g' Basis set name real(kind=dp), public :: ci_tol = 1.0e-8_dp CI energy convergence threshold real(kind=dp), public :: energy_tol = 1.0e-8_dp Energy convergence threshold real(kind=dp), public :: imaginary_shift = 0.0_dp Imaginary shift for intruder states real(kind=dp), public :: ipea_shift = 0.25_dp IPEA shift for CASPT2 (Hartree) integer, public :: max_macro_iter = 100 Maximum macro (orbital optimization) iterations integer, public :: max_micro_iter = 50 Maximum CI iterations per macro step integer, public :: n_active_electrons = 0 Number of active electrons (CAS) integer, public :: n_active_orbitals = 0 Number of active orbitals (CAS) integer, public :: n_inactive_orbitals = -1 Number of inactive (doubly occupied) orbitals\n-1 means auto-determine from nelec and active electrons integer, public :: n_states = 1 Number of states for state-averaged CASSCF character(len=16), public :: orbital_optimizer = 'super-ci' Orbital optimizer: “super-ci”, “newton-raphson”, “ah” (augmented Hessian) real(kind=dp), public :: orbital_tol = 1.0e-6_dp Orbital gradient convergence threshold character(len=16), public :: pt2_type = 'nevpt2' PT2 type: “caspt2”, “nevpt2” logical, public :: spherical = .true. Use spherical (true) or Cartesian (false) basis real(kind=dp), public, allocatable :: state_weights (:) Weights for state averaging (must sum to 1) logical, public :: use_pt2 = .false. Apply perturbative correction after CASSCF logical, public :: verbose = .false. Print iteration details Subroutines private  subroutine mcscf_calc_energy (this, fragment, result) Calculate electronic energy using CASSCF Read more… Arguments Type Intent Optional Attributes Name class( mcscf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine mcscf_calc_gradient (this, fragment, result) Calculate energy gradient using CASSCF Read more… Arguments Type Intent Optional Attributes Name class( mcscf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine mcscf_calc_hessian (this, fragment, result) Calculate energy Hessian using CASSCF Read more… Arguments Type Intent Optional Attributes Name class( mcscf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result","tags":"","url":"module/mqc_method_mcscf.html"},{"title":"mqc_finite_differences – metalquicha","text":"Provides utilities for generating perturbed geometries and computing\nnumerical derivatives via finite differences (gradients, Hessians, etc.)\nGenerate forward/backward displacements\nContainer for displaced geometry\nCompute Hessian from gradient differences\nCompute dipole derivatives from dipole differences\nCopy and displace geometry Uses mqc_physical_fragment pic_types module~~mqc_finite_differences~~UsesGraph module~mqc_finite_differences mqc_finite_differences module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_finite_differences~~UsedByGraph module~mqc_finite_differences mqc_finite_differences proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: DEFAULT_DISPLACEMENT = 0.005_dp ~0.05 Angstrom Derived Types type, public :: displaced_geometry_t Container for a single displaced geometry Components Type Visibility Attributes Name Initial integer, public :: atom_index Which atom was displaced (1-based) integer, public :: coordinate Which coordinate was displaced (1=x, 2=y, 3=z) integer, public :: direction +1 for forward, -1 for backward real(kind=dp), public :: displacement Displacement magnitude in Bohr type( physical_fragment_t ), public :: geometry The displaced geometry Type-Bound Procedures procedure, public :: destroy => displaced_geometry_destroy Subroutines public  subroutine copy_and_displace_geometry (reference_geom, atom_idx, coord_idx, displacement, displaced_geom) Create a copy of reference geometry with one coordinate displaced Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom integer, intent(in) :: atom_idx integer, intent(in) :: coord_idx real(kind=dp), intent(in) :: displacement type( physical_fragment_t ), intent(out) :: displaced_geom public  subroutine finite_diff_dipole_derivatives (n_atoms, forward_dipoles, backward_dipoles, displacement, dipole_derivatives) Compute dipole moment derivatives via central finite differences Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_atoms real(kind=dp), intent(in) :: forward_dipoles (:,:) (3*n_atoms, 3) real(kind=dp), intent(in) :: backward_dipoles (:,:) (3*n_atoms, 3) real(kind=dp), intent(in) :: displacement real(kind=dp), intent(out), allocatable :: dipole_derivatives (:,:) (3, 3*n_atoms) public  subroutine finite_diff_hessian_from_gradients (reference_geom, forward_gradients, backward_gradients, displacement, hessian) Compute Hessian matrix from finite differences of gradients Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: forward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: backward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: displacement real(kind=dp), intent(out), allocatable :: hessian (:,:) (3 n_atoms, 3 n_atoms) public  subroutine generate_perturbed_geometries (reference_geom, displacement, forward_geoms, backward_geoms) Generate all forward and backward displaced geometries for finite difference calculations Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: displacement type( displaced_geometry_t ), intent(out), allocatable :: forward_geoms (:) type( displaced_geometry_t ), intent(out), allocatable :: backward_geoms (:) private  subroutine displaced_geometry_destroy (this) Clean up memory for displaced geometry Arguments Type Intent Optional Attributes Name class( displaced_geometry_t ), intent(inout) :: this","tags":"","url":"module/mqc_finite_differences.html"},{"title":"mqc_error – metalquicha","text":"Error codes Used by module~~mqc_error~~UsedByGraph module~mqc_error mqc_error module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_error module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_basis_file_reader mqc_basis_file_reader module~mqc_basis_file_reader->module~mqc_error module~mqc_basis_reader mqc_basis_reader module~mqc_basis_reader->module~mqc_error module~mqc_basis_reader->module~mqc_basis_file_reader module~mqc_basis_utils mqc_basis_utils module~mqc_basis_utils->module~mqc_error module~mqc_cli_parser mqc_cli_parser module~mqc_cli_parser->module~mqc_error module~mqc_cli_parser->module~mqc_basis_utils module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_error module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_parser->module~mqc_error module~mqc_driver mqc_driver module~mqc_driver->module~mqc_error module~mqc_driver->module~mqc_config_adapter module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_driver->module~mqc_result_types module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_fragment_lookup->module~mqc_error module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_gmbe_utils->module~mqc_error module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_error module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_config_parser module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->module~mqc_error module~mqc_xyz_reader->module~mqc_error proc~build_mbe_lookup_table build_mbe_lookup_table proc~build_mbe_lookup_table->module~mqc_error proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_error proc~compute_gmbe->module~mqc_config_parser proc~compute_gmbe->module~mqc_gmbe_utils proc~compute_gmbe->module~mqc_physical_fragment proc~compute_gmbe->module~mqc_result_types proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_error proc~compute_mbe->module~mqc_config_parser proc~compute_mbe->module~mqc_result_types proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->module~mqc_error proc~compute_mbe_dipole_derivatives->module~mqc_config_parser proc~compute_mbe_dipole_derivatives->module~mqc_result_types proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_error proc~compute_mbe_hessian->module~mqc_config_parser proc~compute_mbe_hessian->module~mqc_result_types proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_error proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->module~mqc_error proc~map_fragment_to_system_dipole_derivatives->module~mqc_config_parser proc~map_fragment_to_system_dipole_derivatives->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_error proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_error proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~node_worker node_worker proc~node_worker->module~mqc_error proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_error proc~process_intersection_derivatives->module~mqc_config_parser proc~process_intersection_derivatives->module~mqc_gmbe_utils proc~process_intersection_derivatives->module~mqc_physical_fragment proc~process_intersection_derivatives->module~mqc_result_types proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_error proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~run_multi_molecule_calculations->module~mqc_config_parser proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->module~mqc_error proc~serial_fragment_processor->module~mqc_result_types proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_error proc~serial_gmbe_pie_processor->module~mqc_physical_fragment proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->module~mqc_error program~main main program~main->module~mqc_error program~main->module~mqc_config_adapter program~main->module~mqc_config_parser program~main->module~mqc_driver program~main->module~mqc_physical_fragment module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_config_parser module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_calculation_interface->module~mqc_result_types module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_dft mqc_method_dft module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_factory->module~mqc_method_xtb module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~apply_distance_screening->module~mqc_physical_fragment proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe_dipole->module~mqc_result_types proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_gradient->module~mqc_result_types proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_config_adapter proc~fragment_should_be_screened->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~global_coordinator global_coordinator proc~global_coordinator->module~mqc_result_types proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~print_gmbe_intersection_debug print_gmbe_intersection_debug proc~print_gmbe_intersection_debug->module~mqc_result_types module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer->module~mqc_mbe_io module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_base proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_base proc~hessian_worker->module~mqc_method_factory proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: ERROR_GENERIC = 1 integer, public, parameter :: ERROR_IO = 2 integer, public, parameter :: ERROR_PARSE = 3 integer, public, parameter :: ERROR_VALIDATION = 4 Stack trace configuration integer, public, parameter :: SUCCESS = 0 integer, private, parameter :: MAX_LOCATION_LEN = 128 Unified error type with stack trace support integer, private, parameter :: MAX_STACK_DEPTH = 20 Derived Types type, public :: error_t Components Type Visibility Attributes Name Initial character(len=MAX_LOCATION_LEN), public :: call_stack (MAX_STACK_DEPTH) Call locations integer, public :: code = SUCCESS Error code (0 = no error) character(len=:), public, allocatable :: message Error message Read more… integer, public :: stack_depth = 0 Current stack depth Type-Bound Procedures procedure, public :: add_context => error_add_context procedure, public :: clear => error_clear procedure, public :: get_code => error_get_code procedure, public :: get_full_trace => error_get_full_trace procedure, public :: get_message => error_get_message procedure, public :: has_error => error_has_error procedure, public :: print_trace => error_print_trace procedure, public :: set => error_set Functions private pure function error_get_code (this) result(code) Get the error code Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value integer private  function error_get_full_trace (this) result(trace) Get complete error message with stack trace\nReturns a multi-line string with error and call stack Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable private pure function error_get_message (this) result(message) Get the error message (without stack trace) Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable private pure function error_has_error (this) result(has_err) Check if an error is set Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value logical Subroutines private pure subroutine error_add_context (this, location) Add a call location to the stack trace\nTypically called when propagating errors upward Read more… Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this character(len=*), intent(in) :: location private pure subroutine error_clear (this) Clear the error state and stack trace Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this private  subroutine error_print_trace (this, unit) Print error with stack trace to specified unit\nIf unit not specified, prints to stdout (unit 6) Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this integer, intent(in), optional :: unit private pure subroutine error_set (this, code, message) Set an error with code and message\nResets the stack trace Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this integer, intent(in) :: code character(len=*), intent(in) :: message","tags":"","url":"module/mqc_error.html"},{"title":"mqc_gmbe_fragment_distribution_scheme – metalquicha","text":"Implements fragment distribution schemes for GMBE calculations with overlapping fragments\nHandles both serial and MPI-parallelized distribution of monomers and intersection fragments\nPIE-based serial processor\nPIE-based MPI coordinator Uses mqc_mbe_fragment_distribution_scheme mqc_thermochemistry mqc_physical_fragment pic_timer mqc_method_config mqc_result_types pic_io mqc_json_output_types mqc_vibrational_analysis mqc_config_parser pic_types pic_logger mqc_mpi_tags pic_mpi_lib mqc_calc_types module~~mqc_gmbe_fragment_distribution_scheme~~UsesGraph module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_calc_types mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_config_parser mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_json_output_types mqc_json_output_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_method_config mqc_method_config module~mqc_gmbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_gmbe_fragment_distribution_scheme->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis pic_io pic_io module~mqc_gmbe_fragment_distribution_scheme->pic_io pic_logger pic_logger module~mqc_gmbe_fragment_distribution_scheme->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_gmbe_fragment_distribution_scheme->pic_mpi_lib pic_timer pic_timer module~mqc_gmbe_fragment_distribution_scheme->pic_timer pic_types pic_types module~mqc_gmbe_fragment_distribution_scheme->pic_types module~mqc_calc_types->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->pic_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_json_output_types->pic_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme->pic_io module~mqc_mbe_fragment_distribution_scheme->pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_timer module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_resources mqc_resources module~mqc_mbe_fragment_distribution_scheme->module~mqc_resources omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces module~mqc_method_config->pic_types module~mqc_method_config->module~mqc_method_types module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error module~mqc_thermochemistry->pic_io module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->module~mqc_physical_constants pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_cgto->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_config_adapter->module~mqc_elements module~mqc_config_adapter->module~mqc_error module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_thermochemistry module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_program_limits mqc_program_limits module~mqc_mbe->module~mqc_program_limits module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_method_factory->module~mqc_method_config module~mqc_method_factory->pic_types module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_types mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_method_types->pic_types module~mqc_physical_constants->pic_types module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calculation_keywords->pic_types module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->pic_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->pic_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_logger module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types module~mqc_method_xtb->module~mqc_error module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_comms->pic_mpi_lib module~mqc_program_limits->pic_types module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types module~mqc_fragment_lookup->module~mqc_error pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_error module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_gmbe_fragment_distribution_scheme~~UsedByGraph module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine gmbe_pie_coordinator (resources, pie_atom_sets, pie_coefficients, n_pie_terms, node_leader_ranks, num_nodes, sys_geom, method_config, calc_type, bonds, json_data) MPI coordinator for PIE-based GMBE calculations\nDistributes PIE terms across MPI ranks and accumulates results\nIf json_data is present, populates it for centralized JSON output Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(in) :: n_pie_terms integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data public  subroutine serial_gmbe_pie_processor (pie_atom_sets, pie_coefficients, n_pie_terms, sys_geom, method_config, calc_type, bonds, json_data) Serial GMBE processor using PIE coefficients\nEvaluates each unique atom set once and sums with PIE coefficients\nSupports energy-only, energy+gradient, and energy+gradient+Hessian calculations\nIf json_data is present, populates it for centralized JSON output Arguments Type Intent Optional Attributes Name integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(in) :: n_pie_terms type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data private  subroutine send_pie_term_to_node (world_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to remote node coordinator Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank private  subroutine send_pie_term_to_worker (node_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to local worker Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank","tags":"","url":"module/mqc_gmbe_fragment_distribution_scheme.html"},{"title":"mqc_method_base – metalquicha","text":"Defines the common interface that all quantum chemistry methods must implement,\nproviding a unified API for energy and gradient calculations.\nAbstract base type for all QC methods Uses mqc_result_types mqc_physical_fragment pic_types module~~mqc_method_base~~UsesGraph module~mqc_method_base mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_base->module~mqc_result_types pic_types pic_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_base~~UsedByGraph module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_method_dft mqc_method_dft module~mqc_method_dft->module~mqc_method_base module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb->module~mqc_method_base proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_base proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_base proc~hessian_worker->module~mqc_method_factory module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface private  subroutine calc_energy_interface(this, fragment, result) Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results abstract interface private  subroutine calc_gradient_interface(this, fragment, result) Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result abstract interface private  subroutine calc_hessian_interface(this, fragment, result) Interface for energy, gradient, and Hessian calculations Computes electronic energy, nuclear gradients, and Hessian matrix for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Derived Types type, public, abstract :: qc_method_t Abstract base type for all quantum chemistry methods Read more… Type-Bound Procedures procedure( calc_energy_interface ), public, deferred :: calc_energy Energy calculation interface procedure( calc_gradient_interface ), public, deferred :: calc_gradient Gradient calculation interface procedure( calc_hessian_interface ), public, deferred :: calc_hessian Hessian calculation interface","tags":"","url":"module/mqc_method_base.html"},{"title":"mqc_physical_constants – metalquicha","text":"Contains fundamental physical constants and unit conversion factors\nused throughout the metalquicha codebase. All values are in atomic units unless otherwise specified.\nReference: CODATA 2018 recommended values where applicable. Uses pic_types module~~mqc_physical_constants~~UsesGraph module~mqc_physical_constants mqc_physical_constants pic_types pic_types module~mqc_physical_constants->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_physical_constants~~UsedByGraph module~mqc_physical_constants mqc_physical_constants module~mqc_json_writer mqc_json_writer module~mqc_json_writer->module~mqc_physical_constants module~mqc_json_output_types mqc_json_output_types module~mqc_json_writer->module~mqc_json_output_types module~mqc_mbe_io mqc_mbe_io module~mqc_json_writer->module~mqc_mbe_io module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_thermochemistry mqc_thermochemistry module~mqc_thermochemistry->module~mqc_physical_constants module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_json_writer module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_json_output_types module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_thermochemistry module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_thermochemistry module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_dft mqc_method_dft module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_physical_fragment proc~apply_distance_screening->module~mqc_config_adapter proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_physical_fragment proc~fragment_should_be_screened->module~mqc_config_adapter proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_thermochemistry proc~hessian_coordinator->module~mqc_vibrational_analysis proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_json_output_types proc~hessian_coordinator->module~mqc_method_base proc~hessian_coordinator->module~mqc_method_factory proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~populate_vibrational_json_data populate_vibrational_json_data proc~populate_vibrational_json_data->module~mqc_thermochemistry proc~populate_vibrational_json_data->module~mqc_json_output_types proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->module~mqc_thermochemistry proc~unfragmented_calculation->module~mqc_vibrational_analysis proc~unfragmented_calculation->module~mqc_json_output_types program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_dft module~mqc_method_factory->module~mqc_method_hf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_factory->module~mqc_method_xtb module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_json_output_types proc~global_coordinator global_coordinator proc~global_coordinator->module~mqc_json_output_types proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_base proc~hessian_worker->module~mqc_method_factory proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~populate_unfragmented_json_data->module~mqc_json_output_types proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->module~mqc_json_output_types proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: AMU_TO_AU = 1822.888_dp Atomic mass unit to atomic units of mass (electron masses)\n1 amu = 1822.888 m_e real(kind=dp), public, parameter :: AMU_TO_KG = 1.66053906660e-27_dp Atomic mass unit to kg (CODATA 2018) real(kind=dp), public, parameter :: ANGSTROM_TO_BOHR = 1.0_dp/BOHR_TO_ANGSTROM Angstrom to Bohr conversion real(kind=dp), public, parameter :: ATM_TO_AU = 3.39893097e-9_dp 1 atm = 101325 Pa, 1 Bohr = 5.29177e-11 m, 1 Hartree = 4.3597e-18 J real(kind=dp), public, parameter :: ATM_TO_PA = 101325.0_dp real(kind=dp), public, parameter :: AU_TO_AMU = 1.0_dp/AMU_TO_AU Atomic units of mass to amu real(kind=dp), public, parameter :: AU_TO_CM1 = 2.642461e7_dp Conversion factor from atomic units (Hartree/Bohr&#94;2/amu) to cm&#94;-1\nDerived from: sqrt(Hartree/(Bohr&#94;2 * amu)) -> s&#94;-1 -> cm&#94;-1 real(kind=dp), public, parameter :: AU_TO_DEBYE = 2.541746_dp Conversion from atomic units (e Bohr) to Debye\n1 e a0 = 2.541746 Debye real(kind=dp), public, parameter :: AU_TO_KMMOL = 1.7770969e6_dp Conversion factor from atomic units of dipole derivatives to km/mol (IR intensity)\nFrom IUPAC: A = (pi * N_A * |d_mu/dQ|&#94;2) / (3 * 4 * pi * epsilon_0 * c&#94;2)\nReference: IUPAC, Quantities, Units and Symbols in Physical Chemistry (1993) real(kind=dp), public, parameter :: AU_TO_MDYNE_ANG = 15.569141_dp Conversion factor from atomic units (Hartree/Bohr&#94;2) to mdyne/Angstrom\n1 Hartree/Bohr&#94;2 = 15.569141 mdyne/A real(kind=dp), public, parameter :: AVOGADRO = 6.02214076e23_dp Avogadro’s number (for reference, not directly used in atomic unit calculations) real(kind=dp), public, parameter :: BOHR_TO_ANGSTROM = 0.52917721092_dp Bohr radius in Angstrom (a0 = 0.529177… A) real(kind=dp), public, parameter :: CAL_TO_J = 4.184_dp Calorie to Joule (thermochemical calorie) real(kind=dp), public, parameter :: CM1_TO_KELVIN = 1.4387773538277_dp cm&#94;-1 to Kelvin conversion factor: theta_vib = (h c/k_B) * nu\nThis is h c/k_B in cm (multiply by frequency in cm&#94;-1 to get K) real(kind=dp), public, parameter :: C_CM_S = 2.99792458e10_dp Speed of light in cm/s real(kind=dp), public, parameter :: DEBYE_TO_AU = 1.0_dp/AU_TO_DEBYE Conversion from Debye to atomic units real(kind=dp), public, parameter :: HARTREE_TO_CALMOL = 627.5094740631_dp*1000.0_dp Hartree to cal/mol real(kind=dp), public, parameter :: HARTREE_TO_EV = 27.211386245988_dp Hartree to eV real(kind=dp), public, parameter :: HARTREE_TO_JMOL = 2625.4996394799_dp*1000.0_dp Hartree to J/mol real(kind=dp), public, parameter :: HARTREE_TO_KCALMOL = 627.5094740631_dp Hartree to kcal/mol real(kind=dp), public, parameter :: HARTREE_TO_KJMOL = 2625.4996394799_dp Hartree to kJ/mol real(kind=dp), public, parameter :: H_HARTREE_S = 1.5198298460574e-16_dp Planck constant in Hartree s\nh = 6.62607015e-34 J s real(kind=dp), public, parameter :: H_SI = 6.62607015e-34_dp Planck constant in J*s (CODATA 2018, exact) real(kind=dp), public, parameter :: KB_HARTREE = 3.1668115634556e-6_dp Boltzmann constant in Hartree/K\nk_B = 1.380649e-23 J/K, 1 Hartree = 4.3597447222071e-18 J real(kind=dp), public, parameter :: KB_SI = 1.380649e-23_dp Boltzmann constant in J/K (CODATA 2018, exact) real(kind=dp), public, parameter :: PI = 3.14159265358979323846_dp Pi constant real(kind=dp), public, parameter :: ROTCONST_AMUA2_TO_GHZ = 505379.07_dp Rotational constant conversion: amu Angstrom&#94;2 to GHz\nB = h / (8 pi&#94;2 I) where I is in SI units\nFor I in amu Angstrom&#94;2: B(GHz) = 505379.07 / I real(kind=dp), public, parameter :: ROTTEMP_AMUA2_TO_K = 24.2637_dp Rotational temperature conversion: amu Angstrom&#94;2 to Kelvin\ntheta_rot = h&#94;2 / (8 pi&#94;2 I k_B)\nFor I in amu*Angstrom&#94;2: theta_rot(K) = 24.2637 / I real(kind=dp), public, parameter :: R_CALMOLK = 1.98720425864_dp Gas constant R in cal/(mol K) for thermochemistry output\nR = 1.98720425864 cal/(mol K) real(kind=dp), public, parameter :: R_HARTREE = 3.1668115634556e-6_dp Gas constant R in Hartree/(mol*K)\nR = N_A * k_B real(kind=dp), public, parameter :: VIB_CLASSICAL_LIMIT = 100.0_dp Classical limit for vibrational modes (u = theta_v/T)\nWhen u > this value, vibrational modes are considered frozen out","tags":"","url":"module/mqc_physical_constants.html"},{"title":"mqc_gmbe_utils – metalquicha","text":"Provides functions for computing fragment intersections, generating k-way\nintersections, and enumerating PIE (Principle of Inclusion-Exclusion) terms\nfor GMBE calculations with overlapping molecular fragments.\nFind shared atoms between two fragments\nGenerate all k-way intersections for GMBE\nCompute atom list for polymer (union of fragments)\nGenerate intersections for polymers\nDFS-based PIE coefficient enumeration Uses mqc_error mqc_combinatorics pic_io pic_types pic_logger module~~mqc_gmbe_utils~~UsesGraph module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_combinatorics mqc_combinatorics module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_error mqc_error module~mqc_gmbe_utils->module~mqc_error pic_io pic_io module~mqc_gmbe_utils->pic_io pic_logger pic_logger module~mqc_gmbe_utils->pic_logger pic_types pic_types module~mqc_gmbe_utils->pic_types module~mqc_combinatorics->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_gmbe_utils~~UsedByGraph module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils mqc_frag_utils module~mqc_frag_utils->module~mqc_gmbe_utils proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_gmbe_utils proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_gmbe_utils module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function find_fragment_intersection (frag1_atoms, n1, frag2_atoms, n2, intersection, n_intersect) result(has_intersection) Find shared atoms between two fragments (for GMBE with overlapping fragments) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag1_atoms (:) Atom indices in fragment 1 (0-indexed) integer, intent(in) :: n1 Number of atoms in fragment 1 integer, intent(in) :: frag2_atoms (:) Atom indices in fragment 2 (0-indexed) integer, intent(in) :: n2 Number of atoms in fragment 2 integer, intent(out), allocatable :: intersection (:) Shared atom indices integer, intent(out) :: n_intersect Number of shared atoms Return Value logical private pure function atom_sets_equal (set1, set2, n_atoms) result(equal) Check if two atom sets are equal (assuming sorted) Arguments Type Intent Optional Attributes Name integer, intent(in) :: set1 (:) integer, intent(in) :: set2 (:) integer, intent(in) :: n_atoms Return Value logical Subroutines public pure subroutine compute_polymer_atoms (sys_geom, polymer, polymer_size, atom_list, n_atoms) Compute the atom list for a polymer (union of atoms from base fragments)\npolymer(:) contains base fragment indices (1-based) Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymer (:) Base fragment indices in this polymer integer, intent(in) :: polymer_size Number of base fragments in polymer integer, intent(out), allocatable :: atom_list (:) Unique atoms in this polymer integer, intent(out) :: n_atoms Number of unique atoms public  subroutine generate_intersections (sys_geom, monomers, polymers, n_monomers, max_intersection_level, intersections, intersection_sets, intersection_levels, n_intersections) Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) Monomer indices integer, intent(inout) :: polymers (:,:) Output: monomers stored here integer, intent(in) :: n_monomers Number of monomers integer, intent(in) :: max_intersection_level Maximum k-way intersection depth integer, intent(out), allocatable :: intersections (:,:) Intersection atom lists integer, intent(out), allocatable :: intersection_sets (:,:) Which k-tuple created each intersection integer, intent(out), allocatable :: intersection_levels (:) Level (k) of each intersection integer, intent(out) :: n_intersections Number of intersections found public  subroutine generate_polymer_intersections (sys_geom, polymers, n_polymers, max_level, intersections, intersection_sets, intersection_levels, n_intersections) Generate all k-way intersections for polymers at any level (GMBE-N)\nThis works with dynamically generated polymers, not just base fragments Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymers (:,:) Polymer definitions (n_polymers, max_level) integer, intent(in) :: n_polymers integer, intent(in) :: max_level integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections public  subroutine gmbe_enumerate_pie_terms (sys_geom, primaries, n_primaries, polymer_level, max_k_level, pie_atom_sets, pie_coefficients, n_pie_terms, error, initial_max_terms) Enumerate all unique intersections via DFS and accumulate PIE coefficients\nThis implements the GMBE(N) algorithm with inclusion-exclusion principle Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: primaries (:,:) Primary polymers (n_primaries, polymer_level) integer, intent(in) :: n_primaries Number of primary polymers integer, intent(in) :: polymer_level Level of primaries (1=monomers, 2=dimers, etc.) integer, intent(in) :: max_k_level Maximum clique size (intersection depth limit) integer, intent(out), allocatable :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_terms) integer, intent(out), allocatable :: pie_coefficients (:) PIE coefficient for each term integer(kind=int64), intent(out) :: n_pie_terms Number of unique PIE terms type( error_t ), intent(out) :: error Error status integer(kind=int64), intent(in), optional :: initial_max_terms Initial PIE storage capacity private recursive subroutine dfs_pie_accumulate (primary_atoms, primary_n_atoms, n_primaries, max_atoms, clique, clique_size, current_atoms, n_current_atoms, candidates, n_candidates, max_k_level, atom_sets, coefficients, n_terms, max_terms, error) DFS helper: accumulate PIE coefficients for intersections Arguments Type Intent Optional Attributes Name integer, intent(in) :: primary_atoms (:,:) Precomputed atom lists integer, intent(in) :: primary_n_atoms (:) Atom counts integer, intent(in) :: n_primaries integer, intent(in) :: max_atoms integer, intent(in) :: clique (:) Current clique integer, intent(in) :: clique_size Size of current clique integer, intent(in) :: current_atoms (:) Atoms in current intersection integer, intent(in) :: n_current_atoms Number of atoms in intersection integer, intent(in) :: candidates (:) Candidate primaries integer, intent(in) :: n_candidates integer, intent(in) :: max_k_level integer, intent(inout), allocatable :: atom_sets (:,:) integer, intent(inout), allocatable :: coefficients (:) integer(kind=int64), intent(inout) :: n_terms integer(kind=int64), intent(inout) :: max_terms type( error_t ), intent(inout) :: error Error status private  subroutine generate_intersections_from_atom_lists (atom_lists, n_atoms_list, n_sets, max_k_level, intersections, intersection_sets, intersection_levels, n_intersections) Generate k-way intersections from arbitrary atom lists (not tied to sys_geom)\nmax_k_level limits the maximum intersection order to prevent combinatorial explosion Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) (max_atoms, n_sets) integer, intent(in) :: n_atoms_list (:) Number of atoms in each set integer, intent(in) :: n_sets Number of sets (polymers) integer, intent(in) :: max_k_level Maximum intersection level to compute integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections private recursive subroutine generate_k_way_intersections_for_level (sys_geom, monomers, n_monomers, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Helper to generate all k-way intersections at a specific level k Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count private  subroutine generate_k_way_intersections_from_lists (atom_lists, n_atoms_list, n_sets, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Generate all k-way intersections from atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) integer, intent(in) :: n_atoms_list (:) integer, intent(in) :: n_sets integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count private  subroutine grow_pie_storage (atom_sets, coefficients, max_terms, max_atoms, error) Grow PIE term storage arrays when capacity is exceeded. Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: atom_sets (:,:) integer, intent(inout), allocatable :: coefficients (:) integer(kind=int64), intent(inout) :: max_terms integer, intent(in) :: max_atoms type( error_t ), intent(inout) :: error private pure subroutine intersect_atom_lists (atoms1, n1, atoms2, n2, intersection, n_intersect) Compute intersection of two atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms1 (:) integer, intent(in) :: n1 integer, intent(in) :: atoms2 (:) integer, intent(in) :: n2 integer, intent(out) :: intersection (:) integer, intent(out) :: n_intersect","tags":"","url":"module/mqc_gmbe_utils.html"},{"title":"mqc_mpi_tags – metalquicha","text":"Module defining MPI communication tags for clarity and maintainability Uses pic_types module~~mqc_mpi_tags~~UsesGraph module~mqc_mpi_tags mqc_mpi_tags pic_types pic_types module~mqc_mpi_tags->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mpi_tags~~UsedByGraph module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: TAG_NODE_FINISH = 302 Global coordinator signals node coordinator to finish integer(kind=default_int), public, parameter :: TAG_NODE_FRAGMENT = 301 Global coordinator sends fragment data to node coordinator integer(kind=default_int), public, parameter :: TAG_NODE_MATRIX_RESULT = 304 Node coordinator sends matrix results to global coordinator integer(kind=default_int), public, parameter :: TAG_NODE_REQUEST = 300 Node coordinator requests work from global coordinator integer(kind=default_int), public, parameter :: TAG_NODE_SCALAR_RESULT = 303 Node coordinator sends results (fragment_idx + scalar) to global coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_FINISH = 202 Coordinator signals worker to finish integer(kind=default_int), public, parameter :: TAG_WORKER_FRAGMENT = 201 Coordinator sends fragment data to worker integer(kind=default_int), public, parameter :: TAG_WORKER_MATRIX_RESULT = 204 Worker sends matrix results back to coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_REQUEST = 200 Worker requests work from node coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_SCALAR_RESULT = 203 Worker sends scalar results back to coordinator","tags":"","url":"module/mqc_mpi_tags.html"},{"title":"mqc_mpi_comms – metalquicha","text":"Container type for MPI communicators - extensible for future parallelism patterns Uses pic_mpi_lib module~~mqc_mpi_comms~~UsesGraph module~mqc_mpi_comms mqc_mpi_comms pic_mpi_lib pic_mpi_lib module~mqc_mpi_comms->pic_mpi_lib Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mpi_comms~~UsedByGraph module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources mqc_resources module~mqc_resources->module~mqc_mpi_comms module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_resources module~mqc_driver mqc_driver module~mqc_driver->module~mqc_resources module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_resources proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_resources program~main main program~main->module~mqc_resources program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: mpi_comms_t Container for MPI communicators Read more… Components Type Visibility Attributes Name Initial type(comm_t), public :: node_comm Node-local communicator type(comm_t), public :: world_comm Global MPI communicator","tags":"","url":"module/mqc_mpi_comms.html"},{"title":"mqc_xyz_reader – metalquicha","text":"Provides functions to parse standard XYZ format files containing\natomic coordinates and element symbols for molecular structures.\nRead XYZ file from disk\nParse XYZ data from string\nSplit text into lines (for testing) Uses mqc_geometry mqc_error pic_types module~~mqc_xyz_reader~~UsesGraph module~mqc_xyz_reader mqc_xyz_reader module~mqc_error mqc_error module~mqc_xyz_reader->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_xyz_reader->module~mqc_geometry pic_types pic_types module~mqc_xyz_reader->pic_types module~mqc_geometry->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_xyz_reader~~UsedByGraph module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_dft mqc_method_dft module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_physical_fragment proc~apply_distance_screening->module~mqc_config_adapter proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_physical_fragment proc~fragment_should_be_screened->module~mqc_config_adapter proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer->module~mqc_mbe_io module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_dft module~mqc_method_factory->module~mqc_method_hf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_factory->module~mqc_method_xtb module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_base proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_base proc~hessian_worker->module~mqc_method_factory proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 Maximum element symbol length Functions private pure function int_to_string (i) result(str) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Subroutines public  subroutine read_xyz_file (filename, geom, error) Read molecular geometry from XYZ format file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Path to XYZ file type( geometry_type ), intent(out) :: geom Parsed molecular geometry type( error_t ), intent(out) :: error Error handling public pure subroutine read_xyz_string (xyz_string, geom, error) Parse molecular geometry from XYZ format string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xyz_string type( geometry_type ), intent(out) :: geom type( error_t ), intent(out) :: error public pure subroutine split_lines (text, lines, nlines) Split input text into lines based on CR, LF, or CRLF line endings\nTrailing newlines do not create empty lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text character(len=:), intent(out), allocatable :: lines (:) integer, intent(out) :: nlines","tags":"","url":"module/mqc_xyz_reader.html"},{"title":"mqc_calc_types – metalquicha","text":"Defines integer constants for calculation types to avoid string comparisons\nthroughout the codebase. Provides conversion utilities between string\nrepresentations and integer constants. Uses pic_types module~~mqc_calc_types~~UsesGraph module~mqc_calc_types mqc_calc_types pic_types pic_types module~mqc_calc_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_calc_types~~UsedByGraph module~mqc_calc_types mqc_calc_types module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_calc_types module~mqc_config_parser mqc_config_parser module~mqc_calculation_interface->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_parser->module~mqc_calc_types module~mqc_driver mqc_driver module~mqc_driver->module~mqc_calc_types module~mqc_driver->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_config_adapter mqc_config_adapter module~mqc_driver->module~mqc_config_adapter module~mqc_driver->module~mqc_physical_fragment module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_calc_types proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_calc_types proc~serial_gmbe_pie_processor->module~mqc_physical_fragment module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_physical_fragment->module~mqc_config_parser module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_config_parser proc~compute_gmbe->module~mqc_physical_fragment proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_config_parser proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->module~mqc_config_parser proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->module~mqc_config_parser proc~map_fragment_to_system_dipole_derivatives->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_config_parser proc~process_intersection_derivatives->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_parser program~main->module~mqc_driver program~main->module~mqc_config_adapter program~main->module~mqc_physical_fragment module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_dft mqc_method_dft module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~apply_distance_screening->module~mqc_physical_fragment proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_config_adapter proc~fragment_should_be_screened->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment module~mqc_json_writer->module~mqc_mbe_io module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_dft module~mqc_method_factory->module~mqc_method_hf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_factory->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_base proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_base proc~hessian_worker->module~mqc_method_factory proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: CALC_TYPE_ENERGY = 1 integer(kind=int32), public, parameter :: CALC_TYPE_GRADIENT = 2 integer(kind=int32), public, parameter :: CALC_TYPE_HESSIAN = 3 integer(kind=int32), public, parameter :: CALC_TYPE_UNKNOWN = 0 Functions public pure function calc_type_from_string (calc_type_str) result(calc_type) Convert calculation type string to integer constant Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: calc_type_str Input string (e.g., “energy”, “gradient”) Return Value integer(kind=int32) Output integer constant public pure function calc_type_to_string (calc_type) result(calc_type_str) Convert calculation type integer constant to string Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: calc_type Input integer constant Return Value character(len=:), allocatable Output string representation","tags":"","url":"module/mqc_calc_types.html"},{"title":"mqc_result_types – metalquicha","text":"Defines data structures for storing and managing results from\nquantum chemistry calculations including energies, gradients, and properties.\nMP2 energy components type\nCoupled cluster energy components type\nEnergy components type\nMain result container type\nMBE aggregated result container type\nSend result over MPI\nReceive result over MPI Uses pic_mpi_lib mqc_error pic_types module~~mqc_result_types~~UsesGraph module~mqc_result_types mqc_result_types module~mqc_error mqc_error module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib pic_types pic_types module~mqc_result_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_result_types~~UsedByGraph module~mqc_result_types mqc_result_types module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_result_types module~mqc_driver mqc_driver module~mqc_driver->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_method_base->module~mqc_result_types module~mqc_method_dft mqc_method_dft module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->module~mqc_method_base proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_result_types proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_result_types proc~compute_mbe_dipole compute_mbe_dipole proc~compute_mbe_dipole->module~mqc_result_types proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->module~mqc_result_types proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_result_types proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_result_types proc~global_coordinator global_coordinator proc~global_coordinator->module~mqc_result_types proc~print_gmbe_intersection_debug print_gmbe_intersection_debug proc~print_gmbe_intersection_debug->module~mqc_result_types proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_result_types proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->module~mqc_result_types module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_dft module~mqc_method_factory->module~mqc_method_hf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_factory->module~mqc_method_xtb module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_base proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_base proc~hessian_worker->module~mqc_method_factory program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: SCS_OS_SCALE = 1.2_dp SCS opposite-spin scaling factor real(kind=dp), private, parameter :: SCS_SS_SCALE = 1.0_dp/3.0_dp SCS same-spin scaling factor Derived Types type, public :: calculation_result_t Container for quantum chemistry calculation results Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dipole (:) Dipole moment vector (3) (Debye) real(kind=dp), public, allocatable :: dipole_derivatives (:,:) Dipole derivatives (3, 3N) in a.u. for IR intensities real(kind=dp), public :: distance = 0.0_dp Minimal atomic distance between monomers (Angstrom, 0 for monomers) type( energy_t ), public :: energy Energy components (Hartree) type( error_t ), public :: error Calculation error (if any) real(kind=dp), public, allocatable :: gradient (:,:) Energy gradient (3, natoms) (Hartree/Bohr) logical, public :: has_dipole = .false. Dipole moment has been computed logical, public :: has_dipole_derivatives = .false. Dipole derivatives have been computed logical, public :: has_energy = .false. Energy has been computed logical, public :: has_error = .false. True if calculation failed logical, public :: has_gradient = .false. Gradient has been computed logical, public :: has_hessian = .false. Hessian has been computed logical, public :: has_sigma = .false. Stress tensor has been computed real(kind=dp), public, allocatable :: hessian (:,:) Energy hessian (future implementation) real(kind=dp), public, allocatable :: sigma (:,:) Stress tensor (3,3) (Hartree/Bohr&#94;3) Type-Bound Procedures procedure, public :: destroy => result_destroy Clean up allocated memory procedure, public :: reset => result_reset Reset all values and flags type, public :: cc_energy_t Container for coupled cluster energy components Components Type Visibility Attributes Name Initial real(kind=dp), public :: doubles = 0.0_dp Doubles contribution (Hartree) real(kind=dp), public :: singles = 0.0_dp Singles contribution (Hartree) real(kind=dp), public :: triples = 0.0_dp Triples contribution (Hartree) Type-Bound Procedures procedure, public :: check_stability => cc_check_stability Check for positive energies (instability) procedure, public :: reset => cc_reset Reset all components to zero procedure, public :: total => cc_total Compute total CC correlation type, public :: energy_t Container for quantum chemistry energy components Read more… Components Type Visibility Attributes Name Initial type( cc_energy_t ), public :: cc Coupled cluster correlation components type( mp2_energy_t ), public :: mp2 MP2 correlation components real(kind=dp), public :: scf = 0.0_dp SCF/HF reference energy (Hartree) Type-Bound Procedures procedure, public :: reset => energy_reset Reset all components to zero procedure, public :: total => energy_total Compute total energy from components type, public :: mbe_result_t Container for Many-Body Expansion aggregated results Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dipole (:) Total dipole moment (3) (e*Bohr) real(kind=dp), public, allocatable :: dipole_derivatives (:,:) Dipole derivatives (3, 3*natoms) for IR intensities real(kind=dp), public, allocatable :: gradient (:,:) Total gradient (3, total_atoms) (Hartree/Bohr) logical, public :: has_dipole = .false. Dipole has been computed logical, public :: has_dipole_derivatives = .false. Dipole derivatives have been computed logical, public :: has_energy = .false. Energy has been computed logical, public :: has_gradient = .false. Gradient has been computed logical, public :: has_hessian = .false. Hessian has been computed real(kind=dp), public, allocatable :: hessian (:,:) Total Hessian (3 natoms, 3 natoms) real(kind=dp), public :: total_energy = 0.0_dp Total MBE energy (Hartree) Type-Bound Procedures procedure, public :: allocate_dipole => mbe_result_allocate_dipole procedure, public :: allocate_gradient => mbe_result_allocate_gradient procedure, public :: allocate_hessian => mbe_result_allocate_hessian procedure, public :: destroy => mbe_result_destroy Clean up allocated memory procedure, public :: reset => mbe_result_reset Reset all values and flags type, public :: mp2_energy_t Container for MP2 energy components (SS/OS) Components Type Visibility Attributes Name Initial real(kind=dp), public :: os = 0.0_dp Opposite-spin correlation energy (Hartree) real(kind=dp), public :: ss = 0.0_dp Same-spin correlation energy (Hartree) Type-Bound Procedures procedure, public :: check_stability => mp2_check_stability Check for positive energies (instability) procedure, public :: reset => mp2_reset Reset both components to zero procedure, public :: scs => mp2_scs Compute SCS-MP2 correlation procedure, public :: total => mp2_total Compute total MP2 correlation Functions private pure function cc_total (this) result(total) Compute total CC correlation energy Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Return Value real(kind=dp) private pure function energy_total (this) result(total) Compute total energy from all components Arguments Type Intent Optional Attributes Name class( energy_t ), intent(in) :: this Return Value real(kind=dp) private pure function mp2_scs (this) result(scs_energy) Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy\nSCS-MP2 uses: E_SCS = (1/3) E_SS + 1.2 E_OS Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) private pure function mp2_total (this) result(total) Compute total MP2 correlation energy Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Subroutines public  subroutine result_irecv (result, comm, source, tag, req) Receive calculation result over MPI (non-blocking)\nReceives SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(request_t), intent(out) :: req public  subroutine result_isend (result, comm, dest, tag, req) Send calculation result over MPI (non-blocking)\nSends SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag type(request_t), intent(out) :: req public  subroutine result_recv (result, comm, source, tag, status) Receive calculation result over MPI (blocking)\nReceives energy components and conditionally receives gradient based on flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(MPI_Status), intent(out) :: status public  subroutine result_send (result, comm, dest, tag) Send calculation result over MPI (blocking)\nSends energy components and conditionally sends gradient based on has_gradient flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag private  subroutine cc_check_stability (this) Check for positive CC correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this private  subroutine cc_reset (this) Reset all CC components to zero Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(inout) :: this private  subroutine energy_reset (this) Reset all energy components to zero Arguments Type Intent Optional Attributes Name class( energy_t ), intent(inout) :: this private  subroutine mbe_result_allocate_dipole (this) Allocate dipole array (always 3 components) Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this private  subroutine mbe_result_allocate_gradient (this, total_atoms) Allocate gradient array for total_atoms Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this integer, intent(in) :: total_atoms private  subroutine mbe_result_allocate_hessian (this, total_atoms) Allocate hessian array for total_atoms Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this integer, intent(in) :: total_atoms private  subroutine mbe_result_destroy (this) Clean up allocated memory in mbe_result_t Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this private  subroutine mbe_result_reset (this) Reset all values and flags in mbe_result_t Arguments Type Intent Optional Attributes Name class( mbe_result_t ), intent(inout) :: this private  subroutine mp2_check_stability (this) Check for positive MP2 correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this private  subroutine mp2_reset (this) Reset both MP2 components to zero Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(inout) :: this private  subroutine result_destroy (this) Clean up allocated memory in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this private  subroutine result_reset (this) Reset all values and flags in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this","tags":"","url":"module/mqc_result_types.html"},{"title":"mqc_config_parser – metalquicha","text":"Parses section-based input files with %section…end blocks\nThis is the new format generated by mqc_prep.py\n========================================================================\nGeneric parsing helpers to eliminate redundancy\n======================================================================== Uses mqc_error mqc_method_types pic_types mqc_geometry mqc_calc_types module~~mqc_config_parser~~UsesGraph module~mqc_config_parser mqc_config_parser module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_config_parser~~UsedByGraph module~mqc_config_parser mqc_config_parser module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_config_adapter module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_physical_fragment module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_physical_fragment->module~mqc_config_parser proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_config_parser proc~compute_gmbe->module~mqc_physical_fragment proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_config_parser proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->module~mqc_config_parser proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->module~mqc_config_parser proc~map_fragment_to_system_dipole_derivatives->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_config_parser proc~process_intersection_derivatives->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_parser program~main->module~mqc_config_adapter program~main->module~mqc_driver program~main->module~mqc_physical_fragment module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_dft mqc_method_dft module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~apply_distance_screening->module~mqc_physical_fragment proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_config_adapter proc~fragment_should_be_screened->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment module~mqc_json_writer->module~mqc_mbe_io module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_dft module~mqc_method_factory->module~mqc_method_hf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_factory->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_base proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_base proc~hessian_worker->module~mqc_method_factory proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_LINE_LEN = 1024 Derived Types type, public :: bond_t Bond definition with atom indices, order, and broken status Components Type Visibility Attributes Name Initial integer, public :: atom_i = 0 integer, public :: atom_j = 0 logical, public :: is_broken = .false. integer, public :: order = 1 type, public :: input_fragment_t Input fragment definition with charge, multiplicity, and atom indices\nThis is the parsed representation from the input file, not the computational fragment Components Type Visibility Attributes Name Initial integer, public :: charge = 0 integer, public, allocatable :: indices (:) Atom indices in this fragment integer, public :: multiplicity = 1 Type-Bound Procedures procedure, public :: destroy => input_fragment_destroy type, public :: molecule_t Single molecule definition with structure, geometry, fragments, and connectivity Components Type Visibility Attributes Name Initial type( bond_t ), public, allocatable :: bonds (:) integer, public :: charge = 0 type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry integer, public :: multiplicity = 1 character(len=:), public, allocatable :: name Optional molecule name integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 Type-Bound Procedures procedure, public :: destroy => molecule_destroy type, public :: mqc_config_t Complete configuration from .mqc file Components Type Visibility Attributes Name Initial real(kind=dp), public :: aimd_dt = 1.0_dp Timestep (femtoseconds) real(kind=dp), public :: aimd_initial_temperature = 300.0_dp Initial temperature for velocity init (K) integer, public :: aimd_nsteps = 0 Number of MD steps (0 = no AIMD) integer, public :: aimd_output_frequency = 1 Write output every N steps logical, public :: allow_overlapping_fragments = .false. character(len=:), public, allocatable :: aux_basis character(len=:), public, allocatable :: basis type( bond_t ), public, allocatable :: bonds (:) integer(kind=int32), public :: calc_type = CALC_TYPE_ENERGY integer, public :: charge = 0 integer, public :: cpcm_nang = 110 Number of angular grid points for CPCM cavity real(kind=dp), public :: cpcm_rscale = 1.0_dp Radii scaling factor for CPCM cavity character(len=:), public, allocatable :: cutoff_method real(kind=dp), public :: dielectric = -1.0_dp Direct dielectric constant (-1 = use solvent lookup) character(len=:), public, allocatable :: distance_metric character(len=:), public, allocatable :: embedding integer, public :: frag_level = 1 character(len=:), public, allocatable :: frag_method MBE, etc. real(kind=dp), public, allocatable :: fragment_cutoffs (:) Distance cutoffs indexed by n-mer level (2=dimer, 3=trimer, etc.) type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry real(kind=dp), public :: hessian_displacement = 0.001_dp Finite difference displacement (Bohr) real(kind=dp), public :: hessian_pressure = 1.0_dp Pressure for thermochemistry (atm) real(kind=dp), public :: hessian_temperature = 298.15_dp Temperature for thermochemistry (K) integer, public :: index_base = 0 0-based or 1-based indexing character(len=:), public, allocatable :: log_level integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method = METHOD_TYPE_GFN2 type( molecule_t ), public, allocatable :: molecules (:) Array of molecules (if nmol > 0) integer, public :: multiplicity = 1 integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 integer, public :: nmol = 0 Number of molecules (0 = single molecule mode for backward compatibility) integer, public :: scf_maxiter = 300 real(kind=dp), public :: scf_tolerance = 1.0e-6_dp character(len=:), public, allocatable :: schema_name character(len=:), public, allocatable :: schema_version logical, public :: skip_json_output = .false. Skip JSON output for large calculations character(len=:), public, allocatable :: solvation_model Solvation model: “alpb” (default), “gbsa”, or “cpcm” character(len=:), public, allocatable :: solvent Solvent name (e.g., “water”, “ethanol”) or empty for gas phase character(len=:), public, allocatable :: units angstrom or bohr logical, public :: use_cds = .true. Include non-polar CDS terms in solvation (not for CPCM) logical, public :: use_shift = .true. Include solution state shift in solvation (not for CPCM) Type-Bound Procedures procedure, public :: destroy => config_destroy Functions private  function parse_method_string (method_str) result(method_type) Parse method string from input file (e.g., “XTB-GFN1” -> gfn1) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Return Value integer(kind=int32) private pure function strip_comment (line) result(stripped) Remove comments (! or #) from a line and trim result Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value character(len=:), allocatable Subroutines public  subroutine read_mqc_file (filename, config, error) Read and parse a .mqc format input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( mqc_config_t ), intent(out) :: config type( error_t ), intent(out) :: error private  subroutine config_destroy (this) Clean up allocated memory in mqc_config_t Arguments Type Intent Optional Attributes Name class( mqc_config_t ), intent(inout) :: this private  subroutine input_fragment_destroy (this) Clean up allocated memory in input_fragment_t Arguments Type Intent Optional Attributes Name class( input_fragment_t ), intent(inout) :: this private  subroutine molecule_destroy (this) Clean up allocated memory in molecule_t Arguments Type Intent Optional Attributes Name class( molecule_t ), intent(inout) :: this private  subroutine parse_aimd_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_connectivity_generic (unit, nbonds, nbroken, bonds, error) Generic parser for %connectivity section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nbonds integer, intent(inout) :: nbroken type( bond_t ), intent(inout), allocatable :: bonds (:) type( error_t ), intent(out) :: error private  subroutine parse_connectivity_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_driver_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_fragment (unit, fragment, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error private  subroutine parse_fragmentation_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_fragments_generic (unit, nfrag, fragments, error) Generic parser for %fragments section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nfrag type( input_fragment_t ), intent(inout), allocatable :: fragments (:) type( error_t ), intent(out) :: error private  subroutine parse_fragments_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_geometry_generic (unit, geom, error) Generic parser for %geometry section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( geometry_type ), intent(inout) :: geom type( error_t ), intent(out) :: error private  subroutine parse_geometry_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_hessian_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_indices_line (line, fragment, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error private  subroutine parse_model_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_molecule_connectivity (unit, mol, error) Parse %connectivity section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecule_fragments (unit, mol, error) Parse %fragments section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecule_geometry (unit, mol, error) Parse %geometry section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecule_structure (unit, mol, error) Parse %structure section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecules_section (unit, config, error) Parse %molecules section containing multiple %molecule blocks Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_scf_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_schema_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_single_molecule (unit, mol, error) Parse a single %molecule block with its sections Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_structure_generic (unit, charge, multiplicity, error) Generic parser for %structure section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: charge integer, intent(inout) :: multiplicity type( error_t ), intent(out) :: error private  subroutine parse_structure_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_system_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_xtb_section (unit, config, error) Parse %xtb section for XTB-specific settings (solvation, etc.) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine skip_to_end (unit, error) Skip lines until ‘end’ marker is found Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( error_t ), intent(out) :: error private  subroutine validate_cutoffs (config, error) Validate that fragment cutoffs are monotonically decreasing\nFor n-mer level N, cutoff(N) must be <= cutoff(N-1) Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: config type( error_t ), intent(out) :: error","tags":"","url":"module/mqc_config_parser.html"},{"title":"mqc_io_helpers – metalquicha","text":"Used by module~~mqc_io_helpers~~UsedByGraph module~mqc_io_helpers mqc_io_helpers module~mqc_driver mqc_driver module~mqc_driver->module~mqc_io_helpers module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_json_writer->module~mqc_io_helpers proc~merge_multi_molecule_json merge_multi_molecule_json proc~merge_multi_molecule_json->module~mqc_io_helpers proc~read_json_content read_json_content proc~read_json_content->module~mqc_io_helpers proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_io_helpers program~main main program~main->module~mqc_io_helpers program~main->module~mqc_driver proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: current_basename = \"\" character(len=256), private :: output_json_filename = \"results.json\" Functions public  function ends_with (str, suffix) Check if string ends with suffix Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix Return Value logical public  function get_basename () result(basename) Get the base name without “output_” prefix and “.json” suffix\nExample: “output_w1.json” -> “w1” Arguments None Return Value character(len=256) public  function get_molecule_name (filename) result(name) Extract molecule name from filename\nExample: “output_multi_structure_molecule_1.json” -> “molecule_1” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value character(len=256) public  function get_output_json_filename () result(filename) Get the current JSON output filename Arguments None Return Value character(len=256) Subroutines public  subroutine set_molecule_suffix (suffix) Append a suffix to the output filename (e.g., for multi-molecule mode)\nExample: suffix=”_mol1” -> “output_multi_structure_mol1.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: suffix public  subroutine set_output_json_filename (input_filename) Set the JSON output filename based on input filename\nExample: “water.mqc” -> “output_water.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_filename","tags":"","url":"module/mqc_io_helpers.html"},{"title":"mqc_logo – metalquicha","text":"Provides the project branding sunflower logo and version information\ndisplayed at program startup.\nDisplay ASCII sunflower logo and project info Used by module~~mqc_logo~~UsedByGraph module~mqc_logo mqc_logo program~main main program~main->module~mqc_logo Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine print_logo () Print the PIC Chemistry ASCII sunflower logo Arguments None","tags":"","url":"module/mqc_logo.html"},{"title":"mqc_thermochemistry – metalquicha","text":"Computes thermodynamic properties from vibrational frequencies and molecular geometry. This module implements standard RRHO thermochemistry calculations including:\n- Zero-point vibrational energy (ZPE)\n- Translational, rotational, vibrational, and electronic contributions\n- Thermal corrections to energy, enthalpy, and Gibbs free energy Default conditions: T = 298.15 K, P = 1 atm\nOutput follows Gaussian-style formatting for compatibility. Uses pic_lapack_interfaces mqc_elements pic_io mqc_physical_constants pic_types pic_logger module~~mqc_thermochemistry~~UsesGraph module~mqc_thermochemistry mqc_thermochemistry module~mqc_elements mqc_elements module~mqc_thermochemistry->module~mqc_elements module~mqc_physical_constants mqc_physical_constants module~mqc_thermochemistry->module~mqc_physical_constants pic_io pic_io module~mqc_thermochemistry->pic_io pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces pic_logger pic_logger module~mqc_thermochemistry->pic_logger pic_types pic_types module~mqc_thermochemistry->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_constants->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_thermochemistry~~UsedByGraph module~mqc_thermochemistry mqc_thermochemistry module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_thermochemistry module~mqc_json_output_types mqc_json_output_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_thermochemistry module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_vibrational_analysis->module~mqc_thermochemistry proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_thermochemistry proc~hessian_coordinator->module~mqc_json_output_types proc~hessian_coordinator->module~mqc_vibrational_analysis proc~populate_vibrational_json_data populate_vibrational_json_data proc~populate_vibrational_json_data->module~mqc_thermochemistry proc~populate_vibrational_json_data->module~mqc_json_output_types proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->module~mqc_thermochemistry proc~unfragmented_calculation->module~mqc_json_output_types proc~unfragmented_calculation->module~mqc_vibrational_analysis module~mqc_driver mqc_driver module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_json_output_types module~mqc_driver->module~mqc_mbe module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_json_output_types proc~global_coordinator global_coordinator proc~global_coordinator->module~mqc_json_output_types proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~populate_unfragmented_json_data->module~mqc_json_output_types proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->module~mqc_json_output_types module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: DEFAULT_PRESSURE = 1.0_dp Default pressure in atm integer, public, parameter :: DEFAULT_SPIN_MULTIPLICITY = 1 Default spin multiplicity (singlet) integer, public, parameter :: DEFAULT_SYMMETRY_NUMBER = 1 Default symmetry number real(kind=dp), public, parameter :: DEFAULT_TEMPERATURE = 298.15_dp Default temperature in Kelvin real(kind=dp), private, parameter :: IMAG_FREQ_THRESHOLD = 0.0_dp Threshold for considering a frequency as imaginary real(kind=dp), private, parameter :: LINEAR_THRESHOLD = 1.0e-6_dp Threshold for considering a moment of inertia as zero (linear molecule detection) Derived Types type, public :: thermochemistry_result_t Container for thermochemistry calculation results Components Type Visibility Attributes Name Initial real(kind=dp), public :: Cv_rot = 0.0_dp Rotational heat capacity real(kind=dp), public :: Cv_trans = 0.0_dp Translational heat capacity real(kind=dp), public :: Cv_vib = 0.0_dp Vibrational heat capacity real(kind=dp), public :: E_elec = 0.0_dp Electronic thermal energy (always 0) real(kind=dp), public :: E_rot = 0.0_dp Rotational thermal energy real(kind=dp), public :: E_trans = 0.0_dp Translational thermal energy real(kind=dp), public :: E_vib = 0.0_dp Vibrational thermal energy (excluding ZPE) real(kind=dp), public :: S_elec = 0.0_dp Electronic entropy real(kind=dp), public :: S_rot = 0.0_dp Rotational entropy real(kind=dp), public :: S_trans = 0.0_dp Translational entropy real(kind=dp), public :: S_vib = 0.0_dp Vibrational entropy logical, public :: is_linear = .false. True if molecule is linear real(kind=dp), public :: moments (3) = 0.0_dp Principal moments of inertia in amu*Angstrom&#94;2 integer, public :: n_imag_freqs = 0 Number of imaginary frequencies (skipped) integer, public :: n_real_freqs = 0 Number of real vibrational frequencies real(kind=dp), public :: pressure = DEFAULT_PRESSURE Pressure in atm real(kind=dp), public :: q_rot = 0.0_dp Rotational partition function real(kind=dp), public :: q_trans = 0.0_dp Translational partition function real(kind=dp), public :: q_vib = 1.0_dp Vibrational partition function real(kind=dp), public :: rot_const (3) = 0.0_dp Rotational constants in GHz integer, public :: spin_multiplicity = DEFAULT_SPIN_MULTIPLICITY Electronic spin multiplicity integer, public :: symmetry_number = DEFAULT_SYMMETRY_NUMBER Rotational symmetry number real(kind=dp), public :: temperature = DEFAULT_TEMPERATURE Temperature in K real(kind=dp), public :: thermal_correction_energy = 0.0_dp E_tot = ZPE + E_trans + E_rot + E_vib real(kind=dp), public :: thermal_correction_enthalpy = 0.0_dp H = E_tot + RT real(kind=dp), public :: thermal_correction_gibbs = 0.0_dp G = H - TS real(kind=dp), public :: total_mass = 0.0_dp Total mass in amu real(kind=dp), public :: zpe_hartree = 0.0_dp ZPE in Hartree real(kind=dp), public :: zpe_kcalmol = 0.0_dp ZPE in kcal/mol Subroutines public  subroutine compute_electronic_entropy (spin_multiplicity, S_elec) Compute electronic entropy contribution. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: spin_multiplicity Electronic spin multiplicity (2S+1) real(kind=dp), intent(out) :: S_elec Electronic entropy in cal/(mol*K) public  subroutine compute_moments_of_inertia (coords, atomic_numbers, n_atoms, center_of_mass, moments, principal_axes, is_linear, total_mass) Compute the principal moments of inertia and detect linear molecules. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (:,:) Atomic coordinates (3, n_atoms) in Bohr integer, intent(in) :: atomic_numbers (:) Atomic numbers integer, intent(in) :: n_atoms Number of atoms real(kind=dp), intent(out) :: center_of_mass (3) Center of mass in Angstrom real(kind=dp), intent(out) :: moments (3) Principal moments in amu*Angstrom&#94;2 real(kind=dp), intent(out) :: principal_axes (3,3) Principal axis vectors (columns) logical, intent(out) :: is_linear True if molecule is linear real(kind=dp), intent(out) :: total_mass Total mass in amu public  subroutine compute_rotational_constants (moments, is_linear, rot_const) Convert moments of inertia to rotational constants in GHz. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: moments (3) Moments in amu*Angstrom&#94;2 logical, intent(in) :: is_linear True if linear molecule real(kind=dp), intent(out) :: rot_const (3) Rotational constants in GHz public  subroutine compute_rotational_thermo (moments, temperature, symmetry_number, is_linear, E, S, Cv) Compute rotational contributions to thermodynamic properties. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: moments (3) Principal moments in amu*Angstrom&#94;2 real(kind=dp), intent(in) :: temperature Temperature in K integer, intent(in) :: symmetry_number Rotational symmetry number logical, intent(in) :: is_linear True if linear molecule real(kind=dp), intent(out) :: E Thermal energy in Hartree real(kind=dp), intent(out) :: S Entropy in cal/(mol*K) real(kind=dp), intent(out) :: Cv Heat capacity in cal/(mol*K) public  subroutine compute_thermochemistry (coords, atomic_numbers, frequencies, n_atoms, n_freqs, result, temperature, pressure, symmetry_number, spin_multiplicity) Main driver for thermochemistry calculations. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: coords (:,:) Coordinates (3, n_atoms) in Bohr integer, intent(in) :: atomic_numbers (:) Atomic numbers real(kind=dp), intent(in) :: frequencies (:) Frequencies in cm&#94;-1 integer, intent(in) :: n_atoms Number of atoms integer, intent(in) :: n_freqs Number of frequencies type( thermochemistry_result_t ), intent(out) :: result Output results real(kind=dp), intent(in), optional :: temperature Temperature in K (default 298.15) real(kind=dp), intent(in), optional :: pressure Pressure in atm (default 1.0) integer, intent(in), optional :: symmetry_number Symmetry number (default 1) integer, intent(in), optional :: spin_multiplicity Spin multiplicity (default 1) public  subroutine compute_translational_thermo (total_mass, temperature, pressure, E, S, Cv) Compute translational contributions to thermodynamic properties. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_mass Total mass in amu real(kind=dp), intent(in) :: temperature Temperature in K real(kind=dp), intent(in) :: pressure Pressure in atm real(kind=dp), intent(out) :: E Thermal energy in Hartree real(kind=dp), intent(out) :: S Entropy in cal/(mol*K) real(kind=dp), intent(out) :: Cv Heat capacity in cal/(mol*K) public  subroutine compute_vibrational_thermo (frequencies, n_freqs, temperature, E, S, Cv) Compute vibrational contributions to thermodynamic properties. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frequencies (:) Frequencies in cm&#94;-1 integer, intent(in) :: n_freqs Number of frequencies real(kind=dp), intent(in) :: temperature Temperature in K real(kind=dp), intent(out) :: E Thermal energy in Hartree (excluding ZPE) real(kind=dp), intent(out) :: S Entropy in cal/(mol*K) real(kind=dp), intent(out) :: Cv Heat capacity in cal/(mol*K) public  subroutine compute_zpe (frequencies, n_freqs, n_real, zpe_hartree, zpe_kcalmol) Compute zero-point vibrational energy from frequencies. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frequencies (:) Vibrational frequencies in cm&#94;-1 integer, intent(in) :: n_freqs Total number of frequencies integer, intent(out) :: n_real Number of real (positive) frequencies used real(kind=dp), intent(out) :: zpe_hartree ZPE in Hartree real(kind=dp), intent(out) :: zpe_kcalmol ZPE in kcal/mol public  subroutine print_thermochemistry (result, electronic_energy, unit) Print thermochemistry results. Arguments Type Intent Optional Attributes Name type( thermochemistry_result_t ), intent(in) :: result real(kind=dp), intent(in) :: electronic_energy Electronic energy in Hartree integer, intent(in), optional :: unit Output unit (default: stdout) private  subroutine compute_partition_functions (total_mass, moments, frequencies, n_freqs, temperature, pressure, sigma, is_linear, q_trans, q_rot, q_vib) Compute partition functions for translation, rotation, and vibration. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: total_mass Total mass in amu real(kind=dp), intent(in) :: moments (3) Principal moments in amu*Angstrom&#94;2 real(kind=dp), intent(in) :: frequencies (:) Frequencies in cm&#94;-1 integer, intent(in) :: n_freqs Number of frequencies real(kind=dp), intent(in) :: temperature Temperature in K real(kind=dp), intent(in) :: pressure Pressure in atm integer, intent(in) :: sigma Symmetry number logical, intent(in) :: is_linear True if linear molecule real(kind=dp), intent(out) :: q_trans Translational partition function real(kind=dp), intent(out) :: q_rot Rotational partition function real(kind=dp), intent(out) :: q_vib Vibrational partition function","tags":"","url":"module/mqc_thermochemistry.html"},{"title":"mqc_combinatorics – metalquicha","text":"Provides pure combinatorial functions for generating molecular fragments\nincluding binomial coefficients, combinations, and fragment counting\nBinomial coefficient calculation\nCalculate total number of fragments\nGenerate sequential monomer indices\nGenerate all fragments up to max level\nGenerate all combinations of size r\nGenerate next combination in sequence\nInitialize combination to [1,2,…,k]\nGenerate next combination (alternate interface)\nDebug utility to print combinations\nCalculate minimal distances for all fragments Uses pic_types module~~mqc_combinatorics~~UsesGraph module~mqc_combinatorics mqc_combinatorics pic_types pic_types module~mqc_combinatorics->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_combinatorics~~UsedByGraph module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils mqc_frag_utils module~mqc_frag_utils->module~mqc_combinatorics module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_gmbe_utils proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_gmbe_utils module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public pure function binomial (n, r) result(c) Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) Read more… Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n Total number of items integer(kind=default_int), intent(in) :: r Number of items to choose Return Value integer(kind=int64) Binomial coefficient result public pure function get_nfrags (n_monomers, max_level) result(n_expected_fragments) Calculate total number of fragments for given system size and max level Read more… Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n_monomers Number of monomers in system integer(kind=default_int), intent(in) :: max_level Maximum fragment size Return Value integer(kind=int64) Total fragment count public  function next_combination (combination, k, n) result(has_next) Generate next combination in lexicographic order\nReturns .true. if there’s a next combination, .false. if we’ve exhausted all Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k integer, intent(in) :: n Return Value logical Subroutines public  subroutine calculate_fragment_distances (polymers, fragment_count, sys_geom, distances) Calculate minimal atomic distance for each fragment\nFor monomers (1-body), distance is 0.0\nFor n-mers (n >= 2), distance is the minimum distance between atoms\nin different constituent monomers Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: distances (:) public recursive subroutine combine (arr, n, r, out_array, count) Generate all combinations of size r from array arr of size n\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count public pure subroutine create_monomer_list (monomers) Generate a list of monomer indices from 1 to N Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(inout), allocatable :: monomers (:) public recursive subroutine generate_fragment_list (monomers, max_level, polymers, count) Generate all possible fragments (combinations of monomers) up to max_level\nUses int64 for count to handle large numbers of fragments that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: monomers (:) integer(kind=default_int), intent(in) :: max_level integer(kind=default_int), intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: count public pure subroutine get_next_combination (indices, k, n, has_next) Generate next combination (updates indices in place)\nhas_next = .true. if there’s a next combination Arguments Type Intent Optional Attributes Name integer, intent(inout) :: indices (:) integer, intent(in) :: k integer, intent(in) :: n logical, intent(out) :: has_next public  subroutine next_combination_init (combination, k) Initialize combination to [1, 2, …, k] Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k public  subroutine print_combos (out_array, count, max_len) Print combinations stored in out_array\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: out_array (:,:) integer(kind=int64), intent(in) :: count integer(kind=default_int), intent(in) :: max_len private recursive subroutine combine_util (arr, n, r, index, data, i, out_array, count) Utility for generating combinations recursively\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(in) :: index integer(kind=default_int), intent(inout) :: data (:) integer(kind=default_int), intent(in) :: i integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count","tags":"","url":"module/mqc_combinatorics.html"},{"title":"mqc_calculation_keywords – metalquicha","text":"Provides structured keyword types for calculation-specific settings\nThese types are embedded in driver_config_t to organize keywords by category Uses pic_types module~~mqc_calculation_keywords~~UsesGraph module~mqc_calculation_keywords mqc_calculation_keywords pic_types pic_types module~mqc_calculation_keywords->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_calculation_keywords~~UsedByGraph module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_config_adapter proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: aimd_keywords_t Ab initio molecular dynamics keywords Components Type Visibility Attributes Name Initial real(kind=dp), public :: dt = 1.0_dp Timestep (femtoseconds) real(kind=dp), public :: initial_temperature = 300.0_dp Initial temperature for velocity init (K) integer, public :: nsteps = 0 Number of MD steps (0 = no AIMD) integer, public :: output_frequency = 1 Write output every N steps type, public :: hessian_keywords_t Hessian calculation keywords Components Type Visibility Attributes Name Initial real(kind=dp), public :: displacement = 0.001_dp Finite difference displacement (Bohr) real(kind=dp), public :: pressure = 1.0_dp Pressure for thermochemistry (atm) real(kind=dp), public :: temperature = 298.15_dp Temperature for thermochemistry (K) type, public :: scf_keywords_t SCF calculation keywords (placeholder for future use) Components Type Visibility Attributes Name Initial real(kind=dp), public :: convergence_threshold = 1.0e-6_dp Convergence threshold for SCF integer, public :: max_iterations = 100 Maximum SCF iterations logical, public :: use_diis = .true. Use DIIS acceleration","tags":"","url":"module/mqc_calculation_keywords.html"},{"title":"mqc_cgto – metalquicha","text":"Defines data structures for cartesian contracted Gaussian type orbitals (CGTOs) Uses pic_types module~~mqc_cgto~~UsesGraph module~mqc_cgto mqc_cgto pic_types pic_types module~mqc_cgto->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_cgto~~UsedByGraph module~mqc_cgto mqc_cgto module~mqc_basis_reader mqc_basis_reader module~mqc_basis_reader->module~mqc_cgto module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_cgto module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_dft mqc_method_dft module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_physical_fragment proc~apply_distance_screening->module~mqc_config_adapter proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_physical_fragment proc~fragment_should_be_screened->module~mqc_config_adapter proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer->module~mqc_mbe_io module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_dft module~mqc_method_factory->module~mqc_method_hf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_factory->module~mqc_method_xtb module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_base proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_base proc~hessian_worker->module~mqc_method_factory proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: atomic_basis_type Atomic basis set data structure Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: element element symbol integer, public :: nshells number of shells in type type( cgto_type ), public, allocatable :: shells (:) array of contracted shells Type-Bound Procedures procedure, public :: allocate_shells => allocate_basis_shells procedure, public :: destroy => atomic_basis_destroy procedure, public :: num_basis_functions => atomic_basis_num_basis_functions type, public :: cgto_type Contracted Gaussian type orbital (CGTO) data structure Components Type Visibility Attributes Name Initial integer, public :: ang_mom Angular momentum quantum number (0=s, 1=p, 2=d, etc.) real(kind=dp), public, allocatable :: coefficients (:) Contraction coefficients real(kind=dp), public, allocatable :: exponents (:) Exponents (alpha values) integer, public :: nfunc Number of primitive Gaussians in the contraction Type-Bound Procedures procedure, public :: allocate_arrays => cgto_allocate_arrays procedure, public :: destroy => cgto_destroy procedure, public :: num_basis_functions => cgto_num_basis_functions type, public :: molecular_basis_type Molecular basis set data structure (assembled basis) Components Type Visibility Attributes Name Initial type( atomic_basis_type ), public, allocatable :: elements (:) array of atomic basis types integer, public :: nelements total number of atoms/elements in a molecule Type-Bound Procedures procedure, public :: allocate_elements => basis_set_allocate_elements procedure, public :: destroy => basis_set_destroy procedure, public :: num_basis_functions => molecular_basis_num_basis_functions Functions private pure function atomic_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for an atom Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer private pure function cgto_num_basis_functions (self) result(nbf) Get number of basis functions in a shell (Cartesian) Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer private pure function molecular_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for the molecule Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Subroutines private pure subroutine allocate_basis_shells (self, nshells) Allocate array of shells in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells private pure subroutine atomic_basis_destroy (self) Clean up allocated memory in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self private pure subroutine basis_set_allocate_elements (self, nelements) Allocate array of atomic basis elements in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements private pure subroutine basis_set_destroy (self) Clean up allocated memory in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self private pure subroutine cgto_allocate_arrays (self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc private pure subroutine cgto_destroy (self) Clean up allocated memory in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self","tags":"","url":"module/mqc_cgto.html"},{"title":"mqc_method_types – metalquicha","text":"Defines integer constants for quantum chemistry methods to avoid string comparisons\nthroughout the codebase. Provides conversion utilities between string\nrepresentations and integer constants. Uses pic_types module~~mqc_method_types~~UsesGraph module~mqc_method_types mqc_method_types pic_types pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_types~~UsedByGraph module~mqc_method_types mqc_method_types module~mqc_config_parser mqc_config_parser module~mqc_config_parser->module~mqc_method_types module~mqc_driver mqc_driver module~mqc_driver->module~mqc_method_types module~mqc_driver->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_method_config mqc_method_config module~mqc_driver->module~mqc_method_config module~mqc_config_adapter mqc_config_adapter module~mqc_driver->module~mqc_config_adapter module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_physical_fragment mqc_physical_fragment module~mqc_driver->module~mqc_physical_fragment module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_config->module~mqc_method_types module~mqc_method_factory->module~mqc_method_types module~mqc_method_factory->module~mqc_method_config module~mqc_method_factory->module~mqc_method_base module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_config_parser module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_physical_fragment->module~mqc_config_parser module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_config_parser proc~compute_gmbe->module~mqc_physical_fragment proc~compute_mbe compute_mbe proc~compute_mbe->module~mqc_config_parser proc~compute_mbe_dipole_derivatives compute_mbe_dipole_derivatives proc~compute_mbe_dipole_derivatives->module~mqc_config_parser proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_factory module~mqc_finite_differences mqc_finite_differences proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_base proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_factory proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_base proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->module~mqc_config_parser proc~map_fragment_to_system_dipole_derivatives->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_config_parser proc~process_intersection_derivatives->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_parser program~main->module~mqc_driver program~main->module~mqc_config_adapter program~main->module~mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~apply_distance_screening->module~mqc_physical_fragment proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_config_adapter proc~fragment_should_be_screened->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment module~mqc_json_writer->module~mqc_mbe_io proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: METHOD_TYPE_CCSD = 40 integer(kind=int32), public, parameter :: METHOD_TYPE_CCSD_F12 = 42 integer(kind=int32), public, parameter :: METHOD_TYPE_CCSD_T = 41 CCSD(T) integer(kind=int32), public, parameter :: METHOD_TYPE_CCSD_T_F12 = 43 CCSD(T)-F12 integer(kind=int32), public, parameter :: METHOD_TYPE_DFT = 11 integer(kind=int32), public, parameter :: METHOD_TYPE_GFN1 = 1 integer(kind=int32), public, parameter :: METHOD_TYPE_GFN2 = 2 integer(kind=int32), public, parameter :: METHOD_TYPE_HF = 10 integer(kind=int32), public, parameter :: METHOD_TYPE_MCSCF = 20 integer(kind=int32), public, parameter :: METHOD_TYPE_MP2 = 30 integer(kind=int32), public, parameter :: METHOD_TYPE_MP2_F12 = 31 integer(kind=int32), public, parameter :: METHOD_TYPE_UNKNOWN = 0 Functions public pure function method_type_from_string (method_str) result(method_type) Convert method type string to integer constant Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Input string (e.g., “gfn1”, “gfn2”, “hf”) Return Value integer(kind=int32) Output integer constant public pure function method_type_to_string (method_type) result(method_str) Convert method type integer constant to string Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: method_type Input integer constant Return Value character(len=:), allocatable Output string representation","tags":"","url":"module/mqc_method_types.html"},{"title":"mqc_elements – metalquicha","text":"Provides atomic numbers, element symbols, and atomic masses for the complete\nperiodic table (elements 1-118) with conversion functions between representations.\nConvert element symbol to atomic number\nConvert atomic number to element symbol\nGet atomic mass by atomic number Uses pic_ascii pic_types module~~mqc_elements~~UsesGraph module~mqc_elements mqc_elements pic_ascii pic_ascii module~mqc_elements->pic_ascii pic_types pic_types module~mqc_elements->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_elements~~UsedByGraph module~mqc_elements mqc_elements module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_elements module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_io->module~mqc_elements module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_physical_fragment->module~mqc_elements module~mqc_thermochemistry mqc_thermochemistry module~mqc_thermochemistry->module~mqc_elements module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_adapter module~mqc_driver->module~mqc_physical_fragment module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_json_output_types mqc_json_output_types module~mqc_driver->module~mqc_json_output_types module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_thermochemistry module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_json_writer->module~mqc_mbe_io module~mqc_json_writer->module~mqc_json_output_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_thermochemistry module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_dft mqc_method_dft module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_config_adapter proc~apply_distance_screening->module~mqc_physical_fragment proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_json_output_types proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_config_adapter proc~fragment_should_be_screened->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_thermochemistry proc~hessian_coordinator->module~mqc_vibrational_analysis proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_json_output_types proc~hessian_coordinator->module~mqc_method_base proc~hessian_coordinator->module~mqc_method_factory proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~populate_vibrational_json_data populate_vibrational_json_data proc~populate_vibrational_json_data->module~mqc_thermochemistry proc~populate_vibrational_json_data->module~mqc_json_output_types proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->module~mqc_thermochemistry proc~unfragmented_calculation->module~mqc_vibrational_analysis proc~unfragmented_calculation->module~mqc_json_output_types program~main main program~main->module~mqc_config_adapter program~main->module~mqc_physical_fragment program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_dft module~mqc_method_factory->module~mqc_method_hf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_factory->module~mqc_method_xtb module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~global_coordinator global_coordinator proc~global_coordinator->module~mqc_json_output_types proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_base proc~hessian_worker->module~mqc_method_factory proc~populate_unfragmented_json_data populate_unfragmented_json_data proc~populate_unfragmented_json_data->module~mqc_json_output_types proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->module~mqc_json_output_types proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: element_masses (n_elements) = [1.008_dp, 4.0026_dp, 6.94_dp, 9.0122_dp, 10.81_dp, 12.011_dp, 14.007_dp, 15.999_dp, 18.998_dp, 20.180_dp, 22.990_dp, 24.305_dp, 26.982_dp, 28.085_dp, 30.974_dp, 32.06_dp, 35.45_dp, 39.948_dp, 39.098_dp, 40.078_dp, 44.956_dp, 47.867_dp, 50.942_dp, 51.996_dp, 54.938_dp, 55.845_dp, 58.933_dp, 58.693_dp, 63.546_dp, 65.38_dp, 69.723_dp, 72.630_dp, 74.922_dp, 78.971_dp, 79.904_dp, 83.798_dp, 85.468_dp, 87.62_dp, 88.906_dp, 91.224_dp, 92.906_dp, 95.95_dp, 98.0_dp, 101.07_dp, 102.91_dp, 106.42_dp, 107.87_dp, 112.41_dp, 114.82_dp, 118.71_dp, 121.76_dp, 127.60_dp, 126.90_dp, 131.29_dp, 132.91_dp, 137.33_dp, 138.91_dp, 140.12_dp, 140.91_dp, 144.24_dp, 145.0_dp, 150.36_dp, 151.96_dp, 157.25_dp, 158.93_dp, 162.50_dp, 164.93_dp, 167.26_dp, 168.93_dp, 173.05_dp, 174.97_dp, 178.49_dp, 180.95_dp, 183.84_dp, 186.21_dp, 190.23_dp, 192.22_dp, 195.08_dp, 196.97_dp, 200.59_dp, 204.38_dp, 207.2_dp, 208.98_dp, 209.0_dp, 210.0_dp, 222.0_dp, 223.0_dp, 226.0_dp, 227.0_dp, 232.04_dp, 231.04_dp, 238.03_dp, 237.0_dp, 244.0_dp, 243.0_dp, 247.0_dp, 247.0_dp, 251.0_dp, 252.0_dp, 257.0_dp, 258.0_dp, 259.0_dp, 262.0_dp, 267.0_dp, 268.0_dp, 271.0_dp, 272.0_dp, 270.0_dp, 276.0_dp, 281.0_dp, 280.0_dp, 285.0_dp, 284.0_dp, 289.0_dp, 288.0_dp, 293.0_dp, 294.0_dp, 294.0_dp] Standard atomic masses in atomic mass units (amu)\nBased on IUPAC standard atomic weights, ordered by atomic number character(len=2), private, parameter :: element_symbols (n_elements) = [character(len=2)::'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og'] Element symbols for the complete periodic table (H through Og)\nOrdered by atomic number from 1 to 118 integer, private, parameter :: n_elements = 118 Functions public pure function element_mass (atomic_number) result(mass) Return atomic mass in atomic mass units (amu) for a given atomic number\nUses standard atomic weights from IUPAC Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value real(kind=dp) public pure function element_number_to_symbol (atomic_number) result(symbol) Convert atomic number to element symbol\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value character(len=2) public pure function element_symbol_to_number (symbol) result(atomic_number) Convert element symbol to atomic number\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Return Value integer","tags":"","url":"module/mqc_elements.html"},{"title":"mqc_json – metalquicha","text":"Uses pic_logger pic_io module~~mqc_json~~UsesGraph module~mqc_json mqc_json pic_io pic_io module~mqc_json->pic_io pic_logger pic_logger module~mqc_json->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_json~~UsedByGraph module~mqc_json mqc_json module~mqc_driver mqc_driver module~mqc_driver->module~mqc_json proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_json proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine merge_multi_molecule_json (individual_files, nmol) Merge individual molecule JSON files into a single combined file Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: individual_files (:) integer, intent(in) :: nmol private  subroutine read_json_content (unit_in, mol_index, unit_out, filename) Read and write JSON content from an individual molecule file\nProperly handles nested structures from fragmented calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit_in integer, intent(in) :: mol_index integer, intent(in) :: unit_out character(len=*), intent(in) :: filename","tags":"","url":"module/mqc_json.html"},{"title":"mqc_physical_fragment – metalquicha","text":"Physical molecular fragment representation and geometry handling Provides data structures and utilities for managing molecular fragments\nwith atomic coordinates, electronic properties, and geometric operations.\nSingle molecular fragment type\nComplete system geometry type\nSystem geometry initialization\nExtract fragment from system\nBuild fragment from explicit atom indices (for intersections)\nValidate fragment has no overlapping atoms Redistribute hydrogen cap gradients to original atoms\nRedistribute hydrogen cap Hessian to original atoms\nRedistribute hydrogen cap dipole derivatives to original atoms\nUnit conversion utilities\nCalculate minimal distance between monomers in a fragment Uses mqc_xyz_reader mqc_elements mqc_error mqc_config_parser mqc_cgto pic_types mqc_physical_constants mqc_geometry module~~mqc_physical_fragment~~UsesGraph module~mqc_physical_fragment mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_physical_fragment~~UsedByGraph module~mqc_physical_fragment mqc_physical_fragment module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_dft mqc_method_dft module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~apply_distance_screening apply_distance_screening proc~apply_distance_screening->module~mqc_physical_fragment proc~apply_distance_screening->module~mqc_config_adapter proc~calculate_fragment_distances calculate_fragment_distances proc~calculate_fragment_distances->module~mqc_physical_fragment proc~compute_gmbe compute_gmbe proc~compute_gmbe->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~fragment_should_be_screened fragment_should_be_screened proc~fragment_should_be_screened->module~mqc_physical_fragment proc~fragment_should_be_screened->module~mqc_config_adapter proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_dipole_derivatives map_fragment_to_system_dipole_derivatives proc~map_fragment_to_system_dipole_derivatives->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~process_intersection_derivatives process_intersection_derivatives proc~process_intersection_derivatives->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_json_writer->module~mqc_mbe_io module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_dft module~mqc_method_factory->module~mqc_method_hf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_factory->module~mqc_method_xtb module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_config_adapter proc~compute_energy_and_forces->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_config_adapter proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_base proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_base proc~hessian_worker->module~mqc_method_factory proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: physical_fragment_t Physical molecular fragment with atomic coordinates and properties Read more… Components Type Visibility Attributes Name Initial type( molecular_basis_type ), public, allocatable :: basis Gaussian basis functions integer, public, allocatable :: cap_replaces_atom (:) Original atom index that each cap replaces (size: n_caps) integer, public :: charge = 0 Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) Cartesian coordinates (3, n_atoms) in Bohr real(kind=dp), public :: distance = 0.0_dp Minimal atomic distance between monomers in fragment (Angstrom, 0 for monomers) integer, public, allocatable :: element_numbers (:) Atomic numbers (Z values) integer, public, allocatable :: local_to_global (:) Map fragment atom index to system atom index (size: n_atoms - n_caps) integer, public :: multiplicity = 1 Spin multiplicity (2S+1) integer, public :: n_atoms Number of atoms in this fragment integer, public :: n_caps = 0 Number of hydrogen caps added (always at end of atom list) integer, public :: nelec = 0 Total number of electrons Type-Bound Procedures procedure, public :: compute_nelec => fragment_compute_nelec Calculate electron count procedure, public :: destroy => fragment_destroy Memory cleanup procedure, public :: set_basis => fragment_set_basis Assign basis set type, public :: system_geometry_t Complete molecular system geometry for fragment-based calculations Read more… Components Type Visibility Attributes Name Initial integer, public :: atoms_per_monomer Atoms in each monomer (0 if variable-sized) integer, public :: charge Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) All coordinates (3, total_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers for all atoms integer, public, allocatable :: fragment_atoms (:,:) Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer, public, allocatable :: fragment_charges (:) Charge for each fragment (n_monomers) integer, public, allocatable :: fragment_multiplicities (:) Multiplicity for each fragment (n_monomers) integer, public, allocatable :: fragment_sizes (:) Number of atoms in each fragment (n_monomers) integer, public :: multiplicity Spin multiplicity (2S+1) integer, public :: n_monomers Number of monomer units in system integer, public :: total_atoms Total number of atoms Type-Bound Procedures procedure, public :: destroy => system_destroy Memory cleanup Functions public pure function calculate_monomer_distance (sys_geom, monomer_indices) result(min_distance) Calculate minimal atomic distance between monomers in a fragment\nFor single monomer (size 1), returns 0.0\nFor multi-monomer fragments, returns minimal distance between atoms in different monomers\nResult is in Angstrom Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) Return Value real(kind=dp) public pure elemental function to_angstrom (bohr_value) result(angstrom_value) Convert coordinate from Bohr to Angstrom Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: bohr_value Return Value real(kind=dp) public pure elemental function to_bohr (angstrom_value) result(bohr_value) Convert coordinate from Angstrom to Bohr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: angstrom_value Return Value real(kind=dp) Subroutines public  subroutine build_fragment_from_atom_list (sys_geom, atom_indices, n_atoms, fragment, error, bonds) Build a fragment from explicit atom list (for GMBE intersection fragments) Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: atom_indices (:) 0-indexed atom indices integer, intent(in) :: n_atoms Number of atoms in list type( physical_fragment_t ), intent(out) :: fragment type( error_t ), intent(out) :: error type( bond_t ), intent(in), optional :: bonds (:) Connectivity for capping public  subroutine build_fragment_from_indices (sys_geom, monomer_indices, fragment, error, bonds) Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) type( physical_fragment_t ), intent(out) :: fragment type( error_t ), intent(out) :: error type( bond_t ), intent(in), optional :: bonds (:) Connectivity information for capping public  subroutine check_duplicate_atoms (fragment, error) Validate that fragment has no spatially overlapping atoms\nChecks if any two atoms are too close together (< 0.01 Bohr)\nThis catches bugs in geometry construction or fragment building Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment type( error_t ), intent(out) :: error public  subroutine initialize_system_geometry (full_geom_file, monomer_file, sys_geom, error) Read full geometry and monomer template, initialize system_geometry_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full_geom_file character(len=*), intent(in) :: monomer_file type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error public  subroutine redistribute_cap_dipole_derivatives (fragment, fragment_dipole_derivs, system_dipole_derivs) Redistribute hydrogen cap dipole derivatives to original atoms Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_dipole_derivs (:,:) (3, 3*n_atoms_fragment) real(kind=dp), intent(inout) :: system_dipole_derivs (:,:) (3, 3*n_atoms_system) public  subroutine redistribute_cap_gradients (fragment, fragment_gradient, system_gradient) Redistribute hydrogen cap gradients to original atoms Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_gradient (:,:) (3, n_atoms_fragment) real(kind=dp), intent(inout) :: system_gradient (:,:) (3, n_atoms_system) public  subroutine redistribute_cap_hessian (fragment, fragment_hessian, system_hessian) Redistribute hydrogen cap Hessian to original atoms Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_hessian (:,:) (3 n_atoms_fragment, 3 n_atoms_fragment) real(kind=dp), intent(inout) :: system_hessian (:,:) (3 n_atoms_system, 3 n_atoms_system) private  subroutine add_hydrogen_caps (atoms_in_fragment, bonds, sys_geom, fragment, base_atom_count) Add hydrogen caps to fragment for broken bonds\nCaps are placed at the position of the atom outside the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in) :: bonds (:) type( system_geometry_t ), intent(in) :: sys_geom type( physical_fragment_t ), intent(inout) :: fragment integer, intent(in) :: base_atom_count Number of non-cap atoms private  subroutine count_hydrogen_caps (atoms_in_fragment, bonds, n_caps) Count how many hydrogen caps are needed for a fragment\nA cap is needed when exactly one atom of a broken bond is in the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in), optional :: bonds (:) integer, intent(out) :: n_caps private  subroutine fragment_compute_nelec (this) Compute number of electrons from atomic numbers and charge Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this private  subroutine fragment_destroy (this) Clean up allocated memory in physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this private  subroutine fragment_set_basis (this, basis) Set the basis set for this fragment Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis private  subroutine system_destroy (this) Clean up allocated memory in system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this","tags":"","url":"module/mqc_physical_fragment.html"},{"title":"mqc_vibrational_analysis – metalquicha","text":"Computes vibrational frequencies from the mass-weighted Hessian matrix.\nUses LAPACK eigenvalue decomposition via pic-blas interfaces. Uses mqc_thermochemistry pic_lapack_interfaces mqc_elements mqc_physical_constants pic_types pic_logger module~~mqc_vibrational_analysis~~UsesGraph module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_elements mqc_elements module~mqc_vibrational_analysis->module~mqc_elements module~mqc_physical_constants mqc_physical_constants module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_thermochemistry mqc_thermochemistry module~mqc_vibrational_analysis->module~mqc_thermochemistry pic_lapack_interfaces pic_lapack_interfaces module~mqc_vibrational_analysis->pic_lapack_interfaces pic_logger pic_logger module~mqc_vibrational_analysis->pic_logger pic_types pic_types module~mqc_vibrational_analysis->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_constants->pic_types module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->module~mqc_physical_constants module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types pic_io pic_io module~mqc_thermochemistry->pic_io Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_vibrational_analysis~~UsedByGraph module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_vibrational_analysis proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_vibrational_analysis proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->module~mqc_vibrational_analysis module~mqc_driver mqc_driver module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine compute_cartesian_displacements (eigenvectors, element_numbers, cartesian_displacements, normalize_max) Convert mass-weighted eigenvectors to Cartesian displacements. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvectors (:,:) Mass-weighted eigenvectors (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N), columns are modes logical, intent(in), optional :: normalize_max If true, normalize so max displacement = 1 (default: true) public  subroutine compute_force_constants (eigenvalues, reduced_masses, force_constants, force_constants_mdyne) Compute force constants for each normal mode. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvalues (:) Eigenvalues from mass-weighted Hessian diagonalization (1/amu) real(kind=dp), intent(in) :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(out), allocatable :: force_constants (:) Force constants in atomic units (Hartree/Bohr²) real(kind=dp), intent(out), optional, allocatable :: force_constants_mdyne (:) Force constants in mdyne/Å (common experimental unit) public  subroutine compute_ir_intensities (dipole_derivatives, eigenvectors, element_numbers, ir_intensities) Compute IR intensities from dipole derivatives and normal modes. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: dipole_derivatives (:,:) Cartesian dipole derivatives (3, 3*N) in atomic units real(kind=dp), intent(in) :: eigenvectors (:,:) Mass-weighted eigenvectors from Hessian diagonalization (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: ir_intensities (:) IR intensities in km/mol (one per mode) public  subroutine compute_reduced_masses (eigenvectors, element_numbers, reduced_masses) Compute reduced masses for each normal mode. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: eigenvectors (:,:) Mass-weighted eigenvectors from diagonalization (3 N x 3 N)\nColumns are normal modes, assumed normalized (Σ_i L²_{i,k} = 1) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: reduced_masses (:) Reduced masses in amu (one per mode) public  subroutine compute_vibrational_analysis (hessian, element_numbers, frequencies, reduced_masses, force_constants, cartesian_displacements, eigenvalues_out, eigenvectors_out, coordinates, project_trans_rot, force_constants_mdyne, dipole_derivatives, ir_intensities) Perform complete vibrational analysis from Hessian matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Hessian matrix in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: frequencies (:) Vibrational frequencies in cm⁻¹ real(kind=dp), intent(out), allocatable :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(out), allocatable :: force_constants (:) Force constants in Hartree/Bohr² real(kind=dp), intent(out), allocatable :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N) real(kind=dp), intent(out), optional, allocatable :: eigenvalues_out (:) Raw eigenvalues from diagonalization real(kind=dp), intent(out), optional, allocatable :: eigenvectors_out (:,:) Mass-weighted eigenvectors real(kind=dp), intent(in), optional :: coordinates (:,:) Atomic coordinates in Bohr (3, N) - required for projection logical, intent(in), optional :: project_trans_rot If true, project out translation/rotation modes real(kind=dp), intent(out), optional, allocatable :: force_constants_mdyne (:) Force constants in mdyne/Å real(kind=dp), intent(in), optional :: dipole_derivatives (:,:) Cartesian dipole derivatives (3, 3*N) in a.u. for IR intensities real(kind=dp), intent(out), optional, allocatable :: ir_intensities (:) IR intensities in km/mol public  subroutine compute_vibrational_frequencies (hessian, element_numbers, frequencies, eigenvalues_out, eigenvectors, coordinates, project_trans_rot, projected_hessian_out) Compute vibrational frequencies from the Hessian matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Hessian matrix in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: frequencies (:) Vibrational frequencies in cm⁻¹ (3 N modes, or 3 N-6 if projected) real(kind=dp), intent(out), optional, allocatable :: eigenvalues_out (:) Raw eigenvalues from diagonalization (Hartree/Bohr²/amu) real(kind=dp), intent(out), optional, allocatable :: eigenvectors (:,:) Normal mode eigenvectors (3 N x 3 N), columns are modes real(kind=dp), intent(in), optional :: coordinates (:,:) Atomic coordinates in Bohr (3, N) - required for projection logical, intent(in), optional :: project_trans_rot If true, project out translation/rotation modes (requires coordinates) real(kind=dp), intent(out), optional, allocatable :: projected_hessian_out (:,:) Mass-weighted Hessian after trans/rot projection (before diagonalization) public  subroutine mass_weight_hessian (hessian, element_numbers, mw_hessian) Apply mass weighting to Hessian matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: hessian (:,:) Input Hessian in Hartree/Bohr² (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms) real(kind=dp), intent(out), allocatable :: mw_hessian (:,:) Mass-weighted Hessian (3 N x 3 N) public  subroutine print_vibrational_analysis (frequencies, reduced_masses, force_constants, cartesian_displacements, element_numbers, force_constants_mdyne, print_displacements, n_atoms, ir_intensities, coordinates, electronic_energy, temperature, pressure) Print vibrational analysis results in a formatted table. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frequencies (:) Vibrational frequencies in cm⁻¹ real(kind=dp), intent(in) :: reduced_masses (:) Reduced masses in amu real(kind=dp), intent(in) :: force_constants (:) Force constants in Hartree/Bohr² (or mdyne/Å if force_constants_mdyne provided) real(kind=dp), intent(in) :: cartesian_displacements (:,:) Cartesian displacement vectors (3 N x 3 N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom real(kind=dp), intent(in), optional :: force_constants_mdyne (:) Force constants in mdyne/Å (if provided, these are printed instead) logical, intent(in), optional :: print_displacements If true, print Cartesian displacement vectors (default: true) integer, intent(in), optional :: n_atoms Number of atoms (if not provided, derived from size of element_numbers) real(kind=dp), intent(in), optional :: ir_intensities (:) IR intensities in km/mol real(kind=dp), intent(in), optional :: coordinates (:,:) Atomic coordinates (3, n_atoms) in Bohr - needed for thermochemistry real(kind=dp), intent(in), optional :: electronic_energy Electronic energy in Hartree - needed for thermochemistry real(kind=dp), intent(in), optional :: temperature Temperature for thermochemistry in K (default: 298.15) real(kind=dp), intent(in), optional :: pressure Pressure for thermochemistry in atm (default: 1.0) public  subroutine project_translation_rotation (mw_hessian, coordinates, element_numbers) Project out translation and rotation modes from mass-weighted Hessian. Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: mw_hessian (:,:) Mass-weighted Hessian (modified in place) real(kind=dp), intent(in) :: coordinates (:,:) Atomic coordinates in Bohr (3, N) integer, intent(in) :: element_numbers (:) Atomic numbers for each atom (N atoms)","tags":"","url":"module/mqc_vibrational_analysis.html"},{"title":"mqc_method_dft – metalquicha","text":"Implements Kohn-Sham DFT quantum chemistry method\nProvides energy and gradient calculations using self-consistent field\nwith exchange-correlation functionals. Uses mqc_method_base mqc_result_types mqc_physical_fragment pic_types module~~mqc_method_dft~~UsesGraph module~mqc_method_dft mqc_method_dft module~mqc_method_base mqc_method_base module~mqc_method_dft->module~mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_dft->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_dft->module~mqc_result_types pic_types pic_types module~mqc_method_dft->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_physical_constants->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_dft~~UsedByGraph module~mqc_method_dft mqc_method_dft module~mqc_method_factory mqc_method_factory module~mqc_method_factory->module~mqc_method_dft module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_factory proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_factory module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( qc_method_t ) :: dft_method_t DFT method implementation Read more… Components Type Visibility Attributes Name Initial type( dft_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => dft_calc_energy procedure, public :: calc_gradient => dft_calc_gradient procedure, public :: calc_hessian => dft_calc_hessian type, public :: dft_options_t DFT calculation options Components Type Visibility Attributes Name Initial integer, public :: angular_points = 302 Number of angular grid points (Lebedev) character(len=32), public :: aux_basis_set = '' Auxiliary basis set for density fitting character(len=32), public :: basis_set = 'sto-3g' Basis set name real(kind=dp), public :: density_tol = 1.0e-6_dp Density matrix convergence threshold integer, public :: diis_size = 8 Number of Fock matrices in DIIS character(len=8), public :: dispersion_type = 'd3bj' Dispersion type: “d3”, “d3bj”, “d4” real(kind=dp), public :: energy_tol = 1.0e-8_dp Energy convergence threshold character(len=32), public :: functional = 'b3lyp' Exchange-correlation functional character(len=16), public :: grid_type = 'medium' Integration grid quality integer, public :: max_iter = 100 Maximum SCF iterations integer, public :: radial_points = 75 Number of radial grid points per atom logical, public :: spherical = .true. Use spherical (true) or Cartesian (false) basis logical, public :: use_density_fitting = .false. Use RI-J approximation logical, public :: use_diis = .true. Use DIIS for SCF convergence logical, public :: use_dispersion = .false. Add empirical dispersion correction logical, public :: verbose = .false. Print SCF iterations Subroutines private  subroutine dft_calc_energy (this, fragment, result) Calculate electronic energy using Kohn-Sham DFT Read more… Arguments Type Intent Optional Attributes Name class( dft_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine dft_calc_gradient (this, fragment, result) Calculate energy gradient using Kohn-Sham DFT Read more… Arguments Type Intent Optional Attributes Name class( dft_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine dft_calc_hessian (this, fragment, result) Calculate energy Hessian using Kohn-Sham DFT Read more… Arguments Type Intent Optional Attributes Name class( dft_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result","tags":"","url":"module/mqc_method_dft.html"},{"title":"mqc_resources – metalquicha","text":"Container type for calculation resources - extensible for future needs Uses mqc_mpi_comms module~~mqc_resources~~UsesGraph module~mqc_resources mqc_resources module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms pic_mpi_lib pic_mpi_lib module~mqc_mpi_comms->pic_mpi_lib Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_resources~~UsedByGraph module~mqc_resources mqc_resources module~mqc_calculation_interface mqc_calculation_interface module~mqc_calculation_interface->module~mqc_resources module~mqc_driver mqc_driver module~mqc_driver->module~mqc_resources module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_resources proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_resources program~main main program~main->module~mqc_resources program~main->module~mqc_driver module~mpi_fragment_work_smod mpi_fragment_work_smod module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme proc~compute_energy_and_forces compute_energy_and_forces proc~compute_energy_and_forces->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: resources_t Container for calculation resources Read more… Components Type Visibility Attributes Name Initial type( mpi_comms_t ), public :: mpi_comms MPI communicators","tags":"","url":"module/mqc_resources.html"},{"title":"mqc_hessian_distribution_scheme – metalquicha","text":"Uses Ancestors: mqc_mbe_fragment_distribution_scheme module~~mqc_hessian_distribution_scheme~~UsesGraph module~mqc_hessian_distribution_scheme mqc_hessian_distribution_scheme module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_hessian_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_calc_types mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_json_output_types mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_config mqc_method_config module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_method_types mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_resources mqc_resources module~mqc_mbe_fragment_distribution_scheme->module~mqc_resources module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_json_output_types->pic_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_program_limits mqc_program_limits module~mqc_mbe->module~mqc_program_limits module~mqc_mbe->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_method_config->module~mqc_method_types module~mqc_method_config->pic_types module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_config module~mqc_method_factory->module~mqc_method_types module~mqc_method_factory->pic_types mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_method_types->pic_types module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->pic_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->pic_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->pic_types module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_logger module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types module~mqc_method_xtb->mctc_env module~mqc_method_xtb->module~mqc_error mctc_io mctc_io module~mqc_method_xtb->mctc_io tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_comms->pic_mpi_lib module~mqc_physical_constants->pic_types module~mqc_program_limits->pic_types module~mqc_thermochemistry->pic_io module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->module~mqc_physical_constants pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types module~mqc_fragment_lookup->module~mqc_error pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_error module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines subroutine populate_unfragmented_json_data (json_data, result) Populate json_data with basic unfragmented calculation results Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(out) :: json_data type( calculation_result_t ), intent(in) :: result subroutine populate_vibrational_json_data (json_data, result, frequencies, reduced_masses, force_constants, thermo_result, ir_intensities) Populate json_data with vibrational analysis results Arguments Type Intent Optional Attributes Name type( json_output_data_t ), intent(out) :: json_data type( calculation_result_t ), intent(in) :: result real(kind=dp), intent(in) :: frequencies (:) real(kind=dp), intent(in) :: reduced_masses (:) real(kind=dp), intent(in) :: force_constants (:) type( thermochemistry_result_t ), intent(in) :: thermo_result real(kind=dp), intent(in), optional :: ir_intensities (:) Module Subroutines module subroutine distributed_unfragmented_hessian (world_comm, sys_geom, method_config, driver_config, json_data) Interface → Compute Hessian for unfragmented system using MPI distribution Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration type( driver_config_t ), intent(in), optional :: driver_config Driver configuration type( json_output_data_t ), intent(out), optional :: json_data JSON output data module subroutine hessian_coordinator (world_comm, sys_geom, method_config, displacement, temperature, pressure, json_data) Interface → Coordinator for distributed Hessian calculation\nDistributes displacement work and collects gradient results Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr) real(kind=dp), intent(in) :: temperature Temperature for thermochemistry (K) real(kind=dp), intent(in) :: pressure Pressure for thermochemistry (atm) type( json_output_data_t ), intent(out), optional :: json_data JSON output data module subroutine hessian_worker (world_comm, sys_geom, method_config, displacement) Interface → Worker for distributed Hessian calculation\nRequests displacement indices, computes gradients, and sends results back Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration real(kind=dp), intent(in) :: displacement Finite difference displacement (Bohr)","tags":"","url":"module/mqc_hessian_distribution_scheme.html"},{"title":"mqc_unfragmented_workflow – metalquicha","text":"Uses Ancestors: mqc_mbe_fragment_distribution_scheme module~~mqc_unfragmented_workflow~~UsesGraph module~mqc_unfragmented_workflow mqc_unfragmented_workflow module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_unfragmented_workflow->module~mqc_mbe_fragment_distribution_scheme module~mqc_calc_types mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_json_output_types mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_config mqc_method_config module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_method_types mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_resources mqc_resources module~mqc_mbe_fragment_distribution_scheme->module~mqc_resources module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_json_output_types->pic_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_program_limits mqc_program_limits module~mqc_mbe->module~mqc_program_limits module~mqc_mbe->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_method_config->module~mqc_method_types module~mqc_method_config->pic_types module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_config module~mqc_method_factory->module~mqc_method_types module~mqc_method_factory->pic_types mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_method_types->pic_types module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->pic_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->pic_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->pic_types module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_logger module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types module~mqc_method_xtb->mctc_env module~mqc_method_xtb->module~mqc_error mctc_io mctc_io module~mqc_method_xtb->mctc_io tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_comms->pic_mpi_lib module~mqc_physical_constants->pic_types module~mqc_program_limits->pic_types module~mqc_thermochemistry->pic_io module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->module~mqc_physical_constants pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types module~mqc_fragment_lookup->module~mqc_error pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_error module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Subroutines module subroutine unfragmented_calculation (sys_geom, method_config, calc_type, bonds, result_out, temperature, pressure, json_data) Interface → Run unfragmented calculation on the entire system (nlevel=0)\nThis is a simple single-process calculation without MPI distribution\nIf result_out is present, returns result instead of writing JSON and destroying it\nIf json_data is present, populates it for centralized JSON output Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( calculation_result_t ), intent(out), optional :: result_out real(kind=dp), intent(in), optional :: temperature Temperature for thermochemistry (K) real(kind=dp), intent(in), optional :: pressure Pressure for thermochemistry (atm) type( json_output_data_t ), intent(out), optional :: json_data","tags":"","url":"module/mqc_unfragmented_workflow.html"},{"title":"mpi_fragment_work_smod – metalquicha","text":"Uses mqc_error Ancestors: mqc_mbe_fragment_distribution_scheme module~~mpi_fragment_work_smod~~UsesGraph module~mpi_fragment_work_smod mpi_fragment_work_smod module~mqc_error mqc_error module~mpi_fragment_work_smod->module~mqc_error module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mpi_fragment_work_smod->module~mqc_mbe_fragment_distribution_scheme module~mqc_calc_types mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_json_output_types mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_config mqc_method_config module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_method_types mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_resources mqc_resources module~mqc_mbe_fragment_distribution_scheme->module~mqc_resources module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_error module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_json_output_types->pic_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_program_limits mqc_program_limits module~mqc_mbe->module~mqc_program_limits module~mqc_mbe->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_method_config->module~mqc_method_types module~mqc_method_config->pic_types module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_config module~mqc_method_factory->module~mqc_method_types module~mqc_method_factory->pic_types mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_method_types->pic_types module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms module~mqc_result_types->module~mqc_error module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->pic_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->pic_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->pic_types module~mqc_method_xtb->module~mqc_error module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_logger module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_comms->pic_mpi_lib module~mqc_physical_constants->pic_types module~mqc_program_limits->pic_types module~mqc_thermochemistry->pic_io module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->module~mqc_physical_constants pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->module~mqc_error module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->module~mqc_error module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines subroutine send_fragment_to_node (world_comm, fragment_idx, polymers, dest_rank) Send fragment data to remote node coordinator\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank subroutine send_fragment_to_worker (node_comm, fragment_idx, polymers, dest_rank) Send fragment data to local worker\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank Module Subroutines module subroutine do_fragment_work (fragment_idx, result, method_config, phys_frag, calc_type, world_comm) Interface → Process a single fragment for quantum chemistry calculation Read more… Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Fragment index for identification type( calculation_result_t ), intent(out) :: result Computation results type( method_config_t ), intent(in) :: method_config Method configuration type( physical_fragment_t ), intent(in), optional :: phys_frag Fragment geometry integer(kind=int32), intent(in) :: calc_type Calculation type type(comm_t), intent(in), optional :: world_comm MPI communicator for abort module subroutine global_coordinator (resources, total_fragments, polymers, max_level, node_leader_ranks, num_nodes, sys_geom, method_config, calc_type, bonds, json_data) Interface → Global coordinator for distributing fragments to node coordinators\nwill act as a node coordinator for a single node calculation\nUses int64 for total_fragments to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data module subroutine node_coordinator (resources, method_config, calc_type) Interface → Node coordinator for distributing fragments to local workers\nHandles work requests and result collection from local workers Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources type( method_config_t ), intent(in) :: method_config Method configuration (passed through to workers) integer(kind=int32), intent(in) :: calc_type module subroutine node_worker (resources, sys_geom, method_config, calc_type, bonds) Interface → Node worker for processing fragments assigned by node coordinator Arguments Type Intent Optional Attributes Name type( resources_t ), intent(in) :: resources type( system_geometry_t ), intent(in), optional :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:)","tags":"","url":"module/mpi_fragment_work_smod.html"},{"title":"mqc_serial_fragment_processor – metalquicha","text":"Uses Ancestors: mqc_mbe_fragment_distribution_scheme module~~mqc_serial_fragment_processor~~UsesGraph module~mqc_serial_fragment_processor mqc_serial_fragment_processor module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_serial_fragment_processor->module~mqc_mbe_fragment_distribution_scheme module~mqc_calc_types mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_json_output_types mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_config mqc_method_config module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_method_types mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_resources mqc_resources module~mqc_mbe_fragment_distribution_scheme->module~mqc_resources module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_config_adapter->pic_types module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_json_output_types->pic_types module~mqc_thermochemistry mqc_thermochemistry module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_program_limits mqc_program_limits module~mqc_mbe->module~mqc_program_limits module~mqc_mbe->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_method_config->module~mqc_method_types module~mqc_method_config->pic_types module~mqc_method_factory->module~mqc_method_base module~mqc_method_factory->module~mqc_method_config module~mqc_method_factory->module~mqc_method_types module~mqc_method_factory->pic_types mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_method_types->pic_types module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_result_types->module~mqc_error module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->pic_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->pic_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->pic_types module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_logger module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types module~mqc_method_xtb->mctc_env module~mqc_method_xtb->module~mqc_error mctc_io mctc_io module~mqc_method_xtb->mctc_io tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_comms->pic_mpi_lib module~mqc_physical_constants->pic_types module~mqc_program_limits->pic_types module~mqc_thermochemistry->pic_io module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->pic_types module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->module~mqc_physical_constants pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types module~mqc_fragment_lookup->module~mqc_error pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_error module~mqc_gmbe_utils->module~mqc_combinatorics Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Subroutines module subroutine serial_fragment_processor (total_fragments, polymers, max_level, sys_geom, method_config, calc_type, bonds, json_data) Interface → Process all fragments serially in single-rank mode\nThis is used when running with only 1 MPI rank Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom type( method_config_t ), intent(in) :: method_config Method configuration integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) type( json_output_data_t ), intent(out), optional :: json_data JSON output data","tags":"","url":"module/mqc_serial_fragment_processor.html"},{"title":"main – metalquicha","text":"Uses mqc_io_helpers mqc_resources pic_knowledge mqc_error mqc_physical_fragment pic_timer pic_io mqc_config_parser mqc_logo pic_logger mqc_config_adapter mqc_driver pic_mpi_lib program~~main~~UsesGraph program~main main module~mqc_config_adapter mqc_config_adapter program~main->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser program~main->module~mqc_config_parser module~mqc_driver mqc_driver program~main->module~mqc_driver module~mqc_error mqc_error program~main->module~mqc_error module~mqc_io_helpers mqc_io_helpers program~main->module~mqc_io_helpers module~mqc_logo mqc_logo program~main->module~mqc_logo module~mqc_physical_fragment mqc_physical_fragment program~main->module~mqc_physical_fragment module~mqc_resources mqc_resources program~main->module~mqc_resources pic_io pic_io program~main->pic_io pic_knowledge pic_knowledge program~main->pic_knowledge pic_logger pic_logger program~main->pic_logger pic_mpi_lib pic_mpi_lib program~main->pic_mpi_lib pic_timer pic_timer program~main->pic_timer module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_error module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_logger module~mqc_calculation_keywords mqc_calculation_keywords module~mqc_config_adapter->module~mqc_calculation_keywords module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_driver->module~mqc_config_adapter module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_error module~mqc_driver->module~mqc_io_helpers module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_resources module~mqc_driver->pic_io module~mqc_driver->pic_logger module~mqc_driver->pic_mpi_lib module~mqc_driver->module~mqc_calc_types module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_json mqc_json module~mqc_driver->module~mqc_json module~mqc_json_output_types mqc_json_output_types module~mqc_driver->module~mqc_json_output_types module~mqc_json_writer mqc_json_writer module~mqc_driver->module~mqc_json_writer module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_method_config mqc_method_config module~mqc_driver->module~mqc_method_config module~mqc_driver->module~mqc_method_types module~mqc_result_types mqc_result_types module~mqc_driver->module~mqc_result_types omp_lib omp_lib module~mqc_driver->omp_lib module~mqc_driver->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_constants mqc_physical_constants module~mqc_physical_fragment->module~mqc_physical_constants module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_mpi_comms mqc_mpi_comms module~mqc_resources->module~mqc_mpi_comms module~mqc_calc_types->pic_types module~mqc_calculation_keywords->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->module~mqc_physical_fragment module~mqc_frag_utils->pic_io module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->pic_io module~mqc_gmbe_fragment_distribution_scheme->pic_logger module~mqc_gmbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_gmbe_fragment_distribution_scheme->pic_timer module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->pic_types module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_thermochemistry mqc_thermochemistry module~mqc_gmbe_fragment_distribution_scheme->module~mqc_thermochemistry module~mqc_vibrational_analysis mqc_vibrational_analysis module~mqc_gmbe_fragment_distribution_scheme->module~mqc_vibrational_analysis module~mqc_json->pic_io module~mqc_json->pic_logger module~mqc_json_output_types->pic_types module~mqc_json_output_types->module~mqc_thermochemistry module~mqc_json_writer->module~mqc_io_helpers module~mqc_json_writer->pic_logger module~mqc_json_writer->module~mqc_json_output_types module~mqc_json_writer->module~mqc_physical_constants module~mqc_json_writer->pic_types json_module json_module module~mqc_json_writer->json_module module~mqc_mbe_io mqc_mbe_io module~mqc_json_writer->module~mqc_mbe_io module~mqc_program_limits mqc_program_limits module~mqc_json_writer->module~mqc_program_limits module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_json_output_types module~mqc_mbe->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_program_limits module~mqc_mbe->module~mqc_thermochemistry module~mqc_mbe->module~mqc_vibrational_analysis module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_adapter module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_resources module~mqc_mbe_fragment_distribution_scheme->pic_io module~mqc_mbe_fragment_distribution_scheme->pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_timer module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_json_output_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_config module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme->omp_lib module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_base mqc_method_base module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_base module~mqc_method_factory mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_factory module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces module~mqc_method_config->module~mqc_method_types module~mqc_method_config->pic_types module~mqc_method_types->pic_types module~mqc_mpi_comms->pic_mpi_lib module~mqc_physical_constants->pic_types module~mqc_result_types->module~mqc_error module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->module~mqc_error module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->module~mqc_error module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_gmbe_utils->module~mqc_combinatorics module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->module~mqc_elements module~mqc_mbe_io->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_method_factory->module~mqc_method_config module~mqc_method_factory->module~mqc_method_types module~mqc_method_factory->pic_types module~mqc_method_factory->module~mqc_method_base mctc_env mctc_env module~mqc_method_factory->mctc_env module~mqc_method_dft mqc_method_dft module~mqc_method_factory->module~mqc_method_dft module~mqc_method_hf mqc_method_hf module~mqc_method_factory->module~mqc_method_hf module~mqc_method_mcscf mqc_method_mcscf module~mqc_method_factory->module~mqc_method_mcscf module~mqc_method_xtb mqc_method_xtb module~mqc_method_factory->module~mqc_method_xtb module~mqc_mpi_tags->pic_types module~mqc_program_limits->pic_types module~mqc_thermochemistry->pic_io module~mqc_thermochemistry->pic_logger module~mqc_thermochemistry->module~mqc_elements module~mqc_thermochemistry->module~mqc_physical_constants module~mqc_thermochemistry->pic_types pic_lapack_interfaces pic_lapack_interfaces module~mqc_thermochemistry->pic_lapack_interfaces module~mqc_vibrational_analysis->pic_logger module~mqc_vibrational_analysis->module~mqc_elements module~mqc_vibrational_analysis->module~mqc_physical_constants module~mqc_vibrational_analysis->pic_types module~mqc_vibrational_analysis->module~mqc_thermochemistry module~mqc_vibrational_analysis->pic_lapack_interfaces module~mqc_method_dft->module~mqc_physical_fragment module~mqc_method_dft->module~mqc_result_types module~mqc_method_dft->pic_types module~mqc_method_dft->module~mqc_method_base module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->pic_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_mcscf->module~mqc_physical_fragment module~mqc_method_mcscf->module~mqc_result_types module~mqc_method_mcscf->pic_types module~mqc_method_mcscf->module~mqc_method_base module~mqc_method_xtb->module~mqc_error module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->pic_logger module~mqc_method_xtb->pic_timer module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_types module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io tblite_container tblite_container module~mqc_method_xtb->tblite_container tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_solvation tblite_solvation module~mqc_method_xtb->tblite_solvation tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Orchestrates MPI initialization, input parsing, geometry loading,\nand dispatches to appropriate calculation routines (fragmented or unfragmented). Calls program~~main~~CallsGraph program~main main abort_comm abort_comm program~main->abort_comm comm_world comm_world program~main->comm_world configure configure program~main->configure error error program~main->error finalize finalize program~main->finalize get_elapsed_time get_elapsed_time program~main->get_elapsed_time get_knowledge get_knowledge program~main->get_knowledge info info program~main->info pic_mpi_finalize pic_mpi_finalize program~main->pic_mpi_finalize pic_mpi_init pic_mpi_init program~main->pic_mpi_init proc~config_to_driver config_to_driver program~main->proc~config_to_driver proc~config_to_system_geometry config_to_system_geometry program~main->proc~config_to_system_geometry proc~ends_with ends_with program~main->proc~ends_with proc~error_get_message error_t%error_get_message program~main->proc~error_get_message proc~error_has_error error_t%error_has_error program~main->proc~error_has_error proc~get_logger_level get_logger_level program~main->proc~get_logger_level proc~print_logo print_logo program~main->proc~print_logo proc~read_mqc_file read_mqc_file program~main->proc~read_mqc_file proc~run_calculation run_calculation program~main->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations program~main->proc~run_multi_molecule_calculations proc~set_output_json_filename set_output_json_filename program~main->proc~set_output_json_filename proc~system_destroy system_geometry_t%system_destroy program~main->proc~system_destroy split split program~main->split start start program~main->start to_char to_char program~main->to_char proc~config_to_system_geometry->proc~error_has_error proc~error_add_context error_t%error_add_context proc~config_to_system_geometry->proc~error_add_context proc~error_set error_t%error_set proc~config_to_system_geometry->proc~error_set proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry warning warning proc~get_logger_level->warning proc~read_mqc_file->proc~error_has_error proc~read_mqc_file->proc~error_add_context proc~read_mqc_file->proc~error_set proc~parse_aimd_section parse_aimd_section proc~read_mqc_file->proc~parse_aimd_section proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_driver_section parse_driver_section proc~read_mqc_file->proc~parse_driver_section proc~parse_fragmentation_section parse_fragmentation_section proc~read_mqc_file->proc~parse_fragmentation_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_geometry_section parse_geometry_section proc~read_mqc_file->proc~parse_geometry_section proc~parse_hessian_section parse_hessian_section proc~read_mqc_file->proc~parse_hessian_section proc~parse_model_section parse_model_section proc~read_mqc_file->proc~parse_model_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_scf_section parse_scf_section proc~read_mqc_file->proc~parse_scf_section proc~parse_schema_section parse_schema_section proc~read_mqc_file->proc~parse_schema_section proc~parse_structure_section parse_structure_section proc~read_mqc_file->proc~parse_structure_section proc~parse_system_section parse_system_section proc~read_mqc_file->proc~parse_system_section proc~parse_xtb_section parse_xtb_section proc~read_mqc_file->proc~parse_xtb_section proc~skip_to_end skip_to_end proc~read_mqc_file->proc~skip_to_end proc~run_calculation->info proc~run_calculation->to_char omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~json_output_data_destroy json_output_data_t%json_output_data_destroy proc~run_calculation->proc~json_output_data_destroy proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~write_json_output write_json_output proc~run_calculation->proc~write_json_output proc~xtb_has_solvation xtb_config_t%xtb_has_solvation proc~run_calculation->proc~xtb_has_solvation proc~run_calculation->warning proc~run_multi_molecule_calculations->abort_comm proc~run_multi_molecule_calculations->error proc~run_multi_molecule_calculations->info proc~run_multi_molecule_calculations->proc~config_to_driver proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~run_multi_molecule_calculations->proc~error_has_error proc~run_multi_molecule_calculations->proc~run_calculation proc~run_multi_molecule_calculations->proc~system_destroy proc~run_multi_molecule_calculations->to_char barrier barrier proc~run_multi_molecule_calculations->barrier proc~run_multi_molecule_calculations->proc~error_add_context proc~error_get_full_trace error_t%error_get_full_trace proc~run_multi_molecule_calculations->proc~error_get_full_trace proc~get_output_json_filename get_output_json_filename proc~run_multi_molecule_calculations->proc~get_output_json_filename proc~merge_multi_molecule_json merge_multi_molecule_json proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json proc~set_molecule_suffix set_molecule_suffix proc~run_multi_molecule_calculations->proc~set_molecule_suffix verbose verbose proc~run_multi_molecule_calculations->verbose proc~error_get_full_trace->proc~error_has_error proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~json_output_data_reset json_output_data_t%json_output_data_reset proc~json_output_data_destroy->proc~json_output_data_reset proc~merge_multi_molecule_json->error proc~merge_multi_molecule_json->info proc~merge_multi_molecule_json->to_char proc~read_json_content read_json_content proc~merge_multi_molecule_json->proc~read_json_content proc~molecule_to_system_geometry->proc~error_set proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~parse_aimd_section->proc~error_set proc~strip_comment strip_comment proc~parse_aimd_section->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_driver_section->proc~error_set proc~calc_type_from_string calc_type_from_string proc~parse_driver_section->proc~calc_type_from_string proc~parse_driver_section->proc~strip_comment proc~parse_fragmentation_section->proc~error_has_error proc~parse_fragmentation_section->proc~error_add_context proc~parse_fragmentation_section->proc~error_set proc~parse_fragmentation_section->proc~strip_comment proc~validate_cutoffs validate_cutoffs proc~parse_fragmentation_section->proc~validate_cutoffs proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_hessian_section->proc~error_set proc~parse_hessian_section->proc~strip_comment proc~parse_model_section->proc~error_set proc~parse_method_string parse_method_string proc~parse_model_section->proc~parse_method_string proc~parse_model_section->proc~strip_comment proc~parse_molecules_section->proc~error_has_error proc~parse_molecules_section->proc~error_add_context proc~parse_molecules_section->proc~error_set proc~parse_molecules_section->proc~skip_to_end proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~strip_comment proc~parse_scf_section->proc~error_set proc~parse_scf_section->proc~strip_comment proc~parse_schema_section->proc~error_set proc~parse_schema_section->proc~strip_comment proc~parse_structure_generic parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~parse_system_section->proc~error_set proc~parse_system_section->proc~strip_comment proc~parse_xtb_section->proc~error_set proc~parse_xtb_section->proc~strip_comment proc~run_fragmented_calculation->abort_comm proc~run_fragmented_calculation->error proc~run_fragmented_calculation->info proc~run_fragmented_calculation->proc~error_get_message proc~run_fragmented_calculation->proc~error_has_error proc~run_fragmented_calculation->to_char proc~run_fragmented_calculation->omp_set_num_threads proc~run_fragmented_calculation->verbose allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast interface~global_coordinator global_coordinator proc~run_fragmented_calculation->interface~global_coordinator interface~node_coordinator node_coordinator proc~run_fragmented_calculation->interface~node_coordinator interface~node_worker node_worker proc~run_fragmented_calculation->interface~node_worker interface~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->interface~serial_fragment_processor leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~apply_distance_screening apply_distance_screening proc~run_fragmented_calculation->proc~apply_distance_screening proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~sort_fragments_by_size sort_fragments_by_size proc~run_fragmented_calculation->proc~sort_fragments_by_size proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char proc~run_unfragmented_calculation->verbose interface~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->interface~distributed_unfragmented_hessian interface~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->interface~unfragmented_calculation proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~write_json_output->error proc~write_gmbe_pie_json_impl write_gmbe_pie_json_impl proc~write_json_output->proc~write_gmbe_pie_json_impl proc~write_mbe_breakdown_json_impl write_mbe_breakdown_json_impl proc~write_json_output->proc~write_mbe_breakdown_json_impl proc~write_unfragmented_json_impl write_unfragmented_json_impl proc~write_json_output->proc~write_unfragmented_json_impl proc~write_vibrational_json_impl write_vibrational_json_impl proc~write_json_output->proc~write_vibrational_json_impl proc~distributed_unfragmented_hessian distributed_unfragmented_hessian interface~distributed_unfragmented_hessian->proc~distributed_unfragmented_hessian proc~global_coordinator global_coordinator interface~global_coordinator->proc~global_coordinator proc~node_coordinator node_coordinator interface~node_coordinator->proc~node_coordinator proc~node_worker node_worker interface~node_worker->proc~node_worker proc~serial_fragment_processor serial_fragment_processor interface~serial_fragment_processor->proc~serial_fragment_processor proc~unfragmented_calculation unfragmented_calculation interface~unfragmented_calculation->proc~unfragmented_calculation proc~apply_distance_screening->info proc~apply_distance_screening->to_char proc~fragment_should_be_screened fragment_should_be_screened proc~apply_distance_screening->proc~fragment_should_be_screened proc~combine_util combine_util proc~combine->proc~combine_util to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->proc~error_has_error proc~gmbe_enumerate_pie_terms->to_char proc~gmbe_enumerate_pie_terms->proc~error_set atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~gmbe_pie_coordinator->abort_comm proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->get_elapsed_time proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->proc~error_get_message proc~gmbe_pie_coordinator->start proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose cart_disp cart_disp proc~gmbe_pie_coordinator->cart_disp configuration configuration proc~gmbe_pie_coordinator->configuration fc_mdyne fc_mdyne proc~gmbe_pie_coordinator->fc_mdyne force_constants force_constants proc~gmbe_pie_coordinator->force_constants frequencies frequencies proc~gmbe_pie_coordinator->frequencies iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~compute_thermochemistry compute_thermochemistry proc~gmbe_pie_coordinator->proc~compute_thermochemistry proc~compute_vibrational_analysis compute_vibrational_analysis proc~gmbe_pie_coordinator->proc~compute_vibrational_analysis proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_vibrational_analysis print_vibrational_analysis proc~gmbe_pie_coordinator->proc~print_vibrational_analysis proc~redistribute_cap_dipole_derivatives redistribute_cap_dipole_derivatives proc~gmbe_pie_coordinator->proc~redistribute_cap_dipole_derivatives proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker reduced_masses reduced_masses proc~gmbe_pie_coordinator->reduced_masses proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~error_add_context proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_add_context proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string proc~parse_single_molecule->proc~error_has_error proc~parse_single_molecule->proc~error_add_context proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_single_molecule->proc~strip_comment proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name proc~serial_gmbe_pie_processor->error proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->proc~error_get_message proc~serial_gmbe_pie_processor->proc~error_has_error proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->proc~error_get_full_trace proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->cart_disp proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->fc_mdyne proc~serial_gmbe_pie_processor->force_constants proc~serial_gmbe_pie_processor->frequencies interface~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->interface~do_fragment_work proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~compute_thermochemistry proc~serial_gmbe_pie_processor->proc~compute_vibrational_analysis proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_vibrational_analysis proc~serial_gmbe_pie_processor->proc~redistribute_cap_dipole_derivatives proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor->reduced_masses proc~sort_fragments_by_size->info sort_index sort_index proc~sort_fragments_by_size->sort_index proc~validate_cutoffs->proc~error_set proc~write_gmbe_pie_json_impl->error proc~write_gmbe_pie_json_impl->info proc~write_gmbe_pie_json_impl->proc~get_output_json_filename add add proc~write_gmbe_pie_json_impl->add create_array create_array proc~write_gmbe_pie_json_impl->create_array create_object create_object proc~write_gmbe_pie_json_impl->create_object destroy destroy proc~write_gmbe_pie_json_impl->destroy initialize initialize proc~write_gmbe_pie_json_impl->initialize proc~get_basename get_basename proc~write_gmbe_pie_json_impl->proc~get_basename proc~write_mbe_breakdown_json_impl->error proc~write_mbe_breakdown_json_impl->info proc~write_mbe_breakdown_json_impl->proc~get_output_json_filename proc~write_mbe_breakdown_json_impl->warning proc~write_mbe_breakdown_json_impl->add proc~write_mbe_breakdown_json_impl->create_array proc~write_mbe_breakdown_json_impl->create_object proc~write_mbe_breakdown_json_impl->destroy proc~write_mbe_breakdown_json_impl->initialize proc~write_mbe_breakdown_json_impl->proc~get_basename proc~get_frag_level_name get_frag_level_name proc~write_mbe_breakdown_json_impl->proc~get_frag_level_name proc~write_unfragmented_json_impl->error proc~write_unfragmented_json_impl->info proc~write_unfragmented_json_impl->proc~get_output_json_filename proc~write_unfragmented_json_impl->add proc~write_unfragmented_json_impl->create_object proc~write_unfragmented_json_impl->destroy proc~write_unfragmented_json_impl->initialize proc~write_unfragmented_json_impl->proc~get_basename proc~write_vibrational_json_impl->error proc~write_vibrational_json_impl->info proc~write_vibrational_json_impl->proc~get_output_json_filename proc~write_vibrational_json_impl->add proc~write_vibrational_json_impl->create_object proc~write_vibrational_json_impl->destroy proc~write_vibrational_json_impl->initialize proc~write_vibrational_json_impl->proc~get_basename proc~do_fragment_work do_fragment_work interface~do_fragment_work->proc~do_fragment_work proc~build_fragment_from_atom_list->proc~error_has_error proc~build_fragment_from_atom_list->proc~error_add_context proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~check_fragment_overlap->to_char proc~check_fragment_overlap->proc~error_set proc~combine_util->proc~combine_util proc~compute_electronic_entropy compute_electronic_entropy proc~compute_thermochemistry->proc~compute_electronic_entropy proc~compute_moments_of_inertia compute_moments_of_inertia proc~compute_thermochemistry->proc~compute_moments_of_inertia proc~compute_partition_functions compute_partition_functions proc~compute_thermochemistry->proc~compute_partition_functions proc~compute_rotational_constants compute_rotational_constants proc~compute_thermochemistry->proc~compute_rotational_constants proc~compute_rotational_thermo compute_rotational_thermo proc~compute_thermochemistry->proc~compute_rotational_thermo proc~compute_translational_thermo compute_translational_thermo proc~compute_thermochemistry->proc~compute_translational_thermo proc~compute_vibrational_thermo compute_vibrational_thermo proc~compute_thermochemistry->proc~compute_vibrational_thermo proc~compute_zpe compute_zpe proc~compute_thermochemistry->proc~compute_zpe proc~compute_cartesian_displacements compute_cartesian_displacements proc~compute_vibrational_analysis->proc~compute_cartesian_displacements proc~compute_force_constants compute_force_constants proc~compute_vibrational_analysis->proc~compute_force_constants proc~compute_ir_intensities compute_ir_intensities proc~compute_vibrational_analysis->proc~compute_ir_intensities proc~compute_reduced_masses compute_reduced_masses proc~compute_vibrational_analysis->proc~compute_reduced_masses proc~compute_vibrational_frequencies compute_vibrational_frequencies proc~compute_vibrational_analysis->proc~compute_vibrational_frequencies proc~dfs_pie_accumulate->proc~error_has_error proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~grow_pie_storage grow_pie_storage proc~dfs_pie_accumulate->proc~grow_pie_storage proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~distributed_unfragmented_hessian->barrier interface~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->interface~hessian_coordinator interface~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->interface~hessian_worker proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~calculate_monomer_distance calculate_monomer_distance proc~fragment_should_be_screened->proc~calculate_monomer_distance proc~get_next_combination get_next_combination proc~fragment_should_be_screened->proc~get_next_combination proc~global_coordinator->abort_comm proc~global_coordinator->error proc~global_coordinator->get_elapsed_time proc~global_coordinator->info proc~global_coordinator->proc~error_get_message proc~global_coordinator->start proc~global_coordinator->to_char proc~global_coordinator->verbose proc~global_coordinator->destroy proc~global_coordinator->iprobe proc~global_coordinator->irecv proc~global_coordinator->isend proc~global_coordinator->proc~result_irecv allocate_dipole allocate_dipole proc~global_coordinator->allocate_dipole allocate_gradient allocate_gradient proc~global_coordinator->allocate_gradient allocate_hessian allocate_hessian proc~global_coordinator->allocate_hessian debug debug proc~global_coordinator->debug proc~compute_mbe compute_mbe proc~global_coordinator->proc~compute_mbe proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~node_coordinator->abort_comm proc~node_coordinator->error proc~node_coordinator->proc~error_get_message proc~node_coordinator->to_char proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->abort_comm proc~node_worker->error proc~node_worker->proc~error_has_error proc~node_worker->to_char proc~node_worker->proc~error_get_full_trace proc~node_worker->interface~do_fragment_work proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~fragment_destroy proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~result_isend proc~node_worker->recv proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_add_context proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~print_vibrational_analysis->info proc~print_vibrational_analysis->warning proc~print_vibrational_analysis->proc~compute_thermochemistry proc~element_number_to_symbol element_number_to_symbol proc~print_vibrational_analysis->proc~element_number_to_symbol proc~print_thermochemistry print_thermochemistry proc~print_vibrational_analysis->proc~print_thermochemistry proc~result_irecv->irecv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~serial_fragment_processor->error proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->info proc~serial_fragment_processor->proc~error_get_message proc~serial_fragment_processor->proc~error_has_error proc~serial_fragment_processor->start proc~serial_fragment_processor->to_char proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->proc~error_get_full_trace proc~serial_fragment_processor->verbose proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->configuration proc~serial_fragment_processor->interface~do_fragment_work proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe proc~mbe_result_allocate_dipole mbe_result_t%mbe_result_allocate_dipole proc~serial_fragment_processor->proc~mbe_result_allocate_dipole proc~mbe_result_allocate_gradient mbe_result_t%mbe_result_allocate_gradient proc~serial_fragment_processor->proc~mbe_result_allocate_gradient proc~mbe_result_allocate_hessian mbe_result_t%mbe_result_allocate_hessian proc~serial_fragment_processor->proc~mbe_result_allocate_hessian proc~unfragmented_calculation->error proc~unfragmented_calculation->info proc~unfragmented_calculation->proc~error_get_message proc~unfragmented_calculation->proc~error_has_error proc~unfragmented_calculation->to_char proc~unfragmented_calculation->proc~error_get_full_trace proc~unfragmented_calculation->cart_disp proc~unfragmented_calculation->configuration proc~unfragmented_calculation->fc_mdyne proc~unfragmented_calculation->force_constants proc~unfragmented_calculation->frequencies proc~unfragmented_calculation->interface~do_fragment_work proc~unfragmented_calculation->proc~compute_thermochemistry proc~unfragmented_calculation->proc~compute_vibrational_analysis proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~print_vibrational_analysis proc~unfragmented_calculation->reduced_masses eigenvalues eigenvalues proc~unfragmented_calculation->eigenvalues ir_intensities ir_intensities proc~unfragmented_calculation->ir_intensities proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~compute_vibrational_frequencies proc~unfragmented_calculation->proc~fragment_compute_nelec proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy projected_hessian projected_hessian proc~unfragmented_calculation->projected_hessian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( driver_config_t ) :: config Driver configuration character(len=:), allocatable :: errmsg Error messages for file I/O type( error_t ) :: error Error handling character(len=256) :: input_file Input file name type( mqc_config_t ) :: mqc_config Parsed .mqc file type(timer_type) :: my_timer Execution timing type( resources_t ) :: resources Resources container (MPI comms, etc.) integer :: stat Status code for file I/O type( system_geometry_t ) :: sys_geom Loaded molecular system Source Code program main !! Orchestrates MPI initialization, input parsing, geometry loading, !! and dispatches to appropriate calculation routines (fragmented or unfragmented). use pic_logger , only : logger => global_logger , info_level use pic_io , only : to_char use pic_mpi_lib , only : pic_mpi_init , comm_world , abort_comm , pic_mpi_finalize use mqc_resources , only : resources_t use mqc_driver , only : run_calculation , run_multi_molecule_calculations use mqc_physical_fragment , only : system_geometry_t use mqc_config_parser , only : mqc_config_t , read_mqc_file use mqc_config_adapter , only : driver_config_t , config_to_driver , config_to_system_geometry , get_logger_level use mqc_io_helpers , only : set_output_json_filename , ends_with use mqc_logo , only : print_logo use pic_timer , only : timer_type use mqc_error , only : error_t use pic_knowledge , only : get_knowledge implicit none type ( timer_type ) :: my_timer !! Execution timing type ( resources_t ) :: resources !! Resources container (MPI comms, etc.) type ( driver_config_t ) :: config !! Driver configuration type ( mqc_config_t ) :: mqc_config !! Parsed .mqc file type ( system_geometry_t ) :: sys_geom !! Loaded molecular system type ( error_t ) :: error !! Error handling integer :: stat !! Status code for file I/O character ( len = :), allocatable :: errmsg !! Error messages for file I/O character ( len = 256 ) :: input_file !! Input file name ! Initialize MPI ! pic-mpi will call mpi_init_thread when needed call pic_mpi_init () ! Create communicators resources % mpi_comms % world_comm = comm_world () resources % mpi_comms % node_comm = resources % mpi_comms % world_comm % split () if ( resources % mpi_comms % world_comm % rank () == 0 ) then call print_logo () call my_timer % start () end if ! Parse command line arguments if ( command_argument_count () == 0 ) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"No input file specified. Usage: mqc input_file.mqc\" ) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) else if ( command_argument_count () == 1 ) then call get_command_argument ( 1 , input_file , status = stat ) if ( stat /= 0 ) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"Error reading command line argument\" ) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if input_file = trim ( input_file ) call set_output_json_filename ( input_file ) ! Validate file extension if (. not . ends_with ( input_file , '.mqc' )) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"Invalid input file extension. Expected .mqc\" ) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if else if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"Too many arguments. Usage: metalquicha [input_file.mqc]\" ) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Parse .mqc input file if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % info ( \"Reading input file: \" // trim ( input_file )) end if call read_mqc_file ( input_file , mqc_config , error ) if ( error % has_error ()) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"Error reading .mqc file: \" // error % get_message ()) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Configure logger if ( allocated ( mqc_config % log_level )) then call logger % configure ( get_logger_level ( mqc_config % log_level )) if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % info ( \"Logger verbosity set to: \" // trim ( mqc_config % log_level )) end if end if ! Handle single vs multiple molecules if ( mqc_config % nmol == 0 ) then ! Single molecule mode (backward compatible) call config_to_driver ( mqc_config , config ) call config_to_system_geometry ( mqc_config , sys_geom , error ) if ( error % has_error ()) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"Error converting geometry: \" // error % get_message ()) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if call run_calculation ( resources , config , sys_geom , mqc_config % bonds ) call sys_geom % destroy () else ! Multi-molecule mode: loop over all molecules call run_multi_molecule_calculations ( resources , mqc_config ) end if if ( resources % mpi_comms % world_comm % rank () == 0 ) then call get_knowledge () call my_timer % stop () call logger % info ( \"Total processing time: \" // to_char ( my_timer % get_elapsed_time ()) // \" s\" ) end if call mqc_config % destroy () call resources % mpi_comms % world_comm % finalize () call resources % mpi_comms % node_comm % finalize () call pic_mpi_finalize () end program main","tags":"","url":"program/main.html"},{"title":"mqc_method_config.f90 – metalquicha","text":"Unified configuration type for quantum chemistry method creation This file depends on sourcefile~~mqc_method_config.f90~~EfferentGraph sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_config.f90~~AfferentGraph sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Unified configuration type for quantum chemistry method creation module mqc_method_config !! Provides configuration types for all quantum chemistry methods. !! Uses composition pattern: method_config_t contains nested config types !! for each method family. The factory reads from the appropriate nested type. use pic_types , only : int32 , dp use mqc_method_types , only : METHOD_TYPE_UNKNOWN implicit none private public :: method_config_t public :: scf_config_t , xtb_config_t , dft_config_t , mcscf_config_t public :: correlation_config_t , cc_config_t , f12_config_t !============================================================================ ! SCF Configuration (shared by HF and DFT) !============================================================================ type :: scf_config_t !! Shared SCF settings for HF and DFT methods integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: energy_convergence = 1.0e-8_dp !! Energy convergence threshold (Hartree) real ( dp ) :: density_convergence = 1.0e-6_dp !! Density matrix convergence threshold logical :: use_diis = . true . !! Use DIIS acceleration integer :: diis_size = 8 !! Number of Fock matrices for DIIS end type scf_config_t !============================================================================ ! XTB Configuration (GFN1, GFN2) !============================================================================ type :: xtb_config_t !! Configuration for semi-empirical xTB methods real ( dp ) :: accuracy = 0.01_dp !! Numerical accuracy parameter real ( dp ) :: electronic_temp = 30 0.0_dp !! Electronic temperature in Kelvin (Fermi smearing) ! Solvation character ( len = 32 ) :: solvent = '' !! Solvent name: \"water\", \"ethanol\", etc. Empty for gas phase character ( len = 16 ) :: solvation_model = '' !! Solvation model: \"alpb\", \"gbsa\", \"cpcm\" logical :: use_cds = . true . !! Include non-polar CDS terms logical :: use_shift = . true . !! Include solution state shift real ( dp ) :: dielectric = - 1.0_dp !! Dielectric constant (-1 = use solvent table) integer :: cpcm_nang = 110 !! Angular grid points for CPCM real ( dp ) :: cpcm_rscale = 1.0_dp !! Radii scaling for CPCM contains procedure :: has_solvation => xtb_has_solvation end type xtb_config_t !============================================================================ ! DFT Configuration (uses scf_config_t for SCF settings) !============================================================================ type :: dft_config_t !! Configuration for Kohn-Sham DFT method !! Note: SCF settings (convergence, DIIS) come from scf_config_t character ( len = 32 ) :: functional = 'b3lyp' !! XC functional: \"lda\", \"pbe\", \"b3lyp\", \"m06-2x\", etc. ! Integration grid character ( len = 16 ) :: grid_type = 'medium' !! Grid quality: \"coarse\", \"medium\", \"fine\", \"ultrafine\" integer :: radial_points = 75 !! Radial grid points per atom integer :: angular_points = 302 !! Angular grid points (Lebedev) ! Density fitting logical :: use_density_fitting = . false . !! Use RI-J approximation character ( len = 32 ) :: aux_basis_set = '' !! Auxiliary basis for density fitting ! Dispersion correction logical :: use_dispersion = . false . !! Add empirical dispersion character ( len = 8 ) :: dispersion_type = 'd3bj' !! Dispersion type: \"d3\", \"d3bj\", \"d4\" end type dft_config_t !============================================================================ ! MCSCF/CASSCF Configuration !============================================================================ type :: mcscf_config_t !! Configuration for MCSCF/CASSCF method ! Active space definition integer :: n_active_electrons = 0 !! Number of active electrons integer :: n_active_orbitals = 0 !! Number of active orbitals integer :: n_inactive_orbitals = - 1 !! Inactive orbitals (-1 = auto from nelec) ! State averaging integer :: n_states = 1 !! Number of states for SA-CASSCF real ( dp ), allocatable :: state_weights (:) !! State weights (must sum to 1) ! Convergence integer :: max_macro_iter = 100 !! Maximum orbital optimization iterations integer :: max_micro_iter = 50 !! Maximum CI iterations per macro real ( dp ) :: orbital_convergence = 1.0e-6_dp !! Orbital gradient threshold real ( dp ) :: ci_convergence = 1.0e-8_dp !! CI energy threshold ! Perturbative corrections logical :: use_pt2 = . false . !! Apply CASPT2/NEVPT2 after CASSCF character ( len = 16 ) :: pt2_type = 'nevpt2' !! PT2 flavor: \"caspt2\", \"nevpt2\" real ( dp ) :: ipea_shift = 0.25_dp !! IPEA shift for CASPT2 real ( dp ) :: imaginary_shift = 0.0_dp !! Imaginary shift for intruder states end type mcscf_config_t !============================================================================ ! Correlation Configuration (shared by MP2, CC, etc.) !============================================================================ type :: correlation_config_t !! Shared settings for all post-HF correlation methods real ( dp ) :: energy_convergence = 1.0e-8_dp !! Correlation energy convergence threshold ! Frozen core integer :: n_frozen_core = - 1 !! Number of frozen core orbitals (-1 = auto from elements) logical :: freeze_core = . true . !! Whether to freeze core orbitals ! Density fitting for correlation logical :: use_df = . true . !! Use density fitting (RI) for correlation integrals character ( len = 32 ) :: aux_basis = '' !! Auxiliary basis for RI (e.g., \"cc-pvdz-ri\", \"cc-pvtz-ri\") ! Local correlation logical :: use_local = . false . !! Use local correlation approximation character ( len = 16 ) :: local_type = 'dlpno' !! Local correlation type: \"pno\", \"dlpno\", \"lmp2\", \"lno\" real ( dp ) :: pno_threshold = 1.0e-7_dp !! PNO occupation threshold for truncation ! Spin-component scaling (for MP2) logical :: use_scs = . false . !! Use spin-component scaled MP2 real ( dp ) :: scs_ss = 1.0_dp / 3.0_dp !! Same-spin scaling factor (default: 1/3 for SCS-MP2) real ( dp ) :: scs_os = 1.2_dp !! Opposite-spin scaling factor (default: 6/5 for SCS-MP2) end type correlation_config_t !============================================================================ ! Coupled Cluster Configuration !============================================================================ type :: cc_config_t !! Coupled-cluster specific settings (CCSD, CCSD(T), CC2, CC3, etc.) integer :: max_iter = 100 !! Maximum CC iterations real ( dp ) :: amplitude_convergence = 1.0e-7_dp !! T-amplitude convergence threshold ! Excitation level logical :: include_triples = . false . !! Include (T) triples correction logical :: perturbative_triples = . true . !! Use perturbative (T) vs full CCSDT ! DIIS for CC logical :: use_diis = . true . !! Use DIIS for amplitude equations integer :: diis_size = 8 !! DIIS subspace size ! EOM-CC for excited states integer :: n_roots = 0 !! Number of EOM-CC roots (0 = ground state only) character ( len = 8 ) :: eom_type = 'ee' !! EOM type: \"ee\" (excitation), \"ip\" (ionization), \"ea\" (attachment) end type cc_config_t !============================================================================ ! F12 Explicitly Correlated Configuration !============================================================================ type :: f12_config_t !! Settings for explicitly correlated F12 methods (MP2-F12, CCSD-F12, etc.) real ( dp ) :: geminal_exponent = 1.0_dp !! Slater-type geminal exponent (beta) character ( len = 8 ) :: ansatz = '3c' !! F12 ansatz: \"3c\", \"3c(fix)\", \"2b\", \"2a\" ! Auxiliary basis sets for F12 character ( len = 32 ) :: cabs_basis = '' !! Complementary auxiliary basis (CABS) for RI character ( len = 32 ) :: optri_basis = '' !! Optional RI basis for F12 intermediates ! Approximations logical :: use_exponent_fit = . false . !! Fit geminal exponent to basis set logical :: scale_triples = . true . !! Apply F12 scaling to (T) correction end type f12_config_t !============================================================================ ! Main Configuration Type (Composition) !============================================================================ type :: method_config_t !! Master configuration containing all method-specific configs !! !! Usage: !!   config%method_type = METHOD_TYPE_DFT !!   config%basis_set = 'cc-pvdz' !!   config%dft%functional = 'pbe0' !!   config%dft%use_dispersion = .true. !----- Common settings (all ab-initio methods) ----- integer ( int32 ) :: method_type = METHOD_TYPE_UNKNOWN !! Method type constant logical :: verbose = . false . !! Enable verbose output character ( len = 32 ) :: basis_set = 'sto-3g' !! Basis set name (HF, DFT, MCSCF) logical :: use_spherical = . true . !! Spherical vs Cartesian basis functions !----- Shared configurations ----- type ( scf_config_t ) :: scf !! Shared SCF settings (used by HF and DFT) type ( correlation_config_t ) :: corr !! Shared correlation settings (used by MP2, CC, etc.) !----- Method-specific configurations ----- type ( xtb_config_t ) :: xtb !! XTB settings (GFN1, GFN2) type ( dft_config_t ) :: dft !! DFT-specific settings (functional, grid, dispersion) type ( mcscf_config_t ) :: mcscf !! MCSCF/CASSCF settings type ( cc_config_t ) :: cc !! Coupled-cluster specific settings (CCSD, CCSD(T), etc.) type ( f12_config_t ) :: f12 !! F12 explicitly correlated settings contains procedure :: reset => config_reset end type method_config_t contains pure logical function xtb_has_solvation ( this ) !! Check if solvation is configured for XTB class ( xtb_config_t ), intent ( in ) :: this xtb_has_solvation = len_trim ( this % solvent ) > 0 . or . this % dielectric > 0.0_dp end function xtb_has_solvation subroutine config_reset ( this ) !! Reset all configuration values to defaults class ( method_config_t ), intent ( inout ) :: this ! Common settings this % method_type = METHOD_TYPE_UNKNOWN this % verbose = . false . this % basis_set = 'sto-3g' this % use_spherical = . true . ! XTB defaults this % xtb % accuracy = 0.01_dp this % xtb % electronic_temp = 30 0.0_dp this % xtb % solvent = '' this % xtb % solvation_model = '' this % xtb % use_cds = . true . this % xtb % use_shift = . true . this % xtb % dielectric = - 1.0_dp this % xtb % cpcm_nang = 110 this % xtb % cpcm_rscale = 1.0_dp ! SCF defaults (shared by HF and DFT) this % scf % max_iter = 100 this % scf % energy_convergence = 1.0e-8_dp this % scf % density_convergence = 1.0e-6_dp this % scf % use_diis = . true . this % scf % diis_size = 8 ! DFT-specific defaults this % dft % functional = 'b3lyp' this % dft % grid_type = 'medium' this % dft % radial_points = 75 this % dft % angular_points = 302 this % dft % use_density_fitting = . false . this % dft % aux_basis_set = '' this % dft % use_dispersion = . false . this % dft % dispersion_type = 'd3bj' ! MCSCF defaults this % mcscf % n_active_electrons = 0 this % mcscf % n_active_orbitals = 0 this % mcscf % n_inactive_orbitals = - 1 this % mcscf % n_states = 1 if ( allocated ( this % mcscf % state_weights )) deallocate ( this % mcscf % state_weights ) this % mcscf % max_macro_iter = 100 this % mcscf % max_micro_iter = 50 this % mcscf % orbital_convergence = 1.0e-6_dp this % mcscf % ci_convergence = 1.0e-8_dp this % mcscf % use_pt2 = . false . this % mcscf % pt2_type = 'nevpt2' this % mcscf % ipea_shift = 0.25_dp this % mcscf % imaginary_shift = 0.0_dp ! Correlation defaults (shared by MP2, CC, etc.) this % corr % energy_convergence = 1.0e-8_dp this % corr % n_frozen_core = - 1 this % corr % freeze_core = . true . this % corr % use_df = . true . this % corr % aux_basis = '' this % corr % use_local = . false . this % corr % local_type = 'dlpno' this % corr % pno_threshold = 1.0e-7_dp this % corr % use_scs = . false . this % corr % scs_ss = 1.0_dp / 3.0_dp this % corr % scs_os = 1.2_dp ! Coupled-cluster defaults this % cc % max_iter = 100 this % cc % amplitude_convergence = 1.0e-7_dp this % cc % include_triples = . false . this % cc % perturbative_triples = . true . this % cc % use_diis = . true . this % cc % diis_size = 8 this % cc % n_roots = 0 this % cc % eom_type = 'ee' ! F12 defaults this % f12 % geminal_exponent = 1.0_dp this % f12 % ansatz = '3c' this % f12 % cabs_basis = '' this % f12 % optri_basis = '' this % f12 % use_exponent_fit = . false . this % f12 % scale_triples = . true . end subroutine config_reset end module mqc_method_config","tags":"","url":"sourcefile/mqc_method_config.f90.html"},{"title":"mqc_mbe.f90 – metalquicha","text":"Many-Body Expansion (MBE) calculation module This file depends on sourcefile~~mqc_mbe.f90~~EfferentGraph sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe.f90~~AfferentGraph sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Many-Body Expansion (MBE) calculation module module mqc_mbe !! Implements hierarchical many-body expansion for fragment-based quantum chemistry !! calculations with MPI parallelization and energy/gradient computation. use pic_types , only : int32 , int64 , dp use pic_timer , only : timer_type use pic_mpi_lib , only : comm_t , send , recv , iprobe , MPI_Status , MPI_ANY_SOURCE , MPI_ANY_TAG , abort_comm use pic_logger , only : logger => global_logger , verbose_level , debug_level , info_level use pic_io , only : to_char use mqc_mbe_io , only : print_detailed_breakdown use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_MBE use mqc_thermochemistry , only : thermochemistry_result_t , compute_thermochemistry use mqc_mpi_tags , only : TAG_WORKER_REQUEST , TAG_WORKER_FRAGMENT , TAG_WORKER_FINISH , & TAG_WORKER_SCALAR_RESULT , & TAG_NODE_REQUEST , TAG_NODE_FRAGMENT , TAG_NODE_FINISH , & TAG_NODE_SCALAR_RESULT use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , build_fragment_from_indices , to_angstrom use mqc_frag_utils , only : get_next_combination , fragment_lookup_t use mqc_vibrational_analysis , only : compute_vibrational_analysis , print_vibrational_analysis use mqc_program_limits , only : MAX_MBE_LEVEL implicit none private ! Public interface public :: compute_mbe !! MBE energy with optional gradient and hessian public :: compute_gmbe !! GMBE energy with optional gradient and hessian contains function compute_mbe_delta ( fragment_idx , fragment , lookup , energies , delta_energies , n , world_comm ) result ( delta_E ) !! Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas) !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all subset deltaE values !! All subsets must have been computed already (guaranteed by processing fragments in order) integer ( int64 ), intent ( in ) :: fragment_idx !! Index of this fragment (already known) integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup !! Pre-built hash table for lookups real ( dp ), intent ( in ) :: energies (:), delta_energies (:) !! Pre-computed delta values type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort real ( dp ) :: delta_E integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer energy delta_E = energies ( fragment_idx ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx < 0 ) then block use pic_io , only : to_char character ( len = 512 ) :: error_msg integer :: j write ( error_msg , '(a,i0,a,*(i0,1x))' ) \"Subset not found! Fragment idx=\" , fragment_idx , & \" seeking subset: \" , ( subset ( j ), j = 1 , subset_size ) call logger % error ( trim ( error_msg )) write ( error_msg , '(a,*(i0,1x))' ) \"  Full fragment: \" , ( fragment ( j ), j = 1 , n ) call logger % error ( trim ( error_msg )) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Subset not found in bottom-up MBE!\" end if end block end if ! Subtract pre-computed delta energy delta_E = delta_E - delta_energies ( subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end function compute_mbe_delta subroutine map_fragment_to_system_gradient ( frag_grad , monomers , sys_geom , sys_grad , bonds , world_comm ) !! Map fragment gradient to system gradient coordinates with hydrogen cap redistribution !! !! This function rebuilds the fragment to get local→global mappings and cap information, !! then redistributes gradients including hydrogen caps to their original atoms. !! !! If bonds are not present, uses the old simple mapping (no caps possible). use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_gradients use mqc_config_parser , only : bond_t use mqc_error , only : error_t use pic_logger , only : verbose_level real ( dp ), intent ( in ) :: frag_grad (:, :) !! (3, natoms_frag) integer , intent ( in ) :: monomers (:) !! Monomer indices in fragment type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_grad (:, :) !! (3, total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort type ( physical_fragment_t ) :: fragment type ( error_t ) :: error integer :: i_mon , i_atom , frag_atom_idx , sys_atom_idx integer :: current_log_level ! Explicitly zero out the entire sys_grad array sys_grad = 0.0_dp ! Debug output call logger % configuration ( level = current_log_level ) if ( current_log_level >= debug_level ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,*(i0,1x))' ) \"  Mapping fragment with \" , size ( monomers ), \" monomers: \" , monomers call logger % debug ( trim ( debug_msg )) write ( debug_msg , '(a,i0,a)' ) \"  Fragment has \" , size ( frag_grad , 2 ), \" atoms\" call logger % debug ( trim ( debug_msg )) end block end if if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Failed to build fragment in gradient mapping\" end if end if ! Use new gradient redistribution with cap handling call redistribute_cap_gradients ( fragment , frag_grad , sys_grad ) ! Clean up call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment gradient to system positions (fixed-size monomers only) frag_atom_idx = 0 do i_mon = 1 , size ( monomers ) do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_idx = frag_atom_idx + 1 sys_atom_idx = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom if ( current_log_level >= debug_level . and . i_atom == 1 ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,i0,a,i0)' ) & \"    Monomer \" , monomers ( i_mon ), \": frag atoms \" , & frag_atom_idx , \" -> sys atom \" , sys_atom_idx call logger % debug ( trim ( debug_msg )) end block end if sys_grad (:, sys_atom_idx ) = frag_grad (:, frag_atom_idx ) end do end do end if end subroutine map_fragment_to_system_gradient subroutine compute_mbe_gradient ( fragment_idx , fragment , lookup , results , delta_gradients , n , sys_geom , bonds , world_comm ) !! Bottom-up computation of n-body gradient correction !! Exactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs) !! All gradients are in system coordinates, so subtraction is simple use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_gradients (:, :, :) !! (3, total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer gradient mapped to system coordinates call map_fragment_to_system_gradient ( results ( fragment_idx )% gradient , fragment , & sys_geom , delta_gradients (:, :, fragment_idx ), bonds , world_comm ) ! Subtract all proper subsets (size 1 to n-1) ! This is EXACTLY like the energy calculation, but for each gradient component do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx < 0 ) then call logger % error ( \"Subset not found in MBE gradient computation\" ) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Subset not found in MBE gradient!\" end if end if ! Subtract pre-computed delta gradient (simple array subtraction in system coords) delta_gradients (:, :, fragment_idx ) = delta_gradients (:, :, fragment_idx ) - & delta_gradients (:, :, subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end subroutine compute_mbe_gradient subroutine compute_mbe_dipole ( fragment_idx , fragment , lookup , results , delta_dipoles , n , world_comm ) !! Bottom-up computation of n-body dipole correction !! Exactly mirrors the energy MBE logic: deltaDipole = Dipole - sum(all subset deltaDipoles) !! Dipoles are additive vectors in the system frame, no coordinate mapping needed use mqc_result_types , only : calculation_result_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_dipoles (:, :) !! (3, fragment_count) type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer dipole delta_dipoles (:, fragment_idx ) = results ( fragment_idx )% dipole ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx < 0 ) then call logger % error ( \"Subset not found in MBE dipole computation\" ) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Subset not found in MBE dipole!\" end if end if ! Subtract pre-computed delta dipole delta_dipoles (:, fragment_idx ) = delta_dipoles (:, fragment_idx ) - & delta_dipoles (:, subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end subroutine compute_mbe_dipole subroutine map_fragment_to_system_hessian ( frag_hess , monomers , sys_geom , sys_hess , bonds ) !! Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_hessian use mqc_config_parser , only : bond_t use mqc_error , only : error_t real ( dp ), intent ( in ) :: frag_hess (:, :) !! (3*natoms_frag, 3*natoms_frag) integer , intent ( in ) :: monomers (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_hess (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: fragment type ( error_t ) :: error ! Zero out sys_hess = 0.0_dp if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , error , bonds ) call redistribute_cap_hessian ( fragment , frag_hess , sys_hess ) call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment Hessian to system positions (fixed-size monomers only) block integer :: i_mon , j_mon , i_atom , j_atom integer :: frag_atom_i , frag_atom_j , sys_atom_i , sys_atom_j integer :: frag_row_start , frag_col_start , sys_row_start , sys_col_start integer :: n_monomers n_monomers = size ( monomers ) frag_atom_i = 0 ! Map each monomer's atoms do i_mon = 1 , n_monomers do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_i = frag_atom_i + 1 sys_atom_i = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom frag_row_start = ( frag_atom_i - 1 ) * 3 + 1 sys_row_start = ( sys_atom_i - 1 ) * 3 + 1 ! Map this atom's Hessian blocks with all other atoms in fragment frag_atom_j = 0 do j_mon = 1 , n_monomers do j_atom = 1 , sys_geom % atoms_per_monomer frag_atom_j = frag_atom_j + 1 sys_atom_j = ( monomers ( j_mon ) - 1 ) * sys_geom % atoms_per_monomer + j_atom frag_col_start = ( frag_atom_j - 1 ) * 3 + 1 sys_col_start = ( sys_atom_j - 1 ) * 3 + 1 ! Copy the 3×3 block for this atom pair sys_hess ( sys_row_start : sys_row_start + 2 , sys_col_start : sys_col_start + 2 ) = & frag_hess ( frag_row_start : frag_row_start + 2 , frag_col_start : frag_col_start + 2 ) end do end do end do end do end block end if end subroutine map_fragment_to_system_hessian subroutine map_fragment_to_system_dipole_derivatives ( frag_dipole_derivs , monomers , sys_geom , sys_dipole_derivs , bonds ) !! Map fragment dipole derivatives to system coordinates with hydrogen cap redistribution !! !! Dipole derivatives have shape (3, 3*N) where each column corresponds to !! the derivative of dipole w.r.t. one Cartesian coordinate of one atom. use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_dipole_derivatives use mqc_config_parser , only : bond_t use mqc_error , only : error_t real ( dp ), intent ( in ) :: frag_dipole_derivs (:, :) !! (3, 3*natoms_frag) integer , intent ( in ) :: monomers (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_dipole_derivs (:, :) !! (3, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: fragment type ( error_t ) :: error ! Zero out sys_dipole_derivs = 0.0_dp if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , error , bonds ) call redistribute_cap_dipole_derivatives ( fragment , frag_dipole_derivs , sys_dipole_derivs ) call fragment % destroy () else ! Code path for fragments without hydrogen caps ! Map fragment dipole derivative columns to system positions (fixed-size monomers only) block integer :: i_mon , i_atom integer :: frag_atom_idx , sys_atom_idx integer :: frag_col_start , sys_col_start integer :: n_monomers n_monomers = size ( monomers ) frag_atom_idx = 0 ! Map each monomer's atoms do i_mon = 1 , n_monomers do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_idx = frag_atom_idx + 1 sys_atom_idx = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom frag_col_start = ( frag_atom_idx - 1 ) * 3 + 1 sys_col_start = ( sys_atom_idx - 1 ) * 3 + 1 ! Copy the 3 columns (x, y, z derivatives) for this atom sys_dipole_derivs (:, sys_col_start : sys_col_start + 2 ) = & frag_dipole_derivs (:, frag_col_start : frag_col_start + 2 ) end do end do end block end if end subroutine map_fragment_to_system_dipole_derivatives subroutine compute_mbe_hessian ( fragment_idx , fragment , lookup , results , delta_hessians , n , sys_geom , bonds ) !! Bottom-up computation of n-body Hessian correction !! Mirrors MBE gradient logic but for second derivatives use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t use mqc_error , only : error_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_hessians (:, :, :) !! (3*total_atoms, 3*total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) integer :: subset_size , i , hess_dim integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next hess_dim = 3 * sys_geom % total_atoms ! Start with the full n-mer Hessian mapped to system coordinates call map_fragment_to_system_hessian ( results ( fragment_idx )% hessian , fragment , & sys_geom , delta_hessians (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do has_next = . true . do while ( has_next ) do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx > 0 ) then ! Subtract this subset's delta Hessian delta_hessians (:, :, fragment_idx ) = delta_hessians (:, :, fragment_idx ) - & delta_hessians (:, :, subset_idx ) end if call get_next_combination ( indices , subset_size , n , has_next ) end do end do end subroutine compute_mbe_hessian subroutine compute_mbe_dipole_derivatives ( fragment_idx , fragment , lookup , results , delta_dipole_derivs , n , sys_geom , bonds ) !! Bottom-up computation of n-body dipole derivative correction !! Mirrors MBE Hessian logic but for dipole derivatives use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t use mqc_error , only : error_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_dipole_derivs (:, :, :) !! (3, 3*total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) integer :: subset_size , i integer :: indices ( MAX_MBE_LEVEL ), subset ( MAX_MBE_LEVEL ) ! Stack arrays to avoid heap contention integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer dipole derivatives mapped to system coordinates call map_fragment_to_system_dipole_derivatives ( results ( fragment_idx )% dipole_derivatives , fragment , & sys_geom , delta_dipole_derivs (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do has_next = . true . do while ( has_next ) do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do subset_idx = lookup % find ( subset ( 1 : subset_size ), subset_size ) if ( subset_idx > 0 ) then ! Subtract this subset's delta dipole derivatives delta_dipole_derivs (:, :, fragment_idx ) = delta_dipole_derivs (:, :, fragment_idx ) - & delta_dipole_derivs (:, :, subset_idx ) end if call get_next_combination ( indices , subset_size , n , has_next ) end do end do end subroutine compute_mbe_dipole_derivatives !--------------------------------------------------------------------------- ! Helper subroutines for reducing code duplication !--------------------------------------------------------------------------- subroutine build_mbe_lookup_table ( polymers , fragment_count , max_level , lookup , error ) !! Build hash table for fast fragment lookups use mqc_error , only : error_t integer , intent ( in ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: max_level type ( fragment_lookup_t ), intent ( inout ) :: lookup type ( error_t ), intent ( out ), optional :: error integer ( int64 ) :: i integer :: fragment_size type ( timer_type ) :: lookup_timer type ( error_t ) :: insert_error call lookup_timer % start () call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) call lookup % insert ( polymers ( i , :), fragment_size , i , insert_error ) if ( insert_error % has_error ()) then if ( present ( error )) then error = insert_error call error % add_context ( \"build_mbe_lookup_table\" ) end if return end if end do call lookup_timer % stop () call logger % debug ( \"Time to build lookup table: \" // to_char ( lookup_timer % get_elapsed_time ()) // \" s\" ) call logger % debug ( \"Hash table size: \" // to_char ( lookup % table_size ) // & \", entries: \" // to_char ( lookup % n_entries )) end subroutine build_mbe_lookup_table subroutine print_mbe_energy_breakdown ( sum_by_level , max_level , total_energy ) !! Print MBE energy breakdown to logger real ( dp ), intent ( in ) :: sum_by_level (:) integer , intent ( in ) :: max_level real ( dp ), intent ( in ) :: total_energy integer :: nlevel character ( len = 256 ) :: energy_line call logger % info ( \"MBE Energy breakdown:\" ) do nlevel = 1 , max_level if ( abs ( sum_by_level ( nlevel )) > 1e-15_dp ) then write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , nlevel , \"-body:  \" , sum_by_level ( nlevel ) call logger % info ( trim ( energy_line )) end if end do write ( energy_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( energy_line )) end subroutine print_mbe_energy_breakdown subroutine print_mbe_gradient_info ( total_gradient , sys_geom , current_log_level ) !! Print MBE gradient information real ( dp ), intent ( in ) :: total_gradient (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: current_log_level integer :: iatom character ( len = 256 ) :: grad_line call logger % info ( \"MBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total MBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end do call logger % info ( \" \" ) end if end subroutine print_mbe_gradient_info subroutine compute_mbe ( polymers , fragment_count , max_level , results , & mbe_result , sys_geom , bonds , world_comm , json_data ) !! Compute many-body expansion (MBE) energy with optional gradient, hessian, and dipole !! !! This is the core routine that handles all MBE computations. !! The caller pre-allocates desired components in mbe_result before calling: !!   - mbe_result%gradient allocated: compute gradient (requires sys_geom) !!   - mbe_result%hessian allocated: compute hessian (requires sys_geom) !!   - mbe_result%dipole allocated: compute total dipole moment !! If json_data is present, populates it for centralized JSON output use mqc_result_types , only : calculation_result_t , mbe_result_t use mqc_config_parser , only : bond_t ! Required arguments integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level type ( calculation_result_t ), intent ( in ) :: results (:) type ( mbe_result_t ), intent ( inout ) :: mbe_result !! Pre-allocated by caller ! Optional arguments type ( system_geometry_t ), intent ( in ), optional :: sys_geom !! Required for gradient/hessian type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond info for H-cap handling type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data ! Local variables integer ( int64 ) :: i integer :: fragment_size , nlevel , current_log_level , hess_dim real ( dp ), allocatable :: sum_by_level (:), delta_energies (:), energies (:) real ( dp ), allocatable :: delta_gradients (:, :, :), delta_hessians (:, :, :) real ( dp ), allocatable :: delta_dipoles (:, :) !! (3, fragment_count) real ( dp ), allocatable :: delta_dipole_derivs (:, :, :) !! (3, 3*total_atoms, fragment_count) real ( dp ), allocatable :: ir_intensities (:) !! IR intensities in km/mol real ( dp ) :: delta_E logical :: do_detailed_print , compute_grad , compute_hess , compute_dipole , compute_dipole_derivs type ( fragment_lookup_t ) :: lookup ! Determine what to compute based on allocated components in mbe_result compute_grad = allocated ( mbe_result % gradient ) compute_hess = allocated ( mbe_result % hessian ) compute_dipole = allocated ( mbe_result % dipole ) compute_dipole_derivs = . false . ! Will be set true if all fragments have dipole_derivatives ! Validate inputs for gradient computation if ( compute_grad ) then do i = 1_int64 , fragment_count if (. not . results ( i )% has_gradient ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have gradient!\" ) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Missing gradient in compute_mbe_internal\" end if end if end do end if ! Validate inputs for hessian computation if ( compute_hess ) then do i = 1_int64 , fragment_count if (. not . results ( i )% has_hessian ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have Hessian!\" ) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Missing Hessian in compute_mbe_internal\" end if end if end do hess_dim = 3 * sys_geom % total_atoms end if ! Validate inputs for dipole computation if ( compute_dipole ) then do i = 1_int64 , fragment_count if (. not . results ( i )% has_dipole ) then call logger % warning ( \"Fragment \" // to_char ( i ) // \" does not have dipole - skipping dipole MBE\" ) compute_dipole = . false . exit end if end do end if ! Check if dipole derivatives are available (for IR intensities) if ( compute_hess ) then compute_dipole_derivs = . true . do i = 1_int64 , fragment_count if (. not . results ( i )% has_dipole_derivatives ) then compute_dipole_derivs = . false . exit end if end do end if ! Get logger configuration call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) ! Allocate energy arrays (always needed) allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) allocate ( energies ( fragment_count )) sum_by_level = 0.0_dp delta_energies = 0.0_dp ! Extract total energies from results do i = 1_int64 , fragment_count energies ( i ) = results ( i )% energy % total () end do ! Allocate gradient delta arrays if needed if ( compute_grad ) then allocate ( delta_gradients ( 3 , sys_geom % total_atoms , fragment_count )) delta_gradients = 0.0_dp mbe_result % gradient = 0.0_dp end if ! Allocate hessian delta arrays if needed if ( compute_hess ) then allocate ( delta_hessians ( hess_dim , hess_dim , fragment_count )) delta_hessians = 0.0_dp mbe_result % hessian = 0.0_dp end if ! Allocate dipole delta arrays if needed if ( compute_dipole ) then allocate ( delta_dipoles ( 3 , fragment_count )) delta_dipoles = 0.0_dp mbe_result % dipole = 0.0_dp end if ! Allocate dipole derivative delta arrays if needed (for IR intensities) if ( compute_dipole_derivs ) then allocate ( delta_dipole_derivs ( 3 , hess_dim , fragment_count )) delta_dipole_derivs = 0.0_dp allocate ( mbe_result % dipole_derivatives ( 3 , hess_dim )) mbe_result % dipole_derivatives = 0.0_dp end if ! Build hash table for fast fragment lookups block use mqc_error , only : error_t type ( error_t ) :: lookup_error call build_mbe_lookup_table ( polymers , fragment_count , max_level , lookup , lookup_error ) if ( lookup_error % has_error ()) then call logger % error ( \"Failed to build lookup table: \" // lookup_error % get_message ()) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Failed to build lookup table\" end if end if end block ! Bottom-up computation: process fragments by size (1-body, then 2-body, etc.) ! This makes the algorithm independent of input fragment order ! We process by n-mer level to ensure all subsets are computed before they're needed do nlevel = 1 , max_level do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) ! Only process fragments of the current nlevel if ( fragment_size /= nlevel ) cycle if ( fragment_size == 1 ) then ! 1-body: delta = value (no subsets to subtract) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) if ( compute_grad ) then call map_fragment_to_system_gradient ( results ( i )% gradient , & polymers ( i , 1 : fragment_size ), sys_geom , delta_gradients (:, :, i ), bonds , world_comm ) end if if ( compute_hess ) then call map_fragment_to_system_hessian ( results ( i )% hessian , & polymers ( i , 1 : fragment_size ), sys_geom , delta_hessians (:, :, i ), bonds ) end if if ( compute_dipole ) then ! For 1-body, delta dipole is just the fragment dipole delta_dipoles (:, i ) = results ( i )% dipole end if if ( compute_dipole_derivs ) then ! For 1-body, delta dipole derivatives are just the fragment values mapped to system call map_fragment_to_system_dipole_derivatives ( results ( i )% dipole_derivatives , & polymers ( i , 1 : fragment_size ), sys_geom , delta_dipole_derivs (:, :, i ), bonds ) end if else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: delta = value - sum(all subset deltas) delta_E = compute_mbe_delta ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size , world_comm ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E if ( compute_grad ) then call compute_mbe_gradient ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_gradients , fragment_size , sys_geom , bonds , world_comm ) end if if ( compute_hess ) then call compute_mbe_hessian ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_hessians , fragment_size , sys_geom , bonds ) end if if ( compute_dipole ) then call compute_mbe_dipole ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_dipoles , fragment_size , world_comm ) end if if ( compute_dipole_derivs ) then call compute_mbe_dipole_derivatives ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_dipole_derivs , fragment_size , sys_geom , bonds ) end if end if end do end do ! Clean up lookup table call lookup % destroy () ! Compute totals and set status flags mbe_result % total_energy = sum ( sum_by_level ) mbe_result % has_energy = . true . if ( compute_grad ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then mbe_result % gradient = mbe_result % gradient + delta_gradients (:, :, i ) end if end do mbe_result % has_gradient = . true . end if if ( compute_hess ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then mbe_result % hessian = mbe_result % hessian + delta_hessians (:, :, i ) end if end do mbe_result % has_hessian = . true . end if if ( compute_dipole ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then mbe_result % dipole = mbe_result % dipole + delta_dipoles (:, i ) end if end do mbe_result % has_dipole = . true . end if if ( compute_dipole_derivs ) then do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then mbe_result % dipole_derivatives = mbe_result % dipole_derivatives + delta_dipole_derivs (:, :, i ) end if end do mbe_result % has_dipole_derivatives = . true . end if ! Print energy breakdown (always) call print_mbe_energy_breakdown ( sum_by_level , max_level , mbe_result % total_energy ) ! Print gradient info if computed if ( compute_grad ) then call print_mbe_gradient_info ( mbe_result % gradient , sys_geom , current_log_level ) end if ! Print hessian info if computed if ( compute_hess ) then call logger % info ( \"MBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( mbe_result % hessian ** 2 )))) ! Compute and print full vibrational analysis with thermochemistry block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) type ( thermochemistry_result_t ) :: thermo_result integer :: n_at , n_modes call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) if ( compute_dipole_derivs ) then call compute_vibrational_analysis ( mbe_result % hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne , & dipole_derivatives = mbe_result % dipole_derivatives , & ir_intensities = ir_intensities ) else call compute_vibrational_analysis ( mbe_result % hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) end if if ( allocated ( frequencies )) then ! Compute thermochemistry n_at = size ( sys_geom % element_numbers ) n_modes = size ( frequencies ) call compute_thermochemistry ( sys_geom % coordinates , sys_geom % element_numbers , & frequencies , n_at , n_modes , thermo_result ) ! Print vibrational analysis to log if ( allocated ( ir_intensities )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & ir_intensities = ir_intensities , & coordinates = sys_geom % coordinates , & electronic_energy = mbe_result % total_energy ) else call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & coordinates = sys_geom % coordinates , & electronic_energy = mbe_result % total_energy ) end if ! Populate json_data for vibrational output if present if ( present ( json_data )) then json_data % output_mode = OUTPUT_MODE_MBE json_data % total_energy = mbe_result % total_energy json_data % has_energy = mbe_result % has_energy json_data % has_vibrational = . true . ! Copy vibrational data allocate ( json_data % frequencies ( n_modes )) allocate ( json_data % reduced_masses ( n_modes )) allocate ( json_data % force_constants ( n_modes )) json_data % frequencies = frequencies json_data % reduced_masses = reduced_masses json_data % force_constants = fc_mdyne json_data % thermo = thermo_result if ( allocated ( ir_intensities )) then allocate ( json_data % ir_intensities ( n_modes )) json_data % ir_intensities = ir_intensities json_data % has_ir_intensities = . true . end if ! Copy dipole if available if ( mbe_result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = mbe_result % dipole json_data % has_dipole = . true . end if ! Copy gradient if available if ( mbe_result % has_gradient ) then allocate ( json_data % gradient , source = mbe_result % gradient ) json_data % has_gradient = . true . end if ! Copy hessian if available if ( mbe_result % has_hessian ) then allocate ( json_data % hessian , source = mbe_result % hessian ) json_data % has_hessian = . true . end if end if if ( allocated ( ir_intensities )) deallocate ( ir_intensities ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if ! Print dipole info if computed if ( compute_dipole ) then block character ( len = 256 ) :: dipole_line real ( dp ) :: dipole_magnitude dipole_magnitude = norm2 ( mbe_result % dipole ) * 2.541746_dp ! Convert e*Bohr to Debye call logger % info ( \"MBE Dipole moment:\" ) write ( dipole_line , '(a,3f15.8)' ) \"  Dipole (e*Bohr): \" , mbe_result % dipole call logger % info ( trim ( dipole_line )) write ( dipole_line , '(a,f15.8)' ) \"  Dipole magnitude (Debye): \" , dipole_magnitude call logger % info ( trim ( dipole_line )) end block end if ! Print detailed breakdown if requested if ( do_detailed_print ) then call print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) end if ! Populate json_data for non-Hessian case if present ! (Hessian case already handled above in the vibrational block) if ( present ( json_data ) . and . . not . compute_hess ) then json_data % output_mode = OUTPUT_MODE_MBE json_data % total_energy = mbe_result % total_energy json_data % has_energy = mbe_result % has_energy json_data % max_level = max_level json_data % fragment_count = fragment_count ! Copy fragment breakdown data allocate ( json_data % polymers ( fragment_count , max_level )) json_data % polymers = polymers ( 1 : fragment_count , 1 : max_level ) allocate ( json_data % fragment_energies ( fragment_count )) json_data % fragment_energies = energies allocate ( json_data % delta_energies ( fragment_count )) json_data % delta_energies = delta_energies allocate ( json_data % sum_by_level ( max_level )) json_data % sum_by_level = sum_by_level ! Copy fragment distances if available allocate ( json_data % fragment_distances ( fragment_count )) do i = 1_int64 , fragment_count json_data % fragment_distances ( i ) = results ( i )% distance end do ! Copy dipole if available if ( mbe_result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = mbe_result % dipole json_data % has_dipole = . true . end if ! Copy gradient if available if ( mbe_result % has_gradient ) then allocate ( json_data % gradient , source = mbe_result % gradient ) json_data % has_gradient = . true . end if end if ! Cleanup deallocate ( sum_by_level , delta_energies , energies ) if ( allocated ( delta_gradients )) deallocate ( delta_gradients ) if ( allocated ( delta_hessians )) deallocate ( delta_hessians ) if ( allocated ( delta_dipoles )) deallocate ( delta_dipoles ) if ( allocated ( delta_dipole_derivs )) deallocate ( delta_dipole_derivs ) end subroutine compute_mbe !--------------------------------------------------------------------------- ! GMBE Helper subroutines for reducing code duplication !--------------------------------------------------------------------------- subroutine print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & max_level , total_energy , has_intersections ) !! Print GMBE energy breakdown using inclusion-exclusion principle real ( dp ), intent ( in ) :: monomer_energy integer , intent ( in ) :: n_monomers real ( dp ), intent ( in ), optional :: level_energies (:) integer , intent ( in ), optional :: level_counts (:) integer , intent ( in ) :: max_level real ( dp ), intent ( in ) :: total_energy logical , intent ( in ) :: has_intersections integer :: k real ( dp ) :: sign_factor character ( len = 256 ) :: line if ( has_intersections ) then call logger % info ( \"GMBE Energy breakdown (Inclusion-Exclusion Principle):\" ) write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"):  \" , monomer_energy call logger % info ( trim ( line )) do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) if ( sign_factor > 0.0_dp ) then write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  +\" , level_energies ( k ) else write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  \" , level_energies ( k ) end if call logger % info ( trim ( line )) end if end do write ( line , '(a,f20.10)' ) \"  Total GMBE:      \" , total_energy call logger % info ( trim ( line )) else call logger % info ( \"GMBE Energy breakdown:\" ) write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"): \" , monomer_energy call logger % info ( trim ( line )) write ( line , '(a,f20.10)' ) \"  Total GMBE:  \" , total_energy call logger % info ( trim ( line )) end if end subroutine print_gmbe_energy_breakdown subroutine print_gmbe_gradient_info ( total_gradient , sys_geom , current_log_level ) !! Print GMBE gradient information real ( dp ), intent ( in ) :: total_gradient (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: current_log_level integer :: iatom character ( len = 256 ) :: grad_line call logger % info ( \"GMBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end do call logger % info ( \" \" ) end if end subroutine print_gmbe_gradient_info subroutine compute_gmbe ( monomers , n_monomers , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , & total_energy , & sys_geom , total_gradient , total_hessian , bonds , world_comm ) !! Compute generalized many-body expansion (GMBE) energy with optional gradient and/or hessian !! !! This is the core routine that handles all GMBE computations using !! the inclusion-exclusion principle for overlapping fragments. !! Optional arguments control what derivatives are computed: !!   - If sys_geom and total_gradient are present: compute gradient !!   - If total_hessian is also present: compute hessian use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_indices , build_fragment_from_atom_list , & redistribute_cap_gradients , redistribute_cap_hessian use mqc_gmbe_utils , only : find_fragment_intersection use mqc_config_parser , only : bond_t use mqc_error , only : error_t ! Required arguments integer , intent ( in ) :: monomers (:) integer , intent ( in ) :: n_monomers type ( calculation_result_t ), intent ( in ) :: monomer_results (:) integer , intent ( in ) :: n_intersections type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) integer , intent ( in ), optional :: intersection_sets (:, :) integer , intent ( in ), optional :: intersection_levels (:) real ( dp ), intent ( out ) :: total_energy ! Optional arguments for gradient computation type ( system_geometry_t ), intent ( in ), optional :: sys_geom real ( dp ), intent ( out ), optional :: total_gradient (:, :) ! Optional arguments for hessian computation real ( dp ), intent ( out ), optional :: total_hessian (:, :) ! Optional bond information for hydrogen cap handling type ( bond_t ), intent ( in ), optional :: bonds (:) ! Optional MPI communicator for abort type ( comm_t ), intent ( in ), optional :: world_comm ! Local variables integer :: i , k , max_level , current_log_level , hess_dim real ( dp ) :: monomer_energy , sign_factor real ( dp ), allocatable :: level_energies (:) integer , allocatable :: level_counts (:) type ( physical_fragment_t ) :: fragment type ( error_t ) :: error integer , allocatable :: monomer_idx (:) logical :: compute_grad , compute_hess , has_intersections ! Determine what to compute based on optional arguments compute_grad = present ( sys_geom ) . and . present ( total_gradient ) compute_hess = compute_grad . and . present ( total_hessian ) has_intersections = n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels ) ! Initialize outputs if ( compute_grad ) then total_gradient = 0.0_dp end if if ( compute_hess ) then total_hessian = 0.0_dp hess_dim = 3 * sys_geom % total_atoms end if ! Sum monomer energies (and gradients/hessians if requested) monomer_energy = 0.0_dp do i = 1 , n_monomers monomer_energy = monomer_energy + monomer_results ( i )% energy % total () ! Accumulate monomer derivatives if requested if ( compute_grad . and . monomer_results ( i )% has_gradient ) then allocate ( monomer_idx ( 1 )) monomer_idx ( 1 ) = monomers ( i ) call build_fragment_from_indices ( sys_geom , monomer_idx , fragment , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Failed to build monomer fragment in GMBE\" end if end if call redistribute_cap_gradients ( fragment , monomer_results ( i )% gradient , total_gradient ) if ( compute_hess . and . monomer_results ( i )% has_hessian ) then call redistribute_cap_hessian ( fragment , monomer_results ( i )% hessian , total_hessian ) end if call fragment % destroy () deallocate ( monomer_idx ) end if end do ! Start with monomer contribution total_energy = monomer_energy ! Handle intersections with inclusion-exclusion if ( has_intersections ) then max_level = maxval ( intersection_levels ) allocate ( level_energies ( 2 : max_level )) allocate ( level_counts ( 2 : max_level )) level_energies = 0.0_dp level_counts = 0 ! Process intersection energies and derivatives do i = 1 , n_intersections k = intersection_levels ( i ) sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) level_energies ( k ) = level_energies ( k ) + intersection_results ( i )% energy % total () level_counts ( k ) = level_counts ( k ) + 1 ! Handle intersection derivatives if requested if ( compute_grad . and . ( intersection_results ( i )% has_gradient . or . & ( compute_hess . and . intersection_results ( i )% has_hessian ))) then call process_intersection_derivatives ( i , k , sign_factor , intersection_results , & intersection_sets , sys_geom , total_gradient , total_hessian , bonds , & compute_grad , compute_hess , hess_dim , world_comm ) end if end do ! Apply inclusion-exclusion to energy do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) total_energy = total_energy + sign_factor * level_energies ( k ) end if end do ! Print energy breakdown call print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & max_level , total_energy , . true .) ! Print debug info for intersections call print_gmbe_intersection_debug ( n_intersections , n_monomers , intersection_sets , & intersection_levels , intersection_results ) deallocate ( level_energies , level_counts ) else ! No intersections - just print monomer sum call print_gmbe_energy_breakdown ( monomer_energy , n_monomers , level_energies , level_counts , & 0 , total_energy , . false .) end if ! Print gradient/hessian info if ( compute_grad ) then call logger % configuration ( level = current_log_level ) call print_gmbe_gradient_info ( total_gradient , sys_geom , current_log_level ) end if if ( compute_hess ) then call logger % info ( \"GMBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) if ( allocated ( frequencies )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & coordinates = sys_geom % coordinates , & electronic_energy = total_energy ) deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if end subroutine compute_gmbe subroutine process_intersection_derivatives ( inter_idx , k , sign_factor , intersection_results , & intersection_sets , sys_geom , total_gradient , & total_hessian , bonds , compute_grad , compute_hess , hess_dim , world_comm ) !! Process derivatives for a single intersection fragment use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_atom_list , & redistribute_cap_gradients , redistribute_cap_hessian use mqc_gmbe_utils , only : find_fragment_intersection use mqc_config_parser , only : bond_t use mqc_error , only : error_t integer , intent ( in ) :: inter_idx , k real ( dp ), intent ( in ) :: sign_factor type ( calculation_result_t ), intent ( in ) :: intersection_results (:) integer , intent ( in ) :: intersection_sets (:, :) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: total_gradient (:, :) real ( dp ), intent ( inout ), optional :: total_hessian (:, :) type ( bond_t ), intent ( in ), optional :: bonds (:) logical , intent ( in ) :: compute_grad , compute_hess integer , intent ( in ) :: hess_dim type ( comm_t ), intent ( in ), optional :: world_comm integer :: j , current_n , next_n , n_intersect integer , allocatable :: current_atoms (:), next_atoms (:), intersect_atoms (:) real ( dp ), allocatable :: term_gradient (:, :), term_hessian (:, :) logical :: has_intersection type ( physical_fragment_t ) :: inter_fragment type ( error_t ) :: inter_error ! Build the intersection atom list call get_monomer_atom_list ( sys_geom , intersection_sets ( 1 , inter_idx ), current_atoms , current_n ) if ( current_n > 0 ) then do j = 2 , k call get_monomer_atom_list ( sys_geom , intersection_sets ( j , inter_idx ), next_atoms , next_n ) has_intersection = find_fragment_intersection ( current_atoms , current_n , & next_atoms , next_n , & intersect_atoms , n_intersect ) deallocate ( current_atoms , next_atoms ) if (. not . has_intersection ) then current_n = 0 exit end if current_n = n_intersect allocate ( current_atoms ( current_n )) current_atoms = intersect_atoms deallocate ( intersect_atoms ) end do end if if ( current_n > 0 ) then call build_fragment_from_atom_list ( sys_geom , current_atoms , current_n , & inter_fragment , inter_error , bonds ) if ( inter_error % has_error ()) then call logger % error ( inter_error % get_full_trace ()) if ( present ( world_comm )) then call abort_comm ( world_comm , 1 ) else error stop \"Failed to build intersection fragment in GMBE\" end if end if if ( compute_grad . and . intersection_results ( inter_idx )% has_gradient ) then allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp call redistribute_cap_gradients ( inter_fragment , intersection_results ( inter_idx )% gradient , & term_gradient ) total_gradient = total_gradient + sign_factor * term_gradient deallocate ( term_gradient ) end if if ( compute_hess . and . intersection_results ( inter_idx )% has_hessian ) then allocate ( term_hessian ( hess_dim , hess_dim )) term_hessian = 0.0_dp call redistribute_cap_hessian ( inter_fragment , intersection_results ( inter_idx )% hessian , & term_hessian ) total_hessian = total_hessian + sign_factor * term_hessian deallocate ( term_hessian ) end if call inter_fragment % destroy () else call logger % warning ( \"GMBE intersection has no atoms; skipping derivatives\" ) end if if ( allocated ( current_atoms )) deallocate ( current_atoms ) end subroutine process_intersection_derivatives subroutine print_gmbe_intersection_debug ( n_intersections , n_monomers , intersection_sets , & intersection_levels , intersection_results ) !! Print debug information about GMBE intersections use mqc_result_types , only : calculation_result_t integer , intent ( in ) :: n_intersections , n_monomers integer , intent ( in ) :: intersection_sets (:, :) integer , intent ( in ) :: intersection_levels (:) type ( calculation_result_t ), intent ( in ) :: intersection_results (:) integer :: i , j , set_size real ( dp ) :: sign_factor character ( len = 512 ) :: detail_line character ( len = 256 ) :: set_str if ( n_intersections > 0 ) then call logger % debug ( \"GMBE intersection details:\" ) do i = 1 , n_intersections set_str = \"(\" set_size = 0 do j = 1 , n_monomers if ( intersection_sets ( j , i ) > 0 ) then if ( set_size > 0 ) set_str = trim ( set_str ) // \",\" write ( set_str , '(a,i0)' ) trim ( set_str ), intersection_sets ( j , i ) set_size = set_size + 1 end if end do set_str = trim ( set_str ) // \")\" sign_factor = real (( - 1 ) ** ( intersection_levels ( i ) + 1 ), dp ) write ( detail_line , '(a,i0,a,i0,a,a,a,f16.8)' ) & \"  Intersection \" , i , \": level=\" , intersection_levels ( i ), & \" fragments=\" , trim ( set_str ), \" energy=\" , intersection_results ( i )% energy % total () call logger % debug ( trim ( detail_line )) end do end if end subroutine print_gmbe_intersection_debug subroutine get_monomer_atom_list ( sys_geom , monomer_idx , atom_list , n_atoms ) !! Build 0-indexed atom list for a monomer, handling fixed or variable-sized fragments. type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_idx integer , allocatable , intent ( out ) :: atom_list (:) integer , intent ( out ) :: n_atoms integer :: i , base_idx if ( allocated ( sys_geom % fragment_atoms )) then n_atoms = sys_geom % fragment_sizes ( monomer_idx ) if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = sys_geom % fragment_atoms ( 1 : n_atoms , monomer_idx ) else allocate ( atom_list ( 0 )) end if else n_atoms = sys_geom % atoms_per_monomer if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) base_idx = ( monomer_idx - 1 ) * sys_geom % atoms_per_monomer do i = 1 , n_atoms atom_list ( i ) = base_idx + ( i - 1 ) end do else allocate ( atom_list ( 0 )) end if end if end subroutine get_monomer_atom_list end module mqc_mbe","tags":"","url":"sourcefile/mqc_mbe.f90.html"},{"title":"mqc_method_xtb.f90 – metalquicha","text":"Extended Tight-Binding (xTB) quantum chemistry method implementation This file depends on sourcefile~~mqc_method_xtb.f90~~EfferentGraph sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_xtb.f90~~AfferentGraph sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Extended Tight-Binding (xTB) quantum chemistry method implementation module mqc_method_xtb !! Provides GFN1-xTB and GFN2-xTB methods via the tblite library, !! implementing the abstract method interface for energy and gradient calculations. use pic_types , only : dp use mqc_method_base , only : qc_method_t use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t use mqc_error , only : ERROR_GENERIC , ERROR_VALIDATION use pic_logger , only : logger => global_logger ! tblite imports (reuse from mqc_mbe) use mctc_env , only : wp , error_type use mctc_io , only : structure_type , new use pic_timer , only : timer_type use tblite_context_type , only : context_type use tblite_wavefunction , only : wavefunction_type , new_wavefunction , get_molecular_dipole_moment use tblite_container , only : container_type use tblite_solvation , only : solvation_type , solvation_input , alpb_input , & new_solvation , new_solvation_cds , new_solvation_shift , & cds_input , shift_input , cpcm_input , cpcm_solvation use tblite_xtb_calculator , only : xtb_calculator use tblite_xtb_gfn1 , only : new_gfn1_calculator use tblite_xtb_gfn2 , only : new_gfn2_calculator use tblite_xtb_singlepoint , only : xtb_singlepoint implicit none private public :: xtb_method_t !! XTB method implementation type type , extends ( qc_method_t ) :: xtb_method_t !! Extended Tight-Binding (xTB) method implementation !! !! Concrete implementation of the abstract quantum chemistry method !! interface for GFN1-xTB and GFN2-xTB calculations via tblite. character ( len = :), allocatable :: variant !! XTB variant: \"gfn1\" or \"gfn2\" logical :: verbose = . false . !! Print calculation details real ( wp ) :: accuracy = 0.01_wp !! Numerical accuracy parameter real ( wp ) :: kt = 30 0.0_wp * 3.166808578545117e-06_wp !! Electronic temperature (300 K) ! Solvation settings (leave solvent unallocated for gas phase) character ( len = :), allocatable :: solvent !! Solvent name: \"water\", \"ethanol\", etc. character ( len = :), allocatable :: solvation_model !! \"alpb\" (default), \"gbsa\", or \"cpcm\" logical :: use_cds = . true . !! Include non-polar CDS terms (not for CPCM) logical :: use_shift = . true . !! Include solution state shift (not for CPCM) ! CPCM-specific settings real ( wp ) :: dielectric = - 1.0_wp !! Direct dielectric constant (-1 = use solvent lookup) integer :: cpcm_nang = 110 !! Number of angular points for CPCM cavity real ( wp ) :: cpcm_rscale = 1.0_wp !! Radii scaling for CPCM cavity contains procedure :: calc_energy => xtb_calc_energy !! Energy-only calculation procedure :: calc_gradient => xtb_calc_gradient !! Energy + gradient calculation procedure :: calc_hessian => xtb_calc_hessian !! Placeholder for Hessian calculation end type xtb_method_t contains subroutine xtb_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity real ( wp ) :: dipole_wp ( 3 ) if ( this % verbose ) then print * , \"XTB: Calculating energy using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge if ( allocated ( this % solvent )) then if ( allocated ( this % solvation_model )) then print * , \"XTB: Solvation: \" , trim ( this % solvation_model ), \" with solvent = \" , this % solvent else print * , \"XTB: Solvation: alpb with solvent = \" , this % solvent end if else print * , \"XTB: Solvation: none (gas phase)\" end if end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure ! charge is real(wp), multiplicity converted to uhf (unpaired electrons) call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default call result % error % set ( ERROR_VALIDATION , \"Unknown XTB variant: \" // this % variant ) result % has_error = . true . return end select if ( allocated ( error )) then call result % error % set ( ERROR_GENERIC , \"Failed to create XTB calculator\" ) result % has_error = . true . return end if ! Add solvation if configured (either solvent name or direct dielectric) if ( allocated ( this % solvent ) . or . this % dielectric > 0.0_wp ) then if ( allocated ( this % solvation_model )) then call add_solvation_to_calc ( calc , mol , this % solvent , this % solvation_model , this % variant , & this % use_cds , this % use_shift , this % dielectric , & this % cpcm_nang , this % cpcm_rscale , error ) else call add_solvation_to_calc ( calc , mol , this % solvent , \"alpb\" , this % variant , & this % use_cds , this % use_shift , this % dielectric , & this % cpcm_nang , this % cpcm_rscale , error ) end if if ( allocated ( error )) then call result % error % set ( ERROR_GENERIC , \"Failed to add solvation: \" // error % message ) result % has_error = . true . return end if end if ! Create wavefunction and run single point calculation call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt ) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , verbosity = verbosity ) ! Compute molecular dipole moment from wavefunction dipole_wp (:) = matmul ( mol % xyz , wfn % qat (:, 1 )) + sum ( wfn % dpat (:, :, 1 ), 2 ) ! Store result (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . ! Store dipole moment allocate ( result % dipole ( 3 )) result % dipole = real ( dipole_wp , dp ) result % has_dipole = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () print * , \"XTB: Dipole (e*Bohr) =\" , result % dipole print * , \"XTB: Dipole magnitude (Debye) =\" , norm2 ( result % dipole ) * 2.541746_dp end if deallocate ( num , xyz ) end subroutine xtb_calc_energy subroutine xtb_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity real ( wp ), allocatable :: gradient (:, :) real ( wp ), allocatable :: sigma (:, :) real ( wp ) :: dipole_wp ( 3 ) if ( this % verbose ) then print * , \"XTB: Calculating gradient using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge if ( allocated ( this % solvent )) then if ( allocated ( this % solvation_model )) then print * , \"XTB: Solvation: \" , trim ( this % solvation_model ), \" with solvent = \" , this % solvent else print * , \"XTB: Solvation: alpb with solvent = \" , this % solvent end if else print * , \"XTB: Solvation: none (gas phase)\" end if end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default call result % error % set ( ERROR_VALIDATION , \"Unknown XTB variant: \" // this % variant ) result % has_error = . true . return end select if ( allocated ( error )) then call result % error % set ( ERROR_GENERIC , \"Failed to create XTB calculator\" ) result % has_error = . true . return end if ! Add solvation if configured (either solvent name or direct dielectric) if ( allocated ( this % solvent ) . or . this % dielectric > 0.0_wp ) then if ( allocated ( this % solvation_model )) then call add_solvation_to_calc ( calc , mol , this % solvent , this % solvation_model , this % variant , & this % use_cds , this % use_shift , this % dielectric , & this % cpcm_nang , this % cpcm_rscale , error ) else call add_solvation_to_calc ( calc , mol , this % solvent , \"alpb\" , this % variant , & this % use_cds , this % use_shift , this % dielectric , & this % cpcm_nang , this % cpcm_rscale , error ) end if if ( allocated ( error )) then call result % error % set ( ERROR_GENERIC , \"Failed to add solvation: \" // error % message ) result % has_error = . true . return end if end if ! Allocate gradient and sigma arrays (initialize to zero) allocate ( gradient ( 3 , fragment % n_atoms )) allocate ( sigma ( 3 , 3 )) gradient = 0.0_wp sigma = 0.0_wp ! Create wavefunction and run single point calculation with gradient call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt , grad = . true .) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , & gradient = gradient , sigma = sigma , verbosity = verbosity ) ! Compute molecular dipole moment from wavefunction dipole_wp (:) = matmul ( mol % xyz , wfn % qat (:, 1 )) + sum ( wfn % dpat (:, :, 1 ), 2 ) ! Store results (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . ! Store gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = real ( gradient , dp ) result % has_gradient = . true . ! Store sigma (stress tensor) allocate ( result % sigma ( 3 , 3 )) result % sigma = real ( sigma , dp ) result % has_sigma = . true . ! Store dipole moment allocate ( result % dipole ( 3 )) result % dipole = real ( dipole_wp , dp ) result % has_dipole = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () print * , \"XTB: Gradient norm =\" , sqrt ( sum ( result % gradient ** 2 )) print * , \"XTB: Dipole (e*Bohr) =\" , result % dipole print * , \"XTB: Dipole magnitude (Debye) =\" , norm2 ( result % dipole ) * 2.541746_dp print * , \"XTB: Gradient calculation complete\" end if deallocate ( num , xyz , gradient , sigma ) end subroutine xtb_calc_gradient subroutine xtb_calc_hessian ( this , fragment , result ) !! Calculate Hessian using finite differences of gradients !! !! Since tblite does not natively support analytic Hessians, this routine !! computes the Hessian numerically via central finite differences: !!   H[i,j] = (grad_j(x_i + h) - grad_j(x_i - h)) / (2h) !! !! This requires 6N gradient calculations (forward and backward for each coordinate) use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , finite_diff_dipole_derivatives , & DEFAULT_DISPLACEMENT use pic_logger , only : logger => global_logger use pic_io , only : to_char class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result type ( displaced_geometry_t ), allocatable :: forward_geoms (:), backward_geoms (:) real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: forward_dipoles (:, :) ! (n_displacements, 3) for IR intensities real ( dp ), allocatable :: backward_dipoles (:, :) ! (n_displacements, 3) for IR intensities type ( calculation_result_t ) :: disp_result real ( dp ) :: displacement integer :: n_atoms , n_displacements , i logical :: compute_dipole_derivs n_atoms = fragment % n_atoms n_displacements = 3 * n_atoms displacement = DEFAULT_DISPLACEMENT if ( this % verbose ) then call logger % info ( \"XTB: Computing Hessian via finite differences\" ) call logger % info ( \"  Method: Central differences of gradients\" ) call logger % info ( \"  Atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) call logger % info ( \"  Finite difference step size: \" // to_char ( displacement ) // \" Bohr\" ) end if ! Generate all perturbed geometries call generate_perturbed_geometries ( fragment , displacement , forward_geoms , backward_geoms ) ! Allocate storage for gradients at displaced geometries allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) ! Allocate storage for dipoles at displaced geometries (for IR intensities) allocate ( forward_dipoles ( n_displacements , 3 )) allocate ( backward_dipoles ( n_displacements , 3 )) forward_dipoles = 0.0_dp backward_dipoles = 0.0_dp compute_dipole_derivs = . true . ! Will be set to false if any dipole is missing ! Compute gradients at all forward-displaced geometries if ( this % verbose ) then call logger % info ( \"  Computing forward-displaced gradients...\" ) end if do i = 1 , n_displacements ! Forward call this % calc_gradient ( forward_geoms ( i )% geometry , disp_result ) if ( disp_result % has_error . or . . not . disp_result % has_gradient ) then call result % error % set ( ERROR_GENERIC , \"Failed to compute gradient for forward displacement \" // to_char ( i )) result % has_error = . true . call disp_result % destroy () return end if forward_gradients ( i , :, :) = disp_result % gradient ! Capture dipole for IR intensity calculation if ( disp_result % has_dipole ) then forward_dipoles ( i , :) = disp_result % dipole else compute_dipole_derivs = . false . end if call disp_result % destroy () ! Backward call this % calc_gradient ( backward_geoms ( i )% geometry , disp_result ) if ( disp_result % has_error . or . . not . disp_result % has_gradient ) then call result % error % set ( ERROR_GENERIC , \"Failed to compute gradient for backward displacement \" // to_char ( i )) result % has_error = . true . call disp_result % destroy () return end if backward_gradients ( i , :, :) = disp_result % gradient ! Capture dipole for IR intensity calculation if ( disp_result % has_dipole ) then backward_dipoles ( i , :) = disp_result % dipole else compute_dipole_derivs = . false . end if call disp_result % destroy () end do if ( this % verbose ) then call logger % info ( \"  Forward and backward gradient calculations complete \" ) end if ! Compute Hessian from finite differences if ( this % verbose ) then call logger % info ( \"  Assembling Hessian matrix...\" ) end if call finite_diff_hessian_from_gradients ( fragment , forward_gradients , backward_gradients , & displacement , result % hessian ) ! Compute dipole derivatives for IR intensity calculation if ( compute_dipole_derivs ) then call finite_diff_dipole_derivatives ( n_atoms , forward_dipoles , backward_dipoles , & displacement , result % dipole_derivatives ) result % has_dipole_derivatives = . true . if ( this % verbose ) then call logger % info ( \"  Dipole derivatives computed for IR intensities\" ) end if end if ! Also compute energy and gradient at reference geometry for completeness call this % calc_gradient ( fragment , disp_result ) if ( disp_result % has_error ) then result % error = disp_result % error result % has_error = . true . call disp_result % destroy () return end if result % energy = disp_result % energy result % has_energy = disp_result % has_energy if ( disp_result % has_gradient ) then allocate ( result % gradient ( 3 , n_atoms )) result % gradient = disp_result % gradient result % has_gradient = . true . end if call disp_result % destroy () result % has_hessian = . true . if ( this % verbose ) then call logger % info ( \"  Hessian calculation complete\" ) end if ! Cleanup deallocate ( forward_gradients , backward_gradients ) deallocate ( forward_dipoles , backward_dipoles ) do i = 1 , n_displacements call forward_geoms ( i )% destroy () call backward_geoms ( i )% destroy () end do deallocate ( forward_geoms , backward_geoms ) end subroutine xtb_calc_hessian subroutine add_solvation_to_calc ( calc , mol , solvent , solvation_model , method , use_cds , use_shift , & dielectric , cpcm_nang , cpcm_rscale , error ) !! Add implicit solvation model to XTB calculator !! !! Adds ALPB, GBSA, or CPCM solvation. For ALPB/GBSA, optionally adds CDS and shift corrections. !! CPCM does not support CDS or shift corrections. type ( xtb_calculator ), intent ( inout ) :: calc type ( structure_type ), intent ( in ) :: mol character ( len =* ), intent ( in ) :: solvent !! Solvent name (can be empty if dielectric > 0) character ( len =* ), intent ( in ) :: solvation_model !! \"alpb\", \"gbsa\", or \"cpcm\" character ( len =* ), intent ( in ) :: method !! \"gfn1\" or \"gfn2\" logical , intent ( in ) :: use_cds , use_shift real ( wp ), intent ( in ) :: dielectric !! Direct dielectric constant (-1 = use solvent lookup) integer , intent ( in ) :: cpcm_nang !! Angular grid points for CPCM real ( wp ), intent ( in ) :: cpcm_rscale !! Radii scaling for CPCM type ( error_type ), allocatable , intent ( out ) :: error type ( solvation_input ) :: solv_input class ( container_type ), allocatable :: cont class ( solvation_type ), allocatable :: solv logical :: use_alpb real ( wp ) :: eps ! Handle CPCM model separately if ( trim ( solvation_model ) == 'cpcm' ) then ! CPCM does not support CDS or shift - silently skip them ! (use_cds and use_shift are ignored for CPCM) ! Get dielectric constant (direct value or lookup from solvent name) if ( dielectric > 0.0_wp ) then eps = dielectric else if ( len_trim ( solvent ) > 0 ) then eps = get_solvent_dielectric ( solvent ) if ( eps < 0.0_wp ) then allocate ( error ) error % message = \"Unknown solvent for CPCM dielectric lookup: \" // trim ( solvent ) return end if else allocate ( error ) error % message = \"CPCM requires either solvent name or dielectric constant\" return end if ! Create CPCM solvation allocate ( solv_input % cpcm ) solv_input % cpcm % dielectric_const = eps solv_input % cpcm % nang = cpcm_nang solv_input % cpcm % rscale = cpcm_rscale call new_solvation ( solv , mol , solv_input , error ) if ( allocated ( error )) return call move_alloc ( solv , cont ) call calc % push_back ( cont ) return end if ! For ALPB/GBSA, we need a solvent name if ( len_trim ( solvent ) == 0 ) then allocate ( error ) error % message = \"ALPB/GBSA solvation requires a solvent name\" return end if ! Determine if using ALPB or GBSA (GBSA = ALPB with alpb flag false) use_alpb = . true . if ( trim ( solvation_model ) == 'gbsa' ) then use_alpb = . false . end if ! 1. Add ALPB/GBSA (polar electrostatic solvation) allocate ( solv_input % alpb ) solv_input % alpb % solvent = solvent solv_input % alpb % alpb = use_alpb call new_solvation ( solv , mol , solv_input , error , method ) if ( allocated ( error )) return call move_alloc ( solv , cont ) call calc % push_back ( cont ) deallocate ( solv_input % alpb ) ! 2. Add CDS (non-polar: cavity, dispersion, surface) if requested if ( use_cds ) then allocate ( solv_input % cds ) solv_input % cds % solvent = solvent call new_solvation_cds ( solv , mol , solv_input , error , method ) if ( allocated ( error )) return call move_alloc ( solv , cont ) call calc % push_back ( cont ) deallocate ( solv_input % cds ) end if ! 3. Add shift (solution state correction) if requested if ( use_shift ) then allocate ( solv_input % shift ) solv_input % shift % solvent = solvent call new_solvation_shift ( solv , solv_input , error , method ) if ( allocated ( error )) return call move_alloc ( solv , cont ) call calc % push_back ( cont ) end if end subroutine add_solvation_to_calc pure function get_solvent_dielectric ( solvent_name ) result ( eps ) !! Get dielectric constant for a named solvent !! !! Returns the static dielectric constant (relative permittivity) for common solvents. !! Returns -1.0 if the solvent is not found. character ( len =* ), intent ( in ) :: solvent_name real ( wp ) :: eps character ( len = 32 ) :: name_lower integer :: i ! Convert to lowercase for case-insensitive matching name_lower = solvent_name do i = 1 , len_trim ( name_lower ) if ( name_lower ( i : i ) >= 'A' . and . name_lower ( i : i ) <= 'Z' ) then name_lower ( i : i ) = char ( ichar ( name_lower ( i : i )) + 32 ) end if end do select case ( trim ( name_lower )) ! Water case ( 'water' , 'h2o' ) eps = 7 8.4_wp ! Alcohols case ( 'methanol' , 'ch3oh' ) eps = 3 2.7_wp case ( 'ethanol' , 'c2h5oh' ) eps = 2 4.6_wp case ( '1-propanol' , 'propanol' ) eps = 2 0.1_wp case ( '2-propanol' , 'isopropanol' ) eps = 1 9.9_wp case ( '1-butanol' , 'butanol' ) eps = 1 7.5_wp case ( '2-butanol' ) eps = 1 5.8_wp case ( '1-octanol' , 'octanol' ) eps = 9.9_wp ! Polar aprotic case ( 'acetone' ) eps = 2 0.7_wp case ( 'acetonitrile' , 'ch3cn' ) eps = 3 7.5_wp case ( 'dmso' , 'dimethylsulfoxide' ) eps = 4 6.7_wp case ( 'dmf' , 'dimethylformamide' ) eps = 3 6.7_wp case ( 'thf' , 'tetrahydrofuran' ) eps = 7.6_wp case ( 'formamide' ) eps = 10 9.5_wp ! Aromatics case ( 'benzene' ) eps = 2.3_wp case ( 'toluene' ) eps = 2.4_wp case ( 'pyridine' ) eps = 1 2.4_wp case ( 'aniline' ) eps = 6.9_wp case ( 'nitrobenzene' ) eps = 3 4.8_wp case ( 'chlorobenzene' ) eps = 5.6_wp ! Halogenated case ( 'chloroform' , 'chcl3' ) eps = 4.8_wp case ( 'dichloromethane' , 'ch2cl2' , 'dcm' ) eps = 8.9_wp case ( 'carbon tetrachloride' , 'ccl4' ) eps = 2.2_wp ! Ethers case ( 'diethylether' , 'ether' ) eps = 4.3_wp case ( 'dioxane' ) eps = 2.2_wp case ( 'furan' ) eps = 2.9_wp ! Alkanes case ( 'pentane' ) eps = 1.8_wp case ( 'hexane' , 'n-hexane' ) eps = 1.9_wp case ( 'cyclohexane' ) eps = 2.0_wp case ( 'heptane' , 'n-heptane' ) eps = 1.9_wp case ( 'octane' , 'n-octane' ) eps = 1.9_wp case ( 'decane' ) eps = 2.0_wp case ( 'hexadecane' ) eps = 2.0_wp ! Other case ( 'nitromethane' ) eps = 3 5.9_wp case ( 'cs2' , 'carbondisulfide' ) eps = 2.6_wp case ( 'ethyl acetate' , 'ethylacetate' ) eps = 6.0_wp case ( 'acetic acid' , 'aceticacid' ) eps = 6.2_wp case ( 'formic acid' , 'formicacid' ) eps = 5 1.1_wp case ( 'phenol' ) eps = 9.8_wp case ( 'woctanol' ) eps = 8.1_wp ! Infinite dielectric (conductor) case ( 'inf' ) eps = 1.0e10_wp case default eps = - 1.0_wp ! Unknown solvent end select end function get_solvent_dielectric end module mqc_method_xtb","tags":"","url":"sourcefile/mqc_method_xtb.f90.html"},{"title":"mqc_mbe_fragment_distribution_scheme_hessian.F90 – metalquicha","text":"This file depends on sourcefile~~mqc_mbe_fragment_distribution_scheme_hessian.f90~~EfferentGraph sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_mpi_comms.f90 mqc_mpi_comms.f90 sourcefile~mqc_resources.f90->sourcefile~mqc_mpi_comms.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( mqc_mbe_fragment_distribution_scheme ) mqc_hessian_distribution_scheme implicit none contains module subroutine distributed_unfragmented_hessian ( world_comm , sys_geom , method_config , driver_config , json_data ) !! Compute Hessian for unfragmented system using MPI distribution !! !! Uses a dynamic work queue approach: workers request displacement indices !! from rank 0, compute gradients, and send results back. This provides !! better load balancing than static work distribution. use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT , & copy_and_displace_geometry use mqc_config_adapter , only : driver_config_t use mqc_json_output_types , only : json_output_data_t type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration type ( driver_config_t ), intent ( in ), optional :: driver_config !! Driver configuration type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data integer :: my_rank , n_ranks real ( dp ) :: displacement real ( dp ) :: temperature , pressure my_rank = world_comm % rank () n_ranks = world_comm % size () ! Use provided settings or defaults if ( present ( driver_config )) then displacement = driver_config % hessian % displacement temperature = driver_config % hessian % temperature pressure = driver_config % hessian % pressure else displacement = DEFAULT_DISPLACEMENT temperature = 29 8.15_dp pressure = 1.0_dp end if if ( my_rank == 0 ) then ! Rank 0 is the coordinator if ( present ( json_data )) then call hessian_coordinator ( world_comm , sys_geom , method_config , displacement , temperature , pressure , json_data ) else call hessian_coordinator ( world_comm , sys_geom , method_config , displacement , temperature , pressure ) end if else ! Other ranks are workers call hessian_worker ( world_comm , sys_geom , method_config , displacement ) end if ! Synchronize all ranks before returning call world_comm % barrier () end subroutine distributed_unfragmented_hessian module subroutine hessian_coordinator ( world_comm , sys_geom , method_config , displacement , temperature , pressure , json_data ) !! Coordinator for distributed Hessian calculation !! Distributes displacement work and collects gradient results use mqc_finite_differences , only : finite_diff_hessian_from_gradients , finite_diff_dipole_derivatives use mqc_vibrational_analysis , only : compute_vibrational_frequencies , & compute_vibrational_analysis , print_vibrational_analysis use mqc_thermochemistry , only : thermochemistry_result_t , compute_thermochemistry use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_UNFRAGMENTED use mqc_method_base , only : qc_method_t use mqc_method_factory , only : create_method type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) real ( dp ), intent ( in ) :: temperature !! Temperature for thermochemistry (K) real ( dp ), intent ( in ) :: pressure !! Pressure for thermochemistry (atm) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data type ( physical_fragment_t ) :: full_system type ( timer_type ) :: coord_timer real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: forward_dipoles (:, :) ! (n_displacements, 3) for IR intensities real ( dp ), allocatable :: backward_dipoles (:, :) ! (n_displacements, 3) for IR intensities real ( dp ), allocatable :: dipole_buffer (:) ! (3) real ( dp ), allocatable :: hessian (:, :) real ( dp ), allocatable :: grad_buffer (:, :) logical :: has_dipole_flag , compute_dipole_derivs type ( calculation_result_t ) :: result integer :: n_atoms , n_displacements , n_ranks integer :: current_disp , finished_workers , dummy_msg , worker_rank integer :: disp_idx , gradient_type ! gradient_type: 1=forward, 2=backward type ( MPI_Status ) :: status logical :: has_pending type ( request_t ) :: req integer :: current_log_level logical :: is_verbose character ( len = 2048 ) :: result_line ! Large buffer for Hessian matrix rows real ( dp ) :: hess_norm integer :: i , j real ( dp ), allocatable :: frequencies (:) real ( dp ), allocatable :: eigenvalues (:) real ( dp ), allocatable :: projected_hessian (:, :) class ( qc_method_t ), allocatable :: calculator !! Polymorphic calculator type ( method_config_t ) :: local_config !! Local copy for verbose override n_ranks = world_comm % size () n_atoms = sys_geom % total_atoms n_displacements = 3 * n_atoms call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) call logger % info ( \"============================================\" ) call logger % info ( \"Distributed unfragmented Hessian calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) call logger % info ( \"  Finite difference step size: \" // to_char ( displacement ) // \" Bohr\" ) call logger % info ( \"  MPI ranks: \" // to_char ( n_ranks )) call logger % info ( \"  Work distribution: Dynamic queue\" ) call logger % info ( \"============================================\" ) ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Allocate storage for all gradients allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) allocate ( grad_buffer ( 3 , n_atoms )) ! Allocate storage for dipoles (for IR intensities) allocate ( forward_dipoles ( n_displacements , 3 )) allocate ( backward_dipoles ( n_displacements , 3 )) allocate ( dipole_buffer ( 3 )) forward_dipoles = 0.0_dp backward_dipoles = 0.0_dp compute_dipole_derivs = . true . ! Will be set false if any dipole is missing current_disp = 1 finished_workers = 0 ! Process work requests and collect results call coord_timer % start () do while ( finished_workers < n_ranks - 1 ) ! Check for incoming gradient results call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE ! Receive: displacement index, gradient type (1=forward, 2=backward), gradient data, dipole call irecv ( world_comm , disp_idx , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call irecv ( world_comm , gradient_type , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call recv ( world_comm , grad_buffer , worker_rank , TAG_WORKER_SCALAR_RESULT , status ) ! Receive dipole flag and data call recv ( world_comm , has_dipole_flag , worker_rank , TAG_WORKER_SCALAR_RESULT , status ) if ( has_dipole_flag ) then call recv ( world_comm , dipole_buffer , worker_rank , TAG_WORKER_SCALAR_RESULT , status ) else compute_dipole_derivs = . false . end if ! Store gradient and dipole in appropriate arrays if ( gradient_type == 1 ) then forward_gradients ( disp_idx , :, :) = grad_buffer if ( has_dipole_flag ) forward_dipoles ( disp_idx , :) = dipole_buffer else backward_gradients ( disp_idx , :, :) = grad_buffer if ( has_dipole_flag ) backward_dipoles ( disp_idx , :) = dipole_buffer end if ! Log progress every 10% or at completion (count both forward and backward) if ( gradient_type == 2 ) then ! Only log after backward gradient to count complete displacements if ( mod ( disp_idx , max ( 1 , n_displacements / 10 )) == 0 . or . disp_idx == n_displacements ) then call logger % info ( \"  Completed \" // to_char ( disp_idx ) // \"/\" // to_char ( n_displacements ) // & \" displacement pairs in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end if end if end if ! Check for work requests from workers call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE call irecv ( world_comm , dummy_msg , worker_rank , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_disp <= n_displacements ) then ! Send next displacement index to worker call isend ( world_comm , current_disp , worker_rank , TAG_WORKER_FRAGMENT , req ) call wait ( req ) current_disp = current_disp + 1 else ! No more work - tell worker to finish call isend ( world_comm , - 1 , worker_rank , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end do deallocate ( grad_buffer ) call coord_timer % stop () call logger % info ( \"All gradient calculations completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Assemble Hessian from finite differences call logger % info ( \"  Assembling Hessian matrix...\" ) call coord_timer % start () call finite_diff_hessian_from_gradients ( full_system , forward_gradients , backward_gradients , & displacement , hessian ) call coord_timer % stop () call logger % info ( \"Hessian assembly completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Compute energy and gradient at reference geometry call logger % info ( \"  Computing reference energy and gradient...\" ) local_config = method_config local_config % verbose = is_verbose calculator = create_method ( local_config ) call calculator % calc_gradient ( full_system , result ) deallocate ( calculator ) ! Store Hessian in result if ( allocated ( result % hessian )) deallocate ( result % hessian ) allocate ( result % hessian ( size ( hessian , 1 ), size ( hessian , 2 ))) result % hessian = hessian result % has_hessian = . true . ! Compute dipole derivatives for IR intensities if all dipoles were received if ( compute_dipole_derivs ) then call logger % info ( \"  Computing dipole derivatives for IR intensities...\" ) call finite_diff_dipole_derivatives ( n_atoms , forward_dipoles , backward_dipoles , & displacement , result % dipole_derivatives ) result % has_dipole_derivatives = . true . end if ! Compute vibrational frequencies from the Hessian (with trans/rot projection) call logger % info ( \"  Computing vibrational frequencies (projecting trans/rot modes)...\" ) call compute_vibrational_frequencies ( result % hessian , sys_geom % element_numbers , frequencies , eigenvalues , & coordinates = sys_geom % coordinates , project_trans_rot = . true ., & projected_hessian_out = projected_hessian ) ! Print results call logger % info ( \"============================================\" ) call logger % info ( \"Distributed Hessian calculation completed\" ) write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) end if if ( result % has_hessian ) then hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) if ( is_verbose . and . n_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * n_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * n_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) ! Print projected mass-weighted Hessian if ( allocated ( projected_hessian )) then call logger % info ( \"Mass-weighted Hessian after trans/rot projection (a.u.):\" ) do i = 1 , 3 * n_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( projected_hessian ( i , j ), j = 1 , 3 * n_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if end if ! Compute and print full vibrational analysis with thermochemistry if ( allocated ( frequencies )) then block real ( dp ), allocatable :: vib_freqs (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:), ir_intensities (:) type ( thermochemistry_result_t ) :: thermo_result integer :: n_at , n_modes if ( result % has_dipole_derivatives ) then call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , vib_freqs , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne , & dipole_derivatives = result % dipole_derivatives , & ir_intensities = ir_intensities ) else call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , vib_freqs , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) end if if ( allocated ( vib_freqs )) then ! Compute thermochemistry n_at = size ( sys_geom % element_numbers ) n_modes = size ( vib_freqs ) call compute_thermochemistry ( sys_geom % coordinates , sys_geom % element_numbers , & vib_freqs , n_at , n_modes , thermo_result , & temperature = temperature , pressure = pressure ) ! Print vibrational analysis to log if ( allocated ( ir_intensities )) then call print_vibrational_analysis ( vib_freqs , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & ir_intensities = ir_intensities , & coordinates = sys_geom % coordinates , & electronic_energy = result % energy % total (), & temperature = temperature , pressure = pressure ) ! Populate json_data if ( present ( json_data )) then call populate_vibrational_json_data ( json_data , result , vib_freqs , reduced_masses , & fc_mdyne , thermo_result , ir_intensities ) end if deallocate ( ir_intensities ) else call print_vibrational_analysis ( vib_freqs , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & coordinates = sys_geom % coordinates , & electronic_energy = result % energy % total (), & temperature = temperature , pressure = pressure ) ! Populate json_data if ( present ( json_data )) then call populate_vibrational_json_data ( json_data , result , vib_freqs , reduced_masses , & fc_mdyne , thermo_result ) end if end if deallocate ( vib_freqs , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block else ! No Hessian/frequencies - populate basic unfragmented data if ( present ( json_data )) then call populate_unfragmented_json_data ( json_data , result ) end if end if ! Cleanup call result % destroy () deallocate ( forward_gradients , backward_gradients ) deallocate ( forward_dipoles , backward_dipoles , dipole_buffer ) if ( allocated ( hessian )) deallocate ( hessian ) if ( allocated ( frequencies )) deallocate ( frequencies ) if ( allocated ( eigenvalues )) deallocate ( eigenvalues ) if ( allocated ( projected_hessian )) deallocate ( projected_hessian ) end subroutine hessian_coordinator module subroutine hessian_worker ( world_comm , sys_geom , method_config , displacement ) !! Worker for distributed Hessian calculation !! Requests displacement indices, computes gradients, and sends results back use mqc_finite_differences , only : copy_and_displace_geometry use mqc_method_base , only : qc_method_t use mqc_method_factory , only : create_method type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) type ( physical_fragment_t ) :: full_system , displaced_geom type ( calculation_result_t ) :: grad_result integer :: n_atoms , disp_idx , atom_idx , coord , gradient_type , dummy_msg type ( MPI_Status ) :: status type ( request_t ) :: req class ( qc_method_t ), allocatable :: calculator !! Polymorphic calculator type ( method_config_t ) :: local_config !! Local copy for verbose override n_atoms = sys_geom % total_atoms ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Create calculator using factory local_config = method_config local_config % verbose = . false . calculator = create_method ( local_config ) dummy_msg = 0 do ! Request work from coordinator call isend ( world_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( world_comm , disp_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) if ( status % MPI_TAG == TAG_WORKER_FINISH ) exit ! Compute displacement index to atom and coordinate atom_idx = ( disp_idx - 1 ) / 3 + 1 coord = mod ( disp_idx - 1 , 3 ) + 1 ! Compute FORWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , displacement , displaced_geom ) call calculator % calc_gradient ( displaced_geom , grad_result ) if ( grad_result % has_error ) then call logger % error ( \"Worker gradient calculation error for forward displacement \" // & to_char ( disp_idx ) // \": \" // grad_result % error % get_message ()) call abort_comm ( world_comm , 1 ) end if if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for forward displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (1=forward), gradient data, dipole flag, dipole gradient_type = 1 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call send ( world_comm , grad_result % has_dipole , 0 , TAG_WORKER_SCALAR_RESULT ) if ( grad_result % has_dipole ) then call send ( world_comm , grad_result % dipole , 0 , TAG_WORKER_SCALAR_RESULT ) end if call grad_result % destroy () call displaced_geom % destroy () ! Compute BACKWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , - displacement , displaced_geom ) call calculator % calc_gradient ( displaced_geom , grad_result ) if ( grad_result % has_error ) then call logger % error ( \"Worker gradient calculation error for backward displacement \" // & to_char ( disp_idx ) // \": \" // grad_result % error % get_message ()) call abort_comm ( world_comm , 1 ) end if if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for backward displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (2=backward), gradient data, dipole flag, dipole gradient_type = 2 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call send ( world_comm , grad_result % has_dipole , 0 , TAG_WORKER_SCALAR_RESULT ) if ( grad_result % has_dipole ) then call send ( world_comm , grad_result % dipole , 0 , TAG_WORKER_SCALAR_RESULT ) end if call grad_result % destroy () call displaced_geom % destroy () end do ! Cleanup deallocate ( calculator ) end subroutine hessian_worker subroutine populate_vibrational_json_data ( json_data , result , frequencies , reduced_masses , & force_constants , thermo_result , ir_intensities ) !! Populate json_data with vibrational analysis results use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_UNFRAGMENTED use mqc_thermochemistry , only : thermochemistry_result_t type ( json_output_data_t ), intent ( out ) :: json_data type ( calculation_result_t ), intent ( in ) :: result real ( dp ), intent ( in ) :: frequencies (:) real ( dp ), intent ( in ) :: reduced_masses (:) real ( dp ), intent ( in ) :: force_constants (:) type ( thermochemistry_result_t ), intent ( in ) :: thermo_result real ( dp ), intent ( in ), optional :: ir_intensities (:) integer :: n_modes n_modes = size ( frequencies ) json_data % output_mode = OUTPUT_MODE_UNFRAGMENTED json_data % total_energy = result % energy % total () json_data % has_energy = . true . ! Copy gradient if available if ( result % has_gradient ) then allocate ( json_data % gradient ( size ( result % gradient , 1 ), size ( result % gradient , 2 ))) json_data % gradient = result % gradient json_data % has_gradient = . true . end if ! Copy dipole if available if ( result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = result % dipole json_data % has_dipole = . true . end if ! Copy Hessian if available if ( result % has_hessian ) then allocate ( json_data % hessian ( size ( result % hessian , 1 ), size ( result % hessian , 2 ))) json_data % hessian = result % hessian json_data % has_hessian = . true . end if ! Copy vibrational data allocate ( json_data % frequencies ( n_modes )) allocate ( json_data % reduced_masses ( n_modes )) allocate ( json_data % force_constants ( n_modes )) json_data % frequencies = frequencies json_data % reduced_masses = reduced_masses json_data % force_constants = force_constants json_data % has_vibrational = . true . ! Copy IR intensities if available if ( present ( ir_intensities )) then allocate ( json_data % ir_intensities ( n_modes )) json_data % ir_intensities = ir_intensities json_data % has_ir_intensities = . true . end if ! Copy thermochemistry json_data % thermo = thermo_result end subroutine populate_vibrational_json_data subroutine populate_unfragmented_json_data ( json_data , result ) !! Populate json_data with basic unfragmented calculation results use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_UNFRAGMENTED type ( json_output_data_t ), intent ( out ) :: json_data type ( calculation_result_t ), intent ( in ) :: result json_data % output_mode = OUTPUT_MODE_UNFRAGMENTED json_data % total_energy = result % energy % total () json_data % has_energy = . true . ! Copy gradient if available if ( result % has_gradient ) then allocate ( json_data % gradient ( size ( result % gradient , 1 ), size ( result % gradient , 2 ))) json_data % gradient = result % gradient json_data % has_gradient = . true . end if ! Copy dipole if available if ( result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = result % dipole json_data % has_dipole = . true . end if ! Copy Hessian if available if ( result % has_hessian ) then allocate ( json_data % hessian ( size ( result % hessian , 1 ), size ( result % hessian , 2 ))) json_data % hessian = result % hessian json_data % has_hessian = . true . end if end subroutine populate_unfragmented_json_data end submodule mqc_hessian_distribution_scheme","tags":"","url":"sourcefile/mqc_mbe_fragment_distribution_scheme_hessian.f90.html"},{"title":"mqc_basis_reader.f90 – metalquicha","text":"This file contains basis set reader routines for basis sets This file depends on sourcefile~~mqc_basis_reader.f90~~EfferentGraph sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_file_reader.f90 mqc_basis_file_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_basis_file_reader.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_basis_file_reader.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This file contains basis set reader routines for basis sets module mqc_basis_reader !! Gaussian basis set parser and molecular basis construction !! !! Provides utilities for parsing Gaussian-type orbital basis sets !! from text files and building molecular basis sets for quantum calculations. use mqc_cgto , only : cgto_type , atomic_basis_type , molecular_basis_type use mqc_basis_file_reader , only : strings_equal use mqc_error , only : error_t , ERROR_PARSE use pic_types , only : dp implicit none private public :: classify_line !! Determine basis file line type public :: parse_element_basis !! Parse basis for single element public :: build_molecular_basis !! Build complete molecular basis public :: ang_mom_char_to_int !! Convert angular momentum character to integer public :: ang_mom_int_to_char !! Convert angular momentum integer to character ! Basis file line classification constants integer , parameter , public :: LINE_UNKNOWN = 0 !! Unrecognized line type integer , parameter , public :: LINE_ATOM = 1 !! Element specification line integer , parameter , public :: LINE_SHELL = 2 !! Shell definition line integer , parameter , public :: LINE_FUNCTION = 3 !! Basis function coefficient line contains pure function ang_mom_char_to_int ( ang_mom_char ) result ( ang_mom ) !! Convert angular momentum character to integer !! !! Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6 !! Special case: L=-1 (combined S+P shell, requires splitting) character ( len = 1 ), intent ( in ) :: ang_mom_char !! Angular momentum symbol integer :: ang_mom !! Corresponding integer value select case ( ang_mom_char ) case ( 'S' ) ang_mom = 0 case ( 'P' ) ang_mom = 1 case ( 'D' ) ang_mom = 2 case ( 'F' ) ang_mom = 3 case ( 'G' ) ang_mom = 4 case ( 'H' ) ang_mom = 5 case ( 'I' ) ang_mom = 6 case ( 'L' ) ang_mom = - 1 ! Special case: L shells are split into S+P case default ang_mom = - 1 end select end function ang_mom_char_to_int pure function ang_mom_int_to_char ( ang_mom ) result ( ang_mom_char ) !! Convert angular momentum integer to character !! !! Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I !! Returns '?' for invalid input values. integer , intent ( in ) :: ang_mom !! Angular momentum quantum number character ( len = 1 ) :: ang_mom_char !! Corresponding symbol character select case ( ang_mom ) case ( 0 ) ang_mom_char = 'S' case ( 1 ) ang_mom_char = 'P' case ( 2 ) ang_mom_char = 'D' case ( 3 ) ang_mom_char = 'F' case ( 4 ) ang_mom_char = 'G' case ( 5 ) ang_mom_char = 'H' case ( 6 ) ang_mom_char = 'I' case default ang_mom_char = '?' end select end function ang_mom_int_to_char pure function classify_line ( line ) result ( line_type ) !! Classify a line from a gamess formatted basis set file character ( len =* ), intent ( in ) :: line integer :: line_type character ( len = :), allocatable :: line_trim line_trim = trim ( adjustl ( line )) if ( is_blank_or_control ( line_trim )) then line_type = LINE_UNKNOWN else if ( is_function_line ( line_trim )) then line_type = LINE_FUNCTION else if ( is_shell_header ( line_trim )) then line_type = LINE_SHELL else line_type = LINE_ATOM end if end function classify_line pure function is_blank_or_control ( line ) result ( res ) !! Check if a line is blank or a control line (starts with '$') character ( len =* ), intent ( in ) :: line logical :: res integer :: trimmed_len trimmed_len = len_trim ( line ) if ( trimmed_len == 0 ) then res = . true . else res = ( line ( 1 : 1 ) == '$' ) end if end function is_blank_or_control pure function is_function_line ( line ) result ( res ) !! Check if a line is a function coefficient line (starts with a number) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char if ( len_trim ( line ) == 0 ) then res = . false . return end if first_char = line ( 1 : 1 ) res = ( first_char >= '0' . and . first_char <= '9' ) end function is_function_line pure function is_shell_header ( line ) result ( res ) !! Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char integer :: ios , dummy res = . false . if ( len_trim ( line ) == 0 ) return first_char = line ( 1 : 1 ) if (. not . any ( first_char == [ 'S' , 'P' , 'D' , 'F' , 'G' , 'H' , 'I' , 'L' ])) return read ( line ( 2 :), * , iostat = ios ) dummy res = ( ios == 0 ) end function is_shell_header pure subroutine parse_element_basis ( basis_string , element_name , atom_basis , error ) !! Parse basis set for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( out ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: nshells ! Pass 1: Find the element and count its shells call count_shells_for_element ( basis_string , element_name , nshells , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_basis_reader:parse_element_basis\" ) return end if if ( nshells == 0 ) then call error % set ( ERROR_PARSE , \"Element \" // trim ( element_name ) // \" not found in basis file\" ) return end if ! ! Allocate shells atom_basis % element = trim ( element_name ) call atom_basis % allocate_shells ( nshells ) ! ! Pass 2: Parse and fill shell data call fill_element_basis ( basis_string , element_name , atom_basis , error ) end subroutine parse_element_basis pure subroutine count_shells_for_element ( basis_string , element_name , nshells , error ) !! Count the number of shells for a specific element in a GAMESS formatted basis string, character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name integer , intent ( out ) :: nshells type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_target_element , found_element character ( len = 1 ) :: ang_mom nshells = 0 in_target_element = . false . found_element = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) case ( LINE_ATOM ) ! Check if this is our target element if ( strings_equal ( line , element_name )) then in_target_element = . true . found_element = . true . else ! Different element - stop counting if we were in target if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Extract angular momentum line = adjustl ( line ) ang_mom = line ( 1 : 1 ) ! L shells become 2 shells (S + P) if ( ang_mom == 'L' ) then nshells = nshells + 2 else nshells = nshells + 1 end if end if case ( LINE_UNKNOWN ) ! Skip blank lines and comments continue case default ! Skip any other line types (e.g., LINE_FUNCTION) continue end select line_start = line_end end do ! Check if we found the element at all if (. not . found_element ) then call error % set ( ERROR_PARSE , \"Element not found in basis string: \" // trim ( element_name )) end if end subroutine count_shells_for_element pure subroutine get_next_line ( string , line_start , line , line_end ) !! Extract the next line from a string starting at line_start character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: line_start character ( len =* ), intent ( out ) :: line integer , intent ( out ) :: line_end integer :: newline_pos if ( line_start > len ( string )) then line = '' line_end = 0 return end if newline_pos = index ( string ( line_start :), new_line ( 'a' )) if ( newline_pos == 0 ) then ! Last line (no newline at end) line = string ( line_start :) line_end = len ( string ) + 1 else line = string ( line_start : line_start + newline_pos - 2 ) line_end = line_start + newline_pos end if end subroutine get_next_line pure subroutine parse_shell_header ( line , ang_mom , nfunc , stat ) !! Parse shell header line (e.g., \"S 2\" or \"L 3\") character ( len =* ), intent ( in ) :: line character ( len = 1 ), intent ( out ) :: ang_mom integer , intent ( out ) :: nfunc integer , intent ( out ) :: stat character ( len = 256 ) :: line_trim line_trim = adjustl ( line ) ang_mom = line_trim ( 1 : 1 ) ! Read the number of functions read ( line_trim ( 2 :), * , iostat = stat ) nfunc end subroutine parse_shell_header pure subroutine parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) !! Parse function line (e.g., \"1 1.0 2.0\" or \"1 1.0 2.0 3.0\" for L shells) character ( len =* ), intent ( in ) :: line integer , intent ( out ) :: func_num real ( dp ), intent ( out ) :: exponent real ( dp ), intent ( out ) :: coeff_s real ( dp ), intent ( out ), optional :: coeff_p logical , intent ( out ) :: has_p integer , intent ( out ) :: stat real ( dp ) :: temp_p has_p = . false . ! Try to read 4 values (func_num, exponent, coeff_s, coeff_p) read ( line , * , iostat = stat ) func_num , exponent , coeff_s , temp_p if ( stat == 0 ) then ! Successfully read 4 values - this is an L shell has_p = . true . if ( present ( coeff_p )) coeff_p = temp_p else ! Try reading just 3 values (func_num, exponent, coeff_s) read ( line , * , iostat = stat ) func_num , exponent , coeff_s end if end subroutine parse_function_line pure subroutine fill_element_basis ( basis_string , element_name , atom_basis , error ) !! Fill in the shell data for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( inout ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_data_block , in_target_element character ( len = 1 ) :: ang_mom integer :: nfunc , func_num , ishell , ifunc real ( dp ) :: exponent , coeff_s , coeff_p logical :: has_p ! L shell handling: we split into two shells, need to track both logical :: reading_l_shell integer :: l_shell_s_idx , l_shell_p_idx integer :: stat in_data_block = . false . in_target_element = . false . ishell = 0 reading_l_shell = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) ! case (LINE_UNKNOWN) !   if (index(line, '$DATA') > 0) then !     in_data_block = .true. !   else if (index(line, '$END') > 0) then !     exit !   end if case ( LINE_ATOM ) if ( strings_equal ( line , element_name )) then in_target_element = . true . else if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Parse shell header call parse_shell_header ( line , ang_mom , nfunc , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse shell header: \" // trim ( line )) return end if if ( ang_mom == 'L' ) then ! L shell: create two shells (S and P) reading_l_shell = . true . ishell = ishell + 1 l_shell_s_idx = ishell atom_basis % shells ( ishell )% ang_mom = 0 ! S call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ishell = ishell + 1 l_shell_p_idx = ishell atom_basis % shells ( ishell )% ang_mom = 1 ! P call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 ! Reset function counter else ! Regular shell reading_l_shell = . false . ishell = ishell + 1 ! Set angular momentum (S=0, P=1, D=2, F=3, G=4, H=5, I=6) atom_basis % shells ( ishell )% ang_mom = ang_mom_char_to_int ( ang_mom ) call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 end if end if case ( LINE_FUNCTION ) if ( in_target_element ) then call parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse function line: \" // trim ( line )) return end if ifunc = ifunc + 1 if ( reading_l_shell ) then if (. not . has_p ) then call error % set ( ERROR_PARSE , \"L shell requires both S and P coefficients\" ) return end if ! Store in both S and P shells atom_basis % shells ( l_shell_s_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_s_idx )% coefficients ( ifunc ) = coeff_s atom_basis % shells ( l_shell_p_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_p_idx )% coefficients ( ifunc ) = coeff_p else ! Store in current shell atom_basis % shells ( ishell )% exponents ( ifunc ) = exponent atom_basis % shells ( ishell )% coefficients ( ifunc ) = coeff_s end if end if case default ! Skip unknown line types (e.g., LINE_UNKNOWN, blank lines, comments) continue end select line_start = line_end end do end subroutine fill_element_basis pure subroutine find_unique_strings ( input_array , unique_array , nunique ) !! Find unique strings in an array !! Returns array of unique strings and count character ( len =* ), intent ( in ) :: input_array (:) character ( len = :), allocatable , intent ( out ) :: unique_array (:) integer , intent ( out ) :: nunique integer :: i , j , n logical :: is_unique character ( len = len ( input_array )), allocatable :: temp_unique (:) n = size ( input_array ) allocate ( temp_unique ( n )) ! Max possible size nunique = 0 do i = 1 , n is_unique = . true . ! Check if we've already seen this string do j = 1 , nunique if ( strings_equal ( input_array ( i ), temp_unique ( j ))) then is_unique = . false . exit end if end do if ( is_unique ) then nunique = nunique + 1 temp_unique ( nunique ) = input_array ( i ) end if end do ! Allocate output array with exact size and copy allocate ( character ( len = len ( input_array )) :: unique_array ( nunique )) unique_array = temp_unique ( 1 : nunique ) end subroutine find_unique_strings pure subroutine copy_atomic_basis ( source , dest ) !! Deep copy of atomic basis data from source to dest type ( atomic_basis_type ), intent ( in ) :: source type ( atomic_basis_type ), intent ( out ) :: dest integer :: ishell dest % element = source % element call dest % allocate_shells ( source % nshells ) do ishell = 1 , source % nshells dest % shells ( ishell )% ang_mom = source % shells ( ishell )% ang_mom call dest % shells ( ishell )% allocate_arrays ( source % shells ( ishell )% nfunc ) dest % shells ( ishell )% exponents = source % shells ( ishell )% exponents dest % shells ( ishell )% coefficients = source % shells ( ishell )% coefficients end do end subroutine copy_atomic_basis subroutine build_molecular_basis ( basis_string , element_names , mol_basis , error ) !! Build molecular basis from geometry and basis file !! Only parses unique elements, then copies basis data to atoms character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_names (:) !! Element for each atom in geometry order type ( molecular_basis_type ), intent ( out ) :: mol_basis type ( error_t ), intent ( out ) :: error integer :: iatom , natoms , iunique , nunique character ( len = :), allocatable :: unique_elements (:) type ( atomic_basis_type ), allocatable :: unique_bases (:) integer :: match_idx match_idx = 0 natoms = size ( element_names ) ! Find unique elements call find_unique_strings ( element_names , unique_elements , nunique ) print * , \"Found \" , nunique , \" unique elements out of \" , natoms , \" atoms\" ! Allocate for unique bases allocate ( unique_bases ( nunique )) ! Parse basis for each unique element do iunique = 1 , nunique print * , \"Parsing basis for: \" , trim ( unique_elements ( iunique )) call parse_element_basis ( basis_string , unique_elements ( iunique ), & unique_bases ( iunique ), error ) if ( error % has_error ()) then ! Prepend context to error message call error % add_context ( \"mqc_basis_reader:read_basis_from_string\" ) call error % set ( ERROR_PARSE , \"Failed to parse basis for element \" // & trim ( unique_elements ( iunique )) // \": \" // error % get_message ()) return end if end do ! Allocate molecular basis and assign to each atom call mol_basis % allocate_elements ( natoms ) do iatom = 1 , natoms ! Find which unique element this atom corresponds to do iunique = 1 , nunique if ( strings_equal ( element_names ( iatom ), unique_elements ( iunique ))) then match_idx = iunique exit end if end do ! Copy the basis data call copy_atomic_basis ( unique_bases ( match_idx ), mol_basis % elements ( iatom )) end do ! Clean up do iunique = 1 , nunique call unique_bases ( iunique )% destroy () end do end subroutine build_molecular_basis end module mqc_basis_reader","tags":"","url":"sourcefile/mqc_basis_reader.f90.html"},{"title":"mqc_program_limits.f90 – metalquicha","text":"Program limits and default parameter, publics Files dependent on this one sourcefile~~mqc_program_limits.f90~~AfferentGraph sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Program limits and default parameter, publics module mqc_program_limits !! Contains compile-time limits and default values for the metalquicha program. !! These are tunable parameter that control memory allocation and algorithm behavior. use pic_types , only : dp implicit none private !--------------------------------------------------------------------------- ! Many-Body Expansion Limits !--------------------------------------------------------------------------- !> Maximum MBE truncation order (1-body, 2-body, ..., N-body) !> Higher orders require factorial growth in fragment combinations integer , parameter , public :: MAX_MBE_LEVEL = 10 !--------------------------------------------------------------------------- ! Numerical Differentiation Defaults !--------------------------------------------------------------------------- !> Default step size for finite difference calculations (Bohr) !> ~0.005 Bohr = ~0.0026 Angstrom, suitable for Hessian/gradient FD real ( dp ), parameter , public :: DEFAULT_FD_DISPLACEMENT = 0.005_dp !--------------------------------------------------------------------------- ! I/O Limits !--------------------------------------------------------------------------- !> Maximum length for input file lines integer , parameter , public :: MAX_LINE_LENGTH = 1024 !> Maximum length for element symbols (e.g., \"He\", \"Uue\") integer , parameter , public :: MAX_ELEMENT_SYMBOL_LEN = 4 !> JSON output format for real numbers (scientific notation) !> Valid values: 'G', 'E', 'EN', 'ES' (json-fortran uses machine precision) character ( len =* ), parameter , public :: JSON_REAL_FORMAT = 'ES' !--------------------------------------------------------------------------- ! Geometry/Structure Limits !--------------------------------------------------------------------------- !> Minimum allowed distance between atoms (Bohr) !> Atoms closer than this are considered overlapping (error condition) real ( dp ), parameter , public :: MIN_ATOM_DISTANCE = 0.01_dp end module mqc_program_limits","tags":"","url":"sourcefile/mqc_program_limits.f90.html"},{"title":"mqc_method_factory.F90 – metalquicha","text":"Factory for creating quantum chemistry method instances This file depends on sourcefile~~mqc_method_factory.f90~~EfferentGraph sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_factory.f90~~AfferentGraph sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Factory for creating quantum chemistry method instances module mqc_method_factory !! Provides centralized creation of quantum chemistry method instances. !! The factory pattern encapsulates method instantiation and configuration, !! making it easy to add new methods without modifying calling code. use pic_types , only : int32 , dp use mqc_method_types , only : METHOD_TYPE_GFN1 , METHOD_TYPE_GFN2 , METHOD_TYPE_HF , & METHOD_TYPE_DFT , METHOD_TYPE_MCSCF , method_type_to_string use mqc_method_config , only : method_config_t use mqc_method_base , only : qc_method_t use mqc_method_hf , only : hf_method_t use mqc_method_dft , only : dft_method_t use mqc_method_mcscf , only : mcscf_method_t #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t use mctc_env , only : wp #endif implicit none private public :: method_factory_t public :: create_method !! Convenience function type :: method_factory_t !! Factory for creating quantum chemistry method instances !! !! Usage: !!   type(method_factory_t) :: factory !!   type(method_config_t) :: config !!   class(qc_method_t), allocatable :: method !! !!   config%method_type = METHOD_TYPE_DFT !!   config%basis_set = \"cc-pvdz\" !!   config%dft%functional = \"pbe0\" !!   method = factory%create(config) contains procedure :: create => factory_create end type method_factory_t contains function factory_create ( this , config ) result ( method ) !! Create a quantum chemistry method instance from configuration !! !! Instantiates the appropriate concrete method type based on !! config%method_type and configures it from the nested config. class ( method_factory_t ), intent ( in ) :: this type ( method_config_t ), intent ( in ) :: config class ( qc_method_t ), allocatable :: method select case ( config % method_type ) #ifndef MQC_WITHOUT_TBLITE case ( METHOD_TYPE_GFN1 , METHOD_TYPE_GFN2 ) allocate ( xtb_method_t :: method ) call configure_xtb ( method , config ) #else case ( METHOD_TYPE_GFN1 , METHOD_TYPE_GFN2 ) error stop \"XTB methods require tblite library (MQC_ENABLE_TBLITE)\" #endif case ( METHOD_TYPE_HF ) allocate ( hf_method_t :: method ) call configure_hf ( method , config ) case ( METHOD_TYPE_DFT ) allocate ( dft_method_t :: method ) call configure_dft ( method , config ) case ( METHOD_TYPE_MCSCF ) allocate ( mcscf_method_t :: method ) call configure_mcscf ( method , config ) case default error stop \"Unknown method type in method_factory_t%create\" end select end function factory_create #ifndef MQC_WITHOUT_TBLITE subroutine configure_xtb ( method , config ) !! Configure an XTB method instance from config%xtb class ( qc_method_t ), intent ( inout ) :: method type ( method_config_t ), intent ( in ) :: config select type ( m => method ) type is ( xtb_method_t ) ! Core settings m % variant = method_type_to_string ( config % method_type ) m % verbose = config % verbose m % accuracy = real ( config % xtb % accuracy , wp ) ! Electronic temperature (convert K to Hartree) ! kt = T * k_B, where k_B = 3.166808578545117e-06 Hartree/K m % kt = real ( config % xtb % electronic_temp , wp ) * 3.166808578545117e-06_wp ! Solvation settings from config%xtb if ( config % xtb % has_solvation ()) then m % solvent = trim ( config % xtb % solvent ) if ( len_trim ( config % xtb % solvation_model ) > 0 ) then m % solvation_model = trim ( config % xtb % solvation_model ) else m % solvation_model = \"alpb\" ! Default end if m % use_cds = config % xtb % use_cds m % use_shift = config % xtb % use_shift m % dielectric = real ( config % xtb % dielectric , wp ) m % cpcm_nang = config % xtb % cpcm_nang m % cpcm_rscale = real ( config % xtb % cpcm_rscale , wp ) end if end select end subroutine configure_xtb #endif subroutine configure_hf ( method , config ) !! Configure a Hartree-Fock method instance from config%scf (shared SCF settings) class ( qc_method_t ), intent ( inout ) :: method type ( method_config_t ), intent ( in ) :: config select type ( m => method ) type is ( hf_method_t ) ! Common settings m % options % basis_set = config % basis_set m % options % spherical = config % use_spherical m % options % verbose = config % verbose ! SCF settings from shared config%scf m % options % max_iter = config % scf % max_iter m % options % conv_tol = config % scf % energy_convergence m % options % density_tol = config % scf % density_convergence m % options % use_diis = config % scf % use_diis m % options % diis_size = config % scf % diis_size end select end subroutine configure_hf subroutine configure_dft ( method , config ) !! Configure a DFT method instance from config%scf (shared) and config%dft (DFT-specific) class ( qc_method_t ), intent ( inout ) :: method type ( method_config_t ), intent ( in ) :: config select type ( m => method ) type is ( dft_method_t ) ! Common settings m % options % basis_set = config % basis_set m % options % spherical = config % use_spherical m % options % verbose = config % verbose ! SCF settings from shared config%scf m % options % max_iter = config % scf % max_iter m % options % energy_tol = config % scf % energy_convergence m % options % density_tol = config % scf % density_convergence m % options % use_diis = config % scf % use_diis m % options % diis_size = config % scf % diis_size ! DFT-specific from config%dft m % options % functional = config % dft % functional m % options % grid_type = config % dft % grid_type m % options % radial_points = config % dft % radial_points m % options % angular_points = config % dft % angular_points ! Density fitting m % options % use_density_fitting = config % dft % use_density_fitting m % options % aux_basis_set = config % dft % aux_basis_set ! Dispersion m % options % use_dispersion = config % dft % use_dispersion m % options % dispersion_type = config % dft % dispersion_type end select end subroutine configure_dft subroutine configure_mcscf ( method , config ) !! Configure a MCSCF method instance from config%mcscf class ( qc_method_t ), intent ( inout ) :: method type ( method_config_t ), intent ( in ) :: config select type ( m => method ) type is ( mcscf_method_t ) ! Common settings m % options % basis_set = config % basis_set m % options % spherical = config % use_spherical m % options % verbose = config % verbose ! Active space from config%mcscf m % options % n_active_electrons = config % mcscf % n_active_electrons m % options % n_active_orbitals = config % mcscf % n_active_orbitals m % options % n_inactive_orbitals = config % mcscf % n_inactive_orbitals ! State averaging m % options % n_states = config % mcscf % n_states if ( allocated ( config % mcscf % state_weights )) then if ( allocated ( m % options % state_weights )) deallocate ( m % options % state_weights ) allocate ( m % options % state_weights ( size ( config % mcscf % state_weights ))) m % options % state_weights = config % mcscf % state_weights end if ! Convergence m % options % max_macro_iter = config % mcscf % max_macro_iter m % options % max_micro_iter = config % mcscf % max_micro_iter m % options % orbital_tol = config % mcscf % orbital_convergence m % options % ci_tol = config % mcscf % ci_convergence ! PT2 corrections m % options % use_pt2 = config % mcscf % use_pt2 m % options % pt2_type = config % mcscf % pt2_type m % options % ipea_shift = config % mcscf % ipea_shift m % options % imaginary_shift = config % mcscf % imaginary_shift end select end subroutine configure_mcscf function create_method ( config ) result ( method ) !! Convenience function to create a method without instantiating factory !! !! Usage: !!   use mqc_method_factory, only: create_method !!   method = create_method(config) type ( method_config_t ), intent ( in ) :: config class ( qc_method_t ), allocatable :: method type ( method_factory_t ) :: factory method = factory % create ( config ) end function create_method end module mqc_method_factory","tags":"","url":"sourcefile/mqc_method_factory.f90.html"},{"title":"mqc_frag_utils.f90 – metalquicha","text":"Fragment generation and manipulation utilities This file depends on sourcefile~~mqc_frag_utils.f90~~EfferentGraph sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_frag_utils.f90~~AfferentGraph sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Fragment generation and manipulation utilities module mqc_frag_utils !! Provides combinatorial functions and algorithms for generating molecular !! fragments, managing fragment lists, and performing many-body expansion calculations. !! !! This module re-exports functionality from specialized modules: !! - mqc_combinatorics: Pure combinatorial mathematics !! - mqc_fragment_lookup: Hash-based fragment index lookup !! - mqc_gmbe_utils: GMBE intersection and PIE enumeration use pic_types , only : int32 , int64 , dp , int_index use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_physical_fragment , only : system_geometry_t use mqc_combinatorics , only : & binomial , & get_nfrags , & create_monomer_list , & generate_fragment_list , & combine , & get_next_combination , & next_combination_init , & next_combination , & print_combos , & calculate_fragment_distances use mqc_fragment_lookup , only : fragment_lookup_t use mqc_gmbe_utils , only : & find_fragment_intersection , & generate_intersections , & compute_polymer_atoms , & generate_polymer_intersections , & gmbe_enumerate_pie_terms implicit none private ! Re-export from mqc_combinatorics public :: binomial public :: create_monomer_list public :: generate_fragment_list public :: combine public :: get_nfrags public :: get_next_combination public :: next_combination_init public :: next_combination public :: print_combos public :: calculate_fragment_distances ! Re-export from mqc_fragment_lookup public :: fragment_lookup_t ! Re-export from mqc_gmbe_utils public :: find_fragment_intersection public :: generate_intersections public :: compute_polymer_atoms public :: generate_polymer_intersections public :: gmbe_enumerate_pie_terms ! Local utilities public :: apply_distance_screening public :: sort_fragments_by_size contains subroutine apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) !! Apply distance-based screening to filter out fragments that exceed cutoff distances !! Modifies polymers array in-place and updates total_fragments count !! !! IMPORTANT: For MBE correctness, if any k-subset of an n-mer exceeds the k-mer cutoff, !! the entire n-mer must be screened out. Otherwise, compute_mbe will fail when trying !! to look up the missing subset. use mqc_physical_fragment , only : calculate_monomer_distance use mqc_config_adapter , only : driver_config_t integer , intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: total_fragments type ( system_geometry_t ), intent ( in ) :: sys_geom type ( driver_config_t ), intent ( in ) :: driver_config integer , intent ( in ) :: max_level integer ( int64 ) :: i , fragments_kept integer :: fragment_size integer ( int64 ) :: fragments_screened logical :: should_screen ! Check if we have cutoffs to apply if (. not . allocated ( driver_config % fragment_cutoffs )) then return ! No screening needed end if fragments_kept = 0_int64 fragments_screened = 0_int64 ! Loop through all fragments and filter based on distance do i = 1_int64 , total_fragments fragment_size = count ( polymers ( i , :) > 0 ) ! Monomers are always kept (distance = 0) if ( fragment_size == 1 ) then fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then ! Compact array - move this fragment to the kept position polymers ( fragments_kept , :) = polymers ( i , :) end if cycle end if ! For n-mers (n >= 2), check if this fragment or any of its subsets should be screened should_screen = fragment_should_be_screened ( polymers ( i , 1 : fragment_size ), fragment_size , & sys_geom , driver_config ) if (. not . should_screen ) then ! Keep this fragment fragments_kept = fragments_kept + 1_int64 if ( fragments_kept /= i ) then polymers ( fragments_kept , :) = polymers ( i , :) end if else ! Screen out this fragment fragments_screened = fragments_screened + 1_int64 end if end do ! Update total fragment count if ( fragments_screened > 0 ) then call logger % info ( \"Distance-based screening applied:\" ) call logger % info ( \"  Fragments before screening: \" // to_char ( total_fragments )) call logger % info ( \"  Fragments screened out: \" // to_char ( fragments_screened )) call logger % info ( \"  Fragments kept: \" // to_char ( fragments_kept )) total_fragments = fragments_kept end if end subroutine apply_distance_screening function fragment_should_be_screened ( fragment , n , sys_geom , driver_config ) result ( should_screen ) !! Check if a fragment should be screened out based on distance cutoffs. !! Returns true if the fragment itself OR any of its k-subsets (k >= 2) exceeds !! the corresponding k-mer cutoff. This ensures MBE subset consistency. use mqc_physical_fragment , only : calculate_monomer_distance use mqc_config_adapter , only : driver_config_t integer , intent ( in ) :: fragment (:) integer , intent ( in ) :: n type ( system_geometry_t ), intent ( in ) :: sys_geom type ( driver_config_t ), intent ( in ) :: driver_config logical :: should_screen integer :: subset_size , num_cutoffs integer :: indices ( n ), subset ( n ) integer :: j real ( dp ) :: distance , cutoff logical :: has_next should_screen = . false . num_cutoffs = size ( driver_config % fragment_cutoffs ) ! Check all subset sizes from 2 up to n (the full fragment) ! If any k-subset exceeds the k-mer cutoff, screen this fragment do subset_size = 2 , n ! Skip if no cutoff defined for this level if ( subset_size > num_cutoffs ) cycle cutoff = driver_config % fragment_cutoffs ( subset_size ) ! Skip if cutoff is non-positive (no screening for this level) if ( cutoff <= 0.0_dp ) cycle ! Initialize first combination indices do j = 1 , subset_size indices ( j ) = j end do ! Loop through all combinations of this size do ! Build current subset do j = 1 , subset_size subset ( j ) = fragment ( indices ( j )) end do ! Calculate distance for this subset distance = calculate_monomer_distance ( sys_geom , subset ( 1 : subset_size )) ! If subset exceeds cutoff, screen the whole fragment if ( distance > cutoff ) then should_screen = . true . return end if ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do end do end function fragment_should_be_screened ! cannot make this pure because sort is not pure subroutine sort_fragments_by_size ( polymers , total_fragments , max_level ) !! Sort fragments by size (largest first) for better load balancing !! Uses in-place sorting to reorder the polymers array !! Larger fragments (e.g., tetramers) are computed before smaller ones (e.g., dimers) use pic_sorting , only : sort_index integer , intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level integer ( int64 ), allocatable :: fragment_sizes (:) integer ( int_index ), allocatable :: sort_indices (:) integer , allocatable :: polymers_copy (:, :) integer ( int64 ) :: i , j , sorted_idx integer :: fragment_size ! Nothing to sort if we have 1 or fewer fragments if ( total_fragments <= 1 ) return ! Allocate arrays for sorting (0-indexed for PIC library) allocate ( fragment_sizes ( 0 : total_fragments - 1 )) allocate ( sort_indices ( 0 : total_fragments - 1 )) ! Calculate fragment sizes do i = 0 , total_fragments - 1 fragment_size = count ( polymers ( i + 1 , :) > 0 ) fragment_sizes ( i ) = int ( fragment_size , int64 ) end do ! Get sort permutation in descending order (largest first) call sort_index ( fragment_sizes , sort_indices , reverse = . true .) ! Reorder polymers array based on sort permutation allocate ( polymers_copy ( size ( polymers , 1 ), size ( polymers , 2 ))) polymers_copy = polymers ! Reorder: new position j gets data from original position sort_indices(j) ! NOTE: sort_indices already contains 1-indexed values, so don't add 1! do j = 0 , total_fragments - 1 sorted_idx = sort_indices ( j ) ! Already 1-indexed! polymers ( j + 1 , :) = polymers_copy ( sorted_idx , :) end do deallocate ( polymers_copy ) deallocate ( fragment_sizes ) deallocate ( sort_indices ) call logger % info ( \"Fragments queue sorted!\" ) end subroutine sort_fragments_by_size end module mqc_frag_utils","tags":"","url":"sourcefile/mqc_frag_utils.f90.html"},{"title":"mqc_config_adapter.f90 – metalquicha","text":"Adapter module to convert mqc_config_t to internal driver structures\nThis module provides a bridge between the .mqc file format and the driver backend This file depends on sourcefile~~mqc_config_adapter.f90~~EfferentGraph sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_config_adapter.f90~~AfferentGraph sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Adapter module to convert mqc_config_t to internal driver structures !! This module provides a bridge between the .mqc file format and the driver backend module mqc_config_adapter !! Provides conversion utilities from mqc_config_t to driver-compatible structures use pic_types , only : dp , int32 use mqc_config_parser , only : mqc_config_t use mqc_physical_fragment , only : system_geometry_t , to_bohr use mqc_elements , only : element_symbol_to_number use mqc_error , only : error_t , ERROR_VALIDATION use mqc_calculation_keywords , only : hessian_keywords_t , aimd_keywords_t , scf_keywords_t use pic_logger , only : logger => global_logger implicit none private public :: driver_config_t !! Minimal config for driver public :: config_to_driver , config_to_system_geometry public :: get_logger_level !! Convert log level string to integer public :: check_fragment_overlap !! Check for overlapping fragments (for testing) !! Runtime configuration for driver (internal use only) type :: driver_config_t ! Core calculation settings integer ( int32 ) :: method !! QC method constant integer ( int32 ) :: calc_type !! Calculation type constant ! Fragmentation settings integer :: nlevel = 0 !! Fragmentation level (0 = unfragmented) logical :: allow_overlapping_fragments = . false . !! Enable GMBE for overlapping fragments integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) real ( dp ), allocatable :: fragment_cutoffs (:) !! Distance cutoffs for n-mer screening (Angstrom) ! XTB solvation settings character ( len = :), allocatable :: solvent !! Solvent name or empty for gas phase character ( len = :), allocatable :: solvation_model !! \"alpb\" (default), \"gbsa\", or \"cpcm\" logical :: use_cds = . true . !! Include CDS non-polar terms (not for CPCM) logical :: use_shift = . true . !! Include solution state shift (not for CPCM) ! CPCM-specific settings real ( dp ) :: dielectric = - 1.0_dp !! Direct dielectric constant (-1 = use solvent lookup) integer :: cpcm_nang = 110 !! Number of angular grid points for CPCM real ( dp ) :: cpcm_rscale = 1.0_dp !! Radii scaling factor for CPCM ! Calculation-specific keywords (structured) type ( hessian_keywords_t ) :: hessian !! Hessian calculation keywords type ( aimd_keywords_t ) :: aimd !! AIMD calculation keywords type ( scf_keywords_t ) :: scf !! SCF calculation keywords ! Output control logical :: skip_json_output = . false . !! Skip JSON output for large calculations end type driver_config_t contains subroutine config_to_driver ( mqc_config , driver_config , molecule_index ) !! Convert mqc_config_t to minimal driver_config_t !! Extracts only the fields needed by the driver !! If molecule_index is provided, uses that molecule's fragment count type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ), intent ( out ) :: driver_config integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: nfrag_to_use ! Copy method and calc_type (already integers) driver_config % method = mqc_config % method driver_config % calc_type = mqc_config % calc_type ! Determine fragment count if ( present ( molecule_index )) then ! Multi-molecule mode: use specific molecule's fragment count if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then nfrag_to_use = 0 else nfrag_to_use = mqc_config % molecules ( molecule_index )% nfrag end if else ! Single molecule mode (backward compatible) nfrag_to_use = mqc_config % nfrag end if ! Set fragmentation level ! For unfragmented calculations (nfrag=0), nlevel must be 0 if ( nfrag_to_use == 0 ) then driver_config % nlevel = 0 else driver_config % nlevel = mqc_config % frag_level end if ! Set GMBE overlapping fragments flag driver_config % allow_overlapping_fragments = mqc_config % allow_overlapping_fragments ! Set GMBE maximum intersection level driver_config % max_intersection_level = mqc_config % max_intersection_level ! Copy fragment distance cutoffs if present if ( allocated ( mqc_config % fragment_cutoffs )) then allocate ( driver_config % fragment_cutoffs ( size ( mqc_config % fragment_cutoffs ))) driver_config % fragment_cutoffs = mqc_config % fragment_cutoffs end if ! Copy XTB solvation settings if ( allocated ( mqc_config % solvent )) then driver_config % solvent = mqc_config % solvent end if if ( allocated ( mqc_config % solvation_model )) then driver_config % solvation_model = mqc_config % solvation_model end if driver_config % use_cds = mqc_config % use_cds driver_config % use_shift = mqc_config % use_shift ! Copy CPCM-specific settings driver_config % dielectric = mqc_config % dielectric driver_config % cpcm_nang = mqc_config % cpcm_nang driver_config % cpcm_rscale = mqc_config % cpcm_rscale ! Set calculation-specific keywords driver_config % hessian % displacement = mqc_config % hessian_displacement driver_config % hessian % temperature = mqc_config % hessian_temperature driver_config % hessian % pressure = mqc_config % hessian_pressure driver_config % aimd % dt = mqc_config % aimd_dt driver_config % aimd % nsteps = mqc_config % aimd_nsteps driver_config % aimd % initial_temperature = mqc_config % aimd_initial_temperature driver_config % aimd % output_frequency = mqc_config % aimd_output_frequency driver_config % scf % max_iterations = mqc_config % scf_maxiter driver_config % scf % convergence_threshold = mqc_config % scf_tolerance ! Output control driver_config % skip_json_output = mqc_config % skip_json_output end subroutine config_to_driver subroutine config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index ) !! Convert mqc_config_t geometry to system_geometry_t !! For unfragmented calculations (nfrag=0), treats entire system as single unit !! For fragmented calculations, currently assumes monomer-based fragmentation !! If molecule_index is provided, uses that specific molecule from multi-molecule mode type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: i logical :: use_angstrom ! Determine units use_angstrom = . true . if ( allocated ( mqc_config % units )) then if ( trim ( mqc_config % units ) == 'bohr' ) then use_angstrom = . false . end if end if ! Handle multi-molecule vs single molecule mode if ( present ( molecule_index )) then ! Multi-molecule mode: extract specific molecule if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then call error % set ( ERROR_VALIDATION , \"Invalid molecule_index in multi-molecule mode\" ) return end if call molecule_to_system_geometry ( mqc_config % molecules ( molecule_index ), & sys_geom , use_angstrom , mqc_config % allow_overlapping_fragments , error ) else ! Single molecule mode (backward compatible) ! Check if geometry is loaded if ( mqc_config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in mqc_config\" ) return end if if ( mqc_config % nfrag == 0 ) then ! Unfragmented calculation: entire system is one \"monomer\" call geometry_to_system_unfragmented ( mqc_config % geometry , sys_geom , use_angstrom ) sys_geom % charge = mqc_config % charge sys_geom % multiplicity = mqc_config % multiplicity else ! Fragmented calculation with explicit fragments call geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_adapter:config_to_system_geometry\" ) return end if end if end if end subroutine config_to_system_geometry subroutine geometry_to_system_unfragmented ( geom , sys_geom , use_angstrom ) !! Convert geometry to system_geometry_t for unfragmented calculation !! Treats entire system as a single monomer use mqc_geometry , only : geometry_type type ( geometry_type ), intent ( in ) :: geom type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom integer :: i ! For unfragmented: n_monomers=1, atoms_per_monomer=natoms sys_geom % n_monomers = 1 sys_geom % atoms_per_monomer = geom % natoms sys_geom % total_atoms = geom % natoms allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine geometry_to_system_unfragmented subroutine initialize_fragmented_system ( nfrag , geom , fragments , charge , multiplicity , & allow_overlapping , use_angstrom , sys_geom , error ) !! Shared helper to initialize system_geometry_t for fragmented calculations !! Handles fragment allocation, size checking, and overlap validation use mqc_geometry , only : geometry_type use mqc_config_parser , only : input_fragment_t integer , intent ( in ) :: nfrag type ( geometry_type ), intent ( in ) :: geom type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: charge , multiplicity logical , intent ( in ) :: allow_overlapping logical , intent ( in ) :: use_angstrom type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer :: i , j , atoms_in_first_frag , max_frag_size logical :: all_same_size ! Set up basic system geometry sys_geom % n_monomers = nfrag sys_geom % total_atoms = geom % natoms sys_geom % charge = charge sys_geom % multiplicity = multiplicity ! Allocate fragment info arrays allocate ( sys_geom % fragment_sizes ( nfrag )) allocate ( sys_geom % fragment_charges ( nfrag )) allocate ( sys_geom % fragment_multiplicities ( nfrag )) ! Get fragment sizes max_frag_size = 0 atoms_in_first_frag = size ( fragments ( 1 )% indices ) all_same_size = . true . do i = 1 , nfrag sys_geom % fragment_sizes ( i ) = size ( fragments ( i )% indices ) sys_geom % fragment_charges ( i ) = fragments ( i )% charge sys_geom % fragment_multiplicities ( i ) = fragments ( i )% multiplicity max_frag_size = max ( max_frag_size , sys_geom % fragment_sizes ( i )) if ( sys_geom % fragment_sizes ( i ) /= atoms_in_first_frag ) then all_same_size = . false . end if end do ! Allocate fragment_atoms array allocate ( sys_geom % fragment_atoms ( max_frag_size , nfrag )) sys_geom % fragment_atoms = - 1 ! Initialize with invalid index ! Store fragment atom indices (0-indexed from input file) do i = 1 , nfrag do j = 1 , sys_geom % fragment_sizes ( i ) sys_geom % fragment_atoms ( j , i ) = fragments ( i )% indices ( j ) end do end do ! Check for overlapping fragments if not allowed if (. not . allow_overlapping ) then call check_fragment_overlap ( fragments , nfrag , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_adapter:geometry_to_system_fragmented\" ) return end if end if ! Set atoms_per_monomer: use common size if identical, else 0 if ( all_same_size ) then sys_geom % atoms_per_monomer = atoms_in_first_frag else sys_geom % atoms_per_monomer = 0 ! Signal variable-sized fragments end if allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine initialize_fragmented_system subroutine geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) !! Convert geometry to system_geometry_t for fragmented calculation !! Supports both identical and variable-sized fragments type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error call initialize_fragmented_system ( mqc_config % nfrag , mqc_config % geometry , mqc_config % fragments , & mqc_config % charge , mqc_config % multiplicity , & mqc_config % allow_overlapping_fragments , use_angstrom , & sys_geom , error ) end subroutine geometry_to_system_fragmented subroutine molecule_to_system_geometry ( mol , sys_geom , use_angstrom , allow_overlapping , error ) !! Convert a molecule_t to system_geometry_t !! Handles both unfragmented (nfrag=0) and fragmented molecules use mqc_config_parser , only : molecule_t type ( molecule_t ), intent ( in ) :: mol type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error logical , intent ( in ) :: allow_overlapping ! Check if geometry is loaded if ( mol % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in molecule\" ) return end if if ( mol % nfrag == 0 ) then ! Unfragmented molecule call geometry_to_system_unfragmented ( mol % geometry , sys_geom , use_angstrom ) sys_geom % charge = mol % charge sys_geom % multiplicity = mol % multiplicity else ! Fragmented molecule call initialize_fragmented_system ( mol % nfrag , mol % geometry , mol % fragments , & mol % charge , mol % multiplicity , & allow_overlapping , use_angstrom , & sys_geom , error ) end if end subroutine molecule_to_system_geometry function get_logger_level ( level_string ) result ( level_int ) !! Convert string log level to integer value !! This function uses the pic_logger constants use pic_logger , only : debug_level , verbose_level , info_level , performance_level , & warning_level , error_level , knowledge_level character ( len =* ), intent ( in ) :: level_string integer :: level_int select case ( trim ( adjustl ( level_string ))) case ( 'debug' , 'Debug' , 'DEBUG' ) level_int = debug_level case ( 'verbose' , 'Verbose' , 'VERBOSE' ) level_int = verbose_level case ( 'info' , 'Info' , 'INFO' ) level_int = info_level case ( 'performance' , 'Performance' , 'PERFORMANCE' ) level_int = performance_level case ( 'warning' , 'Warning' , 'WARNING' ) level_int = warning_level case ( 'error' , 'Error' , 'ERROR' ) level_int = error_level case ( 'knowledge' , 'Knowledge' , 'KNOWLEDGE' ) level_int = knowledge_level case default ! Default to info level if unknown call logger % warning ( \"Unknown log level string: \" // level_string // \". Defaulting to INFO level.\" ) level_int = info_level end select end function get_logger_level subroutine check_fragment_overlap ( fragments , nfrag , error ) !! Check if any atoms appear in multiple fragments !! This is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes use mqc_config_parser , only : input_fragment_t use pic_io , only : to_char type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: nfrag type ( error_t ), intent ( out ) :: error integer :: i , j , k , l integer :: atom_i , atom_j ! Compare each pair of fragments do i = 1 , nfrag - 1 do j = i + 1 , nfrag ! Compare atoms in fragment i with atoms in fragment j do k = 1 , size ( fragments ( i )% indices ) atom_i = fragments ( i )% indices ( k ) do l = 1 , size ( fragments ( j )% indices ) atom_j = fragments ( j )% indices ( l ) if ( atom_i == atom_j ) then ! Found overlapping atom call error % set ( ERROR_VALIDATION , \"Overlapping fragments detected: fragments \" // to_char ( i ) // \" and \" // & to_char ( j ) // \" both contain atom \" // to_char ( atom_i ) // & \". Set allow_overlapping_fragments = true to allow this.\" ) return end if end do end do end do end do end subroutine check_fragment_overlap end module mqc_config_adapter","tags":"","url":"sourcefile/mqc_config_adapter.f90.html"},{"title":"mqc_json_output_types.f90 – metalquicha","text":"Unified JSON output data container\nCentralizes all data needed for JSON output from any calculation type This file depends on sourcefile~~mqc_json_output_types.f90~~EfferentGraph sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_json_output_types.f90~~AfferentGraph sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Unified JSON output data container !! Centralizes all data needed for JSON output from any calculation type module mqc_json_output_types use pic_types , only : int64 , dp use mqc_thermochemistry , only : thermochemistry_result_t implicit none private public :: json_output_data_t public :: OUTPUT_MODE_NONE , OUTPUT_MODE_UNFRAGMENTED , OUTPUT_MODE_MBE , OUTPUT_MODE_GMBE_PIE ! Output mode constants integer , parameter :: OUTPUT_MODE_NONE = 0 integer , parameter :: OUTPUT_MODE_UNFRAGMENTED = 1 integer , parameter :: OUTPUT_MODE_MBE = 2 integer , parameter :: OUTPUT_MODE_GMBE_PIE = 3 type :: json_output_data_t !! Unified container for all JSON output data !! !! This type consolidates all data needed to write JSON output for any !! calculation type (unfragmented, MBE, GMBE PIE). The output_mode field !! determines which format to use when writing JSON. integer :: output_mode = OUTPUT_MODE_NONE !! OUTPUT_MODE_* constant !----- Common data ----- real ( dp ) :: total_energy = 0.0_dp real ( dp ), allocatable :: gradient (:, :) !! (3, natoms) real ( dp ), allocatable :: hessian (:, :) !! (3*natoms, 3*natoms) real ( dp ), allocatable :: dipole (:) !! (3) logical :: has_energy = . false . logical :: has_gradient = . false . logical :: has_hessian = . false . logical :: has_dipole = . false . !----- Vibrational data (optional) ----- real ( dp ), allocatable :: frequencies (:) !! cm&#94;-1 real ( dp ), allocatable :: reduced_masses (:) !! amu real ( dp ), allocatable :: force_constants (:) !! mdyne/Angstrom real ( dp ), allocatable :: ir_intensities (:) !! km/mol type ( thermochemistry_result_t ) :: thermo logical :: has_vibrational = . false . logical :: has_ir_intensities = . false . !----- MBE-specific data (store ALL fragments for detailed output) ----- integer , allocatable :: polymers (:, :) !! Fragment composition (n_fragments, max_level) real ( dp ), allocatable :: fragment_energies (:) !! Per-fragment total energies real ( dp ), allocatable :: delta_energies (:) !! MBE delta corrections real ( dp ), allocatable :: sum_by_level (:) !! Energy sum per level real ( dp ), allocatable :: fragment_distances (:) !! Per-fragment min distances (Angstrom) integer ( int64 ) :: fragment_count = 0 integer :: max_level = 0 !----- GMBE PIE-specific data ----- integer , allocatable :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_terms) integer , allocatable :: pie_coefficients (:) !! PIE coefficients real ( dp ), allocatable :: pie_energies (:) !! Per-term energies integer ( int64 ) :: n_pie_terms = 0 contains procedure :: destroy => json_output_data_destroy procedure :: reset => json_output_data_reset end type json_output_data_t contains subroutine json_output_data_destroy ( this ) !! Clean up all allocated memory class ( json_output_data_t ), intent ( inout ) :: this ! Common data if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) ! Vibrational data if ( allocated ( this % frequencies )) deallocate ( this % frequencies ) if ( allocated ( this % reduced_masses )) deallocate ( this % reduced_masses ) if ( allocated ( this % force_constants )) deallocate ( this % force_constants ) if ( allocated ( this % ir_intensities )) deallocate ( this % ir_intensities ) ! MBE data if ( allocated ( this % polymers )) deallocate ( this % polymers ) if ( allocated ( this % fragment_energies )) deallocate ( this % fragment_energies ) if ( allocated ( this % delta_energies )) deallocate ( this % delta_energies ) if ( allocated ( this % sum_by_level )) deallocate ( this % sum_by_level ) if ( allocated ( this % fragment_distances )) deallocate ( this % fragment_distances ) ! GMBE PIE data if ( allocated ( this % pie_atom_sets )) deallocate ( this % pie_atom_sets ) if ( allocated ( this % pie_coefficients )) deallocate ( this % pie_coefficients ) if ( allocated ( this % pie_energies )) deallocate ( this % pie_energies ) call this % reset () end subroutine json_output_data_destroy subroutine json_output_data_reset ( this ) !! Reset all flags and scalar values to defaults class ( json_output_data_t ), intent ( inout ) :: this this % output_mode = OUTPUT_MODE_NONE this % total_energy = 0.0_dp this % has_energy = . false . this % has_gradient = . false . this % has_hessian = . false . this % has_dipole = . false . this % has_vibrational = . false . this % has_ir_intensities = . false . this % fragment_count = 0 this % max_level = 0 this % n_pie_terms = 0 end subroutine json_output_data_reset end module mqc_json_output_types","tags":"","url":"sourcefile/mqc_json_output_types.f90.html"},{"title":"mqc_fragment_lookup.f90 – metalquicha","text":"Hash-based lookup table for fast fragment index retrieval This file depends on sourcefile~~mqc_fragment_lookup.f90~~EfferentGraph sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_fragment_lookup.f90~~AfferentGraph sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Hash-based lookup table for fast fragment index retrieval module mqc_fragment_lookup !! Provides O(1) hash table for mapping monomer combinations to fragment indices use pic_types , only : int32 , int64 , dp use pic_sorting , only : sort use pic_hash_32bit , only : fnv_1a_hash use mqc_error , only : error_t , ERROR_VALIDATION implicit none private public :: fragment_lookup_t !! Hash-based lookup table type type :: hash_entry_t !! Single entry in hash table (private helper type) integer , allocatable :: key (:) !! Sorted monomer indices integer ( int64 ) :: value !! Fragment index type ( hash_entry_t ), pointer :: next => null () !! Chain for collisions end type hash_entry_t type :: fragment_lookup_t !! Hash-based lookup table for O(1) fragment index retrieval integer :: table_size = 0 type ( hash_entry_t ), allocatable :: table (:) integer ( int64 ) :: n_entries = 0 logical :: initialized = . false . contains procedure :: init => fragment_lookup_init procedure :: insert => fragment_lookup_insert procedure :: find => fragment_lookup_find procedure :: destroy => fragment_lookup_destroy end type fragment_lookup_t contains pure subroutine fragment_lookup_init ( this , estimated_entries ) !! Initialize hash table with estimated size class ( fragment_lookup_t ), intent ( inout ) :: this integer ( int64 ), intent ( in ) :: estimated_entries integer :: i ! Use prime number close to estimated size for better distribution this % table_size = next_prime_internal ( int ( estimated_entries * 1.3_dp )) allocate ( this % table ( this % table_size )) ! Initialize all entries as empty do i = 1 , this % table_size nullify ( this % table ( i )% next ) end do this % n_entries = 0 this % initialized = . true . end subroutine fragment_lookup_init subroutine fragment_lookup_insert ( this , monomers , n , fragment_idx , error ) !! Insert a monomer combination -> fragment index mapping class ( fragment_lookup_t ), intent ( inout ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ), intent ( in ) :: fragment_idx type ( error_t ), intent ( out ), optional :: error integer ( int32 ) :: hash_val integer :: bucket type ( hash_entry_t ), pointer :: new_entry integer , allocatable :: sorted_key (:) if (. not . this % initialized ) then if ( present ( error )) then call error % set ( ERROR_VALIDATION , \"Hash table not initialized\" ) end if return end if ! Sort monomers for canonical key allocate ( sorted_key ( n )) sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Check if this is the first entry in bucket if (. not . allocated ( this % table ( bucket )% key )) then ! First entry in this bucket - use the head entry allocate ( this % table ( bucket )% key ( n )) this % table ( bucket )% key = sorted_key this % table ( bucket )% value = fragment_idx this % n_entries = this % n_entries + 1 else ! Bucket already has entries - chain new entry allocate ( new_entry ) allocate ( new_entry % key ( n )) new_entry % key = sorted_key new_entry % value = fragment_idx new_entry % next => this % table ( bucket )% next this % table ( bucket )% next => new_entry this % n_entries = this % n_entries + 1 end if deallocate ( sorted_key ) end subroutine fragment_lookup_insert function fragment_lookup_find ( this , monomers , n ) result ( idx ) !! Find fragment index for given monomer combination class ( fragment_lookup_t ), intent ( in ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ) :: idx integer ( int32 ) :: hash_val integer :: bucket , sorted_key ( n ) type ( hash_entry_t ), pointer :: entry ! Sort monomers for canonical key sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Search chain if ( allocated ( this % table ( bucket )% key )) then if ( arrays_equal_internal ( this % table ( bucket )% key , sorted_key , n )) then idx = this % table ( bucket )% value return end if entry => this % table ( bucket )% next do while ( associated ( entry )) if ( arrays_equal_internal ( entry % key , sorted_key , n )) then idx = entry % value return end if entry => entry % next end do end if ! Not found idx = - 1 end function fragment_lookup_find pure subroutine fragment_lookup_destroy ( this ) !! Clean up hash table and all chains class ( fragment_lookup_t ), intent ( inout ) :: this integer :: i type ( hash_entry_t ), pointer :: entry , next_entry if (. not . this % initialized ) return do i = 1 , this % table_size ! Free chain entry => this % table ( i )% next do while ( associated ( entry )) next_entry => entry % next if ( allocated ( entry % key )) deallocate ( entry % key ) deallocate ( entry ) entry => next_entry end do ! Free bucket head if ( allocated ( this % table ( i )% key )) deallocate ( this % table ( i )% key ) end do deallocate ( this % table ) this % initialized = . false . end subroutine fragment_lookup_destroy ! Helper functions for hash table pure function arrays_equal_internal ( a , b , n ) result ( equal ) !! Check if two arrays are equal integer , intent ( in ) :: a (:), b (:), n logical :: equal integer :: i equal = . true . if ( size ( a ) /= n . or . size ( b ) /= n ) then equal = . false . return end if do i = 1 , n if ( a ( i ) /= b ( i )) then equal = . false . return end if end do end function arrays_equal_internal pure function next_prime_internal ( n ) result ( p ) !! Find next prime number >= n (simple implementation) integer , intent ( in ) :: n integer :: p , i logical :: is_prime p = max ( n , 2 ) if ( modulo ( p , 2 ) == 0 ) p = p + 1 do is_prime = . true . do i = 3 , int ( sqrt ( real ( p ))) + 1 , 2 if ( modulo ( p , i ) == 0 ) then is_prime = . false . exit end if end do if ( is_prime ) return p = p + 2 end do end function next_prime_internal end module mqc_fragment_lookup","tags":"","url":"sourcefile/mqc_fragment_lookup.f90.html"},{"title":"mqc_mbe_io.f90 – metalquicha","text":"This file depends on sourcefile~~mqc_mbe_io.f90~~EfferentGraph sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe_io.f90~~AfferentGraph sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module mqc_mbe_io !! Non-JSON I/O utilities for MBE calculations !! JSON output has been centralized in mqc_json_writer module use pic_types , only : int32 , int64 , dp use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_physical_fragment , only : physical_fragment_t , to_angstrom use mqc_elements , only : element_number_to_symbol implicit none private public :: print_fragment_xyz , print_detailed_breakdown , get_frag_level_name contains function get_frag_level_name ( frag_level ) result ( level_name ) !! Map body level (n-mer) to descriptive name !! Supports up to decamers (10-mers), then falls back to \"N-mers\" format integer , intent ( in ) :: frag_level character ( len = 32 ) :: level_name select case ( frag_level ) case ( 1 ) level_name = \"monomers\" case ( 2 ) level_name = \"dimers\" case ( 3 ) level_name = \"trimers\" case ( 4 ) level_name = \"tetramers\" case ( 5 ) level_name = \"pentamers\" case ( 6 ) level_name = \"hexamers\" case ( 7 ) level_name = \"heptamers\" case ( 8 ) level_name = \"octamers\" case ( 9 ) level_name = \"nonamers\" case ( 10 ) level_name = \"decamers\" case default ! For levels > 10, use generic format write ( level_name , '(i0,a)' ) frag_level , \"-mers\" end select end function get_frag_level_name subroutine print_fragment_xyz ( fragment_idx , phys_frag ) !! Print fragment geometry in XYZ format integer ( int64 ), intent ( in ) :: fragment_idx type ( physical_fragment_t ), intent ( in ) :: phys_frag integer :: i character ( len = 2 ) :: symbol character ( len = 256 ) :: coord_line call logger % info ( \"=========================================\" ) call logger % info ( \" Fragment \" // to_char ( fragment_idx )) call logger % info ( \" Number of atoms: \" // to_char ( phys_frag % n_atoms )) call logger % info ( \" Coordinates in Angstroms:\" ) call logger % info ( \"-----------------------------------------\" ) do i = 1 , phys_frag % n_atoms symbol = element_number_to_symbol ( phys_frag % element_numbers ( i )) ! Convert from Bohr back to Angstroms for printing write ( coord_line , '(a2,3f15.8)' ) symbol , to_angstrom ( phys_frag % coordinates ( 1 : 3 , i )) call logger % info ( trim ( coord_line )) end do call logger % info ( \"=========================================\" ) end subroutine print_fragment_xyz subroutine print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) !! Print detailed energy breakdown for each fragment !! Shows full energy and deltaE correction for all monomers, dimers, trimers, etc. !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) integer ( int64 ) :: i integer :: fragment_size , j , frag_level character ( len = 512 ) :: fragment_str , energy_line integer ( int64 ) :: count_by_level call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) call logger % verbose ( \"Detailed Energy Breakdown by Fragment\" ) call logger % verbose ( \"============================================\" ) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). Using generic N-mers notation.\" ) end if do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then call logger % verbose ( \" \" ) block character ( len = 256 ) :: header character ( len = 32 ) :: level_name level_name = get_frag_level_name ( frag_level ) write ( header , '(a,a,i0,a)' ) trim ( level_name ), \" (\" , count_by_level , \" fragments):\" ! Capitalize first letter if ( len_trim ( level_name ) > 0 ) then if ( level_name ( 1 : 1 ) >= 'a' . and . level_name ( 1 : 1 ) <= 'z' ) then header ( 1 : 1 ) = achar ( iachar ( header ( 1 : 1 )) - 32 ) end if end if call logger % verbose ( trim ( header )) end block call logger % verbose ( \"--------------------------------------------\" ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then fragment_str = \"[\" do j = 1 , fragment_size if ( j > 1 ) then write ( fragment_str , '(a,a,i0)' ) trim ( fragment_str ), \",\" , polymers ( i , j ) else write ( fragment_str , '(a,i0)' ) trim ( fragment_str ), polymers ( i , j ) end if end do write ( fragment_str , '(a,a)' ) trim ( fragment_str ), \"]\" if ( frag_level == 1 ) then write ( energy_line , '(a,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ) else write ( energy_line , '(a,a,f20.10,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ), & \"   deltaE: \" , delta_energies ( i ) end if call logger % verbose ( trim ( energy_line )) end if end do end if end do call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) end subroutine print_detailed_breakdown end module mqc_mbe_io","tags":"","url":"sourcefile/mqc_mbe_io.f90.html"},{"title":"mqc_libcint_interface.f90 – metalquicha","text":"Libcint Fortran interface module Source Code !! Libcint Fortran interface module module mqc_libcint_interface !! Provides Fortran interface to the Libcint library for integral calculations !use libcint_fortran implicit none private end module mqc_libcint_interface","tags":"","url":"sourcefile/mqc_libcint_interface.f90.html"},{"title":"mqc_method_hf.f90 – metalquicha","text":"Hartree-Fock method implementation for metalquicha This file depends on sourcefile~~mqc_method_hf.f90~~EfferentGraph sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_hf.f90~~AfferentGraph sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Hartree-Fock method implementation for metalquicha module mqc_method_hf !! Implements the Hartree-Fock quantum chemistry method !! Provides energy and gradient calculations using a basic SCF procedure. use pic_types , only : dp use mqc_method_base , only : qc_method_t use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: hf_method_t , hf_options_t type :: hf_options_t !! Hartree-Fock calculation options character ( len = 32 ) :: basis_set = 'sto-3g' !! Basis set name logical :: spherical = . true . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . false . !! Print SCF iterations ! SCF settings (from shared scf_config_t) integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: conv_tol = 1.0e-8_dp !! Energy convergence threshold real ( dp ) :: density_tol = 1.0e-6_dp !! Density matrix convergence threshold logical :: use_diis = . true . !! Use DIIS acceleration integer :: diis_size = 8 !! Number of Fock matrices for DIIS end type hf_options_t type , extends ( qc_method_t ) :: hf_method_t !! Hartree-Fock method implementation type ( hf_options_t ) :: options contains procedure :: calc_energy => hf_calc_energy procedure :: calc_gradient => hf_calc_gradient procedure :: calc_hessian => null_hessian !! Placeholder for Hessian calculation end type hf_method_t contains subroutine hf_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement actual HF calculation ! 1. Convert fragment%basis to libcint format ! 2. Build one-electron integrals (S, T, V) ! 3. Run SCF iterations ! 4. Calculate final energy print * , \"HF: Calculating energy for fragment with\" , fragment % n_atoms , \"atoms\" print * , \"HF: nelec =\" , fragment % nelec print * , \"HF: charge =\" , fragment % charge print * , \"HF: multiplicity =\" , fragment % multiplicity ! Dummy result result % energy % scf = - 1.0_dp ! Placeholder result % has_energy = . true . print * , \"HF: Dummy energy =\" , result % energy % total () end subroutine hf_calc_energy subroutine hf_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement gradient calculation ! 1. Calculate energy (call calc_energy) ! 2. Calculate gradient using integral derivatives print * , \"HF: Calculating gradient for fragment with\" , fragment % n_atoms , \"atoms\" ! First get energy call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . print * , \"HF: Dummy gradient allocated\" end subroutine hf_calc_gradient subroutine null_hessian ( this , fragment , result ) !! Placeholder for Hessian calculation class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result print * , \"HF: Hessian calculation not implemented yet.\" result % has_hessian = . false . end subroutine null_hessian end module mqc_method_hf","tags":"","url":"sourcefile/mqc_method_hf.f90.html"},{"title":"mqc_json_writer.f90 – metalquicha","text":"Centralized JSON output writer\nSingle entry point for all JSON output in metalquicha This file depends on sourcefile~~mqc_json_writer.f90~~EfferentGraph sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_json_writer.f90~~AfferentGraph sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Centralized JSON output writer !! Single entry point for all JSON output in metalquicha module mqc_json_writer use pic_types , only : int64 , dp use pic_logger , only : logger => global_logger use mqc_json_output_types , only : json_output_data_t , & OUTPUT_MODE_UNFRAGMENTED , OUTPUT_MODE_MBE , OUTPUT_MODE_GMBE_PIE use mqc_io_helpers , only : get_output_json_filename , get_basename use mqc_physical_constants , only : HARTREE_TO_CALMOL , R_CALMOLK , AU_TO_DEBYE , CAL_TO_J use mqc_program_limits , only : JSON_REAL_FORMAT use mqc_mbe_io , only : get_frag_level_name use json_module , only : json_core , json_value implicit none private public :: write_json_output !! Single entry point for all JSON output contains subroutine write_json_output ( output_data ) !! THE single entry point for all JSON output !! !! Dispatches to the appropriate JSON writer based on output_mode. !! This is the ONLY place in the codebase where JSON files are written. type ( json_output_data_t ), intent ( in ) :: output_data select case ( output_data % output_mode ) case ( OUTPUT_MODE_UNFRAGMENTED ) if ( output_data % has_vibrational ) then call write_vibrational_json_impl ( output_data ) else call write_unfragmented_json_impl ( output_data ) end if case ( OUTPUT_MODE_MBE ) if ( output_data % has_vibrational ) then call write_vibrational_json_impl ( output_data ) else call write_mbe_breakdown_json_impl ( output_data ) end if case ( OUTPUT_MODE_GMBE_PIE ) if ( output_data % has_vibrational ) then call write_vibrational_json_impl ( output_data ) else call write_gmbe_pie_json_impl ( output_data ) end if case default call logger % error ( \"Unknown output mode in write_json_output\" ) end select end subroutine write_json_output subroutine write_unfragmented_json_impl ( data ) !! Write unfragmented calculation results to output JSON file type ( json_output_data_t ), intent ( in ) :: data type ( json_core ) :: json type ( json_value ), pointer :: root , main_obj , dipole_obj integer :: iunit , io_stat character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () call json % initialize ( real_format = JSON_REAL_FORMAT ) call json % create_object ( root , '' ) call json % create_object ( main_obj , trim ( basename )) call json % add ( root , main_obj ) if ( data % has_energy ) call json % add ( main_obj , 'total_energy' , data % total_energy ) if ( data % has_dipole . and . allocated ( data % dipole )) then call json % create_object ( dipole_obj , 'dipole' ) call json % add ( main_obj , dipole_obj ) call json % add ( dipole_obj , 'x' , data % dipole ( 1 )) call json % add ( dipole_obj , 'y' , data % dipole ( 2 )) call json % add ( dipole_obj , 'z' , data % dipole ( 3 )) call json % add ( dipole_obj , 'magnitude_debye' , norm2 ( data % dipole ) * AU_TO_DEBYE ) end if if ( data % has_gradient . and . allocated ( data % gradient )) then call json % add ( main_obj , 'gradient_norm' , sqrt ( sum ( data % gradient ** 2 ))) end if if ( data % has_hessian . and . allocated ( data % hessian )) then call json % add ( main_obj , 'hessian_frobenius_norm' , sqrt ( sum ( data % hessian ** 2 ))) end if call logger % info ( \"Writing JSON output to \" // trim ( output_file )) open ( newunit = iunit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) call json % destroy ( root ) return end if call json % print ( root , iunit ) close ( iunit ) call json % destroy ( root ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine write_unfragmented_json_impl subroutine write_mbe_breakdown_json_impl ( data ) !! Write detailed MBE energy breakdown to JSON file type ( json_output_data_t ), intent ( in ) :: data type ( json_core ) :: json type ( json_value ), pointer :: root , main_obj , levels_arr , level_obj , frags_arr , frag_obj type ( json_value ), pointer :: dipole_obj integer ( int64 ) :: i , count_by_level integer :: fragment_size , j , frag_level , iunit , io_stat integer , allocatable :: indices (:) character ( len = 32 ) :: level_name character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () if ( data % max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). JSON will use generic N-mers notation.\" ) end if call json % initialize ( real_format = JSON_REAL_FORMAT ) call json % create_object ( root , '' ) call json % create_object ( main_obj , trim ( basename )) call json % add ( root , main_obj ) call json % add ( main_obj , 'total_energy' , data % total_energy ) ! Build levels array call json % create_array ( levels_arr , 'levels' ) call json % add ( main_obj , levels_arr ) do frag_level = 1 , data % max_level count_by_level = 0_int64 do i = 1_int64 , data % fragment_count fragment_size = count ( data % polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then call json % create_object ( level_obj , '' ) call json % add ( levels_arr , level_obj ) level_name = get_frag_level_name ( frag_level ) call json % add ( level_obj , 'frag_level' , frag_level ) call json % add ( level_obj , 'name' , trim ( level_name )) call json % add ( level_obj , 'count' , int ( count_by_level )) if ( allocated ( data % sum_by_level )) then call json % add ( level_obj , 'total_energy' , data % sum_by_level ( frag_level )) end if call json % create_array ( frags_arr , 'fragments' ) call json % add ( level_obj , frags_arr ) do i = 1_int64 , data % fragment_count fragment_size = count ( data % polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then call json % create_object ( frag_obj , '' ) call json % add ( frags_arr , frag_obj ) allocate ( indices ( fragment_size )) indices = data % polymers ( i , 1 : fragment_size ) call json % add ( frag_obj , 'indices' , indices ) deallocate ( indices ) if ( allocated ( data % fragment_energies )) then call json % add ( frag_obj , 'energy' , data % fragment_energies ( i )) end if if ( allocated ( data % fragment_distances )) then call json % add ( frag_obj , 'distance' , data % fragment_distances ( i )) end if if ( frag_level > 1 . and . allocated ( data % delta_energies )) then call json % add ( frag_obj , 'delta_energy' , data % delta_energies ( i )) end if end if end do end if end do ! Add dipole if computed if ( data % has_dipole . and . allocated ( data % dipole )) then call json % create_object ( dipole_obj , 'dipole' ) call json % add ( main_obj , dipole_obj ) call json % add ( dipole_obj , 'x' , data % dipole ( 1 )) call json % add ( dipole_obj , 'y' , data % dipole ( 2 )) call json % add ( dipole_obj , 'z' , data % dipole ( 3 )) call json % add ( dipole_obj , 'magnitude_debye' , norm2 ( data % dipole ) * AU_TO_DEBYE ) end if if ( data % has_gradient . and . allocated ( data % gradient )) then call json % add ( main_obj , 'gradient_norm' , sqrt ( sum ( data % gradient ** 2 ))) end if if ( data % has_hessian . and . allocated ( data % hessian )) then call json % add ( main_obj , 'hessian_frobenius_norm' , sqrt ( sum ( data % hessian ** 2 ))) end if ! Write to file call logger % info ( \"Writing JSON output to \" // trim ( output_file )) open ( newunit = iunit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) call json % destroy ( root ) return end if call json % print ( root , iunit ) close ( iunit ) call json % destroy ( root ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine write_mbe_breakdown_json_impl subroutine write_gmbe_pie_json_impl ( data ) !! Write GMBE PIE calculation results to output JSON file type ( json_output_data_t ), intent ( in ) :: data type ( json_core ) :: json type ( json_value ), pointer :: root , main_obj , pie_obj , terms_arr , term_obj integer :: j , max_atoms , n_atoms , iunit , io_stat integer ( int64 ) :: i , n_nonzero_terms integer , allocatable :: atom_indices (:) character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () call json % initialize ( real_format = JSON_REAL_FORMAT ) call json % create_object ( root , '' ) call json % create_object ( main_obj , trim ( basename )) call json % add ( root , main_obj ) call json % add ( main_obj , 'total_energy' , data % total_energy ) if ( data % has_gradient . and . allocated ( data % gradient )) then call json % add ( main_obj , 'gradient_norm' , sqrt ( sum ( data % gradient ** 2 ))) end if if ( data % has_hessian . and . allocated ( data % hessian )) then call json % add ( main_obj , 'hessian_frobenius_norm' , sqrt ( sum ( data % hessian ** 2 ))) end if ! Count non-zero coefficient terms if ( allocated ( data % pie_coefficients )) then n_nonzero_terms = count ( data % pie_coefficients ( 1 : data % n_pie_terms ) /= 0 ) else n_nonzero_terms = 0 end if ! PIE terms section call json % create_object ( pie_obj , 'pie_terms' ) call json % add ( main_obj , pie_obj ) call json % add ( pie_obj , 'count' , int ( n_nonzero_terms )) call json % create_array ( terms_arr , 'terms' ) call json % add ( pie_obj , terms_arr ) if ( allocated ( data % pie_atom_sets ) . and . allocated ( data % pie_coefficients ) . and . & allocated ( data % pie_energies )) then max_atoms = size ( data % pie_atom_sets , 1 ) do i = 1_int64 , data % n_pie_terms if ( data % pie_coefficients ( i ) == 0 ) cycle call json % create_object ( term_obj , '' ) call json % add ( terms_arr , term_obj ) ! Extract atom list size (atoms until negative sentinel) n_atoms = 0 do while ( n_atoms < max_atoms . and . data % pie_atom_sets ( n_atoms + 1 , i ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_indices ( n_atoms )) atom_indices = data % pie_atom_sets ( 1 : n_atoms , i ) call json % add ( term_obj , 'atom_indices' , atom_indices ) deallocate ( atom_indices ) call json % add ( term_obj , 'coefficient' , data % pie_coefficients ( i )) call json % add ( term_obj , 'energy' , data % pie_energies ( i )) call json % add ( term_obj , 'weighted_energy' , real ( data % pie_coefficients ( i ), dp ) * data % pie_energies ( i )) end do end if ! Write to file call logger % info ( \"Writing GMBE PIE JSON output to \" // trim ( output_file )) open ( newunit = iunit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) call json % destroy ( root ) return end if call json % print ( root , iunit ) close ( iunit ) call json % destroy ( root ) call logger % info ( \"GMBE PIE JSON output written successfully to \" // trim ( output_file )) end subroutine write_gmbe_pie_json_impl subroutine write_vibrational_json_impl ( data ) !! Write vibrational analysis and thermochemistry results to JSON file type ( json_output_data_t ), intent ( in ) :: data type ( json_core ) :: json type ( json_value ), pointer :: root , main_obj , dipole_obj , vib_obj , thermo_obj type ( json_value ), pointer :: moi_obj , rot_obj , pf_obj , contrib_obj , table_obj type ( json_value ), pointer :: trans_obj , rot_contrib , vib_contrib , elec_obj type ( json_value ), pointer :: vib_row , rot_row , int_row , tr_row , tot_row type ( json_value ), pointer :: thermal_obj , total_e_obj integer :: io_stat , iunit character ( len = 256 ) :: output_file , basename real ( dp ) :: pV_cal , H_vib_cal , H_rot_cal , H_trans_cal , H_total_cal real ( dp ) :: Cv_total , S_total , S_total_J , H_int_cal , Cv_int , S_int , S_int_J , Cp_trans real ( dp ) :: grad_norm , hess_norm output_file = get_output_json_filename () basename = get_basename () call json % initialize ( real_format = JSON_REAL_FORMAT ) ! Create root object call json % create_object ( root , '' ) ! Create main object with basename as key call json % create_object ( main_obj , trim ( basename )) call json % add ( root , main_obj ) ! Total energy if ( data % has_energy ) call json % add ( main_obj , 'total_energy' , data % total_energy ) ! Dipole if ( data % has_dipole . and . allocated ( data % dipole )) then call json % create_object ( dipole_obj , 'dipole' ) call json % add ( main_obj , dipole_obj ) call json % add ( dipole_obj , 'x' , data % dipole ( 1 )) call json % add ( dipole_obj , 'y' , data % dipole ( 2 )) call json % add ( dipole_obj , 'z' , data % dipole ( 3 )) call json % add ( dipole_obj , 'magnitude_debye' , norm2 ( data % dipole ) * AU_TO_DEBYE ) end if ! Gradient and Hessian norms if ( data % has_gradient . and . allocated ( data % gradient )) then grad_norm = sqrt ( sum ( data % gradient ** 2 )) call json % add ( main_obj , 'gradient_norm' , grad_norm ) end if if ( data % has_hessian . and . allocated ( data % hessian )) then hess_norm = sqrt ( sum ( data % hessian ** 2 )) call json % add ( main_obj , 'hessian_frobenius_norm' , hess_norm ) end if ! Vibrational analysis section call json % create_object ( vib_obj , 'vibrational_analysis' ) call json % add ( main_obj , vib_obj ) if ( allocated ( data % frequencies )) then call json % add ( vib_obj , 'n_modes' , size ( data % frequencies )) call json % add ( vib_obj , 'frequencies_cm1' , data % frequencies ) end if if ( allocated ( data % reduced_masses )) then call json % add ( vib_obj , 'reduced_masses_amu' , data % reduced_masses ) end if if ( allocated ( data % force_constants )) then call json % add ( vib_obj , 'force_constants_mdyne_ang' , data % force_constants ) end if if ( data % has_ir_intensities . and . allocated ( data % ir_intensities )) then call json % add ( vib_obj , 'ir_intensities_km_mol' , data % ir_intensities ) end if ! Thermochemistry section call json % create_object ( thermo_obj , 'thermochemistry' ) call json % add ( main_obj , thermo_obj ) ! Conditions call json % add ( thermo_obj , 'temperature_K' , data % thermo % temperature ) call json % add ( thermo_obj , 'pressure_atm' , data % thermo % pressure ) call json % add ( thermo_obj , 'molecular_mass_amu' , data % thermo % total_mass ) call json % add ( thermo_obj , 'symmetry_number' , data % thermo % symmetry_number ) call json % add ( thermo_obj , 'spin_multiplicity' , data % thermo % spin_multiplicity ) call json % add ( thermo_obj , 'is_linear' , data % thermo % is_linear ) call json % add ( thermo_obj , 'n_real_frequencies' , data % thermo % n_real_freqs ) call json % add ( thermo_obj , 'n_imaginary_frequencies' , data % thermo % n_imag_freqs ) ! Moments of inertia call json % create_object ( moi_obj , 'moments_of_inertia_amu_ang2' ) call json % add ( thermo_obj , moi_obj ) call json % add ( moi_obj , 'Ia' , data % thermo % moments ( 1 )) call json % add ( moi_obj , 'Ib' , data % thermo % moments ( 2 )) call json % add ( moi_obj , 'Ic' , data % thermo % moments ( 3 )) ! Rotational constants call json % create_object ( rot_obj , 'rotational_constants_GHz' ) call json % add ( thermo_obj , rot_obj ) call json % add ( rot_obj , 'A' , data % thermo % rot_const ( 1 )) call json % add ( rot_obj , 'B' , data % thermo % rot_const ( 2 )) call json % add ( rot_obj , 'C' , data % thermo % rot_const ( 3 )) ! Partition functions call json % create_object ( pf_obj , 'partition_functions' ) call json % add ( thermo_obj , pf_obj ) call json % add ( pf_obj , 'translational' , data % thermo % q_trans ) call json % add ( pf_obj , 'rotational' , data % thermo % q_rot ) call json % add ( pf_obj , 'vibrational' , data % thermo % q_vib ) ! Thermodynamic contributions call json % create_object ( contrib_obj , 'contributions' ) call json % add ( thermo_obj , contrib_obj ) call json % create_object ( trans_obj , 'translational' ) call json % add ( contrib_obj , trans_obj ) call json % add ( trans_obj , 'energy_hartree' , data % thermo % E_trans ) call json % add ( trans_obj , 'entropy_cal_mol_K' , data % thermo % S_trans ) call json % add ( trans_obj , 'Cv_cal_mol_K' , data % thermo % Cv_trans ) call json % create_object ( rot_contrib , 'rotational' ) call json % add ( contrib_obj , rot_contrib ) call json % add ( rot_contrib , 'energy_hartree' , data % thermo % E_rot ) call json % add ( rot_contrib , 'entropy_cal_mol_K' , data % thermo % S_rot ) call json % add ( rot_contrib , 'Cv_cal_mol_K' , data % thermo % Cv_rot ) call json % create_object ( vib_contrib , 'vibrational' ) call json % add ( contrib_obj , vib_contrib ) call json % add ( vib_contrib , 'energy_hartree' , data % thermo % E_vib ) call json % add ( vib_contrib , 'entropy_cal_mol_K' , data % thermo % S_vib ) call json % add ( vib_contrib , 'Cv_cal_mol_K' , data % thermo % Cv_vib ) call json % create_object ( elec_obj , 'electronic' ) call json % add ( contrib_obj , elec_obj ) call json % add ( elec_obj , 'energy_hartree' , data % thermo % E_elec ) call json % add ( elec_obj , 'entropy_cal_mol_K' , data % thermo % S_elec ) ! Contribution table pV_cal = R_CALMOLK * data % thermo % temperature H_vib_cal = data % thermo % E_vib * HARTREE_TO_CALMOL H_rot_cal = data % thermo % E_rot * HARTREE_TO_CALMOL H_trans_cal = data % thermo % E_trans * HARTREE_TO_CALMOL + pV_cal H_total_cal = H_vib_cal + H_rot_cal + H_trans_cal H_int_cal = H_vib_cal + H_rot_cal Cp_trans = data % thermo % Cv_trans + R_CALMOLK Cv_int = data % thermo % Cv_vib + data % thermo % Cv_rot Cv_total = Cp_trans + data % thermo % Cv_rot + data % thermo % Cv_vib S_int = data % thermo % S_vib + data % thermo % S_rot S_int_J = S_int * CAL_TO_J S_total = data % thermo % S_trans + data % thermo % S_rot + data % thermo % S_vib + data % thermo % S_elec S_total_J = S_total * CAL_TO_J call json % create_object ( table_obj , 'contribution_table' ) call json % add ( thermo_obj , table_obj ) call json % create_object ( vib_row , 'VIB' ) call json % add ( table_obj , vib_row ) call json % add ( vib_row , 'H_cal_mol' , H_vib_cal ) call json % add ( vib_row , 'Cp_cal_mol_K' , data % thermo % Cv_vib ) call json % add ( vib_row , 'S_cal_mol_K' , data % thermo % S_vib ) call json % add ( vib_row , 'S_J_mol_K' , data % thermo % S_vib * CAL_TO_J ) call json % create_object ( rot_row , 'ROT' ) call json % add ( table_obj , rot_row ) call json % add ( rot_row , 'H_cal_mol' , H_rot_cal ) call json % add ( rot_row , 'Cp_cal_mol_K' , data % thermo % Cv_rot ) call json % add ( rot_row , 'S_cal_mol_K' , data % thermo % S_rot ) call json % add ( rot_row , 'S_J_mol_K' , data % thermo % S_rot * CAL_TO_J ) call json % create_object ( int_row , 'INT' ) call json % add ( table_obj , int_row ) call json % add ( int_row , 'H_cal_mol' , H_int_cal ) call json % add ( int_row , 'Cp_cal_mol_K' , Cv_int ) call json % add ( int_row , 'S_cal_mol_K' , S_int ) call json % add ( int_row , 'S_J_mol_K' , S_int_J ) call json % create_object ( tr_row , 'TR' ) call json % add ( table_obj , tr_row ) call json % add ( tr_row , 'H_cal_mol' , H_trans_cal ) call json % add ( tr_row , 'Cp_cal_mol_K' , Cp_trans ) call json % add ( tr_row , 'S_cal_mol_K' , data % thermo % S_trans ) call json % add ( tr_row , 'S_J_mol_K' , data % thermo % S_trans * CAL_TO_J ) call json % create_object ( tot_row , 'TOT' ) call json % add ( table_obj , tot_row ) call json % add ( tot_row , 'H_cal_mol' , H_total_cal ) call json % add ( tot_row , 'Cp_cal_mol_K' , Cv_total ) call json % add ( tot_row , 'S_cal_mol_K' , S_total ) call json % add ( tot_row , 'S_J_mol_K' , S_total_J ) ! Zero-point energy call json % add ( thermo_obj , 'zero_point_energy_hartree' , data % thermo % zpe_hartree ) call json % add ( thermo_obj , 'zero_point_energy_kcal_mol' , data % thermo % zpe_kcalmol ) ! Thermal corrections call json % create_object ( thermal_obj , 'thermal_corrections_hartree' ) call json % add ( thermo_obj , thermal_obj ) call json % add ( thermal_obj , 'to_energy' , data % thermo % thermal_correction_energy ) call json % add ( thermal_obj , 'to_enthalpy' , data % thermo % thermal_correction_enthalpy ) call json % add ( thermal_obj , 'to_gibbs' , data % thermo % thermal_correction_gibbs ) ! Total energies call json % create_object ( total_e_obj , 'total_energies_hartree' ) call json % add ( thermo_obj , total_e_obj ) call json % add ( total_e_obj , 'electronic' , data % total_energy ) call json % add ( total_e_obj , 'electronic_plus_zpe' , data % total_energy + data % thermo % zpe_hartree ) call json % add ( total_e_obj , 'electronic_plus_thermal_E' , data % total_energy + data % thermo % thermal_correction_energy ) call json % add ( total_e_obj , 'electronic_plus_thermal_H' , data % total_energy + data % thermo % thermal_correction_enthalpy ) call json % add ( total_e_obj , 'electronic_plus_thermal_G' , data % total_energy + data % thermo % thermal_correction_gibbs ) ! Write to file call logger % info ( \"Writing vibrational/thermochemistry JSON to \" // trim ( output_file )) open ( newunit = iunit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) call json % destroy ( root ) return end if call json % print ( root , iunit ) close ( iunit ) call json % destroy ( root ) call logger % info ( \"Vibrational/thermochemistry JSON written successfully to \" // trim ( output_file )) end subroutine write_vibrational_json_impl end module mqc_json_writer","tags":"","url":"sourcefile/mqc_json_writer.f90.html"},{"title":"mqc_calculation_interface.f90 – metalquicha","text":"External calculation interface for geometry optimization, AIMD, and Monte Carlo This file depends on sourcefile~~mqc_calculation_interface.f90~~EfferentGraph sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_mpi_comms.f90 mqc_mpi_comms.f90 sourcefile~mqc_resources.f90->sourcefile~mqc_mpi_comms.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! External calculation interface for geometry optimization, AIMD, and Monte Carlo module mqc_calculation_interface !! Provides a clean interface for computing energies and forces !! that can be used by optimization algorithms, MD integrators, and MC samplers use pic_types , only : int32 , dp use pic_mpi_lib , only : comm_t , bcast , abort_comm use pic_logger , only : logger => global_logger use mqc_physical_fragment , only : system_geometry_t use mqc_config_parser , only : bond_t use mqc_result_types , only : calculation_result_t use mqc_calc_types , only : CALC_TYPE_ENERGY , CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_resources , only : resources_t implicit none private public :: compute_energy_and_forces public :: sync_geometry_to_workers contains subroutine sync_geometry_to_workers ( sys_geom , comm ) !! Synchronize geometry coordinates from master rank to all worker ranks !! This is needed when master rank updates coordinates for optimization/dynamics !! !! TODO: Implement explicit broadcast if needed. Currently, the fragmented !! calculation infrastructure may already handle geometry distribution. !! For unfragmented calculations on master rank only, this is not needed. type ( system_geometry_t ), intent ( inout ) :: sys_geom type ( comm_t ), intent ( in ) :: comm ! NOTE: For now, we rely on the existing calculation infrastructure ! to handle geometry as needed. If explicit broadcasting is required, ! we can add MPI send/recv logic here later. end subroutine sync_geometry_to_workers subroutine compute_energy_and_forces ( sys_geom , driver_config , resources , & energy , gradient , hessian , bonds ) !! Compute energy and forces for current geometry !! This is the main interface for optimization/dynamics codes !! !! Master rank provides updated geometry, all ranks compute fragments, !! results are returned on master rank only !! !! Usage: !!   1. Master rank updates sys_geom%coordinates !!   2. Call this subroutine (all ranks) !!   3. Master rank receives energy/gradient/hessian !!   4. Master rank updates geometry based on forces !!   5. Repeat from step 1 use mqc_driver , only : run_calculation use mqc_config_adapter , only : driver_config_t type ( system_geometry_t ), intent ( inout ) :: sys_geom type ( driver_config_t ), intent ( in ) :: driver_config type ( resources_t ), intent ( in ) :: resources real ( dp ), intent ( out ) :: energy real ( dp ), intent ( out ), optional :: gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( out ), optional :: hessian (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ) :: result logical :: need_gradient , need_hessian ! Determine what we need based on what's requested need_gradient = present ( gradient ) need_hessian = present ( hessian ) ! Synchronize geometry from master to all ranks ! (Master may have updated coordinates for optimization/dynamics) call sync_geometry_to_workers ( sys_geom , resources % mpi_comms % world_comm ) ! Call the main calculation driver ! This handles both fragmented and unfragmented cases call run_calculation ( resources , driver_config , sys_geom , bonds , result ) ! Extract results (only valid on master rank) if ( resources % mpi_comms % world_comm % rank () == 0 ) then energy = result % energy % total () if ( need_gradient . and . result % has_gradient ) then gradient = result % gradient else if ( need_gradient ) then call logger % error ( \"Gradient requested but not computed!\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if if ( need_hessian . and . result % has_hessian ) then hessian = result % hessian else if ( need_hessian ) then call logger % error ( \"Hessian requested but not computed!\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Clean up call result % destroy () end if end subroutine compute_energy_and_forces end module mqc_calculation_interface","tags":"","url":"sourcefile/mqc_calculation_interface.f90.html"},{"title":"mqc_driver.f90 – metalquicha","text":"Main calculation driver module for metalquicha This file depends on sourcefile~~mqc_driver.f90~~EfferentGraph sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_mpi_comms.f90 mqc_mpi_comms.f90 sourcefile~mqc_resources.f90->sourcefile~mqc_mpi_comms.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_driver.f90~~AfferentGraph sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Main calculation driver module for metalquicha module mqc_driver !! Handles both fragmented (many-body expansion) and unfragmented calculations !! with MPI parallelization and node-based work distribution. use pic_types , only : int32 , int64 , dp use pic_mpi_lib , only : comm_t , abort_comm , bcast , allgather use mqc_resources , only : resources_t use pic_logger , only : logger => global_logger use pic_io , only : to_char use omp_lib , only : omp_get_max_threads , omp_set_num_threads use mqc_mbe_fragment_distribution_scheme , only : global_coordinator , node_coordinator , node_worker , unfragmented_calculation , & serial_fragment_processor , do_fragment_work , distributed_unfragmented_hessian use mqc_method_config , only : method_config_t use mqc_gmbe_fragment_distribution_scheme , only : serial_gmbe_pie_processor , gmbe_pie_coordinator use mqc_frag_utils , only : get_nfrags , create_monomer_list , generate_fragment_list , generate_intersections , & gmbe_enumerate_pie_terms , binomial , combine , apply_distance_screening , sort_fragments_by_size use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , & build_fragment_from_indices , build_fragment_from_atom_list use mqc_config_adapter , only : driver_config_t , config_to_driver , config_to_system_geometry use mqc_method_types , only : method_type_to_string use mqc_calc_types , only : calc_type_to_string , CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_config_parser , only : bond_t , mqc_config_t use mqc_mbe , only : compute_gmbe use mqc_result_types , only : calculation_result_t use mqc_error , only : error_t use mqc_io_helpers , only : set_molecule_suffix , get_output_json_filename use mqc_json , only : merge_multi_molecule_json use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_NONE use mqc_json_writer , only : write_json_output implicit none private public :: run_calculation !! Main entry point for all calculations public :: run_multi_molecule_calculations !! Multi-molecule calculation dispatcher contains subroutine run_calculation ( resources , config , sys_geom , bonds , result_out , all_ranks_write_json ) !! Main calculation dispatcher - routes to fragmented or unfragmented calculation !! !! Determines calculation type based on nlevel and dispatches to appropriate !! calculation routine with proper MPI setup and validation. !! If result_out is present, returns result instead of writing JSON (for dynamics/optimization) type ( resources_t ), intent ( in ) :: resources !! Resources container (MPI comms, etc.) type ( driver_config_t ), intent ( in ) :: config !! Driver configuration type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( calculation_result_t ), intent ( out ), optional :: result_out !! Optional result output logical , intent ( in ), optional :: all_ranks_write_json !! If true, all ranks write JSON (for multi-molecule) ! Local variables integer :: max_level !! Maximum fragment level (nlevel from config) integer :: i !! Loop counter type ( json_output_data_t ) :: json_data !! Cached output data for centralized JSON writing logical :: should_write_json !! Whether this rank should write JSON type ( method_config_t ) :: method_config !! Method configuration built from driver config ! Build method_config from driver_config method_config % method_type = config % method method_config % verbose = . false . ! Controlled by logger level in do_fragment_work ! XTB-specific settings (nested in method_config%xtb) method_config % xtb % use_cds = config % use_cds method_config % xtb % use_shift = config % use_shift method_config % xtb % dielectric = config % dielectric method_config % xtb % cpcm_nang = config % cpcm_nang method_config % xtb % cpcm_rscale = config % cpcm_rscale if ( allocated ( config % solvent )) method_config % xtb % solvent = config % solvent if ( allocated ( config % solvation_model )) then method_config % xtb % solvation_model = config % solvation_model else if ( allocated ( config % solvent ) . or . config % dielectric > 0.0_dp ) then method_config % xtb % solvation_model = 'alpb' ! Default solvation model end if ! Log solvation settings if ( method_config % xtb % has_solvation ()) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then if ( trim ( method_config % xtb % solvation_model ) == 'cpcm' ) then if ( config % dielectric > 0.0_dp ) then call logger % info ( \"XTB solvation enabled: cpcm with dielectric = \" // to_char ( config % dielectric )) else call logger % info ( \"XTB solvation enabled: cpcm with \" // trim ( method_config % xtb % solvent )) end if call logger % info ( \"  CPCM grid points (nang): \" // to_char ( config % cpcm_nang )) call logger % info ( \"  CPCM radii scale: \" // to_char ( config % cpcm_rscale )) else call logger % info ( \"XTB solvation enabled: \" // trim ( method_config % xtb % solvation_model ) // \" with \" // & trim ( method_config % xtb % solvent )) if ( config % use_cds ) call logger % info ( \"  CDS (non-polar) terms: enabled\" ) if ( config % use_shift ) call logger % info ( \"  Solution state shift: enabled\" ) end if end if end if ! Set max_level from config max_level = config % nlevel if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % info ( \"============================================\" ) call logger % info ( \"Loaded geometry:\" ) call logger % info ( \"  Total monomers: \" // to_char ( sys_geom % n_monomers )) call logger % info ( \"  Atoms per monomer: \" // to_char ( sys_geom % atoms_per_monomer )) call logger % info ( \"  Total atoms: \" // to_char ( sys_geom % total_atoms )) call logger % info ( \"  Fragment level: \" // to_char ( max_level )) call logger % info ( \"============================================\" ) end if ! Warn if overlapping fragments flag is set but nlevel=0 if ( config % allow_overlapping_fragments . and . max_level == 0 ) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % warning ( \"allow_overlapping_fragments is set to true, but nlevel=0\" ) call logger % warning ( \"Running unfragmented calculation - overlapping fragments flag will be ignored\" ) end if end if ! GMBE (overlapping fragments) with inclusion-exclusion principle ! GMBE(1): Base fragments are monomers ! GMBE(N): Base fragments are N-mers (e.g., dimers for N=2) ! Algorithm: Generate primaries, use DFS to enumerate overlapping cliques, ! accumulate PIE coefficients per unique atom set, evaluate each once if ( max_level == 0 ) then call omp_set_num_threads ( 1 ) if ( present ( result_out )) then ! For dynamics/optimization: return result directly, no JSON output call run_unfragmented_calculation ( resources % mpi_comms % world_comm , sys_geom , & method_config , config % calc_type , bonds , config , result_out ) else ! Normal mode: collect json_data for centralized output call run_unfragmented_calculation ( resources % mpi_comms % world_comm , sys_geom , & method_config , config % calc_type , bonds , config , & json_data = json_data ) end if else if ( present ( result_out )) then ! For fragmented calculations with result_out (future use) call run_fragmented_calculation ( resources , method_config , config % calc_type , sys_geom , max_level , & config % allow_overlapping_fragments , & config % max_intersection_level , bonds , config ) else ! Normal mode: collect json_data for centralized output call run_fragmented_calculation ( resources , method_config , config % calc_type , sys_geom , max_level , & config % allow_overlapping_fragments , & config % max_intersection_level , bonds , config , json_data ) end if end if ! Centralized JSON output (rank 0 only by default, or all ranks if all_ranks_write_json is set) if (. not . present ( result_out )) then ! Check if JSON output should be skipped if ( config % skip_json_output ) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % info ( \"Skipping JSON output (skip_json_output = true)\" ) end if else ! Determine if this rank should write JSON should_write_json = ( resources % mpi_comms % world_comm % rank () == 0 ) if ( present ( all_ranks_write_json )) then if ( all_ranks_write_json ) should_write_json = . true . end if if ( should_write_json ) then if ( json_data % output_mode /= OUTPUT_MODE_NONE ) then call write_json_output ( json_data ) call json_data % destroy () end if end if end if end if end subroutine run_calculation subroutine run_unfragmented_calculation ( world_comm , sys_geom , method_config , & calc_type , bonds , driver_config , result_out , json_data ) !! Handle unfragmented calculation (nlevel=0) !! !! For single-molecule mode: Only rank 0 runs (validates single rank) !! For multi-molecule mode: ALL ranks can run (each with their own molecule) !! For Hessian calculations with multiple ranks: Uses distributed parallelization !! If result_out is present, returns result instead of writing JSON type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( system_geometry_t ), intent ( in ) :: sys_geom !! Complete system geometry type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( driver_config_t ), intent ( in ), optional :: driver_config !! Driver configuration type ( calculation_result_t ), intent ( out ), optional :: result_out !! Optional result output type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data ! For Hessian calculations with multiple ranks, use distributed approach if ( calc_type == CALC_TYPE_HESSIAN . and . world_comm % size () > 1 ) then if ( world_comm % rank () == 0 ) then call logger % info ( \" \" ) call logger % info ( \"Running distributed unfragmented Hessian calculation\" ) call logger % info ( \"  MPI ranks: \" // to_char ( world_comm % size ())) call logger % info ( \" \" ) end if call distributed_unfragmented_hessian ( world_comm , sys_geom , method_config , driver_config , json_data ) return end if ! Check if this is multi-molecule mode or single-molecule mode ! In multi-molecule mode, each rank processes its own molecule ! In single-molecule mode, only rank 0 should work if ( world_comm % size () == 1 . or . world_comm % rank () == 0 ) then ! Either single-rank calculation, or rank 0 in multi-rank setup call logger % info ( \" \" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) call logger % info ( \" \" ) if ( present ( driver_config )) then call unfragmented_calculation ( sys_geom , method_config , calc_type , bonds , result_out , & driver_config % hessian % temperature , driver_config % hessian % pressure , json_data ) else call unfragmented_calculation ( sys_geom , method_config , calc_type , bonds , result_out , json_data = json_data ) end if else if ( sys_geom % total_atoms > 0 ) then ! Multi-molecule mode: non-zero rank with a molecule call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Running unfragmented calculation\" ) if ( present ( driver_config )) then call unfragmented_calculation ( sys_geom , method_config , calc_type , bonds , result_out , & driver_config % hessian % temperature , driver_config % hessian % pressure , json_data ) else call unfragmented_calculation ( sys_geom , method_config , calc_type , bonds , result_out , json_data = json_data ) end if end if end subroutine run_unfragmented_calculation subroutine run_fragmented_calculation ( resources , method_config , calc_type , sys_geom , max_level , & allow_overlapping_fragments , max_intersection_level , bonds , driver_config , json_data ) !! Handle fragmented calculation (nlevel > 0) !! !! Generates fragments, distributes work across MPI processes organized in nodes, !! and coordinates many-body expansion calculation using hierarchical parallelism. !! If allow_overlapping_fragments=true, uses GMBE with intersection correction. type ( resources_t ), intent ( in ) :: resources !! Resources container (MPI comms, etc.) type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info integer , intent ( in ) :: max_level !! Maximum fragment level for MBE logical , intent ( in ) :: allow_overlapping_fragments !! Use GMBE for overlapping fragments integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth for GMBE type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information type ( driver_config_t ), intent ( in ) :: driver_config !! Driver configuration with cutoffs type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data integer ( int64 ) :: total_fragments !! Total number of fragments generated (int64 to handle large systems) integer , allocatable :: polymers (:, :) !! Fragment composition array (fragment, monomer_indices) integer :: num_nodes !! Number of compute nodes integer :: i , j !! Loop counters integer , allocatable :: node_leader_ranks (:) !! Ranks of processes that lead each node integer , allocatable :: monomers (:) !! Temporary monomer list for fragment generation integer ( int64 ) :: n_expected_frags !! Expected number of fragments based on combinatorics (int64 to handle large systems) integer ( int64 ) :: n_rows !! Number of rows needed for polymers array (int64 to handle large systems) integer :: global_node_rank !! Global rank if this process leads a node, -1 otherwise integer , allocatable :: all_node_leader_ranks (:) !! Node leader status for all ranks ! GMBE-specific variables (old approach - kept for compatibility) integer , allocatable :: intersections (:, :) !! Intersection atom lists (max_atoms, n_intersections) integer , allocatable :: intersection_sets (:, :) !! k-tuples for each intersection (n_monomers, n_intersections) integer , allocatable :: intersection_levels (:) !! Level k of each intersection (n_intersections) integer :: n_intersections , n_monomers !! Counts for GMBE ! GMBE PIE-based variables (new approach) integer :: n_primaries !! Number of primary polymers integer ( int64 ) :: n_primaries_i64 !! For binomial calculation integer , allocatable :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , allocatable :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ) :: n_pie_terms !! Number of unique PIE terms type ( error_t ) :: pie_error !! Error from PIE enumeration ! Generate fragments if ( resources % mpi_comms % world_comm % rank () == 0 ) then if ( allow_overlapping_fragments ) then ! GMBE mode: PIE-based inclusion-exclusion ! GMBE(1): primaries are monomers ! GMBE(N): primaries are N-mers (e.g., dimers for N=2) ! Generate primaries if ( max_level == 1 ) then ! GMBE(1): primaries are base monomers n_primaries = sys_geom % n_monomers allocate ( polymers ( n_primaries , 1 )) do i = 1 , n_primaries polymers ( i , 1 ) = i end do else ! GMBE(N): primaries are all C(M, N) N-tuples n_primaries_i64 = binomial ( sys_geom % n_monomers , max_level ) n_primaries = int ( n_primaries_i64 ) allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_primaries , max_level )) polymers = 0 call create_monomer_list ( monomers ) total_fragments = 0_int64 call combine ( monomers , sys_geom % n_monomers , max_level , polymers , total_fragments ) n_primaries = int ( total_fragments ) deallocate ( monomers ) ! Apply distance-based screening to primaries if cutoffs are provided if ( max_level > 1 ) then ! Only screen if primaries are n-mers (not for GMBE(1) where primaries are monomers) total_fragments = int ( n_primaries , int64 ) call apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) n_primaries = int ( total_fragments ) end if ! Sort primaries by size (largest first) ! TODO: Currently disabled - see comment in MBE section above ! total_fragments = int(n_primaries, int64) call sort_fragments_by_size ( polymers , total_fragments , max_level ) end if call logger % info ( \"Generated \" // to_char ( n_primaries ) // \" primary \" // to_char ( max_level ) // \"-mers for GMBE(\" // & to_char ( max_level ) // \")\" ) ! Use DFS to enumerate PIE terms with coefficients call gmbe_enumerate_pie_terms ( sys_geom , polymers , n_primaries , max_level , max_intersection_level , & pie_atom_sets , pie_coefficients , n_pie_terms , pie_error ) if ( pie_error % has_error ()) then call logger % error ( \"GMBE PIE enumeration failed: \" // pie_error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if call logger % info ( \"GMBE PIE enumeration complete: \" // to_char ( n_pie_terms ) // \" unique subsystems to evaluate\" ) ! For now: total_fragments = n_pie_terms (each PIE term is a subsystem to evaluate) total_fragments = n_pie_terms else ! Standard MBE mode ! Calculate expected number of fragments n_expected_frags = get_nfrags ( sys_geom % n_monomers , max_level ) n_rows = n_expected_frags ! Allocate monomer list and polymers array allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_rows , max_level )) polymers = 0 ! Create monomer list [1, 2, 3, ..., n_monomers] call create_monomer_list ( monomers ) ! Generate all fragments (includes monomers in polymers array) total_fragments = 0_int64 ! First add monomers do i = 1 , sys_geom % n_monomers total_fragments = total_fragments + 1_int64 polymers ( total_fragments , 1 ) = i end do ! Then add n-mers for n >= 2 call generate_fragment_list ( monomers , max_level , polymers , total_fragments ) deallocate ( monomers ) ! Apply distance-based screening if cutoffs are provided call apply_distance_screening ( polymers , total_fragments , sys_geom , driver_config , max_level ) ! Sort fragments by size (largest first) for better load balancing ! TODO: Currently disabled - MBE assembly is now order-independent (uses nested loops), ! but sorting still causes \"Subset not found\" errors in real validation cases. ! Unit tests pass with arbitrary order, so there may be an issue with the hash table ! or fragment generation in production code. Needs investigation. call sort_fragments_by_size ( polymers , total_fragments , max_level ) call logger % info ( \"Generated fragments:\" ) call logger % info ( \"  Total fragments: \" // to_char ( total_fragments )) call logger % info ( \"  Max level: \" // to_char ( max_level )) end if end if ! Broadcast total_fragments to all ranks call bcast ( resources % mpi_comms % world_comm , total_fragments , 1 , 0 ) ! Determine node leaders global_node_rank = - 1 if ( resources % mpi_comms % node_comm % rank () == 0 ) global_node_rank = resources % mpi_comms % world_comm % rank () allocate ( all_node_leader_ranks ( resources % mpi_comms % world_comm % size ())) call allgather ( resources % mpi_comms % world_comm , global_node_rank , all_node_leader_ranks ) num_nodes = count ( all_node_leader_ranks /= - 1 ) if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % info ( \"Running with \" // to_char ( num_nodes ) // \" node(s)\" ) end if allocate ( node_leader_ranks ( num_nodes )) i = 0 do j = 1 , resources % mpi_comms % world_comm % size () if ( all_node_leader_ranks ( j ) /= - 1 ) then i = i + 1 node_leader_ranks ( i ) = all_node_leader_ranks ( j ) end if end do deallocate ( all_node_leader_ranks ) ! Execute appropriate role if ( resources % mpi_comms % world_comm % size () == 1 ) then ! Single rank: process fragments serially call logger % info ( \"Running in serial mode (single MPI rank)\" ) if ( allow_overlapping_fragments ) then ! GMBE serial processing with PIE coefficients call serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , sys_geom , method_config , calc_type , & bonds , json_data ) else ! Standard MBE serial processing call serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method_config , calc_type , bonds , & json_data ) end if else if ( resources % mpi_comms % world_comm % leader () . and . resources % mpi_comms % node_comm % leader ()) then ! Global coordinator (rank 0, node leader on node 0) call omp_set_num_threads ( omp_get_max_threads ()) call logger % verbose ( \"Rank 0: Acting as global coordinator\" ) if ( allow_overlapping_fragments ) then ! GMBE MPI processing - PIE-based approach call gmbe_pie_coordinator ( resources , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method_config , calc_type , bonds , json_data ) else ! Standard MBE MPI processing call global_coordinator ( resources , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , method_config , calc_type , bonds , json_data ) end if else if ( resources % mpi_comms % node_comm % leader ()) then ! Node coordinator (node leader on other nodes) call logger % verbose ( \"Rank \" // to_char ( resources % mpi_comms % world_comm % rank ()) // \": Acting as node coordinator\" ) ! Node coordinator works for both MBE and GMBE (receives fragments from global coordinator) call node_coordinator ( resources , method_config , calc_type ) else ! Worker call omp_set_num_threads ( 1 ) call logger % verbose ( \"Rank \" // to_char ( resources % mpi_comms % world_comm % rank ()) // \": Acting as worker\" ) ! Worker processes work for both MBE and GMBE (fragment_type distinguishes them) call node_worker ( resources , sys_geom , method_config , calc_type , bonds ) end if ! Cleanup if ( resources % mpi_comms % world_comm % rank () == 0 ) then if ( allocated ( polymers )) deallocate ( polymers ) if ( allocated ( node_leader_ranks )) deallocate ( node_leader_ranks ) if ( allocated ( intersections )) deallocate ( intersections ) if ( allocated ( intersection_sets )) deallocate ( intersection_sets ) if ( allocated ( intersection_levels )) deallocate ( intersection_levels ) if ( allocated ( pie_atom_sets )) deallocate ( pie_atom_sets ) if ( allocated ( pie_coefficients )) deallocate ( pie_coefficients ) end if end subroutine run_fragmented_calculation subroutine run_multi_molecule_calculations ( resources , mqc_config ) !! Run calculations for multiple molecules with MPI parallelization !! Each molecule is independent, so assign one molecule per rank use mqc_config_parser , only : mqc_config_t use mqc_config_adapter , only : config_to_system_geometry use mqc_error , only : error_t use mqc_io_helpers , only : set_molecule_suffix , get_output_json_filename use mqc_json , only : merge_multi_molecule_json type ( resources_t ), intent ( in ) :: resources type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ) :: config type ( system_geometry_t ) :: sys_geom type ( resources_t ) :: mol_resources type ( error_t ) :: error integer :: imol , my_rank , num_ranks , color integer :: molecules_processed character ( len = :), allocatable :: mol_name logical :: has_fragmented_molecules character ( len = 256 ), allocatable :: individual_json_files (:) my_rank = resources % mpi_comms % world_comm % rank () num_ranks = resources % mpi_comms % world_comm % size () ! Allocate array to track individual JSON files for merging allocate ( individual_json_files ( mqc_config % nmol )) ! Check if any molecules have fragments (nlevel > 0) has_fragmented_molecules = . false . do imol = 1 , mqc_config % nmol if ( mqc_config % molecules ( imol )% nfrag > 0 ) then has_fragmented_molecules = . true . exit end if end do if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"Multi-molecule mode: \" // to_char ( mqc_config % nmol ) // \" molecules\" ) call logger % info ( \"MPI ranks: \" // to_char ( num_ranks )) if ( has_fragmented_molecules ) then call logger % info ( \"Mode: Sequential execution (fragmented molecules detected)\" ) call logger % info ( \"  Each molecule will use all \" // to_char ( num_ranks ) // \" rank(s) for its calculation\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Mode: Sequential execution (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) call logger % info ( \"Note: More ranks than molecules - ranks \" // to_char ( mqc_config % nmol ) // & \" to \" // to_char ( num_ranks - 1 ) // \" will be idle\" ) else call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) end if call logger % info ( \"============================================\" ) call logger % info ( \" \" ) end if ! Determine execution mode: ! 1. Sequential: Single rank OR fragmented molecules (each molecule needs all ranks) ! 2. Parallel: Multiple ranks AND unfragmented molecules (distribute molecules across ranks) molecules_processed = 0 if ( num_ranks == 1 . or . has_fragmented_molecules ) then ! Sequential mode: process all molecules one after another ! Each molecule uses all available ranks for its calculation do imol = 1 , mqc_config % nmol ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Processing molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) end if ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then call error % add_context ( \"mqc_driver:run_multi_molecule_calculation\" ) if ( my_rank == 0 ) then call logger % error ( \"Error converting geometry for \" // mol_name // \": \" // error % get_full_trace ()) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule call run_calculation ( resources , config , sys_geom , mqc_config % molecules ( imol )% bonds ) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () if ( my_rank == 0 ) then call logger % info ( \"Completed molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) end if molecules_processed = molecules_processed + 1 end do else ! Multiple ranks: distribute molecules across ranks in round-robin fashion molecules_processed = 0 do imol = 1 , mqc_config % nmol ! This rank processes molecules where (imol - 1) mod num_ranks == my_rank if ( mod ( imol - 1 , num_ranks ) == my_rank ) then ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Processing molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then call error % add_context ( \"mqc_driver:run_multi_molecule_calculation\" ) call logger % error ( \"Rank \" // to_char ( my_rank ) // \": Error converting geometry for \" // mol_name // \": \" // error % get_full_trace ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule (all ranks write JSON in parallel mode) call run_calculation ( resources , config , sys_geom , mqc_config % molecules ( imol )% bonds , & all_ranks_write_json = . true .) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Completed molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) molecules_processed = molecules_processed + 1 end if end do if ( molecules_processed == 0 ) then ! Idle rank - no molecules assigned call logger % verbose ( \"Rank \" // to_char ( my_rank ) // \": No molecules assigned (idle)\" ) end if end if ! Synchronize all ranks call resources % mpi_comms % world_comm % barrier () ! In parallel execution, rank 0 needs to reconstruct all JSON filenames for merging ! since each rank only populated its own entry if ( my_rank == 0 . and . num_ranks > 1 . and . . not . has_fragmented_molecules ) then ! Rank 0 constructs filenames for all molecules do imol = 1 , mqc_config % nmol ! Get molecule name if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if ! Construct JSON filename pattern: output_<basename>_<molname>.json ! This mirrors what get_output_json_filename() returns after set_molecule_suffix() call set_molecule_suffix ( \"_\" // trim ( mol_name )) individual_json_files ( imol ) = get_output_json_filename () end do end if ! Merge individual JSON files into one combined file (rank 0 only) if ( my_rank == 0 ) then call merge_multi_molecule_json ( individual_json_files , mqc_config % nmol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"All \" // to_char ( mqc_config % nmol ) // \" molecules completed\" ) if ( has_fragmented_molecules ) then call logger % info ( \"Execution: Sequential (each molecule used all ranks)\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Execution: Sequential (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Execution: Parallel (active ranks: \" // to_char ( mqc_config % nmol ) // \"/\" // to_char ( num_ranks ) // \")\" ) else call logger % info ( \"Execution: Parallel (all ranks active)\" ) end if call logger % info ( \"============================================\" ) end if end subroutine run_multi_molecule_calculations end module mqc_driver","tags":"","url":"sourcefile/mqc_driver.f90.html"},{"title":"mqc_basis_utils.f90 – metalquicha","text":"Utilities for handling basis set names and files This file depends on sourcefile~~mqc_basis_utils.f90~~EfferentGraph sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_basis_utils.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_basis_utils.f90~~AfferentGraph sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_cli_parser.f90 mqc_cli_parser.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_basis_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Utilities for handling basis set names and files module mqc_basis_utils !! Provides utilities for normalizing basis set names and locating basis set files !! !! Normalization rules: !!   * -> s   (e.g., 6-31G* -> 6-31Gs) !!   + -> p   (e.g., 6-31+G -> 6-31pG) !!   (d,p) -> dp (remove parentheses and commas) use mqc_error , only : error_t , ERROR_IO implicit none private public :: normalize_basis_name public :: find_basis_file contains pure function normalize_basis_name ( basis_name ) result ( normalized ) !! Normalize basis set name to filename-safe format !! !! Rules: !!   * -> s !!   + -> p !!   Remove parentheses and commas !! !! Examples: !!   6-31G*      -> 6-31Gs !!   6-31+G*     -> 6-31pGs !!   6-31G(d)    -> 6-31Gd !!   6-311G(d,p) -> 6-311Gdp !!   6-311++G**  -> 6-311ppGss !!   cc-pVDZ     -> cc-pVDZ (unchanged) character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable :: normalized integer :: i , out_pos character ( len = 256 ) :: buffer logical :: in_parens buffer = \"\" out_pos = 0 in_parens = . false . do i = 1 , len_trim ( basis_name ) select case ( basis_name ( i : i )) case ( '*' ) ! Star becomes 's' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 's' case ( '+' ) ! Plus becomes 'p' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 'p' case ( '(' ) ! Start of parentheses - we'll extract contents in_parens = . true . case ( ')' ) ! End of parentheses in_parens = . false . case ( ',' , ' ' ) ! Skip commas and spaces (inside or outside parentheses) continue case default ! Copy character as-is out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = basis_name ( i : i ) end select end do normalized = trim ( buffer ( 1 : out_pos )) end function normalize_basis_name subroutine find_basis_file ( basis_name , filename , error ) !! Find basis set file using normalized name !! !! Search strategy: !!   1. Normalize the basis name (e.g., 6-31G* -> 6-31Gs) !!   2. Look for basis_sets/{normalized}.txt !!   3. If not found, return error !! !! This is a simple, straightforward approach that assumes !! the JSON/mqc input provides the correct basis set name. character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable , intent ( out ) :: filename type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: normalized logical :: file_exists character ( len = 512 ) :: filepath ! Normalize the basis name normalized = normalize_basis_name ( basis_name ) ! Construct file path: basis_sets/{normalized}.txt filepath = \"basis_sets/\" // trim ( normalized ) // \".txt\" ! Check if file exists inquire ( file = trim ( filepath ), exist = file_exists ) if ( file_exists ) then filename = trim ( filepath ) else call error % set ( ERROR_IO , \"Basis set file not found: \" // trim ( filepath ) // & \" (from basis name: \" // trim ( basis_name ) // \")\" ) end if end subroutine find_basis_file end module mqc_basis_utils","tags":"","url":"sourcefile/mqc_basis_utils.f90.html"},{"title":"mqc_geometry.f90 – metalquicha","text":"Geometry data structure for molecular systems Files dependent on this one sourcefile~~mqc_geometry.f90~~AfferentGraph sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Geometry data structure for molecular systems module mqc_geometry !! Defines the geometry data structure for molecular systems use pic_types , only : dp implicit none private public :: geometry_type ! Parameters integer , parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 type :: geometry_type !! Molecular geometry data structure integer :: natoms character ( len = :), allocatable :: elements (:) real ( dp ), allocatable :: coords (:, :) ! coords(3, natoms) character ( len = :), allocatable :: comment contains procedure :: destroy => geometry_destroy end type geometry_type contains subroutine geometry_destroy ( this ) !! Clean up allocated memory in geometry_type class ( geometry_type ), intent ( inout ) :: this if ( allocated ( this % elements )) deallocate ( this % elements ) if ( allocated ( this % coords )) deallocate ( this % coords ) if ( allocated ( this % comment )) deallocate ( this % comment ) this % natoms = 0 end subroutine geometry_destroy end module mqc_geometry","tags":"","url":"sourcefile/mqc_geometry.f90.html"},{"title":"mqc_basis_file_reader.f90 – metalquicha","text":"this file contains the modules and routines to open and read a GAMESS formatted basis set file This file depends on sourcefile~~mqc_basis_file_reader.f90~~EfferentGraph sourcefile~mqc_basis_file_reader.f90 mqc_basis_file_reader.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_basis_file_reader.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_basis_file_reader.f90~~AfferentGraph sourcefile~mqc_basis_file_reader.f90 mqc_basis_file_reader.f90 sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_basis_file_reader.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this file contains the modules and routines to open and read a GAMESS formatted basis set file module mqc_basis_file_reader !! Module for reading and parsing GAMESS formatted basis set files use pic_types , only : int32 , dp use mqc_error , only : error_t , ERROR_IO , ERROR_VALIDATION implicit none private public :: basis_file_t , open_basis_file , extract_element , strings_equal type :: basis_file_t !! Container for basis set file contents character ( len = :), allocatable :: full_content character ( len = :), allocatable :: data_section end type basis_file_t contains subroutine open_basis_file ( basis_file , filename , error ) !! Open and read a GAMESS formatted basis set file type ( basis_file_t ), intent ( out ) :: basis_file character ( len =* ), intent ( in ) :: filename type ( error_t ), intent ( out ) :: error integer :: unit , iostat , file_size logical :: file_exists integer :: data_start , data_end ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"Basis set file not found: \" // filename ) return end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: basis_file % full_content ) ! Open and read entire file open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = iostat ) if ( iostat /= 0 ) then call error % set ( ERROR_IO , \"Error opening file: \" // filename ) return end if read ( unit , iostat = iostat ) basis_file % full_content if ( iostat /= 0 ) then close ( unit ) call error % set ( ERROR_IO , \"Error reading file: \" // filename ) return end if close ( unit ) ! Extract the $DATA section data_start = index ( basis_file % full_content , \"$DATA\" ) if ( data_start == 0 ) then call error % set ( ERROR_VALIDATION , \"Could not find $DATA section in basis set file: \" // filename ) return end if data_end = index ( basis_file % full_content ( data_start :), \"$END\" ) if ( data_end == 0 ) then call error % set ( ERROR_VALIDATION , \"Could not find $END marker in basis set file: \" // filename ) return end if ! Store just the data section (between $DATA and $END) basis_file % data_section = basis_file % full_content ( data_start + 5 : data_start + data_end - 2 ) end subroutine open_basis_file subroutine extract_element ( basis_file , element , element_content , error ) !! Extract the basis set data for a specific element from the basis file type ( basis_file_t ), intent ( in ) :: basis_file character ( len =* ), intent ( in ) :: element character ( len = :), allocatable , intent ( out ) :: element_content type ( error_t ), intent ( out ) :: error integer :: start_pos , end_pos , i character ( len = :), allocatable :: search_element logical :: at_line_start ! Convert element to uppercase for searching search_element = uppercase ( trim ( element )) ! Find the element name (it appears on its own line) start_pos = index ( basis_file % data_section , new_line ( 'a' ) // trim ( search_element ) // new_line ( 'a' )) if ( start_pos == 0 ) then ! Try without leading newline (might be first element after $DATA) if ( index ( basis_file % data_section , trim ( search_element ) // new_line ( 'a' )) == 1 ) then start_pos = 1 else call error % set ( ERROR_VALIDATION , \"Element not found in basis set file: \" // element ) return end if else start_pos = start_pos + 1 ! Skip the leading newline end if ! Find the next element by looking for a line that: ! - Starts with an uppercase letter ! - Has a second character that is also a letter (not a space or number) ! This distinguishes \"CARBON\" from \"S   3\" end_pos = len ( basis_file % data_section ) at_line_start = . false . i = start_pos + len ( search_element ) + 1 do while ( i < len ( basis_file % data_section )) if ( basis_file % data_section ( i : i ) == new_line ( 'a' )) then at_line_start = . true . i = i + 1 cycle end if if ( at_line_start ) then ! We're at the start of a new line if ( is_uppercase_letter ( basis_file % data_section ( i : i ))) then ! Check if next character is also a letter if ( i + 1 <= len ( basis_file % data_section )) then if ( is_letter ( basis_file % data_section ( i + 1 : i + 1 ))) then ! Found next element! end_pos = i - 1 exit end if end if end if at_line_start = . false . end if i = i + 1 end do ! Extract the section element_content = basis_file % data_section ( start_pos : end_pos ) end subroutine extract_element pure function is_letter ( c ) result ( is_alpha ) !! Check if character is a letter (A-Z or a-z) character ( len = 1 ), intent ( in ) :: c logical :: is_alpha integer :: ic ic = iachar ( c ) is_alpha = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) . or . & ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) end function is_letter pure function uppercase ( str ) result ( upper ) !! Convert a string to uppercase, should use pic_ascii! character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: upper integer :: i , ic allocate ( character ( len = len ( str )) :: upper ) upper = str do i = 1 , len ( str ) ic = iachar ( str ( i : i )) if ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) then upper ( i : i ) = achar ( ic - 32 ) end if end do end function uppercase pure function is_uppercase_letter ( c ) result ( is_upper ) !! Check if character is an uppercase letter (A-Z) character ( len = 1 ), intent ( in ) :: c logical :: is_upper integer :: ic ic = iachar ( c ) is_upper = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) end function is_uppercase_letter !> Compare two strings after trimming and adjusting (removing leading/trailing whitespace) pure function strings_equal ( str1 , str2 ) result ( equal ) !! Compare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) character ( len =* ), intent ( in ) :: str1 , str2 logical :: equal equal = trim ( adjustl ( str1 )) == trim ( adjustl ( str2 )) end function strings_equal end module mqc_basis_file_reader","tags":"","url":"sourcefile/mqc_basis_file_reader.f90.html"},{"title":"mqc_mbe_fragment_distribution_scheme.F90 – metalquicha","text":"Many-Body Expansion (MBE) calculation module This file depends on sourcefile~~mqc_mbe_fragment_distribution_scheme.f90~~EfferentGraph sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_mpi_comms.f90 mqc_mpi_comms.f90 sourcefile~mqc_resources.f90->sourcefile~mqc_mpi_comms.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe_fragment_distribution_scheme.f90~~AfferentGraph sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Many-Body Expansion (MBE) calculation module module mqc_mbe_fragment_distribution_scheme !! Implements hierarchical many-body expansion for fragment-based quantum chemistry !! calculations with MPI parallelization and energy/gradient computation. use pic_types , only : int32 , int64 , dp use pic_timer , only : timer_type use pic_blas_interfaces , only : pic_gemm , pic_dot use pic_mpi_lib , only : comm_t , send , recv , isend , irecv , wait , iprobe , MPI_Status , & request_t , MPI_ANY_SOURCE , MPI_ANY_TAG , abort_comm use mqc_resources , only : resources_t use pic_logger , only : logger => global_logger , verbose_level , info_level use pic_io , only : to_char use mqc_mbe_io , only : print_fragment_xyz use omp_lib , only : omp_set_num_threads , omp_get_max_threads use mqc_mbe , only : compute_mbe use mqc_mpi_tags , only : TAG_WORKER_REQUEST , TAG_WORKER_FRAGMENT , TAG_WORKER_FINISH , & TAG_WORKER_SCALAR_RESULT , & TAG_NODE_REQUEST , TAG_NODE_FRAGMENT , TAG_NODE_FINISH , & TAG_NODE_SCALAR_RESULT use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , build_fragment_from_indices , & build_fragment_from_atom_list , to_angstrom , check_duplicate_atoms use mqc_method_types , only : method_type_to_string use mqc_calc_types , only : calc_type_to_string , CALC_TYPE_ENERGY , CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_config_parser , only : bond_t use mqc_config_adapter , only : driver_config_t ! Method API imports use mqc_method_base , only : qc_method_t use mqc_method_config , only : method_config_t use mqc_method_factory , only : create_method use mqc_result_types , only : calculation_result_t , result_send , result_isend , result_recv , result_irecv use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_UNFRAGMENTED , OUTPUT_MODE_MBE , OUTPUT_MODE_GMBE_PIE implicit none private ! Public interface - method_config is passed explicitly to all routines public :: do_fragment_work , global_coordinator , node_coordinator public :: serial_fragment_processor public :: node_worker , unfragmented_calculation , distributed_unfragmented_hessian interface module subroutine do_fragment_work ( fragment_idx , result , method_config , phys_frag , calc_type , world_comm ) implicit none integer ( int64 ), intent ( in ) :: fragment_idx type ( calculation_result_t ), intent ( out ) :: result type ( method_config_t ), intent ( in ) :: method_config !! Method configuration type ( physical_fragment_t ), intent ( in ), optional :: phys_frag integer ( int32 ), intent ( in ) :: calc_type type ( comm_t ), intent ( in ), optional :: world_comm end subroutine do_fragment_work module subroutine global_coordinator ( resources , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , method_config , calc_type , bonds , json_data ) implicit none type ( resources_t ), intent ( in ) :: resources integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level , num_nodes integer , intent ( in ) :: polymers (:, :), node_leader_ranks (:) type ( system_geometry_t ), intent ( in ), optional :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data end subroutine global_coordinator module subroutine node_coordinator ( resources , method_config , calc_type ) implicit none type ( resources_t ), intent ( in ) :: resources type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type end subroutine node_coordinator module subroutine serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , & method_config , calc_type , bonds , json_data ) implicit none integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: polymers (:, :), max_level type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data end subroutine serial_fragment_processor module subroutine node_worker ( resources , sys_geom , method_config , calc_type , bonds ) implicit none type ( resources_t ), intent ( in ) :: resources type ( system_geometry_t ), intent ( in ), optional :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) end subroutine node_worker module subroutine unfragmented_calculation ( sys_geom , method_config , calc_type , bonds , result_out , & temperature , pressure , json_data ) implicit none type ( system_geometry_t ), intent ( in ), optional :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ), intent ( out ), optional :: result_out real ( dp ), intent ( in ), optional :: temperature real ( dp ), intent ( in ), optional :: pressure type ( json_output_data_t ), intent ( out ), optional :: json_data end subroutine unfragmented_calculation module subroutine distributed_unfragmented_hessian ( world_comm , sys_geom , method_config , driver_config , json_data ) implicit none type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration type ( driver_config_t ), intent ( in ), optional :: driver_config !! Driver configuration type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data end subroutine distributed_unfragmented_hessian module subroutine hessian_coordinator ( world_comm , sys_geom , method_config , displacement , temperature , pressure , json_data ) implicit none type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) real ( dp ), intent ( in ) :: temperature !! Temperature for thermochemistry (K) real ( dp ), intent ( in ) :: pressure !! Pressure for thermochemistry (atm) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data end subroutine hessian_coordinator module subroutine hessian_worker ( world_comm , sys_geom , method_config , displacement ) implicit none type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration real ( dp ), intent ( in ) :: displacement !! Finite difference displacement (Bohr) end subroutine hessian_worker end interface end module mqc_mbe_fragment_distribution_scheme","tags":"","url":"sourcefile/mqc_mbe_fragment_distribution_scheme.f90.html"},{"title":"mqc_cli_parser.f90 – metalquicha","text":"Command line argument parsing for metalquicha This file depends on sourcefile~~mqc_cli_parser.f90~~EfferentGraph sourcefile~mqc_cli_parser.f90 mqc_cli_parser.f90 sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_basis_utils.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_basis_utils.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Command line argument parsing for metalquicha module mqc_cli_parser !! Handles parsing of command line options including geometry files, !! basis set specifications, and help/usage display. use mqc_basis_utils , only : normalize_basis_name , find_basis_file use mqc_error , only : error_t , ERROR_PARSE , ERROR_IO implicit none private public :: cli_args_type !! Parsed command line arguments container public :: parse_command_line !! Main argument parsing routine public :: print_usage !! Display program usage information public :: normalize_basis_name !! Standardize basis set names public :: find_basis_file !! Locate basis set files type :: cli_args_type !! Container for parsed command line arguments !! !! Stores file paths and options extracted from command line, !! with automatic memory management for string allocations. character ( len = :), allocatable :: xyz_file !! Input XYZ geometry file path character ( len = :), allocatable :: basis_name !! Basis set name (e.g., \"6-31G\") contains procedure :: destroy => cli_args_destroy !! Memory cleanup end type cli_args_type contains subroutine parse_command_line ( args , error ) !! Parse command line arguments for geometry file and basis set !! !! Extracts XYZ file path and basis set name from command line, !! validates arguments, and handles help requests. type ( cli_args_type ), intent ( out ) :: args !! Parsed argument container type ( error_t ), intent ( out ) :: error !! Error object integer :: nargs !! Number of command line arguments character ( len = 256 ) :: arg_buffer !! Temporary argument buffer integer :: arg_len !! Length of current argument integer :: stat !! Local status for intrinsic calls ! Get number of command line arguments nargs = command_argument_count () ! Check for help flag if ( nargs >= 1 ) then call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading command line argument 1\" ) return end if arg_buffer = trim ( arg_buffer ) if ( arg_buffer == \"-h\" . or . arg_buffer == \"--help\" ) then call print_usage () call error % set ( ERROR_PARSE , \"HELP_REQUESTED\" ) ! Special marker for help return end if end if ! Validate number of arguments if ( nargs < 2 ) then call error % set ( ERROR_PARSE , \"Error: Insufficient arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if if ( nargs > 2 ) then call error % set ( ERROR_PARSE , \"Error: Too many arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if ! Parse argument 1: XYZ file call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry file argument\" ) return end if args % xyz_file = trim ( arg_buffer ) ! Parse argument 2: Basis set name call get_command_argument ( 2 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading basis set name argument\" ) return end if args % basis_name = trim ( arg_buffer ) end subroutine parse_command_line !> Print usage information subroutine print_usage () character ( len = 256 ) :: prog_name integer :: stat call get_command_argument ( 0 , prog_name , status = stat ) if ( stat /= 0 ) prog_name = \"pic_basis_reader\" print * print * , \"Usage: \" , trim ( prog_name ), \" <geometry.xyz> <basis_name>\" print * print * , \"Arguments:\" print * , \"  geometry.xyz   XYZ format molecular geometry file\" print * , \"  basis_name     Name of basis set (e.g., 6-31G, 6-311G**)\" print * print * , \"Options:\" print * , \"  -h, --help     Show this help message\" print * print * , \"Example:\" print * , \"  \" , trim ( prog_name ), \" water.xyz 6-31G\" print * end subroutine print_usage !> Clean up CLI args subroutine cli_args_destroy ( this ) class ( cli_args_type ), intent ( inout ) :: this if ( allocated ( this % xyz_file )) deallocate ( this % xyz_file ) if ( allocated ( this % basis_name )) deallocate ( this % basis_name ) end subroutine cli_args_destroy end module mqc_cli_parser","tags":"","url":"sourcefile/mqc_cli_parser.f90.html"},{"title":"mqc_method_mcscf.f90 – metalquicha","text":"Multi-Configurational Self-Consistent Field (MCSCF) method implementation This file depends on sourcefile~~mqc_method_mcscf.f90~~EfferentGraph sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_mcscf.f90~~AfferentGraph sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Multi-Configurational Self-Consistent Field (MCSCF) method implementation module mqc_method_mcscf !! Implements CASSCF/CASCI quantum chemistry methods !! Provides energy and gradient calculations using complete active space !! with optional perturbative corrections (CASPT2/NEVPT2). use pic_types , only : dp use mqc_method_base , only : qc_method_t use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: mcscf_method_t , mcscf_options_t type :: mcscf_options_t !! MCSCF/CASSCF calculation options character ( len = 32 ) :: basis_set = 'sto-3g' !! Basis set name logical :: spherical = . true . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . false . !! Print iteration details ! Active space definition integer :: n_active_electrons = 0 !! Number of active electrons (CAS) integer :: n_active_orbitals = 0 !! Number of active orbitals (CAS) integer :: n_inactive_orbitals = - 1 !! Number of inactive (doubly occupied) orbitals !! -1 means auto-determine from nelec and active electrons ! State-averaging integer :: n_states = 1 !! Number of states for state-averaged CASSCF real ( dp ), allocatable :: state_weights (:) !! Weights for state averaging (must sum to 1) ! Convergence settings integer :: max_macro_iter = 100 !! Maximum macro (orbital optimization) iterations integer :: max_micro_iter = 50 !! Maximum CI iterations per macro step real ( dp ) :: orbital_tol = 1.0e-6_dp !! Orbital gradient convergence threshold real ( dp ) :: energy_tol = 1.0e-8_dp !! Energy convergence threshold real ( dp ) :: ci_tol = 1.0e-8_dp !! CI energy convergence threshold ! Orbital optimization algorithm character ( len = 16 ) :: orbital_optimizer = 'super-ci' !! Orbital optimizer: \"super-ci\", \"newton-raphson\", \"ah\" (augmented Hessian) ! Perturbative corrections logical :: use_pt2 = . false . !! Apply perturbative correction after CASSCF character ( len = 16 ) :: pt2_type = 'nevpt2' !! PT2 type: \"caspt2\", \"nevpt2\" real ( dp ) :: ipea_shift = 0.25_dp !! IPEA shift for CASPT2 (Hartree) real ( dp ) :: imaginary_shift = 0.0_dp !! Imaginary shift for intruder states end type mcscf_options_t type , extends ( qc_method_t ) :: mcscf_method_t !! MCSCF/CASSCF method implementation !! !! Complete Active Space SCF with optional state-averaging !! and perturbative corrections. Suitable for: !! - Near-degenerate electronic states !! - Bond breaking/formation !! - Transition metal complexes !! - Excited states type ( mcscf_options_t ) :: options contains procedure :: calc_energy => mcscf_calc_energy procedure :: calc_gradient => mcscf_calc_gradient procedure :: calc_hessian => mcscf_calc_hessian end type mcscf_method_t contains subroutine mcscf_calc_energy ( this , fragment , result ) !! Calculate electronic energy using CASSCF !! !! TODO: Implementation requires: !! 1. Build basis set and compute integrals !! 2. Initial orbital guess (HF or read from file) !! 3. Partition orbitals: inactive, active, virtual !! 4. Macro iterations: !!    a. Transform integrals to MO basis !!    b. Solve CI in active space (Davidson or direct) !!    c. Build 1- and 2-RDMs from CI vector !!    d. Compute orbital gradient !!    e. Update orbitals (super-CI, Newton-Raphson, etc.) !!    f. Check convergence !! 5. Optional: CASPT2/NEVPT2 correction class ( mcscf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result integer :: n_inactive if ( this % options % verbose ) then print * , \"MCSCF: Calculating CASSCF energy\" print * , \"MCSCF: Basis set: \" , trim ( this % options % basis_set ) print * , \"MCSCF: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"MCSCF: nelec =\" , fragment % nelec print * , \"MCSCF: charge =\" , fragment % charge print * , \"MCSCF: Active space: (\" , this % options % n_active_electrons , \",\" , & this % options % n_active_orbitals , \")\" ! Calculate inactive orbitals if ( this % options % n_inactive_orbitals < 0 ) then n_inactive = ( fragment % nelec - this % options % n_active_electrons ) / 2 else n_inactive = this % options % n_inactive_orbitals end if print * , \"MCSCF: Inactive orbitals:\" , n_inactive if ( this % options % n_states > 1 ) then print * , \"MCSCF: State-averaged over\" , this % options % n_states , \"states\" end if if ( this % options % use_pt2 ) then print * , \"MCSCF: Will apply \" , trim ( this % options % pt2_type ), \" correction\" end if end if ! Validate active space if ( this % options % n_active_electrons <= 0 . or . this % options % n_active_orbitals <= 0 ) then print * , \"MCSCF: ERROR - Active space not defined!\" print * , \"MCSCF: Set n_active_electrons and n_active_orbitals in config\" result % has_error = . true . return end if ! Placeholder: Return dummy energy ! TODO: Implement actual CASSCF calculation result % energy % scf = - 1.0_dp * fragment % n_atoms ! Placeholder result % has_energy = . true . if ( this % options % verbose ) then print * , \"MCSCF: [STUB] CASSCF Energy =\" , result % energy % total () end if end subroutine mcscf_calc_energy subroutine mcscf_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using CASSCF !! !! TODO: Implementation requires: !! 1. Converged CASSCF (orbitals and CI) !! 2. Solve Z-vector (CPHF-like) equations for response !! 3. Compute gradient contributions: !!    a. One-electron derivative terms !!    b. Two-electron derivative terms (with 2-RDM) !!    c. Orbital response contribution !!    d. CI response contribution (for state-specific) !! For state-averaged: gradient of weighted energy class ( mcscf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result if ( this % options % verbose ) then print * , \"MCSCF: Calculating CASSCF gradient\" end if ! First get energy (and converged orbitals/CI) call this % calc_energy ( fragment , result ) if ( result % has_error ) return ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . if ( this % options % verbose ) then print * , \"MCSCF: [STUB] Gradient computed\" end if end subroutine mcscf_calc_gradient subroutine mcscf_calc_hessian ( this , fragment , result ) !! Calculate energy Hessian using CASSCF !! !! TODO: Analytical CASSCF Hessian is very complex: !! - Requires second derivatives of integrals !! - Coupled-perturbed MCSCF equations !! - CI second derivatives !! Typically done via finite difference of gradients class ( mcscf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result if ( this % options % verbose ) then print * , \"MCSCF: Analytical Hessian not implemented\" print * , \"MCSCF: Use finite difference of gradients instead\" end if ! For now, just compute energy call this % calc_energy ( fragment , result ) result % has_hessian = . false . end subroutine mcscf_calc_hessian end module mqc_method_mcscf","tags":"","url":"sourcefile/mqc_method_mcscf.f90.html"},{"title":"mqc_finite_differences.f90 – metalquicha","text":"Finite difference utilities for numerical derivatives This file depends on sourcefile~~mqc_finite_differences.f90~~EfferentGraph sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_finite_differences.f90~~AfferentGraph sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Finite difference utilities for numerical derivatives module mqc_finite_differences !! Provides utilities for generating perturbed geometries and computing !! numerical derivatives via finite differences (gradients, Hessians, etc.) use pic_types , only : dp use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: generate_perturbed_geometries !! Generate forward/backward displacements public :: displaced_geometry_t !! Container for displaced geometry public :: finite_diff_hessian_from_gradients !! Compute Hessian from gradient differences public :: finite_diff_dipole_derivatives !! Compute dipole derivatives from dipole differences public :: copy_and_displace_geometry !! Copy and displace geometry ! Default displacement step size (Bohr) real ( dp ), parameter , public :: DEFAULT_DISPLACEMENT = 0.005_dp !! ~0.05 Angstrom type :: displaced_geometry_t !! Container for a single displaced geometry integer :: atom_index !! Which atom was displaced (1-based) integer :: coordinate !! Which coordinate was displaced (1=x, 2=y, 3=z) integer :: direction !! +1 for forward, -1 for backward real ( dp ) :: displacement !! Displacement magnitude in Bohr type ( physical_fragment_t ) :: geometry !! The displaced geometry contains procedure :: destroy => displaced_geometry_destroy end type displaced_geometry_t contains subroutine generate_perturbed_geometries ( reference_geom , displacement , forward_geoms , backward_geoms ) !! Generate all forward and backward displaced geometries for finite difference calculations !! !! For a system with N atoms, this generates: !!   - 3N forward-displaced geometries (+x, +y, +z for each atom) !!   - 3N backward-displaced geometries (-x, -y, -z for each atom) !! !! These can be used to compute: !!   - Gradient: from energies at ±displacement !!   - Hessian: from gradients at ±displacement !! !! Args: !!   reference_geom: The reference geometry to perturb !!   displacement: Step size in Bohr (typical: 0.001 Bohr) !!   forward_geoms: Output array of forward-displaced geometries (size: 3*n_atoms) !!   backward_geoms: Output array of backward-displaced geometries (size: 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: displacement type ( displaced_geometry_t ), intent ( out ), allocatable :: forward_geoms (:) type ( displaced_geometry_t ), intent ( out ), allocatable :: backward_geoms (:) integer :: n_atoms , n_displacements integer :: iatom , icoord , idx integer :: i n_atoms = reference_geom % n_atoms n_displacements = 3 * n_atoms ! x, y, z for each atom allocate ( forward_geoms ( n_displacements )) allocate ( backward_geoms ( n_displacements )) ! Generate all displaced geometries idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 ! x, y, z idx = idx + 1 ! Forward displacement (+h) forward_geoms ( idx )% atom_index = iatom forward_geoms ( idx )% coordinate = icoord forward_geoms ( idx )% direction = + 1 forward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , + displacement , & forward_geoms ( idx )% geometry ) ! Backward displacement (-h) backward_geoms ( idx )% atom_index = iatom backward_geoms ( idx )% coordinate = icoord backward_geoms ( idx )% direction = - 1 backward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , - displacement , & backward_geoms ( idx )% geometry ) end do end do end subroutine generate_perturbed_geometries subroutine copy_and_displace_geometry ( reference_geom , atom_idx , coord_idx , displacement , displaced_geom ) !! Create a copy of reference geometry with one coordinate displaced !! !! Args: !!   reference_geom: Original geometry to copy !!   atom_idx: Atom to displace (1-based) !!   coord_idx: Coordinate to displace (1=x, 2=y, 3=z) !!   displacement: Amount to displace in Bohr (positive or negative) !!   displaced_geom: Output displaced geometry type ( physical_fragment_t ), intent ( in ) :: reference_geom integer , intent ( in ) :: atom_idx , coord_idx real ( dp ), intent ( in ) :: displacement type ( physical_fragment_t ), intent ( out ) :: displaced_geom ! Copy basic properties displaced_geom % n_atoms = reference_geom % n_atoms displaced_geom % charge = reference_geom % charge displaced_geom % multiplicity = reference_geom % multiplicity displaced_geom % nelec = reference_geom % nelec displaced_geom % n_caps = reference_geom % n_caps ! Allocate and copy arrays allocate ( displaced_geom % element_numbers ( displaced_geom % n_atoms )) allocate ( displaced_geom % coordinates ( 3 , displaced_geom % n_atoms )) displaced_geom % element_numbers = reference_geom % element_numbers displaced_geom % coordinates = reference_geom % coordinates ! Copy hydrogen cap information if present if ( reference_geom % n_caps > 0 ) then allocate ( displaced_geom % cap_replaces_atom ( displaced_geom % n_caps )) displaced_geom % cap_replaces_atom = reference_geom % cap_replaces_atom end if ! Copy gradient redistribution mapping if present if ( allocated ( reference_geom % local_to_global )) then allocate ( displaced_geom % local_to_global ( size ( reference_geom % local_to_global ))) displaced_geom % local_to_global = reference_geom % local_to_global end if ! Apply displacement to specified coordinate displaced_geom % coordinates ( coord_idx , atom_idx ) = & displaced_geom % coordinates ( coord_idx , atom_idx ) + displacement ! Copy basis set if present (same basis, just different geometry) if ( allocated ( reference_geom % basis )) then ! Note: Basis set will need to be rebuilt with new coordinates ! For now, we don't copy it - it should be set up during calculation end if end subroutine copy_and_displace_geometry subroutine finite_diff_hessian_from_gradients ( reference_geom , forward_gradients , backward_gradients , & displacement , hessian ) !! Compute Hessian matrix from finite differences of gradients !! !! Uses central finite differences: H_ij = (grad_i(+h) - grad_i(-h)) / (2h) !! !! Args: !!   reference_geom: Reference geometry (for dimensioning) !!   forward_gradients: Gradients at forward-displaced geometries (3*n_atoms, 3, n_atoms) !!   backward_gradients: Gradients at backward-displaced geometries (3*n_atoms, 3, n_atoms) !!   displacement: Step size used in Bohr !!   hessian: Output Hessian matrix (3*n_atoms, 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: forward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: backward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: displacement real ( dp ), intent ( out ), allocatable :: hessian (:, :) !! (3*n_atoms, 3*n_atoms) integer :: n_atoms , n_coords integer :: iatom , jatom , icoord , jcoord integer :: i_global , j_global integer :: disp_idx n_atoms = reference_geom % n_atoms n_coords = 3 * n_atoms allocate ( hessian ( n_coords , n_coords )) hessian = 0.0_dp ! Build Hessian using central differences ! H[i,j] = d²E/(dx_i dx_j) = (dE/dx_j at x_i+h - dE/dx_j at x_i-h) / (2h) disp_idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 disp_idx = disp_idx + 1 i_global = 3 * ( iatom - 1 ) + icoord ! For each displacement, compute derivatives of all gradient components do jatom = 1 , n_atoms do jcoord = 1 , 3 j_global = 3 * ( jatom - 1 ) + jcoord ! Central difference: (grad_j(+h) - grad_j(-h)) / (2h) hessian ( i_global , j_global ) = & ( forward_gradients ( disp_idx , jcoord , jatom ) - & backward_gradients ( disp_idx , jcoord , jatom )) / ( 2.0_dp * displacement ) end do end do end do end do ! Symmetrize the Hessian: H = (H + H&#94;T) / 2 ! This reduces numerical noise from finite differences do i_global = 1 , n_coords do j_global = i_global + 1 , n_coords hessian ( i_global , j_global ) = 0.5_dp * ( hessian ( i_global , j_global ) + hessian ( j_global , i_global )) hessian ( j_global , i_global ) = hessian ( i_global , j_global ) end do end do end subroutine finite_diff_hessian_from_gradients subroutine displaced_geometry_destroy ( this ) !! Clean up memory for displaced geometry class ( displaced_geometry_t ), intent ( inout ) :: this call this % geometry % destroy () end subroutine displaced_geometry_destroy subroutine finite_diff_dipole_derivatives ( n_atoms , forward_dipoles , backward_dipoles , & displacement , dipole_derivatives ) !! Compute dipole moment derivatives via central finite differences !! !! Computes: d_mu_k/d_x_j = (mu_k(+h) - mu_k(-h)) / (2h) !! !! This is used for IR intensity calculations, where we need the dipole !! moment derivatives with respect to Cartesian nuclear coordinates. !! !! Args: !!   n_atoms: Number of atoms !!   forward_dipoles: Dipoles at forward-displaced geometries (3*n_atoms, 3) !!   backward_dipoles: Dipoles at backward-displaced geometries (3*n_atoms, 3) !!   displacement: Step size in Bohr !!   dipole_derivatives: Output derivatives (3, 3*n_atoms) in a.u. integer , intent ( in ) :: n_atoms real ( dp ), intent ( in ) :: forward_dipoles (:, :) !! (3*n_atoms, 3) real ( dp ), intent ( in ) :: backward_dipoles (:, :) !! (3*n_atoms, 3) real ( dp ), intent ( in ) :: displacement real ( dp ), intent ( out ), allocatable :: dipole_derivatives (:, :) !! (3, 3*n_atoms) integer :: n_coords , j , k n_coords = 3 * n_atoms allocate ( dipole_derivatives ( 3 , n_coords )) ! Central difference: d_mu_k/d_x_j = (mu_k(x_j+h) - mu_k(x_j-h)) / (2h) do j = 1 , n_coords ! Cartesian coordinate index (which coordinate was displaced) do k = 1 , 3 ! Dipole component (x, y, z) dipole_derivatives ( k , j ) = ( forward_dipoles ( j , k ) - backward_dipoles ( j , k )) / & ( 2.0_dp * displacement ) end do end do end subroutine finite_diff_dipole_derivatives end module mqc_finite_differences","tags":"","url":"sourcefile/mqc_finite_differences.f90.html"},{"title":"mqc_error.f90 – metalquicha","text":"Error handling module for metalquicha\nProvides a unified error type to replace stat/errmsg pairs\nEnhanced with stack trace support for better debugging Files dependent on this one sourcefile~~mqc_error.f90~~AfferentGraph sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_basis_file_reader.f90 mqc_basis_file_reader.f90 sourcefile~mqc_basis_file_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_basis_file_reader.f90 sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_basis_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cli_parser.f90 mqc_cli_parser.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_basis_utils.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_error.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_error.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Error handling module for metalquicha !! Provides a unified error type to replace stat/errmsg pairs !! Enhanced with stack trace support for better debugging module mqc_error implicit none private public :: error_t public :: SUCCESS , ERROR_GENERIC , ERROR_IO , ERROR_PARSE , ERROR_VALIDATION !! Error codes integer , parameter :: SUCCESS = 0 integer , parameter :: ERROR_GENERIC = 1 integer , parameter :: ERROR_IO = 2 integer , parameter :: ERROR_PARSE = 3 integer , parameter :: ERROR_VALIDATION = 4 !! Stack trace configuration integer , parameter :: MAX_STACK_DEPTH = 20 integer , parameter :: MAX_LOCATION_LEN = 128 !! Unified error type with stack trace support type :: error_t integer :: code = SUCCESS !! Error code (0 = no error) character ( len = :), allocatable :: message !! Error message !! Stack trace support integer :: stack_depth = 0 !! Current stack depth character ( len = MAX_LOCATION_LEN ) :: call_stack ( MAX_STACK_DEPTH ) !! Call locations contains procedure :: has_error => error_has_error procedure :: set => error_set procedure :: clear => error_clear procedure :: get_code => error_get_code procedure :: get_message => error_get_message procedure :: add_context => error_add_context procedure :: get_full_trace => error_get_full_trace procedure :: print_trace => error_print_trace end type error_t contains pure function error_has_error ( this ) result ( has_err ) !! Check if an error is set class ( error_t ), intent ( in ) :: this logical :: has_err has_err = ( this % code /= SUCCESS ) end function error_has_error pure subroutine error_set ( this , code , message ) !! Set an error with code and message !! Resets the stack trace class ( error_t ), intent ( inout ) :: this integer , intent ( in ) :: code character ( len =* ), intent ( in ) :: message this % code = code this % message = trim ( message ) this % stack_depth = 0 ! Reset stack when setting new error end subroutine error_set pure subroutine error_clear ( this ) !! Clear the error state and stack trace class ( error_t ), intent ( inout ) :: this this % code = SUCCESS this % stack_depth = 0 if ( allocated ( this % message )) deallocate ( this % message ) end subroutine error_clear pure function error_get_code ( this ) result ( code ) !! Get the error code class ( error_t ), intent ( in ) :: this integer :: code code = this % code end function error_get_code pure function error_get_message ( this ) result ( message ) !! Get the error message (without stack trace) class ( error_t ), intent ( in ) :: this character ( len = :), allocatable :: message if ( allocated ( this % message )) then message = this % message else message = \"\" end if end function error_get_message pure subroutine error_add_context ( this , location ) !! Add a call location to the stack trace !! Typically called when propagating errors upward !! !! Example: !!   call some_routine(..., error) !!   if (error%has_error()) then !!      call error%add_context(\"mqc_mbe:compute_energy\") !!      return !!   end if class ( error_t ), intent ( inout ) :: this character ( len =* ), intent ( in ) :: location if ( this % stack_depth < MAX_STACK_DEPTH ) then this % stack_depth = this % stack_depth + 1 this % call_stack ( this % stack_depth ) = location end if ! If stack is full, silently ignore (could print warning in non-pure version) end subroutine error_add_context function error_get_full_trace ( this ) result ( trace ) !! Get complete error message with stack trace !! Returns a multi-line string with error and call stack class ( error_t ), intent ( in ) :: this character ( len = :), allocatable :: trace character ( len = 2048 ) :: buffer integer :: i , pos if (. not . this % has_error ()) then trace = \"\" return end if ! Build error message write ( buffer , '(A,I0,A)' ) \"Error \" , this % code , \": \" pos = len_trim ( buffer ) + 1 if ( allocated ( this % message )) then buffer ( pos :) = this % message pos = len_trim ( buffer ) + 1 end if ! Add stack trace if available if ( this % stack_depth > 0 ) then buffer ( pos :) = new_line ( 'a' ) // \"Call stack (most recent first):\" pos = len_trim ( buffer ) + 1 do i = this % stack_depth , 1 , - 1 write ( buffer ( pos :), '(A,I0,A)' ) new_line ( 'a' ) // \"  [\" , i , \"] \" pos = len_trim ( buffer ) + 1 buffer ( pos :) = trim ( this % call_stack ( i )) pos = len_trim ( buffer ) + 1 end do end if trace = trim ( buffer ) end function error_get_full_trace subroutine error_print_trace ( this , unit ) !! Print error with stack trace to specified unit !! If unit not specified, prints to stdout (unit 6) class ( error_t ), intent ( in ) :: this integer , intent ( in ), optional :: unit integer :: out_unit , i out_unit = 6 ! stdout if ( present ( unit )) out_unit = unit if (. not . this % has_error ()) return ! Print error message write ( out_unit , '(A,I0,A)' , advance = 'no' ) \"Error \" , this % code , \": \" if ( allocated ( this % message )) then write ( out_unit , '(A)' ) trim ( this % message ) else write ( out_unit , '(A)' ) \"(no message)\" end if ! Print stack trace if available if ( this % stack_depth > 0 ) then write ( out_unit , '(A)' ) \"Call stack (most recent first):\" do i = this % stack_depth , 1 , - 1 write ( out_unit , '(A,I0,A)' , advance = 'no' ) \"  [\" , i , \"] \" write ( out_unit , '(A)' ) trim ( this % call_stack ( i )) end do end if end subroutine error_print_trace end module mqc_error","tags":"","url":"sourcefile/mqc_error.f90.html"},{"title":"mqc_gmbe_fragment_distribution_scheme.f90 – metalquicha","text":"Generalized Many-Body Expansion (GMBE) fragment distribution module This file depends on sourcefile~~mqc_gmbe_fragment_distribution_scheme.f90~~EfferentGraph sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_mpi_comms.f90 mqc_mpi_comms.f90 sourcefile~mqc_resources.f90->sourcefile~mqc_mpi_comms.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_gmbe_fragment_distribution_scheme.f90~~AfferentGraph sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Generalized Many-Body Expansion (GMBE) fragment distribution module module mqc_gmbe_fragment_distribution_scheme !! Implements fragment distribution schemes for GMBE calculations with overlapping fragments !! Handles both serial and MPI-parallelized distribution of monomers and intersection fragments use pic_types , only : int32 , int64 , dp use pic_timer , only : timer_type use mqc_calc_types , only : CALC_TYPE_GRADIENT use pic_mpi_lib , only : comm_t , send , recv , isend , irecv , & wait , iprobe , MPI_Status , request_t , MPI_ANY_SOURCE , MPI_ANY_TAG , abort_comm use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_mpi_tags , only : TAG_WORKER_REQUEST , TAG_WORKER_FRAGMENT , TAG_WORKER_FINISH , & TAG_WORKER_SCALAR_RESULT , & TAG_NODE_REQUEST , TAG_NODE_FRAGMENT , TAG_NODE_FINISH , & TAG_NODE_SCALAR_RESULT use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , build_fragment_from_indices , & build_fragment_from_atom_list use mqc_config_parser , only : bond_t use mqc_result_types , only : calculation_result_t , result_send , result_isend , & result_recv , result_irecv , mbe_result_t use mqc_mbe_fragment_distribution_scheme , only : do_fragment_work use mqc_method_config , only : method_config_t use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_GMBE_PIE use mqc_vibrational_analysis , only : compute_vibrational_analysis , print_vibrational_analysis use mqc_thermochemistry , only : thermochemistry_result_t , compute_thermochemistry implicit none ! Error handling imported where needed private ! Public interface public :: serial_gmbe_pie_processor !! PIE-based serial processor public :: gmbe_pie_coordinator !! PIE-based MPI coordinator contains subroutine serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , & sys_geom , method_config , calc_type , bonds , json_data ) !! Serial GMBE processor using PIE coefficients !! Evaluates each unique atom set once and sums with PIE coefficients !! Supports energy-only, energy+gradient, and energy+gradient+Hessian calculations !! If json_data is present, populates it for centralized JSON output use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN , CALC_TYPE_ENERGY , calc_type_to_string use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian , & redistribute_cap_dipole_derivatives use mqc_error , only : error_t use pic_logger , only : info_level integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( in ) :: n_pie_terms type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data type ( physical_fragment_t ) :: phys_frag type ( calculation_result_t ), allocatable :: results (:) type ( error_t ) :: error integer :: n_atoms , max_atoms , iatom , current_log_level , hess_dim integer ( int64 ) :: term_idx integer , allocatable :: atom_list (:) real ( dp ) :: total_energy , term_energy real ( dp ), allocatable :: pie_energies (:) !! Store individual energies for JSON output real ( dp ), allocatable :: total_gradient (:, :) !! Total gradient (3, total_atoms) real ( dp ), allocatable :: term_gradient (:, :) !! Temporary gradient for each term real ( dp ), allocatable :: total_hessian (:, :) !! Total Hessian (3*total_atoms, 3*total_atoms) real ( dp ), allocatable :: term_hessian (:, :) !! Temporary Hessian for each term real ( dp ), allocatable :: total_dipole_derivs (:, :) !! Total dipole derivatives (3, 3*total_atoms) real ( dp ), allocatable :: term_dipole_derivs (:, :) !! Temporary dipole derivatives for each term real ( dp ), allocatable :: ir_intensities (:) !! IR intensities in km/mol integer :: coeff if ( int ( size ( pie_atom_sets , 2 ), int64 ) < n_pie_terms . or . & int ( size ( pie_coefficients ), int64 ) < n_pie_terms ) then call logger % error ( \"PIE term arrays are smaller than n_pie_terms\" ) error stop \"Invalid PIE term array sizes\" end if call logger % info ( \"Processing \" // to_char ( n_pie_terms ) // \" unique PIE terms...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) total_energy = 0.0_dp max_atoms = size ( pie_atom_sets , 1 ) allocate ( pie_energies ( n_pie_terms )) allocate ( results ( n_pie_terms )) ! Allocate gradient and Hessian arrays if needed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) allocate ( term_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp ! Allocate dipole derivative arrays for IR intensities allocate ( total_dipole_derivs ( 3 , hess_dim )) allocate ( term_dipole_derivs ( 3 , hess_dim )) total_dipole_derivs = 0.0_dp end if do term_idx = 1_int64 , n_pie_terms coeff = pie_coefficients ( term_idx ) ! Skip terms with zero coefficient (shouldn't happen, but safety check) if ( coeff == 0 ) then pie_energies ( term_idx ) = 0.0_dp ! Mark as skipped cycle end if ! Extract atom list for this term n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms == 0 ) then pie_energies ( term_idx ) = 0.0_dp ! Mark as skipped cycle end if allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment from atom list call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build intersection fragment\" end if ! Compute energy (and gradient if requested) call do_fragment_work ( term_idx , results ( term_idx ), method_config , phys_frag , calc_type ) ! Check for calculation errors if ( results ( term_idx )% has_error ) then call logger % error ( \"PIE term \" // to_char ( term_idx ) // \" calculation failed: \" // & results ( term_idx )% error % get_message ()) error stop \"PIE term calculation failed in serial processing\" end if term_energy = results ( term_idx )% energy % total () ! Store energy for JSON output pie_energies ( term_idx ) = term_energy ! Accumulate with PIE coefficient total_energy = total_energy + real ( coeff , dp ) * term_energy ! Accumulate gradient if present if (( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) . and . & results ( term_idx )% has_gradient ) then ! Map fragment gradient to system coordinates with proper cap handling term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( coeff , dp ) * term_gradient end if ! Accumulate Hessian if present if ( calc_type == CALC_TYPE_HESSIAN . and . results ( term_idx )% has_hessian ) then ! Map fragment Hessian to system coordinates with proper cap handling term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( term_idx )% hessian , term_hessian ) ! Accumulate with PIE coefficient total_hessian = total_hessian + real ( coeff , dp ) * term_hessian ! Accumulate dipole derivatives if present (for IR intensities) if ( results ( term_idx )% has_dipole_derivatives ) then term_dipole_derivs = 0.0_dp call redistribute_cap_dipole_derivatives ( phys_frag , results ( term_idx )% dipole_derivatives , & term_dipole_derivs ) total_dipole_derivs = total_dipole_derivs + real ( coeff , dp ) * term_dipole_derivs end if end if call logger % verbose ( \"PIE term \" // to_char ( term_idx ) // \"/\" // to_char ( n_pie_terms ) // & \": \" // to_char ( n_atoms ) // \" atoms, coeff=\" // to_char ( coeff ) // & \", E=\" // to_char ( term_energy )) deallocate ( atom_list ) call phys_frag % destroy () end do call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) ! Print gradient info if computed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end if ! Print Hessian info if computed if ( calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis with thermochemistry block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) type ( thermochemistry_result_t ) :: thermo_result type ( mbe_result_t ) :: gmbe_result integer :: n_at , n_modes call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne , & dipole_derivatives = total_dipole_derivs , & ir_intensities = ir_intensities ) if ( allocated ( frequencies )) then ! Compute thermochemistry n_at = size ( sys_geom % element_numbers ) n_modes = size ( frequencies ) call compute_thermochemistry ( sys_geom % coordinates , sys_geom % element_numbers , & frequencies , n_at , n_modes , thermo_result ) ! Print vibrational analysis to log call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & ir_intensities = ir_intensities , & coordinates = sys_geom % coordinates , & electronic_energy = total_energy ) ! Build temporary mbe_result for JSON output gmbe_result % total_energy = total_energy gmbe_result % has_energy = . true . gmbe_result % has_hessian = . true . if ( allocated ( total_gradient )) then gmbe_result % has_gradient = . true . allocate ( gmbe_result % gradient , source = total_gradient ) end if allocate ( gmbe_result % hessian , source = total_hessian ) ! Populate json_data for vibrational output if present if ( present ( json_data )) then json_data % output_mode = OUTPUT_MODE_GMBE_PIE json_data % total_energy = total_energy json_data % has_energy = . true . json_data % has_vibrational = . true . allocate ( json_data % frequencies ( n_modes )) allocate ( json_data % reduced_masses ( n_modes )) allocate ( json_data % force_constants ( n_modes )) json_data % frequencies = frequencies json_data % reduced_masses = reduced_masses json_data % force_constants = fc_mdyne json_data % thermo = thermo_result if ( allocated ( ir_intensities )) then allocate ( json_data % ir_intensities ( n_modes )) json_data % ir_intensities = ir_intensities json_data % has_ir_intensities = . true . end if if ( allocated ( total_gradient )) then allocate ( json_data % gradient , source = total_gradient ) json_data % has_gradient = . true . end if allocate ( json_data % hessian , source = total_hessian ) json_data % has_hessian = . true . end if if ( allocated ( ir_intensities )) deallocate ( ir_intensities ) call gmbe_result % destroy () deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block end if call logger % info ( \" \" ) ! Populate json_data for non-Hessian case if present if ( present ( json_data ) . and . calc_type /= CALC_TYPE_HESSIAN ) then json_data % output_mode = OUTPUT_MODE_GMBE_PIE json_data % total_energy = total_energy json_data % has_energy = . true . json_data % n_pie_terms = n_pie_terms ! Copy PIE data allocate ( json_data % pie_atom_sets , source = pie_atom_sets (:, 1 : n_pie_terms )) allocate ( json_data % pie_coefficients ( n_pie_terms )) json_data % pie_coefficients = pie_coefficients ( 1 : n_pie_terms ) allocate ( json_data % pie_energies ( n_pie_terms )) json_data % pie_energies = pie_energies if ( allocated ( total_gradient )) then allocate ( json_data % gradient , source = total_gradient ) json_data % has_gradient = . true . end if if ( allocated ( total_hessian )) then allocate ( json_data % hessian , source = total_hessian ) json_data % has_hessian = . true . end if end if deallocate ( pie_energies , results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( term_gradient )) deallocate ( term_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) if ( allocated ( term_hessian )) deallocate ( term_hessian ) if ( allocated ( total_dipole_derivs )) deallocate ( total_dipole_derivs ) if ( allocated ( term_dipole_derivs )) deallocate ( term_dipole_derivs ) end subroutine serial_gmbe_pie_processor subroutine gmbe_pie_coordinator ( resources , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method_config , calc_type , bonds , json_data ) !! MPI coordinator for PIE-based GMBE calculations !! Distributes PIE terms across MPI ranks and accumulates results !! If json_data is present, populates it for centralized JSON output use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian , & redistribute_cap_dipole_derivatives use mqc_resources , only : resources_t type ( resources_t ), intent ( in ) :: resources integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( in ) :: n_pie_terms integer , intent ( in ) :: node_leader_ranks (:), num_nodes type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data type ( timer_type ) :: coord_timer integer ( int64 ) :: current_term_idx , results_received , term_idx integer :: finished_nodes integer :: request_source , dummy_msg type ( MPI_Status ) :: status , local_status logical :: handling_local_workers , has_pending integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer ( int64 ) :: worker_term_map ( resources % mpi_comms % node_comm % size ()) integer :: worker_source real ( dp ) :: total_energy real ( dp ), allocatable :: total_gradient (:, :) real ( dp ), allocatable :: total_hessian (:, :) real ( dp ), allocatable :: total_dipole_derivs (:, :) !! Total dipole derivatives (3, 3*total_atoms) real ( dp ), allocatable :: ir_intensities (:) !! IR intensities in km/mol integer :: hess_dim ! MPI request handles type ( request_t ) :: req if ( int ( size ( pie_atom_sets , 2 ), int64 ) < n_pie_terms . or . & int ( size ( pie_coefficients ), int64 ) < n_pie_terms ) then call logger % error ( \"PIE term arrays are smaller than n_pie_terms\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if current_term_idx = n_pie_terms finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( resources % mpi_comms % node_comm % size () > 1 ) results_received = 0_int64 worker_term_map = 0 allocate ( results ( n_pie_terms )) call logger % verbose ( \"GMBE PIE coordinator starting with \" // to_char ( n_pie_terms ) // & \" PIE terms for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers if ( handling_local_workers ) then do call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE if ( worker_term_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no term was assigned!\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if call result_irecv ( results ( worker_term_map ( worker_source )), resources % mpi_comms % node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Check for calculation errors from worker if ( results ( worker_term_map ( worker_source ))% has_error ) then call logger % error ( \"PIE term \" // to_char ( worker_term_map ( worker_source )) // & \" calculation failed: \" // & results ( worker_term_map ( worker_source ))% error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if worker_term_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , n_pie_terms / 10_int64 )) == 0 . or . & results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( resources % mpi_comms % world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit call irecv ( resources % mpi_comms % world_comm , term_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( term_idx ), resources % mpi_comms % world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) ! Check for calculation errors from node coordinator if ( results ( term_idx )% has_error ) then call logger % error ( \"PIE term \" // to_char ( term_idx ) // \" calculation failed: \" // & results ( term_idx )% error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , n_pie_terms / 10_int64 )) == 0 . or . & results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( resources % mpi_comms % world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( resources % mpi_comms % world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_term_idx >= 1 ) then call send_pie_term_to_node ( resources % mpi_comms % world_comm , current_term_idx , pie_atom_sets , request_source ) current_term_idx = current_term_idx - 1 else call isend ( resources % mpi_comms % world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < resources % mpi_comms % node_comm % size () - 1 ) then call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then if ( worker_term_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( resources % mpi_comms % node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_term_idx >= 1 ) then call send_pie_term_to_worker ( resources % mpi_comms % node_comm , & current_term_idx , pie_atom_sets , local_status % MPI_SOURCE ) worker_term_map ( local_status % MPI_SOURCE ) = current_term_idx current_term_idx = current_term_idx - 1 else call isend ( resources % mpi_comms % node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= resources % mpi_comms % node_comm % size () - 1 & . and . results_received >= n_pie_terms ) then handling_local_workers = . false . finished_nodes = finished_nodes + 1 end if end do call logger % verbose ( \"GMBE PIE coordinator finished all terms\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all PIE terms \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Accumulate results with PIE coefficients call logger % info ( \" \" ) call logger % info ( \"Computing GMBE PIE energy...\" ) call coord_timer % start () total_energy = 0.0_dp do term_idx = 1_int64 , n_pie_terms total_energy = total_energy + real ( pie_coefficients ( term_idx ), dp ) * results ( term_idx )% energy % total () end do ! Handle gradients if computed if ( calc_type == CALC_TYPE_GRADIENT ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp do term_idx = 1_int64 , n_pie_terms if ( results ( term_idx )% has_gradient ) then ! Map fragment gradient to system coordinates block use mqc_error , only : error_t real ( dp ), allocatable :: term_gradient (:, :) type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) call phys_frag % destroy () deallocate ( atom_list ) end if ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system block use pic_logger , only : info_level integer :: iatom , current_log_level call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end block deallocate ( total_gradient ) end if ! Handle Hessians if computed if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp ! Also allocate gradient for Hessian calculations if (. not . allocated ( total_gradient )) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if ! Allocate dipole derivative arrays for IR intensities allocate ( total_dipole_derivs ( 3 , hess_dim )) total_dipole_derivs = 0.0_dp do term_idx = 1_int64 , n_pie_terms if ( results ( term_idx )% has_hessian . or . results ( term_idx )% has_gradient ) then block use mqc_error , only : error_t real ( dp ), allocatable :: term_gradient (:, :), term_hessian (:, :), term_dipole_derivs (:, :) type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , error , bonds ) ! Redistribute gradient if present if ( results ( term_idx )% has_gradient ) then allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end if ! Redistribute Hessian if present if ( results ( term_idx )% has_hessian ) then allocate ( term_hessian ( hess_dim , hess_dim )) term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( term_idx )% hessian , term_hessian ) total_hessian = total_hessian + real ( pie_coefficients ( term_idx ), dp ) * term_hessian deallocate ( term_hessian ) ! Accumulate dipole derivatives if present (for IR intensities) if ( results ( term_idx )% has_dipole_derivatives ) then allocate ( term_dipole_derivs ( 3 , hess_dim )) term_dipole_derivs = 0.0_dp call redistribute_cap_dipole_derivatives ( phys_frag , & results ( term_idx )% dipole_derivatives , & term_dipole_derivs ) total_dipole_derivs = total_dipole_derivs + & real ( pie_coefficients ( term_idx ), dp ) * term_dipole_derivs deallocate ( term_dipole_derivs ) end if end if call phys_frag % destroy () deallocate ( atom_list ) end if end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print Hessian information call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Compute and print full vibrational analysis with thermochemistry block real ( dp ), allocatable :: frequencies (:), reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:) type ( thermochemistry_result_t ) :: thermo_result type ( mbe_result_t ) :: gmbe_result integer :: n_at , n_modes call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_analysis ( total_hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne , & dipole_derivatives = total_dipole_derivs , & ir_intensities = ir_intensities ) if ( allocated ( frequencies )) then ! Compute thermochemistry n_at = size ( sys_geom % element_numbers ) n_modes = size ( frequencies ) call compute_thermochemistry ( sys_geom % coordinates , sys_geom % element_numbers , & frequencies , n_at , n_modes , thermo_result ) ! Print vibrational analysis to log call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & ir_intensities = ir_intensities , & coordinates = sys_geom % coordinates , & electronic_energy = total_energy ) ! Build temporary mbe_result for JSON output gmbe_result % total_energy = total_energy gmbe_result % has_energy = . true . gmbe_result % has_hessian = . true . if ( allocated ( total_gradient )) then gmbe_result % has_gradient = . true . allocate ( gmbe_result % gradient , source = total_gradient ) end if allocate ( gmbe_result % hessian , source = total_hessian ) ! Populate json_data for vibrational output if present if ( present ( json_data )) then json_data % output_mode = OUTPUT_MODE_GMBE_PIE json_data % total_energy = total_energy json_data % has_energy = . true . json_data % has_vibrational = . true . allocate ( json_data % frequencies ( n_modes )) allocate ( json_data % reduced_masses ( n_modes )) allocate ( json_data % force_constants ( n_modes )) json_data % frequencies = frequencies json_data % reduced_masses = reduced_masses json_data % force_constants = fc_mdyne json_data % thermo = thermo_result if ( allocated ( ir_intensities )) then allocate ( json_data % ir_intensities ( n_modes )) json_data % ir_intensities = ir_intensities json_data % has_ir_intensities = . true . end if if ( allocated ( total_gradient )) then allocate ( json_data % gradient , source = total_gradient ) json_data % has_gradient = . true . end if allocate ( json_data % hessian , source = total_hessian ) json_data % has_hessian = . true . end if if ( allocated ( ir_intensities )) deallocate ( ir_intensities ) call gmbe_result % destroy () deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if end block if ( allocated ( total_dipole_derivs )) deallocate ( total_dipole_derivs ) end if call coord_timer % stop () call logger % info ( \"Time to compute GMBE PIE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) call logger % info ( \" \" ) ! Populate json_data for non-Hessian case if present if ( present ( json_data ) . and . calc_type /= CALC_TYPE_HESSIAN ) then block real ( dp ), allocatable :: pie_energies (:) allocate ( pie_energies ( n_pie_terms )) do term_idx = 1_int64 , n_pie_terms pie_energies ( term_idx ) = results ( term_idx )% energy % total () end do json_data % output_mode = OUTPUT_MODE_GMBE_PIE json_data % total_energy = total_energy json_data % has_energy = . true . json_data % n_pie_terms = n_pie_terms allocate ( json_data % pie_atom_sets , source = pie_atom_sets (:, 1 : n_pie_terms )) allocate ( json_data % pie_coefficients ( n_pie_terms )) json_data % pie_coefficients = pie_coefficients ( 1 : n_pie_terms ) allocate ( json_data % pie_energies ( n_pie_terms )) json_data % pie_energies = pie_energies if ( allocated ( total_gradient )) then allocate ( json_data % gradient , source = total_gradient ) json_data % has_gradient = . true . end if if ( allocated ( total_hessian )) then allocate ( json_data % hessian , source = total_hessian ) json_data % has_hessian = . true . end if deallocate ( pie_energies ) end block end if deallocate ( results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) end subroutine gmbe_pie_coordinator subroutine send_pie_term_to_node ( world_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to remote node coordinator type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( world_comm , term_idx , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , n_atoms , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , atom_list , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_node subroutine send_pie_term_to_worker ( node_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to local worker type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( node_comm , term_idx , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , n_atoms , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , atom_list , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_worker end module mqc_gmbe_fragment_distribution_scheme","tags":"","url":"sourcefile/mqc_gmbe_fragment_distribution_scheme.f90.html"},{"title":"mqc_method_base.f90 – metalquicha","text":"Abstract base module for quantum chemistry method implementations This file depends on sourcefile~~mqc_method_base.f90~~EfferentGraph sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_base.f90~~AfferentGraph sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Abstract base module for quantum chemistry method implementations module mqc_method_base !! Defines the common interface that all quantum chemistry methods must implement, !! providing a unified API for energy and gradient calculations. use pic_types , only : dp use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: qc_method_t !! Abstract base type for all QC methods type , abstract :: qc_method_t !! Abstract base type for all quantum chemistry methods !! !! Defines the required interface for energy and gradient calculations !! that must be implemented by all concrete method types (XTB, HF, etc.). contains procedure ( calc_energy_interface ), deferred :: calc_energy !! Energy calculation interface procedure ( calc_gradient_interface ), deferred :: calc_gradient !! Gradient calculation interface procedure ( calc_hessian_interface ), deferred :: calc_hessian !! Hessian calculation interface end type qc_method_t abstract interface subroutine calc_energy_interface ( this , fragment , result ) !! Interface for energy-only calculations !! !! Computes the electronic energy for a molecular fragment !! using the specified quantum chemistry method. import :: qc_method_t , calculation_result_t , physical_fragment_t implicit none class ( qc_method_t ), intent ( in ) :: this !! Method instance type ( physical_fragment_t ), intent ( in ) :: fragment !! Molecular fragment type ( calculation_result_t ), intent ( out ) :: result !! Calculation results end subroutine calc_energy_interface subroutine calc_gradient_interface ( this , fragment , result ) !! Interface for energy and gradient calculations !! !! Computes both electronic energy and nuclear gradients for a !! molecular fragment using the specified quantum chemistry method. import :: qc_method_t , calculation_result_t , physical_fragment_t implicit none class ( qc_method_t ), intent ( in ) :: this !! Method instance type ( physical_fragment_t ), intent ( in ) :: fragment !! Molecular fragment type ( calculation_result_t ), intent ( out ) :: result end subroutine calc_gradient_interface subroutine calc_hessian_interface ( this , fragment , result ) !! Interface for energy, gradient, and Hessian calculations !! !! Computes electronic energy, nuclear gradients, and Hessian matrix for a !! molecular fragment using the specified quantum chemistry method. import :: qc_method_t , calculation_result_t , physical_fragment_t implicit none class ( qc_method_t ), intent ( in ) :: this !! Method instance type ( physical_fragment_t ), intent ( in ) :: fragment !! Molecular fragment type ( calculation_result_t ), intent ( out ) :: result end subroutine calc_hessian_interface end interface end module mqc_method_base","tags":"","url":"sourcefile/mqc_method_base.f90.html"},{"title":"main.f90 – metalquicha","text":"Main program for metalquicha quantum chemistry calculations Input format: .mqc (section-based format) Usage: metalquicha input_file.mqc This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~main.f90->sourcefile~mqc_error.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~main.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_logo.f90 mqc_logo.f90 sourcefile~main.f90->sourcefile~mqc_logo.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~main.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_mpi_comms.f90 mqc_mpi_comms.f90 sourcefile~mqc_resources.f90->sourcefile~mqc_mpi_comms.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Main program for metalquicha quantum chemistry calculations !! !! Input format: .mqc (section-based format) !! !! Usage: metalquicha input_file.mqc program main !! Orchestrates MPI initialization, input parsing, geometry loading, !! and dispatches to appropriate calculation routines (fragmented or unfragmented). use pic_logger , only : logger => global_logger , info_level use pic_io , only : to_char use pic_mpi_lib , only : pic_mpi_init , comm_world , abort_comm , pic_mpi_finalize use mqc_resources , only : resources_t use mqc_driver , only : run_calculation , run_multi_molecule_calculations use mqc_physical_fragment , only : system_geometry_t use mqc_config_parser , only : mqc_config_t , read_mqc_file use mqc_config_adapter , only : driver_config_t , config_to_driver , config_to_system_geometry , get_logger_level use mqc_io_helpers , only : set_output_json_filename , ends_with use mqc_logo , only : print_logo use pic_timer , only : timer_type use mqc_error , only : error_t use pic_knowledge , only : get_knowledge implicit none type ( timer_type ) :: my_timer !! Execution timing type ( resources_t ) :: resources !! Resources container (MPI comms, etc.) type ( driver_config_t ) :: config !! Driver configuration type ( mqc_config_t ) :: mqc_config !! Parsed .mqc file type ( system_geometry_t ) :: sys_geom !! Loaded molecular system type ( error_t ) :: error !! Error handling integer :: stat !! Status code for file I/O character ( len = :), allocatable :: errmsg !! Error messages for file I/O character ( len = 256 ) :: input_file !! Input file name ! Initialize MPI ! pic-mpi will call mpi_init_thread when needed call pic_mpi_init () ! Create communicators resources % mpi_comms % world_comm = comm_world () resources % mpi_comms % node_comm = resources % mpi_comms % world_comm % split () if ( resources % mpi_comms % world_comm % rank () == 0 ) then call print_logo () call my_timer % start () end if ! Parse command line arguments if ( command_argument_count () == 0 ) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"No input file specified. Usage: mqc input_file.mqc\" ) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) else if ( command_argument_count () == 1 ) then call get_command_argument ( 1 , input_file , status = stat ) if ( stat /= 0 ) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"Error reading command line argument\" ) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if input_file = trim ( input_file ) call set_output_json_filename ( input_file ) ! Validate file extension if (. not . ends_with ( input_file , '.mqc' )) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"Invalid input file extension. Expected .mqc\" ) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if else if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"Too many arguments. Usage: metalquicha [input_file.mqc]\" ) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Parse .mqc input file if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % info ( \"Reading input file: \" // trim ( input_file )) end if call read_mqc_file ( input_file , mqc_config , error ) if ( error % has_error ()) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"Error reading .mqc file: \" // error % get_message ()) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Configure logger if ( allocated ( mqc_config % log_level )) then call logger % configure ( get_logger_level ( mqc_config % log_level )) if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % info ( \"Logger verbosity set to: \" // trim ( mqc_config % log_level )) end if end if ! Handle single vs multiple molecules if ( mqc_config % nmol == 0 ) then ! Single molecule mode (backward compatible) call config_to_driver ( mqc_config , config ) call config_to_system_geometry ( mqc_config , sys_geom , error ) if ( error % has_error ()) then if ( resources % mpi_comms % world_comm % rank () == 0 ) then call logger % error ( \"Error converting geometry: \" // error % get_message ()) end if call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if call run_calculation ( resources , config , sys_geom , mqc_config % bonds ) call sys_geom % destroy () else ! Multi-molecule mode: loop over all molecules call run_multi_molecule_calculations ( resources , mqc_config ) end if if ( resources % mpi_comms % world_comm % rank () == 0 ) then call get_knowledge () call my_timer % stop () call logger % info ( \"Total processing time: \" // to_char ( my_timer % get_elapsed_time ()) // \" s\" ) end if call mqc_config % destroy () call resources % mpi_comms % world_comm % finalize () call resources % mpi_comms % node_comm % finalize () call pic_mpi_finalize () end program main","tags":"","url":"sourcefile/main.f90.html"},{"title":"mqc_physical_constants.f90 – metalquicha","text":"Physical constants and unit conversion factors Files dependent on this one sourcefile~~mqc_physical_constants.f90~~AfferentGraph sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Physical constants and unit conversion factors module mqc_physical_constants !! Contains fundamental physical constants and unit conversion factors !! used throughout the metalquicha codebase. !! !! All values are in atomic units unless otherwise specified. !! Reference: CODATA 2018 recommended values where applicable. use pic_types , only : dp implicit none private !--------------------------------------------------------------------------- ! Fundamental Constants !--------------------------------------------------------------------------- !> Bohr radius in Angstrom (a0 = 0.529177... A) real ( dp ), parameter , public :: BOHR_TO_ANGSTROM = 0.52917721092_dp !> Angstrom to Bohr conversion real ( dp ), parameter , public :: ANGSTROM_TO_BOHR = 1.0_dp / BOHR_TO_ANGSTROM !> Atomic mass unit to atomic units of mass (electron masses) !> 1 amu = 1822.888 m_e real ( dp ), parameter , public :: AMU_TO_AU = 182 2.888_dp !> Atomic units of mass to amu real ( dp ), parameter , public :: AU_TO_AMU = 1.0_dp / AMU_TO_AU !> Atomic mass unit to kg (CODATA 2018) real ( dp ), parameter , public :: AMU_TO_KG = 1.66053906660e-27_dp !--------------------------------------------------------------------------- ! Vibrational Spectroscopy Conversions !--------------------------------------------------------------------------- !> Conversion factor from atomic units (Hartree/Bohr&#94;2/amu) to cm&#94;-1 !> Derived from: sqrt(Hartree/(Bohr&#94;2 * amu)) -> s&#94;-1 -> cm&#94;-1 real ( dp ), parameter , public :: AU_TO_CM1 = 2.642461e7_dp !> Conversion factor from atomic units (Hartree/Bohr&#94;2) to mdyne/Angstrom !> 1 Hartree/Bohr&#94;2 = 15.569141 mdyne/A real ( dp ), parameter , public :: AU_TO_MDYNE_ANG = 1 5.569141_dp !> Conversion factor from atomic units of dipole derivatives to km/mol (IR intensity) !> From IUPAC: A = (pi * N_A * |d_mu/dQ|&#94;2) / (3 * 4 * pi * epsilon_0 * c&#94;2) !> Reference: IUPAC, Quantities, Units and Symbols in Physical Chemistry (1993) real ( dp ), parameter , public :: AU_TO_KMMOL = 1.7770969e6_dp !--------------------------------------------------------------------------- ! Dipole Moment Conversions !--------------------------------------------------------------------------- !> Conversion from atomic units (e*Bohr) to Debye !> 1 e*a0 = 2.541746 Debye real ( dp ), parameter , public :: AU_TO_DEBYE = 2.541746_dp !> Conversion from Debye to atomic units real ( dp ), parameter , public :: DEBYE_TO_AU = 1.0_dp / AU_TO_DEBYE !--------------------------------------------------------------------------- ! Energy Conversions !--------------------------------------------------------------------------- !> Hartree to eV real ( dp ), parameter , public :: HARTREE_TO_EV = 2 7.211386245988_dp !> Hartree to kcal/mol real ( dp ), parameter , public :: HARTREE_TO_KCALMOL = 62 7.5094740631_dp !> Hartree to kJ/mol real ( dp ), parameter , public :: HARTREE_TO_KJMOL = 262 5.4996394799_dp !> Hartree to cal/mol real ( dp ), parameter , public :: HARTREE_TO_CALMOL = 62 7.5094740631_dp * 100 0.0_dp !> Hartree to J/mol real ( dp ), parameter , public :: HARTREE_TO_JMOL = 262 5.4996394799_dp * 100 0.0_dp !> Calorie to Joule (thermochemical calorie) real ( dp ), parameter , public :: CAL_TO_J = 4.184_dp !--------------------------------------------------------------------------- ! Thermochemistry Constants (CODATA 2018) !--------------------------------------------------------------------------- !> Boltzmann constant in Hartree/K !> k_B = 1.380649e-23 J/K, 1 Hartree = 4.3597447222071e-18 J real ( dp ), parameter , public :: KB_HARTREE = 3.1668115634556e-6_dp !> Boltzmann constant in J/K (CODATA 2018, exact) real ( dp ), parameter , public :: KB_SI = 1.380649e-23_dp !> Planck constant in Hartree*s !> h = 6.62607015e-34 J*s real ( dp ), parameter , public :: H_HARTREE_S = 1.5198298460574e-16_dp !> Planck constant in J*s (CODATA 2018, exact) real ( dp ), parameter , public :: H_SI = 6.62607015e-34_dp !> Speed of light in cm/s real ( dp ), parameter , public :: C_CM_S = 2.99792458e10_dp !> cm&#94;-1 to Kelvin conversion factor: theta_vib = (h*c/k_B) * nu !> This is h*c/k_B in cm (multiply by frequency in cm&#94;-1 to get K) real ( dp ), parameter , public :: CM1_TO_KELVIN = 1.4387773538277_dp !> Gas constant R in cal/(mol*K) for thermochemistry output !> R = 1.98720425864 cal/(mol*K) real ( dp ), parameter , public :: R_CALMOLK = 1.98720425864_dp !> Gas constant R in Hartree/(mol*K) !> R = N_A * k_B real ( dp ), parameter , public :: R_HARTREE = 3.1668115634556e-6_dp !> Pressure: 1 atm in atomic units (Hartree/Bohr&#94;3) !> 1 atm = 101325 Pa, 1 Bohr = 5.29177e-11 m, 1 Hartree = 4.3597e-18 J real ( dp ), parameter , public :: ATM_TO_AU = 3.39893097e-9_dp !> Pressure: 1 atm in Pa (exact by definition) real ( dp ), parameter , public :: ATM_TO_PA = 10132 5.0_dp !> Pi constant real ( dp ), parameter , public :: PI = 3.14159265358979323846_dp !> Avogadro's number (for reference, not directly used in atomic unit calculations) real ( dp ), parameter , public :: AVOGADRO = 6.02214076e23_dp !> Rotational constant conversion: amu*Angstrom&#94;2 to GHz !> B = h / (8*pi&#94;2*I) where I is in SI units !> For I in amu*Angstrom&#94;2: B(GHz) = 505379.07 / I real ( dp ), parameter , public :: ROTCONST_AMUA2_TO_GHZ = 50537 9.07_dp !> Rotational temperature conversion: amu*Angstrom&#94;2 to Kelvin !> theta_rot = h&#94;2 / (8*pi&#94;2*I*k_B) !> For I in amu*Angstrom&#94;2: theta_rot(K) = 24.2637 / I real ( dp ), parameter , public :: ROTTEMP_AMUA2_TO_K = 2 4.2637_dp !> Classical limit for vibrational modes (u = theta_v/T) !> When u > this value, vibrational modes are considered frozen out real ( dp ), parameter , public :: VIB_CLASSICAL_LIMIT = 10 0.0_dp end module mqc_physical_constants","tags":"","url":"sourcefile/mqc_physical_constants.f90.html"},{"title":"mqc_gmbe_utils.f90 – metalquicha","text":"GMBE (Generalized Many-Body Expansion) utilities for overlapping fragments This file depends on sourcefile~~mqc_gmbe_utils.f90~~EfferentGraph sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_gmbe_utils.f90~~AfferentGraph sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! GMBE (Generalized Many-Body Expansion) utilities for overlapping fragments module mqc_gmbe_utils !! Provides functions for computing fragment intersections, generating k-way !! intersections, and enumerating PIE (Principle of Inclusion-Exclusion) terms !! for GMBE calculations with overlapping molecular fragments. use pic_types , only : default_int , int32 , int64 , dp use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_combinatorics , only : next_combination , next_combination_init use mqc_error , only : error_t , ERROR_VALIDATION implicit none private public :: find_fragment_intersection !! Find shared atoms between two fragments public :: generate_intersections !! Generate all k-way intersections for GMBE public :: compute_polymer_atoms !! Compute atom list for polymer (union of fragments) public :: generate_polymer_intersections !! Generate intersections for polymers public :: gmbe_enumerate_pie_terms !! DFS-based PIE coefficient enumeration contains function find_fragment_intersection ( frag1_atoms , n1 , frag2_atoms , n2 , & intersection , n_intersect ) result ( has_intersection ) !! Find shared atoms between two fragments (for GMBE with overlapping fragments) !! !! This function identifies atoms that appear in both fragments, which is essential !! for computing intersection-corrected energies in GMBE. !! !! Algorithm: O(n1 * n2) brute-force comparison !! - Loop through all atoms in fragment 1 !! - For each atom, check if it appears in fragment 2 !! - Collect all shared atoms !! !! Returns: !!   .true. if fragments share at least one atom, .false. otherwise !! !! Output: !!   intersection - allocatable array containing shared atom indices !!   n_intersect - number of shared atoms integer , intent ( in ) :: frag1_atoms (:) !! Atom indices in fragment 1 (0-indexed) integer , intent ( in ) :: n1 !! Number of atoms in fragment 1 integer , intent ( in ) :: frag2_atoms (:) !! Atom indices in fragment 2 (0-indexed) integer , intent ( in ) :: n2 !! Number of atoms in fragment 2 integer , allocatable , intent ( out ) :: intersection (:) !! Shared atom indices integer , intent ( out ) :: n_intersect !! Number of shared atoms logical :: has_intersection integer :: i , j integer , allocatable :: temp_intersection (:) integer :: temp_count ! Allocate temporary array (max possible size is min(n1, n2)) allocate ( temp_intersection ( min ( n1 , n2 ))) temp_count = 0 ! Find all shared atoms do i = 1 , n1 do j = 1 , n2 if ( frag1_atoms ( i ) == frag2_atoms ( j )) then ! Found a shared atom temp_count = temp_count + 1 temp_intersection ( temp_count ) = frag1_atoms ( i ) exit ! Move to next atom in frag1 end if end do end do ! Set output n_intersect = temp_count has_intersection = ( temp_count > 0 ) ! Allocate and copy result if intersection exists if ( has_intersection ) then allocate ( intersection ( n_intersect )) intersection = temp_intersection ( 1 : n_intersect ) end if deallocate ( temp_intersection ) end function find_fragment_intersection subroutine generate_intersections ( sys_geom , monomers , polymers , n_monomers , max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) !! !! For a system with overlapping fragments, this computes k-way intersections !! following the inclusion-exclusion principle for GMBE. !! The max_intersection_level parameter controls the maximum depth to avoid combinatorial explosion. !! !! Algorithm: !! - For each k from 2 to min(max_intersection_level, n_monomers): !!   - Generate all C(n_monomers, k) combinations !!   - For each combination, compute intersection of all k fragments !!   - Store non-empty intersections with their level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:) !! Monomer indices integer , intent ( inout ) :: polymers (:, :) !! Output: monomers stored here integer , intent ( in ) :: n_monomers !! Number of monomers integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth integer , allocatable , intent ( out ) :: intersections (:, :) !! Intersection atom lists integer , allocatable , intent ( out ) :: intersection_sets (:, :) !! Which k-tuple created each intersection integer , allocatable , intent ( out ) :: intersection_levels (:) !! Level (k) of each intersection integer , intent ( out ) :: n_intersections !! Number of intersections found ! Temporaries for storing intersections integer , allocatable :: temp_intersections (:, :) integer , allocatable :: temp_sets (:, :) integer , allocatable :: temp_levels (:) integer , allocatable :: temp_intersection (:) integer , allocatable :: current_intersection (:) integer :: temp_n_intersect , current_n_intersect logical :: has_intersection integer :: k , intersection_count , max_atoms , max_intersections , max_k_level integer :: i , idx integer , allocatable :: combination (:) ! Store monomers in polymers array polymers ( 1 : n_monomers , 1 ) = monomers ( 1 : n_monomers ) if ( n_monomers < 2 ) then n_intersections = 0 return end if ! Count maximum possible intersections: sum of C(n,k) for k=2 to n ! For small n, this is 2&#94;n - n - 1 max_intersections = 2 ** n_monomers - n_monomers - 1 ! Find maximum atoms in any fragment for allocation max_atoms = maxval ( sys_geom % fragment_sizes ( 1 : n_monomers )) ! Allocate temporary arrays allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_monomers , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 ! Determine actual maximum intersection level to use max_k_level = min ( max_intersection_level , n_monomers ) if ( max_k_level < n_monomers ) then call logger % info ( \"Generating k-way intersections up to k=\" // to_char ( max_k_level ) // & \" (limited by max_intersection_level)\" ) else call logger % info ( \"Generating all k-way intersections for GMBE (inclusion-exclusion principle)\" ) end if ! Loop over intersection levels k from 2 to max_k_level do k = 2 , max_k_level ! Generate all C(n_monomers, k) combinations allocate ( combination ( k )) call generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_monomers , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_monomers , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , max_k_level idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else call logger % info ( \"No intersections found (fragments are non-overlapping)\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections recursive subroutine generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Helper to generate all k-way intersections at a specific level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:), n_monomers , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , mono_idx , frag_size logical :: has_intersection ! Generate combinations using an iterative approach call next_combination_init ( combination , k ) do ! Compute intersection of all fragments in this combination has_intersection = . false . ! Start with the first fragment in the combination mono_idx = monomers ( combination ( 1 )) frag_size = sys_geom % fragment_sizes ( mono_idx ) allocate ( current_intersection ( frag_size )) current_intersection = sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ) current_n_intersect = frag_size ! Intersect with each subsequent fragment do i = 2 , k mono_idx = monomers ( combination ( i )) frag_size = sys_geom % fragment_sizes ( mono_idx ) has_intersection = find_fragment_intersection ( & current_intersection , current_n_intersect , & sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ), frag_size , & temp_intersection , temp_n_intersect ) if (. not . has_intersection ) then ! Intersection is empty, break early deallocate ( current_intersection ) if ( allocated ( temp_intersection )) deallocate ( temp_intersection ) exit end if ! Replace current_intersection with the new intersection deallocate ( current_intersection ) allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection current_n_intersect = temp_n_intersect deallocate ( temp_intersection ) end do ! If we have a non-empty intersection, store it if ( has_intersection . and . allocated ( current_intersection )) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection temp_sets ( 1 : k , intersection_count ) = monomers ( combination ) temp_levels ( intersection_count ) = k deallocate ( current_intersection ) end if ! Get next combination if (. not . next_combination ( combination , k , n_monomers )) exit end do end subroutine generate_k_way_intersections_for_level pure subroutine compute_polymer_atoms ( sys_geom , polymer , polymer_size , atom_list , n_atoms ) !! Compute the atom list for a polymer (union of atoms from base fragments) !! polymer(:) contains base fragment indices (1-based) use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymer (:) !! Base fragment indices in this polymer integer , intent ( in ) :: polymer_size !! Number of base fragments in polymer integer , allocatable , intent ( out ) :: atom_list (:) !! Unique atoms in this polymer integer , intent ( out ) :: n_atoms !! Number of unique atoms integer , allocatable :: temp_atoms (:) integer :: i , j , frag_idx , frag_size , temp_count logical :: already_present ! Allocate temporary array (worst case: all atoms from all fragments) allocate ( temp_atoms ( sys_geom % total_atoms )) temp_count = 0 ! Loop through each base fragment in the polymer do i = 1 , polymer_size frag_idx = polymer ( i ) if ( frag_idx == 0 ) exit ! Padding zeros frag_size = sys_geom % fragment_sizes ( frag_idx ) ! Add each atom from this fragment (avoid duplicates) do j = 1 , frag_size already_present = . false . ! Check if this atom is already in our list block integer :: k , current_atom current_atom = sys_geom % fragment_atoms ( j , frag_idx ) do k = 1 , temp_count if ( temp_atoms ( k ) == current_atom ) then already_present = . true . exit end if end do end block ! Add if not already present if (. not . already_present ) then temp_count = temp_count + 1 temp_atoms ( temp_count ) = sys_geom % fragment_atoms ( j , frag_idx ) end if end do end do ! Copy to output array n_atoms = temp_count allocate ( atom_list ( n_atoms )) atom_list = temp_atoms ( 1 : n_atoms ) deallocate ( temp_atoms ) end subroutine compute_polymer_atoms subroutine generate_polymer_intersections ( sys_geom , polymers , n_polymers , max_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for polymers at any level (GMBE-N) !! This works with dynamically generated polymers, not just base fragments use mqc_physical_fragment , only : system_geometry_t use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymers (:, :) !! Polymer definitions (n_polymers, max_level) integer , intent ( in ) :: n_polymers , max_level integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer , allocatable :: polymer_atoms (:, :) !! Atom lists for each polymer integer , allocatable :: polymer_n_atoms (:) !! Number of atoms in each polymer integer :: max_atoms_per_polymer integer :: i , polymer_size , max_intersection_level call logger % info ( \"Computing atom compositions for \" // to_char ( n_polymers ) // \" polymers...\" ) ! First, compute atom list for each polymer ! Find max atoms needed max_atoms_per_polymer = 0 do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) ! Worst case: all atoms from all fragments in this polymer max_atoms_per_polymer = max ( max_atoms_per_polymer , polymer_size * maxval ( sys_geom % fragment_sizes )) end do allocate ( polymer_atoms ( max_atoms_per_polymer , n_polymers )) allocate ( polymer_n_atoms ( n_polymers )) polymer_atoms = 0 ! Compute atoms for each polymer do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , polymers ( i , 1 : polymer_size ), polymer_size , atom_list , n_atoms ) polymer_n_atoms ( i ) = n_atoms polymer_atoms ( 1 : n_atoms , i ) = atom_list deallocate ( atom_list ) end block end do call logger % info ( \"Finding intersections between polymers...\" ) ! For GMBE(N), limit intersections to level N+1 to prevent combinatorial explosion ! GMBE(2): dimers → 3-way intersections max ! GMBE(3): trimers → 4-way intersections max max_intersection_level = max_level + 1 call logger % info ( \"Limiting intersections to level \" // to_char ( max_intersection_level ) // & \" (polymer level \" // to_char ( max_level ) // \" + 1)\" ) ! Now generate intersections between these polymer atom sets call generate_intersections_from_atom_lists ( polymer_atoms , polymer_n_atoms , n_polymers , & max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) deallocate ( polymer_atoms , polymer_n_atoms ) end subroutine generate_polymer_intersections subroutine generate_intersections_from_atom_lists ( atom_lists , n_atoms_list , n_sets , max_k_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate k-way intersections from arbitrary atom lists (not tied to sys_geom) !! max_k_level limits the maximum intersection order to prevent combinatorial explosion use pic_logger , only : logger => global_logger use pic_io , only : to_char integer , intent ( in ) :: atom_lists (:, :) !! (max_atoms, n_sets) integer , intent ( in ) :: n_atoms_list (:) !! Number of atoms in each set integer , intent ( in ) :: n_sets !! Number of sets (polymers) integer , intent ( in ) :: max_k_level !! Maximum intersection level to compute integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer :: max_intersections , max_atoms integer , allocatable :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer :: intersection_count , k , idx , actual_max_k integer , allocatable :: combination (:) if ( n_sets < 2 ) then n_intersections = 0 return end if ! Limit k-way intersections to min(max_k_level, n_sets) actual_max_k = min ( max_k_level , n_sets ) max_intersections = 2 ** n_sets - n_sets - 1 max_atoms = maxval ( n_atoms_list ) allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_sets , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 call logger % info ( \"Generating k-way intersections (k=2 to \" // to_char ( actual_max_k ) // \")\" ) ! Loop over intersection levels k from 2 to actual_max_k do k = 2 , actual_max_k allocate ( combination ( k )) call generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_sets , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_sets , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , actual_max_k idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else allocate ( intersections ( 1 , 0 )) allocate ( intersection_sets ( 1 , 0 )) allocate ( intersection_levels ( 0 )) call logger % info ( \"No intersections found\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections_from_atom_lists subroutine generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Generate all k-way intersections from atom lists integer , intent ( in ) :: atom_lists (:, :), n_atoms_list (:), n_sets , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , set_idx logical :: has_intersection call next_combination_init ( combination , k ) do ! Compute intersection of all sets in this combination has_intersection = . false . ! Start with the first set in the combination set_idx = combination ( 1 ) allocate ( current_intersection ( n_atoms_list ( set_idx ))) current_intersection = atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) current_n_intersect = n_atoms_list ( set_idx ) ! Intersect with each subsequent set do i = 2 , k set_idx = combination ( i ) allocate ( temp_intersection ( current_n_intersect )) ! Find intersection temp_n_intersect = 0 do j = 1 , current_n_intersect if ( any ( atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) == current_intersection ( j ))) then temp_n_intersect = temp_n_intersect + 1 temp_intersection ( temp_n_intersect ) = current_intersection ( j ) end if end do ! Update current intersection deallocate ( current_intersection ) if ( temp_n_intersect > 0 ) then allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection ( 1 : temp_n_intersect ) current_n_intersect = temp_n_intersect has_intersection = . true . else has_intersection = . false . end if deallocate ( temp_intersection ) if (. not . has_intersection ) exit end do ! Store if we found an intersection if ( has_intersection . and . current_n_intersect > 0 ) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection ( 1 : current_n_intersect ) temp_sets ( 1 : k , intersection_count ) = combination ( 1 : k ) temp_levels ( intersection_count ) = k end if if ( allocated ( current_intersection )) deallocate ( current_intersection ) ! Get next combination if (. not . next_combination ( combination , k , n_sets )) exit end do end subroutine generate_k_way_intersections_from_lists subroutine gmbe_enumerate_pie_terms ( sys_geom , primaries , n_primaries , polymer_level , max_k_level , & pie_atom_sets , pie_coefficients , n_pie_terms , error , initial_max_terms ) !! Enumerate all unique intersections via DFS and accumulate PIE coefficients !! This implements the GMBE(N) algorithm with inclusion-exclusion principle !! !! Algorithm: !! 1. For each primary i, start DFS with clique=[i] !! 2. Recursively grow cliques by adding overlapping primaries !! 3. For each clique of size k, compute intersection and add PIE coefficient: !!    coefficient = (+1) if k odd, (-1) if k even !! 4. Accumulate coefficients for each unique atom set use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: primaries (:, :) !! Primary polymers (n_primaries, polymer_level) integer , intent ( in ) :: n_primaries !! Number of primary polymers integer , intent ( in ) :: polymer_level !! Level of primaries (1=monomers, 2=dimers, etc.) integer , intent ( in ) :: max_k_level !! Maximum clique size (intersection depth limit) integer , allocatable , intent ( out ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_terms) integer , allocatable , intent ( out ) :: pie_coefficients (:) !! PIE coefficient for each term integer ( int64 ), intent ( out ) :: n_pie_terms !! Number of unique PIE terms type ( error_t ), intent ( out ) :: error !! Error status integer ( int64 ), intent ( in ), optional :: initial_max_terms !! Initial PIE storage capacity ! Temporary storage for PIE terms (allocate generously) integer ( int64 ), parameter :: INITIAL_MAX_PIE_TERMS = 100000_int64 ! Adjust if needed integer ( int64 ) :: max_terms integer ( default_int ) :: max_terms_i integer , allocatable :: temp_atom_sets (:, :) integer , allocatable :: temp_coefficients (:) integer , allocatable :: primary_atoms (:, :) !! Precomputed atom lists for each primary integer , allocatable :: primary_n_atoms (:) !! Atom counts for each primary integer , allocatable :: clique (:) !! Current clique being built integer , allocatable :: current_atoms (:) !! Current intersection atoms integer , allocatable :: candidates (:) !! Candidate primaries to add integer :: i , j , max_atoms , n_candidates call logger % info ( \"Enumerating GMBE PIE terms via DFS...\" ) ! Find maximum atoms in any fragment max_atoms = sys_geom % total_atoms ! Allocate temporary storage if ( present ( initial_max_terms )) then max_terms = initial_max_terms else max_terms = INITIAL_MAX_PIE_TERMS end if if ( max_terms < 1_int64 ) then call error % set ( ERROR_VALIDATION , \"Initial PIE term capacity must be positive\" ) return end if if ( max_terms > int ( huge ( 0_default_int ), int64 )) then call error % set ( ERROR_VALIDATION , \"Initial PIE term capacity exceeds default integer limit\" ) return end if max_terms_i = int ( max_terms , default_int ) allocate ( temp_atom_sets ( max_atoms , max_terms_i )) allocate ( temp_coefficients ( max_terms_i )) temp_atom_sets = - 1 temp_coefficients = 0 n_pie_terms = 0_int64 ! Precompute atom lists for all primaries allocate ( primary_atoms ( max_atoms , n_primaries )) allocate ( primary_n_atoms ( n_primaries )) primary_atoms = - 1 do i = 1 , n_primaries block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , primaries ( i , :), polymer_level , atom_list , n_atoms ) primary_n_atoms ( i ) = n_atoms primary_atoms ( 1 : n_atoms , i ) = atom_list ( 1 : n_atoms ) deallocate ( atom_list ) end block end do ! Allocate work arrays allocate ( clique ( max_k_level )) allocate ( current_atoms ( max_atoms )) allocate ( candidates ( n_primaries )) ! Start DFS from each primary do i = 1 , n_primaries ! Initial clique: just primary i clique ( 1 ) = i current_atoms ( 1 : primary_n_atoms ( i )) = primary_atoms ( 1 : primary_n_atoms ( i ), i ) ! Candidates: all primaries after i (to avoid duplicates) n_candidates = n_primaries - i if ( n_candidates > 0 ) then candidates ( 1 : n_candidates ) = [( i + j , j = 1 , n_candidates )] end if ! DFS from this primary call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , 1 , current_atoms ( 1 : primary_n_atoms ( i )), primary_n_atoms ( i ), & candidates , n_candidates , max_k_level , & temp_atom_sets , temp_coefficients , n_pie_terms , max_terms , error ) if ( error % has_error ()) return end do ! Copy to output arrays if ( n_pie_terms > 0_int64 ) then if ( n_pie_terms > int ( huge ( 0_default_int ), int64 )) then call error % set ( ERROR_VALIDATION , \"n_pie_terms exceeds default integer limit\" ) return end if allocate ( pie_atom_sets ( max_atoms , int ( n_pie_terms , default_int ))) allocate ( pie_coefficients ( int ( n_pie_terms , default_int ))) pie_atom_sets = temp_atom_sets (:, 1 : n_pie_terms ) pie_coefficients = temp_coefficients ( 1 : n_pie_terms ) end if call logger % info ( \"Generated \" // to_char ( n_pie_terms ) // \" unique PIE terms\" ) ! Cleanup deallocate ( temp_atom_sets , temp_coefficients , primary_atoms , primary_n_atoms ) deallocate ( clique , current_atoms , candidates ) end subroutine gmbe_enumerate_pie_terms recursive subroutine dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , clique_size , current_atoms , n_current_atoms , & candidates , n_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms , error ) !! DFS helper: accumulate PIE coefficients for intersections integer , intent ( in ) :: primary_atoms (:, :) !! Precomputed atom lists integer , intent ( in ) :: primary_n_atoms (:) !! Atom counts integer , intent ( in ) :: n_primaries , max_atoms integer , intent ( in ) :: clique (:) !! Current clique integer , intent ( in ) :: clique_size !! Size of current clique integer , intent ( in ) :: current_atoms (:) !! Atoms in current intersection integer , intent ( in ) :: n_current_atoms !! Number of atoms in intersection integer , intent ( in ) :: candidates (:) !! Candidate primaries integer , intent ( in ) :: n_candidates integer , intent ( in ) :: max_k_level integer , allocatable , intent ( inout ) :: atom_sets (:, :) integer , allocatable , intent ( inout ) :: coefficients (:) integer ( int64 ), intent ( inout ) :: n_terms integer ( int64 ), intent ( inout ) :: max_terms type ( error_t ), intent ( inout ) :: error !! Error status integer :: sign , i , candidate_idx , candidate_pos integer ( int64 ) :: term_idx integer , allocatable :: new_atoms (:), new_candidates (:) integer :: n_new_atoms , n_new_candidates logical :: found ! Skip empty intersections if ( n_current_atoms == 0 ) return ! Compute PIE sign: (+1) for odd clique size, (-1) for even sign = merge ( 1 , - 1 , mod ( clique_size , 2 ) == 1 ) ! Find or create entry for this atom set found = . false . do term_idx = 1_int64 , n_terms if ( atom_sets_equal ( atom_sets (:, term_idx ), current_atoms , n_current_atoms )) then coefficients ( term_idx ) = coefficients ( term_idx ) + sign found = . true . exit end if end do if (. not . found ) then ! New atom set if ( n_terms >= max_terms ) then call grow_pie_storage ( atom_sets , coefficients , max_terms , max_atoms , error ) if ( error % has_error ()) return end if n_terms = n_terms + 1_int64 atom_sets ( 1 : n_current_atoms , n_terms ) = current_atoms ( 1 : n_current_atoms ) atom_sets ( n_current_atoms + 1 :, n_terms ) = - 1 coefficients ( n_terms ) = sign end if ! Stop if we've reached maximum clique size if ( clique_size >= max_k_level ) return if ( n_candidates == 0 ) return ! Try adding each candidate to the clique allocate ( new_atoms ( max_atoms )) allocate ( new_candidates ( n_primaries )) do i = 1 , n_candidates candidate_idx = candidates ( i ) ! Compute intersection with this candidate call intersect_atom_lists ( current_atoms , n_current_atoms , & primary_atoms (:, candidate_idx ), primary_n_atoms ( candidate_idx ), & new_atoms , n_new_atoms ) ! Skip if no intersection if ( n_new_atoms == 0 ) cycle ! New candidates: must come after this one and overlap with new_atoms n_new_candidates = 0 do candidate_pos = i + 1 , n_candidates block integer :: test_candidate , test_n_intersect integer , allocatable :: test_intersect (:) test_candidate = candidates ( candidate_pos ) allocate ( test_intersect ( max_atoms )) call intersect_atom_lists ( new_atoms , n_new_atoms , & primary_atoms (:, test_candidate ), primary_n_atoms ( test_candidate ), & test_intersect , test_n_intersect ) if ( test_n_intersect > 0 ) then n_new_candidates = n_new_candidates + 1 new_candidates ( n_new_candidates ) = test_candidate end if deallocate ( test_intersect ) end block end do ! Recurse block integer :: new_clique ( clique_size + 1 ) new_clique ( 1 : clique_size ) = clique ( 1 : clique_size ) new_clique ( clique_size + 1 ) = candidate_idx call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & new_clique , clique_size + 1 , new_atoms , n_new_atoms , & new_candidates , n_new_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms , error ) if ( error % has_error ()) then deallocate ( new_atoms , new_candidates ) return end if end block end do deallocate ( new_atoms , new_candidates ) end subroutine dfs_pie_accumulate subroutine grow_pie_storage ( atom_sets , coefficients , max_terms , max_atoms , error ) !! Grow PIE term storage arrays when capacity is exceeded. integer , allocatable , intent ( inout ) :: atom_sets (:, :) integer , allocatable , intent ( inout ) :: coefficients (:) integer ( int64 ), intent ( inout ) :: max_terms integer , intent ( in ) :: max_atoms type ( error_t ), intent ( inout ) :: error integer ( int64 ) :: new_max_terms integer ( default_int ) :: old_terms_i , new_terms_i integer , allocatable :: new_atom_sets (:, :) integer , allocatable :: new_coefficients (:) integer ( int64 ) :: max_default_int max_default_int = int ( huge ( 0_default_int ), int64 ) new_max_terms = max_terms * 2_int64 if ( new_max_terms <= max_terms ) then call error % set ( ERROR_VALIDATION , \"PIE term capacity overflow\" ) return end if if ( new_max_terms > max_default_int ) then new_max_terms = max_default_int end if if ( new_max_terms == max_terms ) then call error % set ( ERROR_VALIDATION , \"Exceeded maximum PIE terms (\" // to_char ( max_terms ) // \")\" ) return end if old_terms_i = int ( max_terms , default_int ) new_terms_i = int ( new_max_terms , default_int ) allocate ( new_atom_sets ( max_atoms , new_terms_i )) new_atom_sets = - 1 new_atom_sets (:, 1 : old_terms_i ) = atom_sets (:, 1 : old_terms_i ) allocate ( new_coefficients ( new_terms_i )) new_coefficients = 0 new_coefficients ( 1 : old_terms_i ) = coefficients ( 1 : old_terms_i ) call move_alloc ( new_atom_sets , atom_sets ) call move_alloc ( new_coefficients , coefficients ) max_terms = new_max_terms end subroutine grow_pie_storage pure function atom_sets_equal ( set1 , set2 , n_atoms ) result ( equal ) !! Check if two atom sets are equal (assuming sorted) integer , intent ( in ) :: set1 (:), set2 (:) integer , intent ( in ) :: n_atoms logical :: equal integer :: i equal = . true . do i = 1 , n_atoms if ( set1 ( i ) /= set2 ( i )) then equal = . false . return end if end do end function atom_sets_equal pure subroutine intersect_atom_lists ( atoms1 , n1 , atoms2 , n2 , intersection , n_intersect ) !! Compute intersection of two atom lists integer , intent ( in ) :: atoms1 (:), n1 , atoms2 (:), n2 integer , intent ( out ) :: intersection (:) integer , intent ( out ) :: n_intersect integer :: i , j n_intersect = 0 do i = 1 , n1 if ( atoms1 ( i ) < 0 ) cycle do j = 1 , n2 if ( atoms2 ( j ) < 0 ) cycle if ( atoms1 ( i ) == atoms2 ( j )) then n_intersect = n_intersect + 1 intersection ( n_intersect ) = atoms1 ( i ) exit end if end do end do end subroutine intersect_atom_lists end module mqc_gmbe_utils","tags":"","url":"sourcefile/mqc_gmbe_utils.f90.html"},{"title":"mqc_mpi_tags.f90 – metalquicha","text":"contains MPI tags used in the MQC parallel implementation Files dependent on this one sourcefile~~mqc_mpi_tags.f90~~AfferentGraph sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! contains MPI tags used in the MQC parallel implementation module mqc_mpi_tags !! Module defining MPI communication tags for clarity and maintainability use pic_types , only : default_int implicit none private ! Local worker communication tags (shared memory within a node) integer ( default_int ), parameter , public :: TAG_WORKER_REQUEST = 200 !! Worker requests work from node coordinator integer ( default_int ), parameter , public :: TAG_WORKER_FRAGMENT = 201 !! Coordinator sends fragment data to worker integer ( default_int ), parameter , public :: TAG_WORKER_FINISH = 202 !! Coordinator signals worker to finish integer ( default_int ), parameter , public :: TAG_WORKER_SCALAR_RESULT = 203 !! Worker sends scalar results back to coordinator integer ( default_int ), parameter , public :: TAG_WORKER_MATRIX_RESULT = 204 !! Worker sends matrix results back to coordinator ! Remote node communication tags (between nodes via world communicator) integer ( default_int ), parameter , public :: TAG_NODE_REQUEST = 300 !! Node coordinator requests work from global coordinator integer ( default_int ), parameter , public :: TAG_NODE_FRAGMENT = 301 !! Global coordinator sends fragment data to node coordinator integer ( default_int ), parameter , public :: TAG_NODE_FINISH = 302 !! Global coordinator signals node coordinator to finish integer ( default_int ), parameter , public :: TAG_NODE_SCALAR_RESULT = 303 !! Node coordinator sends results (fragment_idx + scalar) to global coordinator integer ( default_int ), parameter , public :: TAG_NODE_MATRIX_RESULT = 304 !! Node coordinator sends matrix results to global coordinator end module mqc_mpi_tags","tags":"","url":"sourcefile/mqc_mpi_tags.f90.html"},{"title":"mqc_mpi_comms.f90 – metalquicha","text":"MPI communicators container for the application Files dependent on this one sourcefile~~mqc_mpi_comms.f90~~AfferentGraph sourcefile~mqc_mpi_comms.f90 mqc_mpi_comms.f90 sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~mqc_resources.f90->sourcefile~mqc_mpi_comms.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! MPI communicators container for the application module mqc_mpi_comms !! Container type for MPI communicators - extensible for future parallelism patterns use pic_mpi_lib , only : comm_t implicit none private public :: mpi_comms_t type :: mpi_comms_t !! Container for MPI communicators !! !! This type bundles all MPI communicators needed by the application. !! Currently supports world and node communicators, but can be extended !! to support team-based parallelism patterns. type ( comm_t ) :: world_comm !! Global MPI communicator type ( comm_t ) :: node_comm !! Node-local communicator ! Future extensions: ! type(comm_t) :: team_comm           !! Intra-team communicator ! type(comm_t) :: team_worker_comm    !! Team workers (excluding leader) ! type(comm_t) :: inter_team_comm     !! Cross-team communicator ! type(comm_t) :: team_leaders_comm   !! Team leaders only end type mpi_comms_t end module mqc_mpi_comms","tags":"","url":"sourcefile/mqc_mpi_comms.f90.html"},{"title":"mqc_xyz_reader.f90 – metalquicha","text":"XYZ molecular geometry file reader This file depends on sourcefile~~mqc_xyz_reader.f90~~EfferentGraph sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_xyz_reader.f90~~AfferentGraph sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! XYZ molecular geometry file reader module mqc_xyz_reader !! Provides functions to parse standard XYZ format files containing !! atomic coordinates and element symbols for molecular structures. use pic_types , only : dp use mqc_geometry , only : geometry_type use mqc_error , only : error_t , ERROR_IO , ERROR_PARSE implicit none private public :: read_xyz_file !! Read XYZ file from disk public :: read_xyz_string !! Parse XYZ data from string public :: split_lines !! Split text into lines (for testing) ! Constants integer , parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 !! Maximum element symbol length contains subroutine read_xyz_file ( filename , geom , error ) !! Read molecular geometry from XYZ format file !! !! Parses standard XYZ files with format: !! Line 1: Number of atoms !! Line 2: Comment/title line !! Lines 3+: Element X Y Z (coordinates in Angstrom) character ( len =* ), intent ( in ) :: filename !! Path to XYZ file type ( geometry_type ), intent ( out ) :: geom !! Parsed molecular geometry type ( error_t ), intent ( out ) :: error !! Error handling integer :: unit !! File unit number integer :: io_stat !! I/O operation status integer :: file_size !! File size in bytes logical :: file_exists !! Whether file exists on disk character ( len = :), allocatable :: file_contents !! Full file content buffer ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"XYZ file not found: \" // trim ( filename )) return end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: file_contents ) ! Open and read entire file as stream open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening file: \" // trim ( filename )) return end if read ( unit , iostat = io_stat ) file_contents close ( unit ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error reading file: \" // trim ( filename )) return end if ! Parse the contents call read_xyz_string ( file_contents , geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_xyz_reader:read_xyz_file\" ) return end if end subroutine read_xyz_file pure subroutine read_xyz_string ( xyz_string , geom , error ) !! Parse molecular geometry from XYZ format string character ( len =* ), intent ( in ) :: xyz_string type ( geometry_type ), intent ( out ) :: geom type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: lines (:) integer :: nlines , iatom , io_stat character ( len = 256 ) :: element real ( dp ) :: x , y , z ! Split into lines call split_lines ( xyz_string , lines , nlines ) if ( nlines < 2 ) then call error % set ( ERROR_PARSE , \"XYZ file must have at least 2 lines (natoms + comment)\" ) return end if ! Read number of atoms from first line read ( lines ( 1 ), * , iostat = io_stat ) geom % natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to read number of atoms from first line\" ) return end if if ( geom % natoms < 0 ) then call error % set ( ERROR_PARSE , \"Number of atoms must be non-negative\" ) return end if ! Store comment line geom % comment = trim ( adjustl ( lines ( 2 ))) ! Check we have enough lines if ( nlines < 2 + geom % natoms ) then call error % set ( ERROR_PARSE , \"XYZ file has insufficient lines: expected \" // & trim ( int_to_string ( 2 + geom % natoms )) // \", got \" // & trim ( int_to_string ( nlines ))) return end if ! Allocate arrays allocate ( character ( len = MAX_ELEMENT_SYMBOL_LEN ) :: geom % elements ( geom % natoms )) allocate ( geom % coords ( 3 , geom % natoms )) ! Read atom data do iatom = 1 , geom % natoms read ( lines ( 2 + iatom ), * , iostat = io_stat ) element , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse atom data on line \" // & trim ( int_to_string ( 2 + iatom )) // \": '\" // & trim ( lines ( 2 + iatom )) // \"'\" ) return end if geom % elements ( iatom ) = trim ( adjustl ( element )) geom % coords ( 1 , iatom ) = x geom % coords ( 2 , iatom ) = y geom % coords ( 3 , iatom ) = z end do end subroutine read_xyz_string pure function int_to_string ( i ) result ( str ) !! Convert integer to string integer , intent ( in ) :: i character ( len = :), allocatable :: str character ( len = 20 ) :: buffer write ( buffer , '(I0)' ) i str = trim ( adjustl ( buffer )) end function int_to_string pure subroutine split_lines ( text , lines , nlines ) !! Split input text into lines based on CR, LF, or CRLF line endings !! Trailing newlines do not create empty lines character ( len =* ), intent ( in ) :: text character ( len = :), allocatable , intent ( out ) :: lines (:) integer , intent ( out ) :: nlines integer :: i , line_start , line_end , max_line_len character ( len = :), allocatable :: temp_lines (:) if ( len ( text ) == 0 ) then nlines = 0 allocate ( character ( len = 1 ) :: lines ( 0 )) return end if ! Pass 1: Count lines and find maximum line length nlines = 0 max_line_len = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 ! Skip both CR and LF else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 max_line_len = max ( max_line_len , len ( text ) - line_start + 1 ) end if ! Handle empty text or ensure at least length 1 if ( max_line_len == 0 ) max_line_len = 1 ! Allocate output array allocate ( character ( len = max_line_len ) :: temp_lines ( nlines )) ! Pass 2: Extract lines nlines = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = len ( text ) - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if ! Copy to output (use explicit loop for Intel compiler compatibility) allocate ( character ( len = max_line_len ) :: lines ( nlines )) block integer :: iline do iline = 1 , nlines lines ( iline ) = temp_lines ( iline ) end do end block end subroutine split_lines end module mqc_xyz_reader","tags":"","url":"sourcefile/mqc_xyz_reader.f90.html"},{"title":"mqc_calc_types.f90 – metalquicha","text":"Calculation type constants for quantum chemistry calculations Files dependent on this one sourcefile~~mqc_calc_types.f90~~AfferentGraph sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Calculation type constants for quantum chemistry calculations module mqc_calc_types !! Defines integer constants for calculation types to avoid string comparisons !! throughout the codebase. Provides conversion utilities between string !! representations and integer constants. use pic_types , only : int32 implicit none private ! Public constants public :: CALC_TYPE_ENERGY , CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN public :: CALC_TYPE_UNKNOWN ! Public functions public :: calc_type_from_string , calc_type_to_string ! Calculation type constants integer ( int32 ), parameter :: CALC_TYPE_UNKNOWN = 0 integer ( int32 ), parameter :: CALC_TYPE_ENERGY = 1 integer ( int32 ), parameter :: CALC_TYPE_GRADIENT = 2 integer ( int32 ), parameter :: CALC_TYPE_HESSIAN = 3 contains pure function calc_type_from_string ( calc_type_str ) result ( calc_type ) !! Convert calculation type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns CALC_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: calc_type_str !! Input string (e.g., \"energy\", \"gradient\") integer ( int32 ) :: calc_type !! Output integer constant character ( len = len_trim ( calc_type_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( calc_type_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) case ( 'energy' ) calc_type = CALC_TYPE_ENERGY case ( 'gradient' ) calc_type = CALC_TYPE_GRADIENT case ( 'hessian' ) calc_type = CALC_TYPE_HESSIAN case default calc_type = CALC_TYPE_UNKNOWN end select end function calc_type_from_string pure function calc_type_to_string ( calc_type ) result ( calc_type_str ) !! Convert calculation type integer constant to string !! !! Provides human-readable string representation of calculation type. integer ( int32 ), intent ( in ) :: calc_type !! Input integer constant character ( len = :), allocatable :: calc_type_str !! Output string representation select case ( calc_type ) case ( CALC_TYPE_ENERGY ) calc_type_str = \"energy\" case ( CALC_TYPE_GRADIENT ) calc_type_str = \"gradient\" case ( CALC_TYPE_HESSIAN ) calc_type_str = \"hessian\" case default calc_type_str = \"unknown\" end select end function calc_type_to_string end module mqc_calc_types","tags":"","url":"sourcefile/mqc_calc_types.f90.html"},{"title":"mqc_result_types.f90 – metalquicha","text":"Quantum chemistry calculation result containers This file depends on sourcefile~~mqc_result_types.f90~~EfferentGraph sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_result_types.f90~~AfferentGraph sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Quantum chemistry calculation result containers module mqc_result_types !! Defines data structures for storing and managing results from !! quantum chemistry calculations including energies, gradients, and properties. use pic_types , only : dp use pic_mpi_lib , only : comm_t , isend , irecv , send , recv , wait , request_t , MPI_Status use mqc_error , only : error_t implicit none private public :: mp2_energy_t !! MP2 energy components type public :: cc_energy_t !! Coupled cluster energy components type public :: energy_t !! Energy components type public :: calculation_result_t !! Main result container type public :: mbe_result_t !! MBE aggregated result container type public :: result_send , result_isend !! Send result over MPI public :: result_recv , result_irecv !! Receive result over MPI ! SCS-MP2 scaling parameters real ( dp ), parameter :: SCS_SS_SCALE = 1.0_dp / 3.0_dp !! SCS same-spin scaling factor real ( dp ), parameter :: SCS_OS_SCALE = 1.2_dp !! SCS opposite-spin scaling factor type :: mp2_energy_t !! Container for MP2 energy components (SS/OS) real ( dp ) :: ss = 0.0_dp !! Same-spin correlation energy (Hartree) real ( dp ) :: os = 0.0_dp !! Opposite-spin correlation energy (Hartree) contains procedure :: total => mp2_total !! Compute total MP2 correlation procedure :: scs => mp2_scs !! Compute SCS-MP2 correlation procedure :: reset => mp2_reset !! Reset both components to zero procedure :: check_stability => mp2_check_stability !! Check for positive energies (instability) end type mp2_energy_t type :: cc_energy_t !! Container for coupled cluster energy components real ( dp ) :: singles = 0.0_dp !! Singles contribution (Hartree) real ( dp ) :: doubles = 0.0_dp !! Doubles contribution (Hartree) real ( dp ) :: triples = 0.0_dp !! Triples contribution (Hartree) contains procedure :: total => cc_total !! Compute total CC correlation procedure :: reset => cc_reset !! Reset all components to zero procedure :: check_stability => cc_check_stability !! Check for positive energies (instability) end type cc_energy_t type :: energy_t !! Container for quantum chemistry energy components !! !! Stores energy contributions from different levels of theory. !! Total energy is computed as: scf + mp2%total() + cc%total() real ( dp ) :: scf = 0.0_dp !! SCF/HF reference energy (Hartree) type ( mp2_energy_t ) :: mp2 !! MP2 correlation components type ( cc_energy_t ) :: cc !! Coupled cluster correlation components ! add more as needed, also need to modify the total energy function contains procedure :: total => energy_total !! Compute total energy from components procedure :: reset => energy_reset !! Reset all components to zero end type energy_t type :: calculation_result_t !! Container for quantum chemistry calculation results !! !! Stores computed quantities from QC calculations with flags !! indicating which properties have been computed. type ( energy_t ) :: energy !! Energy components (Hartree) real ( dp ), allocatable :: gradient (:, :) !! Energy gradient (3, natoms) (Hartree/Bohr) real ( dp ), allocatable :: sigma (:, :) !! Stress tensor (3,3) (Hartree/Bohr&#94;3) real ( dp ), allocatable :: hessian (:, :) !! Energy hessian (future implementation) real ( dp ), allocatable :: dipole (:) !! Dipole moment vector (3) (Debye) real ( dp ), allocatable :: dipole_derivatives (:, :) !! Dipole derivatives (3, 3N) in a.u. for IR intensities ! Fragment metadata real ( dp ) :: distance = 0.0_dp !! Minimal atomic distance between monomers (Angstrom, 0 for monomers) ! Computation status flags logical :: has_energy = . false . !! Energy has been computed logical :: has_gradient = . false . !! Gradient has been computed logical :: has_sigma = . false . !! Stress tensor has been computed logical :: has_hessian = . false . !! Hessian has been computed logical :: has_dipole = . false . !! Dipole moment has been computed logical :: has_dipole_derivatives = . false . !! Dipole derivatives have been computed ! Error handling type ( error_t ) :: error !! Calculation error (if any) logical :: has_error = . false . !! True if calculation failed contains procedure :: destroy => result_destroy !! Clean up allocated memory procedure :: reset => result_reset !! Reset all values and flags end type calculation_result_t type :: mbe_result_t !! Container for Many-Body Expansion aggregated results !! !! Stores total properties computed via MBE: energy, gradient, hessian, dipole. !! Caller allocates desired components before calling compute_mbe; the function !! uses allocated() to determine what to compute and sets has_* flags on success. real ( dp ) :: total_energy = 0.0_dp !! Total MBE energy (Hartree) real ( dp ), allocatable :: gradient (:, :) !! Total gradient (3, total_atoms) (Hartree/Bohr) real ( dp ), allocatable :: hessian (:, :) !! Total Hessian (3*natoms, 3*natoms) real ( dp ), allocatable :: dipole (:) !! Total dipole moment (3) (e*Bohr) real ( dp ), allocatable :: dipole_derivatives (:, :) !! Dipole derivatives (3, 3*natoms) for IR intensities ! Computation status flags logical :: has_energy = . false . !! Energy has been computed logical :: has_gradient = . false . !! Gradient has been computed logical :: has_hessian = . false . !! Hessian has been computed logical :: has_dipole = . false . !! Dipole has been computed logical :: has_dipole_derivatives = . false . !! Dipole derivatives have been computed contains procedure :: destroy => mbe_result_destroy !! Clean up allocated memory procedure :: reset => mbe_result_reset !! Reset all values and flags procedure :: allocate_gradient => mbe_result_allocate_gradient procedure :: allocate_hessian => mbe_result_allocate_hessian procedure :: allocate_dipole => mbe_result_allocate_dipole end type mbe_result_t contains pure function mp2_total ( this ) result ( total ) !! Compute total MP2 correlation energy class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % ss + this % os end function mp2_total pure function mp2_scs ( this ) result ( scs_energy ) !! Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy !! SCS-MP2 uses: E_SCS = (1/3)*E_SS + 1.2*E_OS class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: scs_energy scs_energy = SCS_SS_SCALE * this % ss + SCS_OS_SCALE * this % os end function mp2_scs subroutine mp2_reset ( this ) !! Reset both MP2 components to zero class ( mp2_energy_t ), intent ( inout ) :: this this % ss = 0.0_dp this % os = 0.0_dp end subroutine mp2_reset subroutine mp2_check_stability ( this ) !! Check for positive MP2 correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( mp2_energy_t ), intent ( in ) :: this if ( this % ss > 0.0_dp ) then call logger % warning ( \"MP2 same-spin correlation energy is positive - possible instability!\" ) end if if ( this % os > 0.0_dp ) then call logger % warning ( \"MP2 opposite-spin correlation energy is positive - possible instability!\" ) end if end subroutine mp2_check_stability pure function cc_total ( this ) result ( total ) !! Compute total CC correlation energy class ( cc_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % singles + this % doubles + this % triples end function cc_total subroutine cc_reset ( this ) !! Reset all CC components to zero class ( cc_energy_t ), intent ( inout ) :: this this % singles = 0.0_dp this % doubles = 0.0_dp this % triples = 0.0_dp end subroutine cc_reset subroutine cc_check_stability ( this ) !! Check for positive CC correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( cc_energy_t ), intent ( in ) :: this if ( this % singles > 0.0_dp ) then call logger % warning ( \"CC singles correlation energy is positive - possible instability!\" ) end if if ( this % doubles > 0.0_dp ) then call logger % warning ( \"CC doubles correlation energy is positive - possible instability!\" ) end if if ( this % triples > 0.0_dp ) then call logger % warning ( \"CC triples correlation energy is positive - possible instability!\" ) end if end subroutine cc_check_stability pure function energy_total ( this ) result ( total ) !! Compute total energy from all components class ( energy_t ), intent ( in ) :: this real ( dp ) :: total ! this line needs to me modified if more components are added total = this % scf + this % mp2 % total () + this % cc % total () end function energy_total subroutine energy_reset ( this ) !! Reset all energy components to zero class ( energy_t ), intent ( inout ) :: this this % scf = 0.0_dp call this % mp2 % reset () call this % cc % reset () end subroutine energy_reset subroutine result_destroy ( this ) !! Clean up allocated memory in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % sigma )) deallocate ( this % sigma ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) if ( allocated ( this % dipole_derivatives )) deallocate ( this % dipole_derivatives ) call this % reset () end subroutine result_destroy subroutine result_reset ( this ) !! Reset all values and flags in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this call this % energy % reset () call this % error % clear () this % has_energy = . false . this % has_gradient = . false . this % has_sigma = . false . this % has_hessian = . false . this % has_dipole = . false . this % has_dipole_derivatives = . false . this % has_error = . false . end subroutine result_reset !--------------------------------------------------------------------------- ! mbe_result_t type-bound procedures !--------------------------------------------------------------------------- subroutine mbe_result_destroy ( this ) !! Clean up allocated memory in mbe_result_t class ( mbe_result_t ), intent ( inout ) :: this if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) if ( allocated ( this % dipole_derivatives )) deallocate ( this % dipole_derivatives ) call this % reset () end subroutine mbe_result_destroy subroutine mbe_result_reset ( this ) !! Reset all values and flags in mbe_result_t class ( mbe_result_t ), intent ( inout ) :: this this % total_energy = 0.0_dp this % has_energy = . false . this % has_gradient = . false . this % has_hessian = . false . this % has_dipole = . false . this % has_dipole_derivatives = . false . end subroutine mbe_result_reset subroutine mbe_result_allocate_gradient ( this , total_atoms ) !! Allocate gradient array for total_atoms class ( mbe_result_t ), intent ( inout ) :: this integer , intent ( in ) :: total_atoms if ( allocated ( this % gradient )) deallocate ( this % gradient ) allocate ( this % gradient ( 3 , total_atoms )) this % gradient = 0.0_dp end subroutine mbe_result_allocate_gradient subroutine mbe_result_allocate_hessian ( this , total_atoms ) !! Allocate hessian array for total_atoms class ( mbe_result_t ), intent ( inout ) :: this integer , intent ( in ) :: total_atoms integer :: hess_dim hess_dim = 3 * total_atoms if ( allocated ( this % hessian )) deallocate ( this % hessian ) allocate ( this % hessian ( hess_dim , hess_dim )) this % hessian = 0.0_dp end subroutine mbe_result_allocate_hessian subroutine mbe_result_allocate_dipole ( this ) !! Allocate dipole array (always 3 components) class ( mbe_result_t ), intent ( inout ) :: this if ( allocated ( this % dipole )) deallocate ( this % dipole ) allocate ( this % dipole ( 3 )) this % dipole = 0.0_dp end subroutine mbe_result_allocate_dipole subroutine result_send ( result , comm , dest , tag ) !! Send calculation result over MPI (blocking) !! Sends energy components and conditionally sends gradient based on has_gradient flag type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag ! Send energy components call send ( comm , result % energy % scf , dest , tag ) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send fragment metadata call send ( comm , result % distance , dest , tag ) ! Send gradient flag and data if present call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if ! Send Hessian flag and data if present call send ( comm , result % has_hessian , dest , tag ) if ( result % has_hessian ) then call send ( comm , result % hessian , dest , tag ) end if ! Send dipole flag and data if present call send ( comm , result % has_dipole , dest , tag ) if ( result % has_dipole ) then call send ( comm , result % dipole , dest , tag ) end if ! Send dipole derivatives flag and data if present call send ( comm , result % has_dipole_derivatives , dest , tag ) if ( result % has_dipole_derivatives ) then call send ( comm , result % dipole_derivatives , dest , tag ) end if end subroutine result_send subroutine result_isend ( result , comm , dest , tag , req ) !! Send calculation result over MPI (non-blocking) !! Sends SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag type ( request_t ), intent ( out ) :: req ! Send SCF energy (non-blocking) call isend ( comm , result % energy % scf , dest , tag , req ) ! Send other energy components (blocking to avoid needing multiple request handles) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send fragment metadata call send ( comm , result % distance , dest , tag ) ! Send gradient flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if ! Send Hessian flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_hessian , dest , tag ) if ( result % has_hessian ) then call send ( comm , result % hessian , dest , tag ) end if ! Send dipole flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_dipole , dest , tag ) if ( result % has_dipole ) then call send ( comm , result % dipole , dest , tag ) end if ! Send dipole derivatives flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_dipole_derivatives , dest , tag ) if ( result % has_dipole_derivatives ) then call send ( comm , result % dipole_derivatives , dest , tag ) end if end subroutine result_isend subroutine result_recv ( result , comm , source , tag , status ) !! Receive calculation result over MPI (blocking) !! Receives energy components and conditionally receives gradient based on flag type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( MPI_Status ), intent ( out ) :: status ! Receive energy components call recv ( comm , result % energy % scf , source , tag , status ) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive fragment metadata call recv ( comm , result % distance , source , tag , status ) ! Receive gradient flag and data if present call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data if present call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if ! Receive dipole flag and data if present call recv ( comm , result % has_dipole , source , tag , status ) if ( result % has_dipole ) then ! Receive allocatable dipole array (MPI lib handles allocation) call recv ( comm , result % dipole , source , tag , status ) end if ! Receive dipole derivatives flag and data if present call recv ( comm , result % has_dipole_derivatives , source , tag , status ) if ( result % has_dipole_derivatives ) then ! Receive allocatable dipole derivatives array (MPI lib handles allocation) call recv ( comm , result % dipole_derivatives , source , tag , status ) end if end subroutine result_recv subroutine result_irecv ( result , comm , source , tag , req ) !! Receive calculation result over MPI (non-blocking) !! Receives SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( request_t ), intent ( out ) :: req type ( MPI_Status ) :: status ! Receive SCF energy (non-blocking) call irecv ( comm , result % energy % scf , source , tag , req ) ! Receive other energy components (blocking to avoid needing multiple request handles) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive fragment metadata call recv ( comm , result % distance , source , tag , status ) ! Receive gradient flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if ! Receive dipole flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_dipole , source , tag , status ) if ( result % has_dipole ) then ! Receive allocatable dipole array (MPI lib handles allocation) call recv ( comm , result % dipole , source , tag , status ) end if ! Receive dipole derivatives flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_dipole_derivatives , source , tag , status ) if ( result % has_dipole_derivatives ) then ! Receive allocatable dipole derivatives array (MPI lib handles allocation) call recv ( comm , result % dipole_derivatives , source , tag , status ) end if end subroutine result_irecv end module mqc_result_types","tags":"","url":"sourcefile/mqc_result_types.f90.html"},{"title":"mqc_config_parser.f90 – metalquicha","text":"Parser for MQC section-based input files (.mqc format) This file depends on sourcefile~~mqc_config_parser.f90~~EfferentGraph sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_config_parser.f90~~AfferentGraph sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Parser for MQC section-based input files (.mqc format) module mqc_config_parser !! Parses section-based input files with %section...end blocks !! This is the new format generated by mqc_prep.py use pic_types , only : dp , int32 , int64 use mqc_method_types , only : method_type_from_string , METHOD_TYPE_GFN2 , METHOD_TYPE_UNKNOWN use mqc_calc_types , only : calc_type_from_string , CALC_TYPE_ENERGY , CALC_TYPE_UNKNOWN use mqc_geometry , only : geometry_type use mqc_error , only : error_t , ERROR_IO , ERROR_PARSE , ERROR_VALIDATION implicit none private public :: mqc_config_t , read_mqc_file public :: input_fragment_t , bond_t , molecule_t ! Maximum line length for reading integer , parameter :: MAX_LINE_LEN = 1024 type :: input_fragment_t !! Input fragment definition with charge, multiplicity, and atom indices !! This is the parsed representation from the input file, not the computational fragment integer :: charge = 0 integer :: multiplicity = 1 integer , allocatable :: indices (:) !! Atom indices in this fragment contains procedure :: destroy => input_fragment_destroy end type input_fragment_t type :: bond_t !! Bond definition with atom indices, order, and broken status integer :: atom_i = 0 integer :: atom_j = 0 integer :: order = 1 logical :: is_broken = . false . end type bond_t type :: molecule_t !! Single molecule definition with structure, geometry, fragments, and connectivity character ( len = :), allocatable :: name !! Optional molecule name ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) contains procedure :: destroy => molecule_destroy end type molecule_t type :: mqc_config_t !! Complete configuration from .mqc file ! Schema information character ( len = :), allocatable :: schema_name character ( len = :), allocatable :: schema_version integer :: index_base = 0 !! 0-based or 1-based indexing character ( len = :), allocatable :: units !! angstrom or bohr ! Model information integer ( int32 ) :: method = METHOD_TYPE_GFN2 character ( len = :), allocatable :: basis character ( len = :), allocatable :: aux_basis ! XTB solvation settings character ( len = :), allocatable :: solvent !! Solvent name (e.g., \"water\", \"ethanol\") or empty for gas phase character ( len = :), allocatable :: solvation_model !! Solvation model: \"alpb\" (default), \"gbsa\", or \"cpcm\" logical :: use_cds = . true . !! Include non-polar CDS terms in solvation (not for CPCM) logical :: use_shift = . true . !! Include solution state shift in solvation (not for CPCM) ! CPCM-specific settings real ( dp ) :: dielectric = - 1.0_dp !! Direct dielectric constant (-1 = use solvent lookup) integer :: cpcm_nang = 110 !! Number of angular grid points for CPCM cavity real ( dp ) :: cpcm_rscale = 1.0_dp !! Radii scaling factor for CPCM cavity ! Driver information integer ( int32 ) :: calc_type = CALC_TYPE_ENERGY ! Multiple molecules support integer :: nmol = 0 !! Number of molecules (0 = single molecule mode for backward compatibility) type ( molecule_t ), allocatable :: molecules (:) !! Array of molecules (if nmol > 0) ! Single molecule fields (backward compatibility - used if nmol == 0) ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) ! SCF settings integer :: scf_maxiter = 300 real ( dp ) :: scf_tolerance = 1.0e-6_dp ! Hessian settings real ( dp ) :: hessian_displacement = 0.001_dp !! Finite difference displacement (Bohr) real ( dp ) :: hessian_temperature = 29 8.15_dp !! Temperature for thermochemistry (K) real ( dp ) :: hessian_pressure = 1.0_dp !! Pressure for thermochemistry (atm) ! AIMD settings real ( dp ) :: aimd_dt = 1.0_dp !! Timestep (femtoseconds) integer :: aimd_nsteps = 0 !! Number of MD steps (0 = no AIMD) real ( dp ) :: aimd_initial_temperature = 30 0.0_dp !! Initial temperature for velocity init (K) integer :: aimd_output_frequency = 1 !! Write output every N steps ! Fragmentation settings character ( len = :), allocatable :: frag_method !! MBE, etc. integer :: frag_level = 1 logical :: allow_overlapping_fragments = . false . integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) character ( len = :), allocatable :: embedding character ( len = :), allocatable :: cutoff_method character ( len = :), allocatable :: distance_metric real ( dp ), allocatable :: fragment_cutoffs (:) !! Distance cutoffs indexed by n-mer level (2=dimer, 3=trimer, etc.) ! Logger settings (kept for compatibility) character ( len = :), allocatable :: log_level ! Output control logical :: skip_json_output = . false . !! Skip JSON output for large calculations contains procedure :: destroy => config_destroy end type mqc_config_t contains pure function strip_comment ( line ) result ( stripped ) !! Remove comments (! or #) from a line and trim result character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: stripped integer :: comment_pos ! Find first occurrence of ! or # comment_pos = index ( line , '!' ) if ( comment_pos == 0 ) comment_pos = index ( line , '#' ) if ( comment_pos > 0 ) then ! Comment found - take everything before it stripped = trim ( adjustl ( line ( 1 : comment_pos - 1 ))) else ! No comment - use full line stripped = trim ( adjustl ( line )) end if end function strip_comment subroutine read_mqc_file ( filename , config , error ) !! Read and parse a .mqc format input file character ( len =* ), intent ( in ) :: filename type ( mqc_config_t ), intent ( out ) :: config type ( error_t ), intent ( out ) :: error integer :: unit , io_stat character ( len = MAX_LINE_LEN ) :: line logical :: file_exists type ( error_t ) :: parse_error inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"Input file not found: \" // trim ( filename )) return end if open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening input file: \" // trim ( filename )) return end if ! Set defaults config % log_level = \"info\" ! Read file line by line and dispatch to section parsers do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for section start if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%schema' ) call parse_schema_section ( unit , config , parse_error ) case ( '%model' ) call parse_model_section ( unit , config , parse_error ) case ( '%driver' ) call parse_driver_section ( unit , config , parse_error ) case ( '%structure' ) call parse_structure_section ( unit , config , parse_error ) case ( '%geometry' ) call parse_geometry_section ( unit , config , parse_error ) case ( '%fragments' ) call parse_fragments_section ( unit , config , parse_error ) case ( '%connectivity' ) call parse_connectivity_section ( unit , config , parse_error ) case ( '%scf' ) call parse_scf_section ( unit , config , parse_error ) case ( '%xtb' ) call parse_xtb_section ( unit , config , parse_error ) case ( '%hessian' ) call parse_hessian_section ( unit , config , parse_error ) case ( '%aimd' ) call parse_aimd_section ( unit , config , parse_error ) case ( '%fragmentation' ) call parse_fragmentation_section ( unit , config , parse_error ) case ( '%system' ) call parse_system_section ( unit , config , parse_error ) case ( '%molecules' ) call parse_molecules_section ( unit , config , parse_error ) case default ! Skip unknown sections call skip_to_end ( unit , parse_error ) end select if ( parse_error % has_error ()) then error = parse_error call error % add_context ( \"mqc_config_parser:read_mqc_file\" ) close ( unit ) return end if end if end do close ( unit ) ! Validate required fields if (. not . allocated ( config % schema_name )) then call error % set ( ERROR_VALIDATION , \"Missing required section: %schema\" ) return end if ! Validate geometry: required for single-molecule mode, not for multi-molecule mode if ( config % nmol == 0 ) then ! Single molecule mode: require top-level geometry if (. not . allocated ( config % geometry % coords ) . or . config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"Missing required section: %geometry\" ) return end if else ! Multi-molecule mode: each molecule must have geometry (validated during parsing) ! No additional validation needed here end if end subroutine read_mqc_file subroutine parse_schema_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Unexpected end of file in %schema section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'name' ) config % schema_name = trim ( value ) case ( 'version' ) config % schema_version = trim ( value ) case ( 'index_base' ) read ( value , * , iostat = io_stat ) config % index_base case ( 'units' ) config % units = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %schema section: \" // trim ( key )) return end select end do end subroutine parse_schema_section subroutine parse_model_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %model section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'method' ) ! Parse method string (e.g., \"XTB-GFN1\" -> \"gfn1\") config % method = parse_method_string ( trim ( value )) if ( config % method == METHOD_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid method: \" // trim ( value )) return end if case ( 'basis' ) config % basis = trim ( value ) case ( 'aux_basis' ) config % aux_basis = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %model section: \" // trim ( key )) return end select end do end subroutine parse_model_section subroutine parse_driver_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %driver section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'type' ) config % calc_type = calc_type_from_string ( trim ( value )) if ( config % calc_type == CALC_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid calc_type: \" // trim ( value )) return end if case default call error % set ( ERROR_PARSE , \"Unknown key in %driver section: \" // trim ( key )) return end select end do end subroutine parse_driver_section subroutine parse_structure_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , config % charge , config % multiplicity , error ) end subroutine parse_structure_section subroutine parse_geometry_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , config % geometry , error ) end subroutine parse_geometry_section subroutine parse_fragments_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , config % nfrag , config % fragments , error ) end subroutine parse_fragments_section subroutine parse_fragment ( unit , fragment , error ) integer , intent ( in ) :: unit type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_indices in_indices = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragment\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_indices ) then in_indices = . false . cycle else exit end if end if if ( trim ( line ) == '%indices' ) then in_indices = . true . cycle end if if ( in_indices ) then ! Read indices call parse_indices_line ( line , fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_single_fragment_section\" ) return end if else eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) fragment % charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) fragment % multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in fragment properties: \" // trim ( key )) return end select end if end if end do end subroutine parse_fragment subroutine parse_indices_line ( line , fragment , error ) character ( len =* ), intent ( in ) :: line type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error integer :: io_stat , pos , count , i , idx character ( len = MAX_LINE_LEN ) :: temp_line integer , allocatable :: temp_indices (:), new_indices (:) temp_line = line ! Count how many integers count = 0 do read ( temp_line , * , iostat = io_stat ) idx if ( io_stat /= 0 ) exit count = count + 1 ! Remove the read integer from temp_line pos = scan ( temp_line , ' ' ) if ( pos == 0 ) exit temp_line = adjustl ( temp_line ( pos :)) end do if ( count == 0 ) return ! Allocate temporary array allocate ( temp_indices ( count )) ! Read the integers read ( line , * , iostat = io_stat ) temp_indices if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading fragment indices\" ) deallocate ( temp_indices ) return end if ! Append to existing indices if ( allocated ( fragment % indices )) then allocate ( new_indices ( size ( fragment % indices ) + count )) new_indices ( 1 : size ( fragment % indices )) = fragment % indices new_indices ( size ( fragment % indices ) + 1 :) = temp_indices call move_alloc ( new_indices , fragment % indices ) else call move_alloc ( temp_indices , fragment % indices ) end if end subroutine parse_indices_line subroutine parse_connectivity_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , config % nbonds , config % nbroken , config % bonds , error ) end subroutine parse_connectivity_section subroutine parse_scf_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %scf section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'maxiter' ) read ( value , * , iostat = io_stat ) config % scf_maxiter case ( 'tolerance' ) read ( value , * , iostat = io_stat ) config % scf_tolerance case default call error % set ( ERROR_PARSE , \"Unknown key in %scf section: \" // trim ( key )) return end select end do end subroutine parse_scf_section subroutine parse_xtb_section ( unit , config , error ) !! Parse %xtb section for XTB-specific settings (solvation, etc.) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %xtb section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'solvent' ) config % solvent = trim ( value ) case ( 'solvation_model' ) config % solvation_model = trim ( value ) case ( 'use_cds' ) config % use_cds = ( trim ( value ) == 'true' ) case ( 'use_shift' ) config % use_shift = ( trim ( value ) == 'true' ) case ( 'dielectric' ) read ( value , * , iostat = io_stat ) config % dielectric if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid dielectric value: \" // trim ( value )) return end if case ( 'cpcm_nang' ) read ( value , * , iostat = io_stat ) config % cpcm_nang if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid cpcm_nang value: \" // trim ( value )) return end if case ( 'cpcm_rscale' ) read ( value , * , iostat = io_stat ) config % cpcm_rscale if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid cpcm_rscale value: \" // trim ( value )) return end if case default call error % set ( ERROR_PARSE , \"Unknown key in %xtb section: \" // trim ( key )) return end select end do end subroutine parse_xtb_section subroutine parse_hessian_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %hessian section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'finite_difference_displacement' , 'displacement' ) read ( value , * , iostat = io_stat ) config % hessian_displacement case ( 'temperature' ) read ( value , * , iostat = io_stat ) config % hessian_temperature if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid temperature value: \" // trim ( value )) return end if case ( 'pressure' ) read ( value , * , iostat = io_stat ) config % hessian_pressure if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid pressure value: \" // trim ( value )) return end if case default call error % set ( ERROR_PARSE , \"Unknown key in %hessian section: \" // trim ( key )) return end select end do end subroutine parse_hessian_section subroutine parse_aimd_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %aimd section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'dt' , 'timestep' ) read ( value , * , iostat = io_stat ) config % aimd_dt case ( 'nsteps' , 'steps' ) read ( value , * , iostat = io_stat ) config % aimd_nsteps case ( 'initial_temperature' , 'temperature' ) read ( value , * , iostat = io_stat ) config % aimd_initial_temperature case ( 'output_frequency' , 'output_freq' ) read ( value , * , iostat = io_stat ) config % aimd_output_frequency case default call error % set ( ERROR_PARSE , \"Unknown key in %aimd section: \" // trim ( key )) return end select end do end subroutine parse_aimd_section subroutine parse_fragmentation_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_cutoffs in_cutoffs = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragmentation section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_cutoffs ) then ! Validate cutoffs before leaving the cutoffs section call validate_cutoffs ( config , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_fragmentation_section\" ) return end if in_cutoffs = . false . cycle else exit end if end if if ( trim ( line ) == '%cutoffs' ) then in_cutoffs = . true . cycle end if eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( in_cutoffs ) then ! Parse cutoffs: numeric keys like \"2\", \"3\", \"4\", etc. ! representing n-mer level (2=dimer, 3=trimer, etc.) block integer :: nmer_level real ( dp ) :: cutoff_value ! Try to read the key as an integer (n-mer level) read ( key , * , iostat = io_stat ) nmer_level if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid n-mer level in cutoffs (expected integer): \" // trim ( key )) return end if ! Validate n-mer level if ( nmer_level < 2 ) then call error % set ( ERROR_PARSE , \"N-mer level must be >= 2 in cutoffs\" ) return end if if ( nmer_level > 10 ) then call error % set ( ERROR_PARSE , \"N-mer level too large in cutoffs (max 10 for decamer)\" ) return end if ! Read the cutoff value read ( value , * , iostat = io_stat ) cutoff_value if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid cutoff value: \" // trim ( value )) return end if ! Allocate array if not yet allocated (up to decamer = 10) if (. not . allocated ( config % fragment_cutoffs )) then allocate ( config % fragment_cutoffs ( 10 )) config % fragment_cutoffs = - 1.0_dp ! Initialize with sentinel value end if ! Store the cutoff value at the appropriate index config % fragment_cutoffs ( nmer_level ) = cutoff_value end block else select case ( trim ( key )) case ( 'method' ) config % frag_method = trim ( value ) case ( 'level' ) read ( value , * , iostat = io_stat ) config % frag_level if ( io_stat == 0 ) then if ( config % frag_level < 0 ) then call error % set ( ERROR_VALIDATION , \"Fragmentation level must be >= 0 (0 = unfragmented)\" ) return end if if ( config % frag_level > 10 ) then call error % set ( ERROR_VALIDATION , & \"Fragmentation level must be <= 10 (decamers). Higher levels not supported.\" ) return end if end if case ( 'allow_overlapping_fragments' ) config % allow_overlapping_fragments = ( trim ( value ) == 'true' ) case ( 'max_intersection_level' ) read ( value , * , iostat = io_stat ) config % max_intersection_level if ( io_stat == 0 ) then if ( config % max_intersection_level < 1 ) then call error % set ( ERROR_VALIDATION , \"max_intersection_level must be >= 1\" ) return end if if ( config % max_intersection_level > 10 ) then call error % set ( ERROR_VALIDATION , & \"max_intersection_level must be <= 10 (decamers). Higher levels not supported.\" ) return end if end if case ( 'embedding' ) config % embedding = trim ( value ) case ( 'cutoff_method' ) config % cutoff_method = trim ( value ) case ( 'distance_metric' ) config % distance_metric = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %fragmentation section: \" // trim ( key )) return end select end if end do end subroutine parse_fragmentation_section subroutine parse_system_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %system section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'log_level' ) config % log_level = trim ( value ) case ( 'skip_json_output' ) config % skip_json_output = ( trim ( value ) == 'true' . or . trim ( value ) == '.true.' ) case default call error % set ( ERROR_PARSE , \"Unknown key in %system section: \" // trim ( key )) return end select end do end subroutine parse_system_section subroutine parse_molecules_section ( unit , config , error ) !! Parse %molecules section containing multiple %molecule blocks integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nmol , imol nmol = 0 ! First pass: read nmol do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecules section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nmol' ) then read ( value , * , iostat = io_stat ) nmol if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nmol value\" ) return end if exit end if end if end do if ( nmol == 0 ) then ! No molecules, just skip to end call skip_to_end ( unit , error ) return end if config % nmol = nmol allocate ( config % molecules ( nmol )) ! Parse individual molecules imol = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%molecule' ) then imol = imol + 1 if ( imol > nmol ) then call error % set ( ERROR_PARSE , \"More molecules than declared nmol\" ) return end if call parse_single_molecule ( unit , config % molecules ( imol ), error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_molecules_section\" ) return end if end if end do if ( imol /= nmol ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nmol , \" molecules, found \" , imol call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_molecules_section subroutine parse_single_molecule ( unit , mol , error ) !! Parse a single %molecule block with its sections integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecule\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit ! Check for key=value pairs (like name) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'name' ) then mol % name = trim ( value ) cycle end if end if ! Check for subsections if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%structure' ) call parse_molecule_structure ( unit , mol , error ) case ( '%geometry' ) call parse_molecule_geometry ( unit , mol , error ) case ( '%fragments' ) call parse_molecule_fragments ( unit , mol , error ) case ( '%connectivity' ) call parse_molecule_connectivity ( unit , mol , error ) case default ! Skip unknown subsections call skip_to_end ( unit , error ) end select if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_single_molecule\" ) return end if end if end do end subroutine parse_single_molecule subroutine parse_molecule_structure ( unit , mol , error ) !! Parse %structure section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , mol % charge , mol % multiplicity , error ) end subroutine parse_molecule_structure subroutine parse_molecule_geometry ( unit , mol , error ) !! Parse %geometry section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , mol % geometry , error ) end subroutine parse_molecule_geometry subroutine parse_molecule_fragments ( unit , mol , error ) !! Parse %fragments section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , mol % nfrag , mol % fragments , error ) end subroutine parse_molecule_fragments subroutine parse_molecule_connectivity ( unit , mol , error ) !! Parse %connectivity section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , mol % nbonds , mol % nbroken , mol % bonds , error ) end subroutine parse_molecule_connectivity subroutine skip_to_end ( unit , error ) !! Skip lines until 'end' marker is found integer , intent ( in ) :: unit type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line integer :: io_stat do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file while skipping section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) exit end do end subroutine skip_to_end function parse_method_string ( method_str ) result ( method_type ) !! Parse method string from input file (e.g., \"XTB-GFN1\" -> gfn1) character ( len =* ), intent ( in ) :: method_str integer ( int32 ) :: method_type character ( len = :), allocatable :: lower_str , method_part integer :: dash_pos , i ! Convert to lowercase allocate ( character ( len = len_trim ( method_str )) :: lower_str ) lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Handle \"XTB-GFN1\" format -> extract \"gfn1\" if ( index ( lower_str , 'xtb' ) > 0 ) then dash_pos = index ( lower_str , '-' ) if ( dash_pos > 0 ) then method_part = lower_str ( dash_pos + 1 :) else method_part = lower_str end if else method_part = lower_str end if method_type = method_type_from_string ( method_part ) end function parse_method_string subroutine molecule_destroy ( this ) !! Clean up allocated memory in molecule_t class ( molecule_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % name )) deallocate ( this % name ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) end subroutine molecule_destroy subroutine config_destroy ( this ) !! Clean up allocated memory in mqc_config_t class ( mqc_config_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % schema_name )) deallocate ( this % schema_name ) if ( allocated ( this % schema_version )) deallocate ( this % schema_version ) if ( allocated ( this % units )) deallocate ( this % units ) if ( allocated ( this % basis )) deallocate ( this % basis ) if ( allocated ( this % aux_basis )) deallocate ( this % aux_basis ) if ( allocated ( this % log_level )) deallocate ( this % log_level ) if ( allocated ( this % frag_method )) deallocate ( this % frag_method ) if ( allocated ( this % embedding )) deallocate ( this % embedding ) if ( allocated ( this % cutoff_method )) deallocate ( this % cutoff_method ) if ( allocated ( this % distance_metric )) deallocate ( this % distance_metric ) if ( allocated ( this % fragment_cutoffs )) deallocate ( this % fragment_cutoffs ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) ! Clean up molecules array (multi-molecule mode) if ( allocated ( this % molecules )) then do i = 1 , size ( this % molecules ) call this % molecules ( i )% destroy () end do deallocate ( this % molecules ) end if end subroutine config_destroy subroutine input_fragment_destroy ( this ) !! Clean up allocated memory in input_fragment_t class ( input_fragment_t ), intent ( inout ) :: this if ( allocated ( this % indices )) deallocate ( this % indices ) end subroutine input_fragment_destroy !! ======================================================================== !! Generic parsing helpers to eliminate redundancy !! ======================================================================== subroutine parse_structure_generic ( unit , charge , multiplicity , error ) !! Generic parser for %structure section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: charge , multiplicity type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %structure section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in %structure section: \" // trim ( key )) return end select end do end subroutine parse_structure_generic subroutine parse_geometry_generic ( unit , geom , error ) !! Generic parser for %geometry section (works for both config and molecule) integer , intent ( in ) :: unit type ( geometry_type ), intent ( inout ) :: geom type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , elem integer :: io_stat , natoms , i real ( dp ) :: x , y , z ! Read number of atoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading natoms in %geometry section\" ) return end if read ( line , * , iostat = io_stat ) natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid natoms in %geometry section\" ) return end if geom % natoms = natoms ! Read blank line (comment line in XYZ format) read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading comment line in %geometry section\" ) return end if geom % comment = trim ( line ) ! Allocate arrays allocate ( character ( len = 4 ) :: geom % elements ( natoms )) allocate ( geom % coords ( 3 , natoms )) ! Read coordinates do i = 1 , natoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry coordinates\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) then call error % set ( ERROR_PARSE , \"Unexpected 'end' while reading geometry\" ) return end if read ( line , * , iostat = io_stat ) elem , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid coordinate format in %geometry section\" ) return end if geom % elements ( i ) = trim ( elem ) geom % coords ( 1 , i ) = x geom % coords ( 2 , i ) = y geom % coords ( 3 , i ) = z end do ! Read 'end' marker read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_VALIDATION , \"Missing 'end' in %geometry section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) /= 'end' ) then call error % set ( ERROR_PARSE , \"Expected 'end' after geometry coordinates\" ) return end if end subroutine parse_geometry_generic subroutine parse_fragments_generic ( unit , nfrag , fragments , error ) !! Generic parser for %fragments section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nfrag type ( input_fragment_t ), allocatable , intent ( inout ) :: fragments (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nfrag_local , ifrag nfrag_local = 0 ! First pass: read nfrag do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragments section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nfrag' ) then read ( value , * , iostat = io_stat ) nfrag_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nfrag value\" ) return end if exit end if end if end do if ( nfrag_local == 0 ) then ! No fragments, just skip to end call skip_to_end ( unit , error ) return end if nfrag = nfrag_local allocate ( fragments ( nfrag )) ! Parse individual fragments ifrag = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%fragment' ) then ifrag = ifrag + 1 if ( ifrag > nfrag ) then call error % set ( ERROR_PARSE , \"More fragments than declared nfrag\" ) return end if call parse_fragment ( unit , fragments ( ifrag ), error ) if ( error % has_error ()) then call error % add_context ( \"mqc_config_parser:parse_molecule_fragments\" ) return end if end if end do if ( ifrag /= nfrag ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nfrag , \" fragments, found \" , ifrag call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_fragments_generic subroutine parse_connectivity_generic ( unit , nbonds , nbroken , bonds , error ) !! Generic parser for %connectivity section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nbonds , nbroken type ( bond_t ), allocatable , intent ( inout ) :: bonds (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value , status_str integer :: io_stat , eq_pos , nbonds_local , ibond integer :: atom_i , atom_j , order nbonds_local = 0 ! First pass: read nbonds do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %connectivity section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbonds' ) then read ( value , * , iostat = io_stat ) nbonds_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nbonds value\" ) return end if exit end if end if end do if ( nbonds_local == 0 ) then ! No bonds, just skip to end call skip_to_end ( unit , error ) return end if nbonds = nbonds_local allocate ( bonds ( nbonds )) ! Read bonds ibond = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for key=value pairs (like nbroken=9) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbroken' ) then read ( value , * , iostat = io_stat ) nbroken end if cycle end if if ( trim ( strip_comment ( line )) == 'end' ) exit ! Parse bond line: atom_i atom_j order broken/preserved read ( line , * , iostat = io_stat ) atom_i , atom_j , order , status_str if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid bond format in %connectivity section\" ) return end if ibond = ibond + 1 if ( ibond > nbonds ) then call error % set ( ERROR_PARSE , \"More bonds than declared nbonds\" ) return end if bonds ( ibond )% atom_i = atom_i bonds ( ibond )% atom_j = atom_j bonds ( ibond )% order = order bonds ( ibond )% is_broken = ( trim ( status_str ) == 'broken' ) end do end subroutine parse_connectivity_generic subroutine validate_cutoffs ( config , error ) !! Validate that fragment cutoffs are monotonically decreasing !! For n-mer level N, cutoff(N) must be <= cutoff(N-1) type ( mqc_config_t ), intent ( in ) :: config type ( error_t ), intent ( out ) :: error integer :: i , level_low , level_high real ( dp ) :: cutoff_low , cutoff_high character ( len = 256 ) :: msg if (. not . allocated ( config % fragment_cutoffs )) return ! Check monotonicity for consecutive levels with defined cutoffs do i = 2 , size ( config % fragment_cutoffs ) level_low = i - 1 level_high = i cutoff_low = config % fragment_cutoffs ( level_low ) cutoff_high = config % fragment_cutoffs ( level_high ) ! Skip if either cutoff is not defined (negative or zero sentinel value) if ( cutoff_low <= 0.0_dp . or . cutoff_high <= 0.0_dp ) cycle ! Validate monotonic decreasing if ( cutoff_high > cutoff_low ) then write ( msg , '(a,i0,a,f0.2,a,i0,a,f0.2,a)' ) & \"Fragment cutoffs must be monotonically decreasing: \" , & level_high , \"-mer cutoff (\" , cutoff_high , \") cannot be larger than \" , & level_low , \"-mer cutoff (\" , cutoff_low , \"). Check %cutoffs section.\" call error % set ( ERROR_PARSE , trim ( msg )) return end if end do end subroutine validate_cutoffs end module mqc_config_parser","tags":"","url":"sourcefile/mqc_config_parser.f90.html"},{"title":"mqc_io_helpers.f90 – metalquicha","text":"IO helper utilities for file naming and string operations\nProvides utilities for output filename management and string parsing Files dependent on this one sourcefile~~mqc_io_helpers.f90~~AfferentGraph sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! IO helper utilities for file naming and string operations !! Provides utilities for output filename management and string parsing module mqc_io_helpers implicit none private character ( len = 256 ) :: output_json_filename = \"results.json\" character ( len = 256 ) :: current_basename = \"\" public :: set_output_json_filename , get_output_json_filename , get_basename public :: set_molecule_suffix public :: get_molecule_name , ends_with contains subroutine set_output_json_filename ( input_filename ) !! Set the JSON output filename based on input filename !! Example: \"water.mqc\" -> \"output_water.json\" character ( len =* ), intent ( in ) :: input_filename integer :: dot_pos , slash_pos character ( len = 256 ) :: basename ! Find last slash (if any) to extract basename slash_pos = index ( input_filename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = input_filename ( slash_pos + 1 :) else basename = input_filename end if ! Find last dot to remove extension dot_pos = index ( basename , '.' , back = . true .) if ( dot_pos > 0 ) then basename = basename ( 1 : dot_pos - 1 ) end if ! Store basename for later use current_basename = trim ( basename ) ! Construct output filename: output_<basename>.json output_json_filename = \"output_\" // trim ( basename ) // \".json\" end subroutine set_output_json_filename subroutine set_molecule_suffix ( suffix ) !! Append a suffix to the output filename (e.g., for multi-molecule mode) !! Example: suffix=\"_mol1\" -> \"output_multi_structure_mol1.json\" character ( len =* ), intent ( in ) :: suffix if ( len_trim ( current_basename ) > 0 ) then output_json_filename = \"output_\" // trim ( current_basename ) // trim ( suffix ) // \".json\" end if end subroutine set_molecule_suffix function get_output_json_filename () result ( filename ) !! Get the current JSON output filename character ( len = 256 ) :: filename filename = trim ( output_json_filename ) end function get_output_json_filename function get_basename () result ( basename ) !! Get the base name without \"output_\" prefix and \".json\" suffix !! Example: \"output_w1.json\" -> \"w1\" character ( len = 256 ) :: basename integer :: start_pos , end_pos ! Remove \"output_\" prefix (7 characters) start_pos = 8 ! Find \".json\" suffix end_pos = index ( output_json_filename , '.json' , back = . true .) - 1 if ( end_pos > start_pos ) then basename = output_json_filename ( start_pos : end_pos ) else basename = \"unknown\" end if end function get_basename function get_molecule_name ( filename ) result ( name ) !! Extract molecule name from filename !! Example: \"output_multi_structure_molecule_1.json\" -> \"molecule_1\" character ( len =* ), intent ( in ) :: filename character ( len = 256 ) :: name integer :: start_pos , end_pos ! Find \"_molecule_\" or similar pattern start_pos = index ( filename , '_molecule_' ) if ( start_pos == 0 ) start_pos = index ( filename , '_mol_' ) if ( start_pos > 0 ) then start_pos = start_pos + 1 ! Skip leading underscore end_pos = index ( filename , '.json' ) - 1 if ( end_pos > start_pos ) then name = filename ( start_pos : end_pos ) else name = \"unknown\" end if else name = \"unknown\" end if end function get_molecule_name logical function ends_with ( str , suffix ) !! Check if string ends with suffix character ( len =* ), intent ( in ) :: str , suffix integer :: str_len , suffix_len str_len = len_trim ( str ) suffix_len = len_trim ( suffix ) if ( suffix_len > str_len ) then ends_with = . false . return end if ends_with = ( str ( str_len - suffix_len + 1 : str_len ) == suffix ) end function ends_with end module mqc_io_helpers","tags":"","url":"sourcefile/mqc_io_helpers.f90.html"},{"title":"mqc_logo.f90 – metalquicha","text":"ASCII art logo display for metalquicha Files dependent on this one sourcefile~~mqc_logo.f90~~AfferentGraph sourcefile~mqc_logo.f90 mqc_logo.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_logo.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! ASCII art logo display for metalquicha module mqc_logo !! Provides the project branding sunflower logo and version information !! displayed at program startup. implicit none private public :: print_logo !! Display ASCII sunflower logo and project info contains subroutine print_logo () !! Print the PIC Chemistry ASCII sunflower logo write ( * , '(A)' ) ' ' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                        __   __' write ( * , '(A)' ) '                     .-(  ''.''  )-.' write ( * , '(A)' ) '                    (   \\  |  /   )' write ( * , '(A)' ) '                   ( ''`-.;;;;;.-''` )' write ( * , '(A)' ) '                  ( :-==;;;;;;;==-: )' write ( * , '(A)' ) '                   (  .-'';;;;;''-.  )' write ( * , '(A)' ) '                    (``  /  |  \\  ``)' write ( * , '(A)' ) '                     ''-(__.''.__)-''' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                      (Art by jgs)' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '    ╔═══════════════════════════════════════════════╗' write ( * , '(A)' ) '    ║              Met\"al q\"uicha                   ║' write ( * , '(A)' ) '    ║                (Sunflower)                    ║' write ( * , '(A)' ) '    ║   A hastily put together Fortran code for     ║' write ( * , '(A)' ) '    ║     Fragmented Based Quantum Chemistry        ║' write ( * , '(A)' ) '    ║                                               ║' write ( * , '(A)' ) '    ║        Coded up by Jorge as a hobby           ║' write ( * , '(A)' ) '    ╚═══════════════════════════════════════════════╝' write ( * , '(A)' ) ' ' end subroutine print_logo end module mqc_logo","tags":"","url":"sourcefile/mqc_logo.f90.html"},{"title":"mqc_thermochemistry.f90 – metalquicha","text":"Thermochemistry calculations using the Rigid Rotor Harmonic Oscillator (RRHO) approximation This file depends on sourcefile~~mqc_thermochemistry.f90~~EfferentGraph sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_thermochemistry.f90~~AfferentGraph sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Thermochemistry calculations using the Rigid Rotor Harmonic Oscillator (RRHO) approximation module mqc_thermochemistry !! Computes thermodynamic properties from vibrational frequencies and molecular geometry. !! !! This module implements standard RRHO thermochemistry calculations including: !! - Zero-point vibrational energy (ZPE) !! - Translational, rotational, vibrational, and electronic contributions !! - Thermal corrections to energy, enthalpy, and Gibbs free energy !! !! Default conditions: T = 298.15 K, P = 1 atm !! Output follows Gaussian-style formatting for compatibility. use pic_types , only : dp use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_physical_constants , only : BOHR_TO_ANGSTROM , AMU_TO_AU , AMU_TO_KG , & KB_HARTREE , KB_SI , H_SI , CM1_TO_KELVIN , & R_CALMOLK , R_HARTREE , ATM_TO_PA , CAL_TO_J , & PI , ROTCONST_AMUA2_TO_GHZ , ROTTEMP_AMUA2_TO_K , & VIB_CLASSICAL_LIMIT , & HARTREE_TO_KCALMOL , HARTREE_TO_JMOL , HARTREE_TO_CALMOL use mqc_elements , only : element_mass use pic_lapack_interfaces , only : pic_syev implicit none private public :: thermochemistry_result_t public :: compute_moments_of_inertia public :: compute_rotational_constants public :: compute_zpe public :: compute_translational_thermo public :: compute_rotational_thermo public :: compute_vibrational_thermo public :: compute_electronic_entropy public :: compute_thermochemistry public :: print_thermochemistry !> Default temperature in Kelvin real ( dp ), parameter , public :: DEFAULT_TEMPERATURE = 29 8.15_dp !> Default pressure in atm real ( dp ), parameter , public :: DEFAULT_PRESSURE = 1.0_dp !> Default symmetry number integer , parameter , public :: DEFAULT_SYMMETRY_NUMBER = 1 !> Default spin multiplicity (singlet) integer , parameter , public :: DEFAULT_SPIN_MULTIPLICITY = 1 !> Threshold for considering a moment of inertia as zero (linear molecule detection) real ( dp ), parameter :: LINEAR_THRESHOLD = 1.0e-6_dp !> Threshold for considering a frequency as imaginary real ( dp ), parameter :: IMAG_FREQ_THRESHOLD = 0.0_dp type :: thermochemistry_result_t !! Container for thermochemistry calculation results real ( dp ) :: temperature = DEFAULT_TEMPERATURE !! Temperature in K real ( dp ) :: pressure = DEFAULT_PRESSURE !! Pressure in atm integer :: symmetry_number = DEFAULT_SYMMETRY_NUMBER !! Rotational symmetry number integer :: spin_multiplicity = DEFAULT_SPIN_MULTIPLICITY !! Electronic spin multiplicity logical :: is_linear = . false . !! True if molecule is linear ! Molecular properties real ( dp ) :: total_mass = 0.0_dp !! Total mass in amu real ( dp ) :: moments ( 3 ) = 0.0_dp !! Principal moments of inertia in amu*Angstrom&#94;2 real ( dp ) :: rot_const ( 3 ) = 0.0_dp !! Rotational constants in GHz ! Zero-point energy real ( dp ) :: zpe_hartree = 0.0_dp !! ZPE in Hartree real ( dp ) :: zpe_kcalmol = 0.0_dp !! ZPE in kcal/mol ! Thermal energy contributions (Hartree) real ( dp ) :: E_trans = 0.0_dp !! Translational thermal energy real ( dp ) :: E_rot = 0.0_dp !! Rotational thermal energy real ( dp ) :: E_vib = 0.0_dp !! Vibrational thermal energy (excluding ZPE) real ( dp ) :: E_elec = 0.0_dp !! Electronic thermal energy (always 0) ! Entropy contributions (cal/(mol*K)) real ( dp ) :: S_trans = 0.0_dp !! Translational entropy real ( dp ) :: S_rot = 0.0_dp !! Rotational entropy real ( dp ) :: S_vib = 0.0_dp !! Vibrational entropy real ( dp ) :: S_elec = 0.0_dp !! Electronic entropy ! Heat capacity contributions (cal/(mol*K)) real ( dp ) :: Cv_trans = 0.0_dp !! Translational heat capacity real ( dp ) :: Cv_rot = 0.0_dp !! Rotational heat capacity real ( dp ) :: Cv_vib = 0.0_dp !! Vibrational heat capacity ! Summary quantities (Hartree) real ( dp ) :: thermal_correction_energy = 0.0_dp !! E_tot = ZPE + E_trans + E_rot + E_vib real ( dp ) :: thermal_correction_enthalpy = 0.0_dp !! H = E_tot + RT real ( dp ) :: thermal_correction_gibbs = 0.0_dp !! G = H - TS ! Partition functions real ( dp ) :: q_trans = 0.0_dp !! Translational partition function real ( dp ) :: q_rot = 0.0_dp !! Rotational partition function real ( dp ) :: q_vib = 1.0_dp !! Vibrational partition function ! Counts integer :: n_real_freqs = 0 !! Number of real vibrational frequencies integer :: n_imag_freqs = 0 !! Number of imaginary frequencies (skipped) end type thermochemistry_result_t contains subroutine compute_moments_of_inertia ( coords , atomic_numbers , n_atoms , & center_of_mass , moments , principal_axes , is_linear , total_mass ) !! Compute the principal moments of inertia and detect linear molecules. !! !! Calculates the center of mass, inertia tensor, and diagonalizes to get !! principal moments. A molecule is considered linear if one moment is !! essentially zero (< LINEAR_THRESHOLD). real ( dp ), intent ( in ) :: coords (:, :) !! Atomic coordinates (3, n_atoms) in Bohr integer , intent ( in ) :: atomic_numbers (:) !! Atomic numbers integer , intent ( in ) :: n_atoms !! Number of atoms real ( dp ), intent ( out ) :: center_of_mass ( 3 ) !! Center of mass in Angstrom real ( dp ), intent ( out ) :: moments ( 3 ) !! Principal moments in amu*Angstrom&#94;2 real ( dp ), intent ( out ) :: principal_axes ( 3 , 3 ) !! Principal axis vectors (columns) logical , intent ( out ) :: is_linear !! True if molecule is linear real ( dp ), intent ( out ) :: total_mass !! Total mass in amu real ( dp ) :: coords_ang ( 3 , n_atoms ) real ( dp ) :: masses ( n_atoms ) real ( dp ) :: rel_coords ( 3 , n_atoms ) real ( dp ) :: inertia_tensor ( 3 , 3 ) integer :: i , info real ( dp ) :: mass_i , x , y , z ! Convert coordinates to Angstrom coords_ang = coords * BOHR_TO_ANGSTROM ! Get atomic masses total_mass = 0.0_dp do i = 1 , n_atoms masses ( i ) = element_mass ( atomic_numbers ( i )) total_mass = total_mass + masses ( i ) end do ! Compute center of mass center_of_mass = 0.0_dp do i = 1 , n_atoms center_of_mass (:) = center_of_mass (:) + masses ( i ) * coords_ang (:, i ) end do center_of_mass = center_of_mass / total_mass ! Compute coordinates relative to center of mass do i = 1 , n_atoms rel_coords (:, i ) = coords_ang (:, i ) - center_of_mass (:) end do ! Build inertia tensor inertia_tensor = 0.0_dp do i = 1 , n_atoms mass_i = masses ( i ) x = rel_coords ( 1 , i ) y = rel_coords ( 2 , i ) z = rel_coords ( 3 , i ) ! Diagonal elements: I_xx = sum(m * (y&#94;2 + z&#94;2)), etc. inertia_tensor ( 1 , 1 ) = inertia_tensor ( 1 , 1 ) + mass_i * ( y * y + z * z ) inertia_tensor ( 2 , 2 ) = inertia_tensor ( 2 , 2 ) + mass_i * ( x * x + z * z ) inertia_tensor ( 3 , 3 ) = inertia_tensor ( 3 , 3 ) + mass_i * ( x * x + y * y ) ! Off-diagonal elements: I_xy = -sum(m * x * y), etc. inertia_tensor ( 1 , 2 ) = inertia_tensor ( 1 , 2 ) - mass_i * x * y inertia_tensor ( 1 , 3 ) = inertia_tensor ( 1 , 3 ) - mass_i * x * z inertia_tensor ( 2 , 3 ) = inertia_tensor ( 2 , 3 ) - mass_i * y * z end do ! Symmetrize inertia_tensor ( 2 , 1 ) = inertia_tensor ( 1 , 2 ) inertia_tensor ( 3 , 1 ) = inertia_tensor ( 1 , 3 ) inertia_tensor ( 3 , 2 ) = inertia_tensor ( 2 , 3 ) ! Diagonalize to get principal moments principal_axes = inertia_tensor call pic_syev ( principal_axes , moments , 'V' , 'U' , info ) if ( info /= 0 ) then call logger % warning ( \"Failed to diagonalize inertia tensor, info = \" // & trim ( adjustl ( to_char ( info )))) moments = 0.0_dp is_linear = . false . return end if ! Check for linear molecule: one moment should be ~0 ! Moments are returned in ascending order is_linear = ( moments ( 1 ) < LINEAR_THRESHOLD ) end subroutine compute_moments_of_inertia subroutine compute_rotational_constants ( moments , is_linear , rot_const ) !! Convert moments of inertia to rotational constants in GHz. !! !! B = h / (8 * pi&#94;2 * I) where I is in SI units. !! For I in amu*Angstrom&#94;2: B(GHz) = 505379.07 / I real ( dp ), intent ( in ) :: moments ( 3 ) !! Moments in amu*Angstrom&#94;2 logical , intent ( in ) :: is_linear !! True if linear molecule real ( dp ), intent ( out ) :: rot_const ( 3 ) !! Rotational constants in GHz integer :: i rot_const = 0.0_dp if ( is_linear ) then ! For linear molecules, only one rotational constant matters ! Use the largest moment (moments are sorted ascending) if ( moments ( 3 ) > LINEAR_THRESHOLD ) then rot_const ( 1 ) = ROTCONST_AMUA2_TO_GHZ / moments ( 3 ) end if else ! For nonlinear molecules, compute all three do i = 1 , 3 if ( moments ( i ) > LINEAR_THRESHOLD ) then rot_const ( i ) = ROTCONST_AMUA2_TO_GHZ / moments ( i ) end if end do end if end subroutine compute_rotational_constants subroutine compute_zpe ( frequencies , n_freqs , n_real , zpe_hartree , zpe_kcalmol ) !! Compute zero-point vibrational energy from frequencies. !! !! ZPE = (1/2) * h * sum(nu_i) for all real frequencies. !! Imaginary frequencies (negative values) are skipped with a warning. real ( dp ), intent ( in ) :: frequencies (:) !! Vibrational frequencies in cm&#94;-1 integer , intent ( in ) :: n_freqs !! Total number of frequencies integer , intent ( out ) :: n_real !! Number of real (positive) frequencies used real ( dp ), intent ( out ) :: zpe_hartree !! ZPE in Hartree real ( dp ), intent ( out ) :: zpe_kcalmol !! ZPE in kcal/mol integer :: i real ( dp ) :: freq_sum integer :: n_imag freq_sum = 0.0_dp n_real = 0 n_imag = 0 do i = 1 , n_freqs if ( frequencies ( i ) > IMAG_FREQ_THRESHOLD ) then freq_sum = freq_sum + frequencies ( i ) n_real = n_real + 1 else if ( frequencies ( i ) < IMAG_FREQ_THRESHOLD ) then n_imag = n_imag + 1 end if ! Frequencies exactly at threshold (typically trans/rot modes ~0) are skipped end do if ( n_imag > 0 ) then call logger % warning ( \"Thermochemistry: \" // trim ( adjustl ( to_char ( n_imag ))) // & \" imaginary frequency(ies) skipped\" ) end if ! ZPE = 0.5 * sum(h * c * nu) where nu is in cm&#94;-1 ! In atomic units: ZPE = 0.5 * sum(nu * CM1_TO_KELVIN * KB_HARTREE) ! Actually: h*c*nu [cm&#94;-1] = h*c*nu [J] = nu * CM1_TO_KELVIN * k_B [J] ! So ZPE [Hartree] = 0.5 * sum(nu) * CM1_TO_KELVIN * KB_HARTREE zpe_hartree = 0.5_dp * freq_sum * CM1_TO_KELVIN * KB_HARTREE zpe_kcalmol = zpe_hartree * HARTREE_TO_KCALMOL end subroutine compute_zpe subroutine compute_translational_thermo ( total_mass , temperature , pressure , E , S , Cv ) !! Compute translational contributions to thermodynamic properties. !! !! Uses ideal gas partition function (Sackur-Tetrode equation for entropy). !! E_trans = 3/2 * R * T !! S_trans = R * [5/2 + ln((2*pi*m*k*T/h&#94;2)&#94;(3/2) * k*T/P)] !! Cv_trans = 3/2 * R real ( dp ), intent ( in ) :: total_mass !! Total mass in amu real ( dp ), intent ( in ) :: temperature !! Temperature in K real ( dp ), intent ( in ) :: pressure !! Pressure in atm real ( dp ), intent ( out ) :: E !! Thermal energy in Hartree real ( dp ), intent ( out ) :: S !! Entropy in cal/(mol*K) real ( dp ), intent ( out ) :: Cv !! Heat capacity in cal/(mol*K) real ( dp ) :: mass_kg , T , P_pa real ( dp ) :: lambda_cubed , V_molar , qt ! Convert inputs to SI mass_kg = total_mass * AMU_TO_KG T = temperature P_pa = pressure * ATM_TO_PA ! Thermal de Broglie wavelength cubed: lambda&#94;3 = (h&#94;2 / (2*pi*m*k*T))&#94;(3/2) lambda_cubed = ( H_SI * H_SI / ( 2.0_dp * PI * mass_kg * KB_SI * T )) ** 1.5_dp ! Molar volume at given T and P (ideal gas): V = R*T/P = k*T/P per molecule V_molar = KB_SI * T / P_pa ! m&#94;3 per molecule ! Translational partition function per molecule qt = V_molar / lambda_cubed ! Thermal energy: E = 3/2 * R * T E = 1.5_dp * R_HARTREE * temperature ! Entropy (Sackur-Tetrode): S = R * [5/2 + ln(qt)] S = R_CALMOLK * ( 2.5_dp + log ( qt )) ! Heat capacity: Cv = 3/2 * R Cv = 1.5_dp * R_CALMOLK end subroutine compute_translational_thermo subroutine compute_rotational_thermo ( moments , temperature , symmetry_number , is_linear , E , S , Cv ) !! Compute rotational contributions to thermodynamic properties. !! !! Uses rigid rotor approximation (classical limit, high T). !! For nonlinear: E = 3/2 RT, Cv = 3/2 R !! For linear: E = RT, Cv = R real ( dp ), intent ( in ) :: moments ( 3 ) !! Principal moments in amu*Angstrom&#94;2 real ( dp ), intent ( in ) :: temperature !! Temperature in K integer , intent ( in ) :: symmetry_number !! Rotational symmetry number logical , intent ( in ) :: is_linear !! True if linear molecule real ( dp ), intent ( out ) :: E !! Thermal energy in Hartree real ( dp ), intent ( out ) :: S !! Entropy in cal/(mol*K) real ( dp ), intent ( out ) :: Cv !! Heat capacity in cal/(mol*K) real ( dp ) :: theta_rot ( 3 ) real ( dp ) :: T , sigma real ( dp ) :: qr integer :: i T = temperature sigma = real ( symmetry_number , dp ) ! Calculate rotational temperatures: theta_rot = h&#94;2 / (8*pi&#94;2*I*k_B) ! For I in amu*Angstrom&#94;2: !   I_SI = I * 1.66054e-47 kg*m&#94;2 !   theta_rot = h&#94;2 / (8*pi&#94;2 * I_SI * k_B) !             = (6.62607e-34)&#94;2 / (8 * pi&#94;2 * 1.66054e-47 * 1.38065e-23 * I) !             = ROTTEMP_AMUA2_TO_K / I  [K] do i = 1 , 3 if ( moments ( i ) > LINEAR_THRESHOLD ) then theta_rot ( i ) = ROTTEMP_AMUA2_TO_K / moments ( i ) else theta_rot ( i ) = 0.0_dp end if end do if ( is_linear ) then ! Linear molecule: 2 rotational degrees of freedom E = R_HARTREE * T Cv = R_CALMOLK ! S = R * [1 + ln(T / (sigma * theta_rot))] ! Use the average of the two non-zero theta values if ( theta_rot ( 3 ) > 0.0_dp ) then qr = T / ( sigma * theta_rot ( 3 )) S = R_CALMOLK * ( 1.0_dp + log ( qr )) else S = 0.0_dp end if else ! Nonlinear molecule: 3 rotational degrees of freedom E = 1.5_dp * R_HARTREE * T Cv = 1.5_dp * R_CALMOLK ! S = R * [3/2 + ln(sqrt(pi) * T&#94;(3/2) / (sigma * sqrt(theta_A*theta_B*theta_C)))] if ( theta_rot ( 1 ) > 0.0_dp . and . theta_rot ( 2 ) > 0.0_dp . and . theta_rot ( 3 ) > 0.0_dp ) then qr = sqrt ( PI ) * ( T ** 1.5_dp ) / ( sigma * sqrt ( theta_rot ( 1 ) * theta_rot ( 2 ) * theta_rot ( 3 ))) S = R_CALMOLK * ( 1.5_dp + log ( qr )) else S = 0.0_dp end if end if end subroutine compute_rotational_thermo subroutine compute_vibrational_thermo ( frequencies , n_freqs , temperature , E , S , Cv ) !! Compute vibrational contributions to thermodynamic properties. !! !! Uses quantum harmonic oscillator partition function. !! E_vib = R * sum(theta_v * [1/(exp(u)-1)]) where u = theta_v/T !! S_vib = R * sum([u/(exp(u)-1) - ln(1-exp(-u))]) !! Cv_vib = R * sum(u&#94;2 * exp(u) / (exp(u)-1)&#94;2) !! !! Note: ZPE is NOT included here (computed separately). real ( dp ), intent ( in ) :: frequencies (:) !! Frequencies in cm&#94;-1 integer , intent ( in ) :: n_freqs !! Number of frequencies real ( dp ), intent ( in ) :: temperature !! Temperature in K real ( dp ), intent ( out ) :: E !! Thermal energy in Hartree (excluding ZPE) real ( dp ), intent ( out ) :: S !! Entropy in cal/(mol*K) real ( dp ), intent ( out ) :: Cv !! Heat capacity in cal/(mol*K) integer :: i real ( dp ) :: T , freq , theta_v , u real ( dp ) :: exp_u , exp_neg_u real ( dp ) :: E_sum , S_sum , Cv_sum T = temperature E_sum = 0.0_dp S_sum = 0.0_dp Cv_sum = 0.0_dp do i = 1 , n_freqs freq = frequencies ( i ) ! Skip imaginary and near-zero frequencies if ( freq <= IMAG_FREQ_THRESHOLD ) cycle if ( freq < 1 0.0_dp ) cycle ! Skip very low frequencies (likely trans/rot residuals) ! Vibrational temperature: theta_v = h*c*nu / k = 1.4388 * nu (cm&#94;-1) theta_v = CM1_TO_KELVIN * freq ! Reduced temperature ratio u = theta_v / T ! Avoid numerical issues for very large u (very low T or high freq) if ( u > VIB_CLASSICAL_LIMIT ) then ! Classical limit: modes are frozen out cycle end if exp_u = exp ( u ) exp_neg_u = exp ( - u ) ! Energy contribution (excluding ZPE): theta_v / (exp(u) - 1) E_sum = E_sum + theta_v / ( exp_u - 1.0_dp ) ! Entropy contribution: u/(exp(u)-1) - ln(1-exp(-u)) S_sum = S_sum + u / ( exp_u - 1.0_dp ) - log ( 1.0_dp - exp_neg_u ) ! Heat capacity contribution: u&#94;2 * exp(u) / (exp(u)-1)&#94;2 Cv_sum = Cv_sum + ( u * u * exp_u ) / (( exp_u - 1.0_dp ) ** 2 ) end do ! Convert to proper units E = KB_HARTREE * E_sum ! Hartree S = R_CALMOLK * S_sum ! cal/(mol*K) Cv = R_CALMOLK * Cv_sum ! cal/(mol*K) end subroutine compute_vibrational_thermo subroutine compute_electronic_entropy ( spin_multiplicity , S_elec ) !! Compute electronic entropy contribution. !! !! S_elec = R * ln(2S+1) where 2S+1 is the spin multiplicity. !! For singlet (mult=1): S_elec = 0 integer , intent ( in ) :: spin_multiplicity !! Electronic spin multiplicity (2S+1) real ( dp ), intent ( out ) :: S_elec !! Electronic entropy in cal/(mol*K) S_elec = R_CALMOLK * log ( real ( spin_multiplicity , dp )) end subroutine compute_electronic_entropy subroutine compute_partition_functions ( total_mass , moments , frequencies , n_freqs , & temperature , pressure , sigma , is_linear , & q_trans , q_rot , q_vib ) !! Compute partition functions for translation, rotation, and vibration. real ( dp ), intent ( in ) :: total_mass !! Total mass in amu real ( dp ), intent ( in ) :: moments ( 3 ) !! Principal moments in amu*Angstrom&#94;2 real ( dp ), intent ( in ) :: frequencies (:) !! Frequencies in cm&#94;-1 integer , intent ( in ) :: n_freqs !! Number of frequencies real ( dp ), intent ( in ) :: temperature !! Temperature in K real ( dp ), intent ( in ) :: pressure !! Pressure in atm integer , intent ( in ) :: sigma !! Symmetry number logical , intent ( in ) :: is_linear !! True if linear molecule real ( dp ), intent ( out ) :: q_trans !! Translational partition function real ( dp ), intent ( out ) :: q_rot !! Rotational partition function real ( dp ), intent ( out ) :: q_vib !! Vibrational partition function real ( dp ) :: mass_kg , T , P_pa real ( dp ) :: lambda , V_molar real ( dp ) :: theta_rot ( 3 ), u integer :: i T = temperature mass_kg = total_mass * AMU_TO_KG P_pa = pressure * ATM_TO_PA ! Translational partition function: q_trans = (2*pi*m*k*T/h&#94;2)&#94;(3/2) * V ! where V = kT/P for ideal gas (per molecule) lambda = H_SI / sqrt ( 2.0_dp * PI * mass_kg * KB_SI * T ) ! thermal de Broglie wavelength V_molar = KB_SI * T / P_pa ! volume per molecule q_trans = V_molar / ( lambda ** 3 ) ! Rotational partition function ! theta_rot = h&#94;2 / (8*pi&#94;2*I*k_B) = ROTTEMP_AMUA2_TO_K / I (for I in amu*Angstrom&#94;2) do i = 1 , 3 if ( moments ( i ) > 1.0e-6_dp ) then theta_rot ( i ) = ROTTEMP_AMUA2_TO_K / moments ( i ) else theta_rot ( i ) = 0.0_dp end if end do if ( is_linear ) then ! Linear: q_rot = T / (sigma * theta_rot) if ( theta_rot ( 3 ) > 0.0_dp ) then q_rot = T / ( real ( sigma , dp ) * theta_rot ( 3 )) else q_rot = 1.0_dp end if else ! Nonlinear: q_rot = sqrt(pi) * T&#94;(3/2) / (sigma * sqrt(theta_A * theta_B * theta_C)) if ( theta_rot ( 1 ) > 0.0_dp . and . theta_rot ( 2 ) > 0.0_dp . and . theta_rot ( 3 ) > 0.0_dp ) then q_rot = sqrt ( PI ) * ( T ** 1.5_dp ) / & ( real ( sigma , dp ) * sqrt ( theta_rot ( 1 ) * theta_rot ( 2 ) * theta_rot ( 3 ))) else q_rot = 1.0_dp end if end if ! Vibrational partition function: q_vib = Product_i [1 / (1 - exp(-u_i))] ! where u_i = h*nu/(k*T) = theta_vib/T = 1.4388 * nu(cm&#94;-1) / T q_vib = 1.0_dp do i = 1 , n_freqs if ( frequencies ( i ) > 1 0.0_dp ) then ! Skip near-zero frequencies u = CM1_TO_KELVIN * frequencies ( i ) / T if ( u < 10 0.0_dp ) then ! Avoid overflow q_vib = q_vib / ( 1.0_dp - exp ( - u )) end if end if end do end subroutine compute_partition_functions subroutine compute_thermochemistry ( coords , atomic_numbers , frequencies , n_atoms , n_freqs , & result , temperature , pressure , symmetry_number , spin_multiplicity ) !! Main driver for thermochemistry calculations. !! !! Computes all thermodynamic quantities from molecular geometry and vibrational frequencies. real ( dp ), intent ( in ) :: coords (:, :) !! Coordinates (3, n_atoms) in Bohr integer , intent ( in ) :: atomic_numbers (:) !! Atomic numbers real ( dp ), intent ( in ) :: frequencies (:) !! Frequencies in cm&#94;-1 integer , intent ( in ) :: n_atoms !! Number of atoms integer , intent ( in ) :: n_freqs !! Number of frequencies type ( thermochemistry_result_t ), intent ( out ) :: result !! Output results real ( dp ), intent ( in ), optional :: temperature !! Temperature in K (default 298.15) real ( dp ), intent ( in ), optional :: pressure !! Pressure in atm (default 1.0) integer , intent ( in ), optional :: symmetry_number !! Symmetry number (default 1) integer , intent ( in ), optional :: spin_multiplicity !! Spin multiplicity (default 1) real ( dp ) :: center_of_mass ( 3 ) real ( dp ) :: principal_axes ( 3 , 3 ) real ( dp ) :: T , P integer :: sigma , mult real ( dp ) :: S_total ! Set parameters T = DEFAULT_TEMPERATURE P = DEFAULT_PRESSURE sigma = DEFAULT_SYMMETRY_NUMBER mult = DEFAULT_SPIN_MULTIPLICITY if ( present ( temperature )) T = temperature if ( present ( pressure )) P = pressure if ( present ( symmetry_number )) sigma = symmetry_number if ( present ( spin_multiplicity )) mult = spin_multiplicity result % temperature = T result % pressure = P result % symmetry_number = sigma result % spin_multiplicity = mult ! Compute moments of inertia call compute_moments_of_inertia ( coords , atomic_numbers , n_atoms , & center_of_mass , result % moments , principal_axes , & result % is_linear , result % total_mass ) ! Compute rotational constants call compute_rotational_constants ( result % moments , result % is_linear , result % rot_const ) ! Compute ZPE call compute_zpe ( frequencies , n_freqs , result % n_real_freqs , & result % zpe_hartree , result % zpe_kcalmol ) result % n_imag_freqs = n_freqs - result % n_real_freqs ! Compute translational contributions call compute_translational_thermo ( result % total_mass , T , P , & result % E_trans , result % S_trans , result % Cv_trans ) ! Compute rotational contributions call compute_rotational_thermo ( result % moments , T , sigma , result % is_linear , & result % E_rot , result % S_rot , result % Cv_rot ) ! Compute vibrational contributions (thermal, excluding ZPE) call compute_vibrational_thermo ( frequencies , n_freqs , T , & result % E_vib , result % S_vib , result % Cv_vib ) ! Compute electronic contributions result % E_elec = 0.0_dp ! Ground state only call compute_electronic_entropy ( mult , result % S_elec ) ! Compute partition functions call compute_partition_functions ( result % total_mass , result % moments , frequencies , n_freqs , & T , P , sigma , result % is_linear , & result % q_trans , result % q_rot , result % q_vib ) ! Compute summary quantities ! Thermal correction to energy = ZPE + E_trans + E_rot + E_vib + E_elec result % thermal_correction_energy = result % zpe_hartree + & result % E_trans + result % E_rot + result % E_vib + result % E_elec ! Thermal correction to enthalpy = E_tot + RT result % thermal_correction_enthalpy = result % thermal_correction_energy + R_HARTREE * T ! Total entropy in Hartree/K S_total = ( result % S_trans + result % S_rot + result % S_vib + result % S_elec ) / HARTREE_TO_CALMOL ! Thermal correction to Gibbs = H - TS result % thermal_correction_gibbs = result % thermal_correction_enthalpy - T * S_total end subroutine compute_thermochemistry subroutine print_thermochemistry ( result , electronic_energy , unit ) !! Print thermochemistry results. type ( thermochemistry_result_t ), intent ( in ) :: result real ( dp ), intent ( in ) :: electronic_energy !! Electronic energy in Hartree integer , intent ( in ), optional :: unit !! Output unit (default: stdout) real ( dp ) :: H_total_cal , Cv_total , S_total , S_total_J real ( dp ) :: H_vib_cal , H_rot_cal , H_trans_cal real ( dp ) :: H_T , TS , G_T real ( dp ) :: total_energy , total_enthalpy , total_free_energy real ( dp ) :: H0_HT_PV , pV_cal character ( len = 512 ) :: line ! pV term = RT for ideal gas (in cal/mol) pV_cal = R_CALMOLK * result % temperature ! Compute enthalpy contributions (what xtb shows in \"enthalpy\" column) ! VIB: thermal vibrational energy only (ZPE is reported separately) H_vib_cal = result % E_vib * HARTREE_TO_CALMOL ! ROT: just internal energy (3/2)RT for nonlinear, RT for linear - no pV term H_rot_cal = result % E_rot * HARTREE_TO_CALMOL ! TR: includes pV term, so (5/2)RT for translation enthalpy H_trans_cal = result % E_trans * HARTREE_TO_CALMOL + pV_cal ! TOT: sum of thermal contributions (VIB + ROT + TR), NOT including ZPE H_total_cal = H_vib_cal + H_rot_cal + H_trans_cal ! Use Cp for translation (Cv + R) as is standard for thermochemistry output Cv_total = ( result % Cv_trans + R_CALMOLK ) + result % Cv_rot + result % Cv_vib S_total = result % S_trans + result % S_rot + result % S_vib + result % S_elec S_total_J = S_total * CAL_TO_J ! cal to J ! Thermodynamic quantities in Hartree ! H(0)-H(T)+PV is the thermal correction WITHOUT ZPE (just E_trans + E_rot + E_vib + RT) H0_HT_PV = result % E_trans + result % E_rot + result % E_vib + R_HARTREE * result % temperature ! H(T) is full thermal correction including ZPE H_T = result % thermal_correction_enthalpy TS = result % thermal_correction_enthalpy - result % thermal_correction_gibbs G_T = result % thermal_correction_gibbs total_energy = electronic_energy total_enthalpy = electronic_energy + result % thermal_correction_enthalpy total_free_energy = electronic_energy + result % thermal_correction_gibbs ! Print header call logger % info ( \" \" ) call logger % info ( \"Thermochemistry (RRHO)\" ) call logger % info ( \"======================\" ) call logger % info ( \" \" ) ! Setup section - simple list write ( line , '(A,F10.4,A)' ) \"  Temperature:       \" , result % temperature , \" K\" call logger % info ( trim ( line )) write ( line , '(A,F10.4,A)' ) \"  Pressure:          \" , result % pressure , \" atm\" call logger % info ( trim ( line )) write ( line , '(A,F10.4,A)' ) \"  Molecular mass:    \" , result % total_mass , \" amu\" call logger % info ( trim ( line )) write ( line , '(A,I6)' ) \"  Vibrational modes: \" , result % n_real_freqs call logger % info ( trim ( line )) if ( result % n_imag_freqs > 0 ) then write ( line , '(A,I6,A)' ) \"  Imaginary freqs:   \" , result % n_imag_freqs , \" (skipped)\" call logger % info ( trim ( line )) end if if ( result % is_linear ) then call logger % info ( \"  Linear molecule:   yes\" ) else call logger % info ( \"  Linear molecule:   no\" ) end if write ( line , '(A,I6)' ) \"  Symmetry number:   \" , result % symmetry_number call logger % info ( trim ( line )) call logger % info ( \" \" ) ! Contribution table call logger % info ( \"  temp (K)       q        H(cal/mol)  Cp(cal/K/mol)  S(cal/K/mol)  S(J/K/mol)\" ) call logger % info ( \"  -------------------------------------------------------------------------\" ) write ( line , '(F8.2,A,ES10.3,F12.3,F14.3,F14.3,F12.3)' ) & result % temperature , \"  VIB\" , result % q_vib , H_vib_cal , result % Cv_vib , & result % S_vib , result % S_vib * CAL_TO_J call logger % info ( trim ( line )) write ( line , '(A,ES10.3,F12.3,F14.3,F14.3,F12.3)' ) & \"          ROT\" , result % q_rot , H_rot_cal , result % Cv_rot , & result % S_rot , result % S_rot * CAL_TO_J call logger % info ( trim ( line )) write ( line , '(A,ES10.3,F12.3,F14.3,F14.3,F12.3)' ) & \"          INT\" , result % q_rot * result % q_vib , H_vib_cal + H_rot_cal , & result % Cv_vib + result % Cv_rot , result % S_vib + result % S_rot , & ( result % S_vib + result % S_rot ) * CAL_TO_J call logger % info ( trim ( line )) ! For TR, report Cp = Cv + R (constant pressure heat capacity for ideal gas) write ( line , '(A,ES10.3,F12.3,F14.3,F14.3,F12.3)' ) & \"          TR \" , result % q_trans , H_trans_cal , result % Cv_trans + R_CALMOLK , & result % S_trans , result % S_trans * CAL_TO_J call logger % info ( trim ( line )) call logger % info ( \"  -------------------------------------------------------------------------\" ) write ( line , '(A,F12.3,F14.3,F14.3,F12.3)' ) & \"          TOT           \" , H_total_cal , Cv_total , S_total , S_total_J call logger % info ( trim ( line )) call logger % info ( \" \" ) ! Thermal corrections table call logger % info ( \" \" ) call logger % info ( \"Thermal Corrections (Hartree)\" ) call logger % info ( \"-----------------------------\" ) write ( line , '(A,F18.12)' ) \"  Zero-point energy:              \" , result % zpe_hartree call logger % info ( trim ( line )) write ( line , '(A,F18.12)' ) \"  Thermal correction to Energy:   \" , result % thermal_correction_energy call logger % info ( trim ( line )) write ( line , '(A,F18.12)' ) \"  Thermal correction to Enthalpy: \" , result % thermal_correction_enthalpy call logger % info ( trim ( line )) write ( line , '(A,F18.12)' ) \"  Thermal correction to Gibbs:    \" , result % thermal_correction_gibbs call logger % info ( trim ( line )) call logger % info ( \" \" ) ! Final totals call logger % info ( \"Total Energies (Hartree)\" ) call logger % info ( \"------------------------\" ) write ( line , '(A,F20.12)' ) \"  Electronic energy:            \" , total_energy call logger % info ( trim ( line )) write ( line , '(A,F20.12)' ) \"  Electronic + ZPE:             \" , total_energy + result % zpe_hartree call logger % info ( trim ( line )) write ( line , '(A,F20.12)' ) \"  Electronic + thermal (E):     \" , total_energy + result % thermal_correction_energy call logger % info ( trim ( line )) write ( line , '(A,F20.12)' ) \"  Electronic + thermal (H):     \" , total_enthalpy call logger % info ( trim ( line )) write ( line , '(A,F20.12)' ) \"  Electronic + thermal (G):     \" , total_free_energy call logger % info ( trim ( line )) call logger % info ( \" \" ) end subroutine print_thermochemistry end module mqc_thermochemistry","tags":"","url":"sourcefile/mqc_thermochemistry.f90.html"},{"title":"mqc_unfragmented_workflow.f90 – metalquicha","text":"This file depends on sourcefile~~mqc_unfragmented_workflow.f90~~EfferentGraph sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_error.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_mpi_comms.f90 mqc_mpi_comms.f90 sourcefile~mqc_resources.f90->sourcefile~mqc_mpi_comms.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( mqc_mbe_fragment_distribution_scheme ) mqc_unfragmented_workflow implicit none contains module subroutine unfragmented_calculation ( sys_geom , method_config , calc_type , bonds , result_out , & temperature , pressure , json_data ) !! Run unfragmented calculation on the entire system (nlevel=0) !! This is a simple single-process calculation without MPI distribution !! If result_out is present, returns result instead of writing JSON and destroying it !! If json_data is present, populates it for centralized JSON output use mqc_error , only : error_t use mqc_vibrational_analysis , only : compute_vibrational_frequencies , & compute_vibrational_analysis , print_vibrational_analysis use mqc_thermochemistry , only : thermochemistry_result_t , compute_thermochemistry use mqc_json_output_types , only : json_output_data_t , OUTPUT_MODE_UNFRAGMENTED type ( system_geometry_t ), intent ( in ), optional :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ), intent ( out ), optional :: result_out real ( dp ), intent ( in ), optional :: temperature !! Temperature for thermochemistry (K) real ( dp ), intent ( in ), optional :: pressure !! Pressure for thermochemistry (atm) type ( json_output_data_t ), intent ( out ), optional :: json_data type ( calculation_result_t ) :: result integer :: total_atoms type ( physical_fragment_t ) :: full_system type ( error_t ) :: error integer :: i if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for unfragmented calculation\" ) error stop \"Missing geometry in unfragmented_calculation\" end if total_atoms = sys_geom % total_atoms call logger % info ( \"============================================\" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( total_atoms )) call logger % info ( \"============================================\" ) ! Build the full system as a single fragment ! For overlapping fragments, we use the full system directly (not concatenating fragments) full_system % n_atoms = total_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( total_atoms )) allocate ( full_system % coordinates ( 3 , total_atoms )) ! Copy all atoms from system geometry full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates ! Set charge and multiplicity from system full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Validate geometry (check for spatially overlapping atoms) call check_duplicate_atoms ( full_system , error ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Overlapping atoms in unfragmented system\" end if ! Process the full system call do_fragment_work ( 0_int64 , result , method_config , phys_frag = full_system , calc_type = calc_type ) ! Check for calculation errors if ( result % has_error ) then call logger % error ( \"Unfragmented calculation failed: \" // result % error % get_message ()) if ( present ( result_out )) then result_out = result return else error stop \"Unfragmented calculation failed\" end if end if call logger % info ( \"============================================\" ) call logger % info ( \"Unfragmented calculation completed\" ) block character ( len = 2048 ) :: result_line ! Large buffer for Hessian matrix rows integer :: current_log_level , iatom , i , j real ( dp ) :: hess_norm write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_dipole ) then write ( result_line , '(a,3f15.8)' ) \"  Dipole (e*Bohr): \" , result % dipole call logger % info ( trim ( result_line )) write ( result_line , '(a,f15.8)' ) \"  Dipole magnitude (Debye): \" , norm2 ( result % dipole ) * 2.541746_dp call logger % info ( trim ( result_line )) end if if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) ! Print full gradient if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Gradient (Hartree/Bohr):\" ) do iatom = 1 , total_atoms write ( result_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & result % gradient ( 1 , iatom ), result % gradient ( 2 , iatom ), result % gradient ( 3 , iatom ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if if ( result % has_hessian ) then ! Compute Frobenius norm of Hessian hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) ! Print full Hessian if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * total_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * total_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if ! Compute and print vibrational analysis block real ( dp ), allocatable :: frequencies (:), eigenvalues (:), projected_hessian (:, :) real ( dp ), allocatable :: reduced_masses (:), force_constants (:) real ( dp ), allocatable :: cart_disp (:, :), fc_mdyne (:), ir_intensities (:) integer :: ii , jj ! First get projected Hessian for verbose output call logger % info ( \"  Computing vibrational analysis (projecting trans/rot modes)...\" ) call compute_vibrational_frequencies ( result % hessian , sys_geom % element_numbers , frequencies , eigenvalues , & coordinates = sys_geom % coordinates , project_trans_rot = . true ., & projected_hessian_out = projected_hessian ) ! Print projected mass-weighted Hessian if verbose and small system if ( current_log_level >= verbose_level . and . total_atoms < 20 ) then if ( allocated ( projected_hessian )) then call logger % info ( \" \" ) call logger % info ( \"Mass-weighted Hessian after trans/rot projection (a.u.):\" ) do ii = 1 , 3 * total_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , ii , \": \" , & ( projected_hessian ( ii , jj ), jj = 1 , 3 * total_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if ! Compute full vibrational analysis and print (with IR intensities if available) if ( result % has_dipole_derivatives ) then call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne , & dipole_derivatives = result % dipole_derivatives , & ir_intensities = ir_intensities ) else call compute_vibrational_analysis ( result % hessian , sys_geom % element_numbers , frequencies , & reduced_masses , force_constants , cart_disp , & coordinates = sys_geom % coordinates , & project_trans_rot = . true ., & force_constants_mdyne = fc_mdyne ) end if if ( allocated ( frequencies )) then ! Compute thermochemistry for JSON output block type ( thermochemistry_result_t ) :: thermo_result integer :: n_modes , n_at n_at = size ( sys_geom % element_numbers ) n_modes = size ( frequencies ) call compute_thermochemistry ( sys_geom % coordinates , sys_geom % element_numbers , & frequencies , n_at , n_modes , thermo_result , & temperature = temperature , pressure = pressure ) ! Print vibrational analysis to log if ( allocated ( ir_intensities )) then call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & ir_intensities = ir_intensities , & coordinates = sys_geom % coordinates , & electronic_energy = result % energy % total (), & temperature = temperature , pressure = pressure ) else call print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cart_disp , sys_geom % element_numbers , & force_constants_mdyne = fc_mdyne , & coordinates = sys_geom % coordinates , & electronic_energy = result % energy % total (), & temperature = temperature , pressure = pressure ) end if ! Populate json_data if present (for centralized JSON output) if ( present ( json_data )) then json_data % output_mode = OUTPUT_MODE_UNFRAGMENTED json_data % total_energy = result % energy % total () json_data % has_energy = result % has_energy json_data % has_vibrational = . true . ! Copy vibrational data allocate ( json_data % frequencies ( n_modes )) allocate ( json_data % reduced_masses ( n_modes )) allocate ( json_data % force_constants ( n_modes )) json_data % frequencies = frequencies json_data % reduced_masses = reduced_masses json_data % force_constants = fc_mdyne json_data % thermo = thermo_result if ( allocated ( ir_intensities )) then allocate ( json_data % ir_intensities ( n_modes )) json_data % ir_intensities = ir_intensities json_data % has_ir_intensities = . true . end if ! Copy dipole if available if ( result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = result % dipole json_data % has_dipole = . true . end if ! Copy gradient if available if ( result % has_gradient ) then allocate ( json_data % gradient ( 3 , total_atoms )) json_data % gradient = result % gradient json_data % has_gradient = . true . end if ! Copy hessian if available if ( result % has_hessian ) then allocate ( json_data % hessian ( 3 * total_atoms , 3 * total_atoms )) json_data % hessian = result % hessian json_data % has_hessian = . true . end if end if if ( allocated ( ir_intensities )) deallocate ( ir_intensities ) end block deallocate ( frequencies , reduced_masses , force_constants , cart_disp , fc_mdyne ) end if if ( allocated ( eigenvalues )) deallocate ( eigenvalues ) if ( allocated ( projected_hessian )) deallocate ( projected_hessian ) end block end if end block call logger % info ( \"============================================\" ) ! Return result to caller or handle json_data if ( present ( result_out )) then ! Transfer result to output (for dynamics/optimization) result_out = result else ! Populate json_data for non-Hessian case if present ! (Hessian case already handled above in the vibrational block) if ( present ( json_data ) . and . . not . result % has_hessian ) then json_data % output_mode = OUTPUT_MODE_UNFRAGMENTED json_data % total_energy = result % energy % total () json_data % has_energy = result % has_energy if ( result % has_dipole ) then allocate ( json_data % dipole ( 3 )) json_data % dipole = result % dipole json_data % has_dipole = . true . end if if ( result % has_gradient ) then allocate ( json_data % gradient ( 3 , total_atoms )) json_data % gradient = result % gradient json_data % has_gradient = . true . end if end if call result % destroy () end if end subroutine unfragmented_calculation end submodule mqc_unfragmented_workflow","tags":"","url":"sourcefile/mqc_unfragmented_workflow.f90.html"},{"title":"mqc_mbe_mpi_fragment_distribution_scheme.F90 – metalquicha","text":"This file depends on sourcefile~~mqc_mbe_mpi_fragment_distribution_scheme.f90~~EfferentGraph sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_error.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_mpi_comms.f90 mqc_mpi_comms.f90 sourcefile~mqc_resources.f90->sourcefile~mqc_mpi_comms.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( mqc_mbe_fragment_distribution_scheme ) mpi_fragment_work_smod use mqc_error , only : ERROR_VALIDATION , ERROR_GENERIC implicit none contains module subroutine do_fragment_work ( fragment_idx , result , method_config , phys_frag , calc_type , world_comm ) !! Process a single fragment for quantum chemistry calculation !! !! Performs energy and gradient calculation on a molecular fragment using !! the factory pattern to create a calculator from the provided method_config. !! Verbosity is controlled by the global logger level. use pic_logger , only : verbose_level integer ( int64 ), intent ( in ) :: fragment_idx !! Fragment index for identification type ( calculation_result_t ), intent ( out ) :: result !! Computation results type ( method_config_t ), intent ( in ) :: method_config !! Method configuration type ( physical_fragment_t ), intent ( in ), optional :: phys_frag !! Fragment geometry integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( comm_t ), intent ( in ), optional :: world_comm !! MPI communicator for abort integer :: current_log_level !! Current logger verbosity level logical :: is_verbose !! Whether verbose output is enabled integer ( int32 ) :: calc_type_local !! Local copy of calc_type type ( method_config_t ) :: local_config !! Local copy for verbose override class ( qc_method_t ), allocatable :: calculator !! Polymorphic calculator instance calc_type_local = calc_type ! Query logger to determine verbosity call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) ! Print fragment geometry if provided and verbose mode is enabled if ( present ( phys_frag )) then if ( is_verbose ) then call print_fragment_xyz ( fragment_idx , phys_frag ) end if ! Copy config and override verbose based on logger level local_config = method_config local_config % verbose = is_verbose ! Create calculator using factory calculator = create_method ( local_config ) ! Run the calculation using polymorphic dispatch select case ( calc_type_local ) case ( CALC_TYPE_ENERGY ) call calculator % calc_energy ( phys_frag , result ) case ( CALC_TYPE_GRADIENT ) call calculator % calc_gradient ( phys_frag , result ) case ( CALC_TYPE_HESSIAN ) call calculator % calc_hessian ( phys_frag , result ) case default call result % error % set ( ERROR_VALIDATION , \"Unknown calc_type: \" // calc_type_to_string ( calc_type_local )) result % has_error = . true . return end select ! Check for calculation errors if ( result % has_error ) then call result % error % add_context ( \"do_fragment_work:fragment_\" // to_char ( fragment_idx )) return end if ! Copy fragment distance to result for JSON output result % distance = phys_frag % distance ! Cleanup deallocate ( calculator ) else ! For empty fragments, set energy to zero call result % energy % reset () result % has_energy = . true . end if end subroutine do_fragment_work module subroutine global_coordinator ( resources , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , method_config , calc_type , bonds , json_data ) !! Global coordinator for distributing fragments to node coordinators !! will act as a node coordinator for a single node calculation !! Uses int64 for total_fragments to handle large fragment counts that overflow int32. use mqc_json_output_types , only : json_output_data_t type ( resources_t ), intent ( in ) :: resources integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level , num_nodes integer , intent ( in ) :: polymers (:, :), node_leader_ranks (:) type ( system_geometry_t ), intent ( in ), optional :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data type ( timer_type ) :: coord_timer integer ( int64 ) :: current_fragment , results_received integer :: finished_nodes integer :: request_source , dummy_msg integer ( int64 ) :: fragment_idx type ( MPI_Status ) :: status , local_status logical :: handling_local_workers logical :: has_pending integer ( int32 ) :: calc_type_local ! For local workers integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer ( int64 ) :: worker_fragment_map ( resources % mpi_comms % node_comm % size ()) integer :: worker_source ! MPI request handles for non-blocking operations type ( request_t ) :: req calc_type_local = calc_type current_fragment = total_fragments finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( resources % mpi_comms % node_comm % size () > 1 ) results_received = 0_int64 ! Allocate storage for results allocate ( results ( total_fragments )) worker_fragment_map = 0 call logger % verbose ( \"Global coordinator starting with \" // to_char ( total_fragments ) // & \" fragments for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers ! This MUST be checked before sending new work to avoid race conditions if ( handling_local_workers ) then ! Keep checking for results until there are none pending do call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Receive result and store it using the fragment index for this worker call result_irecv ( results ( worker_fragment_map ( worker_source )), resources % mpi_comms % node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Check for calculation errors from worker if ( results ( worker_fragment_map ( worker_source ))% has_error ) then call logger % error ( \"Fragment \" // to_char ( worker_fragment_map ( worker_source )) // & \" calculation failed: \" // & results ( worker_fragment_map ( worker_source ))% error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Clear the mapping since we've received the result worker_fragment_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( resources % mpi_comms % world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit ! Receive fragment index and result from node coordinator ! TODO: serialize the data for better performance call irecv ( resources % mpi_comms % world_comm , fragment_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( fragment_idx ), resources % mpi_comms % world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) ! Check for calculation errors from node coordinator if ( results ( fragment_idx )% has_error ) then call logger % error ( \"Fragment \" // to_char ( fragment_idx ) // \" calculation failed: \" // & results ( fragment_idx )% error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( resources % mpi_comms % world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( resources % mpi_comms % world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_fragment >= 1 ) then call send_fragment_to_node ( resources % mpi_comms % world_comm , current_fragment , polymers , request_source ) current_fragment = current_fragment - 1 else call isend ( resources % mpi_comms % world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < resources % mpi_comms % node_comm % size () - 1 ) then call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( resources % mpi_comms % node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_fragment >= 1 ) then call send_fragment_to_worker ( resources % mpi_comms % node_comm , current_fragment , polymers , & local_status % MPI_SOURCE ) ! Track which fragment was sent to this worker worker_fragment_map ( local_status % MPI_SOURCE ) = current_fragment current_fragment = current_fragment - 1 else call isend ( resources % mpi_comms % node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if ! If worker still has pending results, skip the work request ! It will be processed on the next iteration after results are received end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= resources % mpi_comms % node_comm % size () - 1 & . and . results_received >= total_fragments ) then handling_local_workers = . false . if ( num_nodes == 1 ) then finished_nodes = finished_nodes + 1 call logger % debug ( \"Manually incremented finished_nodes for self\" ) else finished_nodes = finished_nodes + 1 call logger % verbose ( \"Global coordinator finished local workers\" ) end if end if end do call logger % verbose ( \"Global coordinator finished all fragments\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) block use mqc_result_types , only : mbe_result_t type ( mbe_result_t ) :: mbe_result ! Compute the many-body expansion call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Allocate mbe_result components based on calc_type call mbe_result % allocate_dipole () ! Always compute dipole if ( calc_type_local == CALC_TYPE_HESSIAN ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for Hessian calculation in global_coordinator\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if call mbe_result % allocate_gradient ( sys_geom % total_atoms ) call mbe_result % allocate_hessian ( sys_geom % total_atoms ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for gradient calculation in global_coordinator\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if call mbe_result % allocate_gradient ( sys_geom % total_atoms ) end if call compute_mbe ( polymers , total_fragments , max_level , results , mbe_result , & sys_geom , bonds , resources % mpi_comms % world_comm , json_data ) call mbe_result % destroy () call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end block ! Cleanup deallocate ( results ) end subroutine global_coordinator subroutine send_fragment_to_node ( world_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to remote node coordinator !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int64 ) :: fragment_idx_int64 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int64 = int ( fragment_idx , kind = int64 ) call isend ( world_comm , fragment_idx_int64 , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , fragment_size , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , fragment_indices , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_node subroutine send_fragment_to_worker ( node_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to local worker !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int64 ) :: fragment_idx_int64 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int64 = int ( fragment_idx , kind = int64 ) call isend ( node_comm , fragment_idx_int64 , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , fragment_size , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , fragment_indices , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_worker module subroutine node_coordinator ( resources , method_config , calc_type ) !! Node coordinator for distributing fragments to local workers !! Handles work requests and result collection from local workers type ( resources_t ), intent ( in ) :: resources type ( method_config_t ), intent ( in ) :: method_config !! Method configuration (passed through to workers) integer ( int32 ), intent ( in ) :: calc_type integer ( int64 ) :: fragment_idx integer ( int32 ) :: fragment_size , fragment_type , dummy_msg integer ( int32 ) :: finished_workers integer ( int32 ), allocatable :: fragment_indices (:) type ( MPI_Status ) :: status , global_status logical :: local_message_pending , more_fragments , has_result integer ( int32 ) :: local_dummy ! For tracking worker-fragment mapping and collecting results integer ( int64 ) :: worker_fragment_map ( resources % mpi_comms % node_comm % size ()) integer ( int32 ) :: worker_source type ( calculation_result_t ) :: worker_result ! MPI request handles for non-blocking operations type ( request_t ) :: req finished_workers = 0 more_fragments = . true . dummy_msg = 0 worker_fragment_map = 0 do while ( finished_workers < resources % mpi_comms % node_comm % size () - 1 ) ! PRIORITY 1: Check for incoming results from local workers call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_result , status ) if ( has_result ) then worker_source = status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Node coordinator received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Receive result from worker call result_irecv ( worker_result , resources % mpi_comms % node_comm , worker_source , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Check for calculation errors before forwarding if ( worker_result % has_error ) then call logger % error ( \"Fragment \" // to_char ( worker_fragment_map ( worker_source )) // & \" calculation failed on worker \" // to_char ( worker_source ) // \": \" // & worker_result % error % get_message ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Forward results to global coordinator with fragment index call isend ( resources % mpi_comms % world_comm , worker_fragment_map ( worker_source ), 0 , TAG_NODE_SCALAR_RESULT , req ) ! fragment_idx call wait ( req ) call result_isend ( worker_result , resources % mpi_comms % world_comm , 0 , TAG_NODE_SCALAR_RESULT , req ) ! result call wait ( req ) ! Clear the mapping worker_fragment_map ( worker_source ) = 0 end if ! PRIORITY 2: Check for work requests from local workers call iprobe ( resources % mpi_comms % node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , local_message_pending , status ) if ( local_message_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( status % MPI_SOURCE ) == 0 ) then call irecv ( resources % mpi_comms % node_comm , local_dummy , status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( more_fragments ) then call isend ( resources % mpi_comms % world_comm , dummy_msg , 0 , TAG_NODE_REQUEST , req ) call wait ( req ) call irecv ( resources % mpi_comms % world_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , global_status ) if ( global_status % MPI_TAG == TAG_NODE_FRAGMENT ) then ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( resources % mpi_comms % world_comm , fragment_type , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) call irecv ( resources % mpi_comms % world_comm , fragment_size , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( resources % mpi_comms % world_comm , fragment_indices , 0 , TAG_NODE_FRAGMENT , global_status ) ! Forward to worker call isend ( resources % mpi_comms % node_comm , fragment_idx , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( resources % mpi_comms % node_comm , fragment_type , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( resources % mpi_comms % node_comm , fragment_size , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( resources % mpi_comms % node_comm , fragment_indices , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Track which fragment was sent to this worker worker_fragment_map ( status % MPI_SOURCE ) = fragment_idx deallocate ( fragment_indices ) else call isend ( resources % mpi_comms % node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 more_fragments = . false . end if else call isend ( resources % mpi_comms % node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end if end do end subroutine node_coordinator module subroutine node_worker ( resources , sys_geom , method_config , calc_type , bonds ) !! Node worker for processing fragments assigned by node coordinator use mqc_error , only : error_t type ( resources_t ), intent ( in ) :: resources type ( system_geometry_t ), intent ( in ), optional :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int64 ) :: fragment_idx integer ( int32 ) :: fragment_size , dummy_msg integer ( int32 ) :: fragment_type !! 0 = monomer (indices), 1 = intersection (atom list) integer ( int32 ), allocatable :: fragment_indices (:) type ( calculation_result_t ) :: result type ( MPI_Status ) :: status type ( physical_fragment_t ) :: phys_frag type ( error_t ) :: error ! MPI request handles for non-blocking operations type ( request_t ) :: req dummy_msg = 0 do call isend ( resources % mpi_comms % node_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( resources % mpi_comms % node_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) select case ( status % MPI_TAG ) case ( TAG_WORKER_FRAGMENT ) ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( resources % mpi_comms % node_comm , fragment_type , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call irecv ( resources % mpi_comms % node_comm , fragment_size , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( resources % mpi_comms % node_comm , fragment_indices , 0 , TAG_WORKER_FRAGMENT , status ) ! Build physical fragment based on type if ( present ( sys_geom )) then if ( fragment_type == 0 ) then ! Monomer: fragment_indices are monomer indices call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , error , bonds ) else ! Intersection: fragment_indices are atom indices call build_fragment_from_atom_list ( sys_geom , fragment_indices , fragment_size , phys_frag , error , bonds ) end if if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end if ! Process the chemistry fragment with physical geometry call do_fragment_work ( fragment_idx , result , method_config , phys_frag , calc_type , resources % mpi_comms % world_comm ) call phys_frag % destroy () else ! Process without physical geometry (old behavior) call do_fragment_work ( fragment_idx , result , method_config , & calc_type = calc_type , world_comm = resources % mpi_comms % world_comm ) end if ! Send result back to coordinator call result_isend ( result , resources % mpi_comms % node_comm , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clean up result call result % destroy () deallocate ( fragment_indices ) case ( TAG_WORKER_FINISH ) exit case default ! Unexpected MPI tag - this should not happen in normal operation call logger % error ( \"Worker received unexpected MPI tag: \" // to_char ( status % MPI_TAG )) call logger % error ( \"Expected TAG_WORKER_FRAGMENT or TAG_WORKER_FINISH\" ) call abort_comm ( resources % mpi_comms % world_comm , 1 ) end select end do end subroutine node_worker end submodule mpi_fragment_work_smod","tags":"","url":"sourcefile/mqc_mbe_mpi_fragment_distribution_scheme.f90.html"},{"title":"mqc_combinatorics.f90 – metalquicha","text":"Combinatorial mathematics utilities for fragment generation This file depends on sourcefile~~mqc_combinatorics.f90~~EfferentGraph sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_combinatorics.f90~~AfferentGraph sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Combinatorial mathematics utilities for fragment generation module mqc_combinatorics !! Provides pure combinatorial functions for generating molecular fragments !! including binomial coefficients, combinations, and fragment counting use pic_types , only : default_int , int32 , int64 implicit none private public :: binomial !! Binomial coefficient calculation public :: get_nfrags !! Calculate total number of fragments public :: create_monomer_list !! Generate sequential monomer indices public :: generate_fragment_list !! Generate all fragments up to max level public :: combine !! Generate all combinations of size r public :: get_next_combination !! Generate next combination in sequence public :: next_combination_init !! Initialize combination to [1,2,...,k] public :: next_combination !! Generate next combination (alternate interface) public :: print_combos !! Debug utility to print combinations public :: calculate_fragment_distances !! Calculate minimal distances for all fragments contains pure function get_nfrags ( n_monomers , max_level ) result ( n_expected_fragments ) !! Calculate total number of fragments for given system size and max level !! !! Computes the sum of binomial coefficients C(n,k) for k=1 to max_level, !! representing all possible fragments from monomers to max_level-mers. !! Uses int64 to handle large fragment counts that overflow int32. integer ( default_int ), intent ( in ) :: n_monomers !! Number of monomers in system integer ( default_int ), intent ( in ) :: max_level !! Maximum fragment size integer ( int64 ) :: n_expected_fragments !! Total fragment count integer ( default_int ) :: i !! Loop counter n_expected_fragments = 0_int64 do i = 1 , max_level n_expected_fragments = n_expected_fragments + binomial ( n_monomers , i ) end do end function get_nfrags pure function binomial ( n , r ) result ( c ) !! Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) !! !! Calculates \"n choose r\" using iterative algorithm to avoid !! factorial overflow for large numbers. !! Uses int64 to handle large combinatorial values that overflow int32. integer ( default_int ), intent ( in ) :: n !! Total number of items integer ( default_int ), intent ( in ) :: r !! Number of items to choose integer ( int64 ) :: c !! Binomial coefficient result integer ( default_int ) :: i !! Loop counter if ( r == 0 . or . r == n ) then c = 1_int64 else if ( r > n ) then c = 0_int64 else c = 1_int64 do i = 1 , r c = c * int ( n - i + 1 , int64 ) / int ( i , int64 ) end do end if end function binomial pure subroutine create_monomer_list ( monomers ) !! Generate a list of monomer indices from 1 to N integer ( default_int ), allocatable , intent ( inout ) :: monomers (:) integer ( default_int ) :: i , length length = size ( monomers , 1 ) do i = 1 , length monomers ( i ) = i end do end subroutine create_monomer_list recursive subroutine generate_fragment_list ( monomers , max_level , polymers , count ) !! Generate all possible fragments (combinations of monomers) up to max_level !! Uses int64 for count to handle large numbers of fragments that overflow int32. integer ( default_int ), intent ( in ) :: monomers (:), max_level integer ( default_int ), intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: r , n n = size ( monomers , 1 ) do r = 2 , max_level call combine ( monomers , n , r , polymers , count ) end do end subroutine generate_fragment_list recursive subroutine combine ( arr , n , r , out_array , count ) !! Generate all combinations of size r from array arr of size n !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:) integer ( default_int ), intent ( in ) :: n , r integer ( default_int ), intent ( inout ) :: out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: data ( r ) call combine_util ( arr , n , r , 1 , data , 1 , out_array , count ) end subroutine combine recursive subroutine combine_util ( arr , n , r , index , data , i , out_array , count ) !! Utility for generating combinations recursively !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:), n , r , index , i integer ( default_int ), intent ( inout ) :: data (:), out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: j if ( index > r ) then count = count + 1_int64 out_array ( count , 1 : r ) = data ( 1 : r ) return end if do j = i , n data ( index ) = arr ( j ) call combine_util ( arr , n , r , index + 1 , data , j + 1 , out_array , count ) end do end subroutine combine_util subroutine print_combos ( out_array , count , max_len ) !! Print combinations stored in out_array !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: out_array (:, :), max_len integer ( int64 ), intent ( in ) :: count integer ( int64 ) :: i integer ( default_int ) :: j do i = 1_int64 , count do j = 1 , max_len if ( out_array ( i , j ) == 0 ) exit write ( * , '(I0)' , advance = 'no' ) out_array ( i , j ) if ( j < max_len . and . out_array ( i , j + 1 ) /= 0 ) then write ( * , '(A)' , advance = 'no' ) \":\" end if end do write ( * , * ) ! newline end do end subroutine print_combos pure subroutine get_next_combination ( indices , k , n , has_next ) !! Generate next combination (updates indices in place) !! has_next = .true. if there's a next combination integer , intent ( inout ) :: indices (:) integer , intent ( in ) :: k , n logical , intent ( out ) :: has_next integer :: i has_next = . true . i = k do while ( i >= 1 ) if ( indices ( i ) < n - k + i ) then indices ( i ) = indices ( i ) + 1 do while ( i < k ) i = i + 1 indices ( i ) = indices ( i - 1 ) + 1 end do return end if i = i - 1 end do has_next = . false . end subroutine get_next_combination subroutine next_combination_init ( combination , k ) !! Initialize combination to [1, 2, ..., k] integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k integer :: i do i = 1 , k combination ( i ) = i end do end subroutine next_combination_init function next_combination ( combination , k , n ) result ( has_next ) !! Generate next combination in lexicographic order !! Returns .true. if there's a next combination, .false. if we've exhausted all integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k , n logical :: has_next integer :: i has_next = . true . ! Find the rightmost element that can be incremented i = k do while ( i >= 1 ) if ( combination ( i ) < n - k + i ) then combination ( i ) = combination ( i ) + 1 ! Reset all elements to the right do while ( i < k ) i = i + 1 combination ( i ) = combination ( i - 1 ) + 1 end do return end if i = i - 1 end do ! No more combinations has_next = . false . end function next_combination subroutine calculate_fragment_distances ( polymers , fragment_count , sys_geom , distances ) !! Calculate minimal atomic distance for each fragment !! For monomers (1-body), distance is 0.0 !! For n-mers (n >= 2), distance is the minimum distance between atoms !! in different constituent monomers use pic_types , only : dp use mqc_physical_fragment , only : system_geometry_t , to_angstrom integer ( default_int ), intent ( in ) :: polymers (:, :) integer ( int64 ), intent ( in ) :: fragment_count type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: distances (:) integer ( int64 ) :: ifrag integer :: fragment_size , i , j , iatom , jatom integer :: mon_i , mon_j integer :: atom_start_i , atom_end_i , atom_start_j , atom_end_j integer :: k real ( dp ) :: dist , min_dist real ( dp ) :: dx , dy , dz logical :: is_variable_size ! Check if we have variable-sized fragments is_variable_size = allocated ( sys_geom % fragment_sizes ) do ifrag = 1_int64 , fragment_count fragment_size = count ( polymers ( ifrag , :) > 0 ) if ( fragment_size == 1 ) then ! Monomers have distance 0 distances ( ifrag ) = 0.0_dp else ! For n-mers, calculate minimal distance between atoms in different monomers min_dist = huge ( 1.0_dp ) ! Loop over all pairs of monomers in this fragment do i = 1 , fragment_size - 1 mon_i = polymers ( ifrag , i ) do j = i + 1 , fragment_size mon_j = polymers ( ifrag , j ) if ( is_variable_size ) then ! Variable-sized fragments: use fragment_atoms to get atom indices ! Count atoms in this fragment do iatom = 1 , sys_geom % fragment_sizes ( mon_i ) atom_start_i = sys_geom % fragment_atoms ( iatom , mon_i ) + 1 ! Convert to 1-indexed do jatom = 1 , sys_geom % fragment_sizes ( mon_j ) atom_start_j = sys_geom % fragment_atoms ( jatom , mon_j ) + 1 ! Convert to 1-indexed ! Calculate distance dx = sys_geom % coordinates ( 1 , atom_start_i ) - sys_geom % coordinates ( 1 , atom_start_j ) dy = sys_geom % coordinates ( 2 , atom_start_i ) - sys_geom % coordinates ( 2 , atom_start_j ) dz = sys_geom % coordinates ( 3 , atom_start_i ) - sys_geom % coordinates ( 3 , atom_start_j ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_dist ) min_dist = dist end do end do else ! Fixed-sized monomers: calculate atom range directly atom_start_i = ( mon_i - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_i = mon_i * sys_geom % atoms_per_monomer atom_start_j = ( mon_j - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_j = mon_j * sys_geom % atoms_per_monomer ! Loop over all atoms in monomer i do iatom = atom_start_i , atom_end_i ! Loop over all atoms in monomer j do jatom = atom_start_j , atom_end_j ! Calculate distance (coordinates are in Bohr) dx = sys_geom % coordinates ( 1 , iatom ) - sys_geom % coordinates ( 1 , jatom ) dy = sys_geom % coordinates ( 2 , iatom ) - sys_geom % coordinates ( 2 , jatom ) dz = sys_geom % coordinates ( 3 , iatom ) - sys_geom % coordinates ( 3 , jatom ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_dist ) min_dist = dist end do end do end if end do end do ! Convert from Bohr to Angstrom distances ( ifrag ) = to_angstrom ( min_dist ) end if end do end subroutine calculate_fragment_distances end module mqc_combinatorics","tags":"","url":"sourcefile/mqc_combinatorics.f90.html"},{"title":"mqc_calculation_keywords.f90 – metalquicha","text":"Calculation keyword types for structured configuration Files dependent on this one sourcefile~~mqc_calculation_keywords.f90~~AfferentGraph sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Calculation keyword types for structured configuration module mqc_calculation_keywords !! Provides structured keyword types for calculation-specific settings !! These types are embedded in driver_config_t to organize keywords by category use pic_types , only : dp implicit none private public :: hessian_keywords_t , aimd_keywords_t , scf_keywords_t type :: hessian_keywords_t !! Hessian calculation keywords real ( dp ) :: displacement = 0.001_dp !! Finite difference displacement (Bohr) real ( dp ) :: temperature = 29 8.15_dp !! Temperature for thermochemistry (K) real ( dp ) :: pressure = 1.0_dp !! Pressure for thermochemistry (atm) end type hessian_keywords_t type :: aimd_keywords_t !! Ab initio molecular dynamics keywords real ( dp ) :: dt = 1.0_dp !! Timestep (femtoseconds) integer :: nsteps = 0 !! Number of MD steps (0 = no AIMD) real ( dp ) :: initial_temperature = 30 0.0_dp !! Initial temperature for velocity init (K) integer :: output_frequency = 1 !! Write output every N steps end type aimd_keywords_t type :: scf_keywords_t !! SCF calculation keywords (placeholder for future use) logical :: use_diis = . true . !! Use DIIS acceleration integer :: max_iterations = 100 !! Maximum SCF iterations real ( dp ) :: convergence_threshold = 1.0e-6_dp !! Convergence threshold for SCF end type scf_keywords_t end module mqc_calculation_keywords","tags":"","url":"sourcefile/mqc_calculation_keywords.f90.html"},{"title":"mqc_cgto.f90 – metalquicha","text":"Data structures for cartesian contracted Gaussian type orbitals (CGTOs) Files dependent on this one sourcefile~~mqc_cgto.f90~~AfferentGraph sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Data structures for cartesian contracted Gaussian type orbitals (CGTOs) module mqc_cgto !! Defines data structures for cartesian contracted Gaussian type orbitals (CGTOs) use pic_types , only : dp implicit none private public :: cgto_type , atomic_basis_type , molecular_basis_type type :: cgto_type !! Contracted Gaussian type orbital (CGTO) data structure integer :: ang_mom !! Angular momentum quantum number (0=s, 1=p, 2=d, etc.) integer :: nfunc !! Number of primitive Gaussians in the contraction real ( dp ), allocatable :: exponents (:) !! Exponents (alpha values) real ( dp ), allocatable :: coefficients (:) !! Contraction coefficients contains procedure :: allocate_arrays => cgto_allocate_arrays procedure :: destroy => cgto_destroy procedure :: num_basis_functions => cgto_num_basis_functions end type cgto_type type :: atomic_basis_type !! Atomic basis set data structure character ( len = :), allocatable :: element !! element symbol type ( cgto_type ), allocatable :: shells (:) !! array of contracted shells integer :: nshells !! number of shells in type contains procedure :: allocate_shells => allocate_basis_shells procedure :: destroy => atomic_basis_destroy procedure :: num_basis_functions => atomic_basis_num_basis_functions end type atomic_basis_type type :: molecular_basis_type !! Molecular basis set data structure (assembled basis) type ( atomic_basis_type ), allocatable :: elements (:) !! array of atomic basis types integer :: nelements !! total number of atoms/elements in a molecule contains procedure :: allocate_elements => basis_set_allocate_elements procedure :: destroy => basis_set_destroy procedure :: num_basis_functions => molecular_basis_num_basis_functions end type molecular_basis_type contains pure subroutine cgto_allocate_arrays ( self , nfunc ) !! Allocate arrays for exponents and coefficients in a CGTO class ( cgto_type ), intent ( inout ) :: self integer , intent ( in ) :: nfunc self % nfunc = nfunc allocate ( self % exponents ( nfunc )) allocate ( self % coefficients ( nfunc )) end subroutine cgto_allocate_arrays pure subroutine cgto_destroy ( self ) !! Clean up allocated memory in a CGTO class ( cgto_type ), intent ( inout ) :: self if ( allocated ( self % exponents )) deallocate ( self % exponents ) if ( allocated ( self % coefficients )) deallocate ( self % coefficients ) self % nfunc = 0 self % ang_mom = 0 end subroutine cgto_destroy pure subroutine allocate_basis_shells ( self , nshells ) !! Allocate array of shells in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nshells self % nshells = nshells allocate ( self % shells ( nshells )) end subroutine allocate_basis_shells pure subroutine atomic_basis_destroy ( self ) !! Clean up allocated memory in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % shells )) then do i = 1 , self % nshells call self % shells ( i )% destroy () end do deallocate ( self % shells ) end if if ( allocated ( self % element )) deallocate ( self % element ) self % nshells = 0 end subroutine atomic_basis_destroy pure subroutine basis_set_allocate_elements ( self , nelements ) !! Allocate array of atomic basis elements in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nelements self % nelements = nelements allocate ( self % elements ( nelements )) end subroutine basis_set_allocate_elements pure subroutine basis_set_destroy ( self ) !! Clean up allocated memory in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % elements )) then do i = 1 , self % nelements call self % elements ( i )% destroy () end do deallocate ( self % elements ) end if self % nelements = 0 end subroutine basis_set_destroy pure function cgto_num_basis_functions ( self ) result ( nbf ) !! Get number of basis functions in a shell (Cartesian) class ( cgto_type ), intent ( in ) :: self integer :: nbf ! Cartesian: (ang_mom+1)*(ang_mom+2)/2 nbf = ( self % ang_mom + 1 ) * ( self % ang_mom + 2 ) / 2 end function cgto_num_basis_functions pure function atomic_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for an atom class ( atomic_basis_type ), intent ( in ) :: self integer :: nbf integer :: ishell nbf = 0 do ishell = 1 , self % nshells nbf = nbf + self % shells ( ishell )% num_basis_functions () end do end function atomic_basis_num_basis_functions pure function molecular_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for the molecule class ( molecular_basis_type ), intent ( in ) :: self integer :: nbf integer :: iatom nbf = 0 do iatom = 1 , self % nelements nbf = nbf + self % elements ( iatom )% num_basis_functions () end do end function molecular_basis_num_basis_functions end module mqc_cgto","tags":"","url":"sourcefile/mqc_cgto.f90.html"},{"title":"mqc_method_types.f90 – metalquicha","text":"Method type constants for quantum chemistry methods Files dependent on this one sourcefile~~mqc_method_types.f90~~AfferentGraph sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Method type constants for quantum chemistry methods module mqc_method_types !! Defines integer constants for quantum chemistry methods to avoid string comparisons !! throughout the codebase. Provides conversion utilities between string !! representations and integer constants. use pic_types , only : int32 implicit none private ! Public constants - Semi-empirical public :: METHOD_TYPE_GFN1 , METHOD_TYPE_GFN2 ! Public constants - SCF methods public :: METHOD_TYPE_HF , METHOD_TYPE_DFT ! Public constants - Multi-reference public :: METHOD_TYPE_MCSCF ! Public constants - Correlation methods public :: METHOD_TYPE_MP2 , METHOD_TYPE_CCSD , METHOD_TYPE_CCSD_T public :: METHOD_TYPE_MP2_F12 , METHOD_TYPE_CCSD_F12 , METHOD_TYPE_CCSD_T_F12 public :: METHOD_TYPE_UNKNOWN ! Public functions public :: method_type_from_string , method_type_to_string ! Method type constants integer ( int32 ), parameter :: METHOD_TYPE_UNKNOWN = 0 ! Semi-empirical (1-9) integer ( int32 ), parameter :: METHOD_TYPE_GFN1 = 1 integer ( int32 ), parameter :: METHOD_TYPE_GFN2 = 2 ! SCF methods (10-19) integer ( int32 ), parameter :: METHOD_TYPE_HF = 10 integer ( int32 ), parameter :: METHOD_TYPE_DFT = 11 ! Multi-reference (20-29) integer ( int32 ), parameter :: METHOD_TYPE_MCSCF = 20 ! Perturbation theory (30-39) integer ( int32 ), parameter :: METHOD_TYPE_MP2 = 30 integer ( int32 ), parameter :: METHOD_TYPE_MP2_F12 = 31 ! Coupled cluster (40-59) integer ( int32 ), parameter :: METHOD_TYPE_CCSD = 40 integer ( int32 ), parameter :: METHOD_TYPE_CCSD_T = 41 !! CCSD(T) integer ( int32 ), parameter :: METHOD_TYPE_CCSD_F12 = 42 integer ( int32 ), parameter :: METHOD_TYPE_CCSD_T_F12 = 43 !! CCSD(T)-F12 contains pure function method_type_from_string ( method_str ) result ( method_type ) !! Convert method type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns METHOD_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: method_str !! Input string (e.g., \"gfn1\", \"gfn2\", \"hf\") integer ( int32 ) :: method_type !! Output integer constant character ( len = len_trim ( method_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) ! Semi-empirical case ( 'gfn1' , 'gfn1-xtb' ) method_type = METHOD_TYPE_GFN1 case ( 'gfn2' , 'gfn2-xtb' ) method_type = METHOD_TYPE_GFN2 ! SCF methods case ( 'hf' , 'rhf' , 'uhf' , 'hartree-fock' ) method_type = METHOD_TYPE_HF case ( 'dft' , 'ks' , 'kohn-sham' ) method_type = METHOD_TYPE_DFT ! Multi-reference case ( 'mcscf' , 'casscf' , 'casci' ) method_type = METHOD_TYPE_MCSCF ! Perturbation theory case ( 'mp2' , 'ri-mp2' , 'df-mp2' , 'scs-mp2' , 'sos-mp2' ) method_type = METHOD_TYPE_MP2 case ( 'mp2-f12' , 'ri-mp2-f12' , 'df-mp2-f12' ) method_type = METHOD_TYPE_MP2_F12 ! Coupled cluster case ( 'ccsd' , 'ri-ccsd' , 'df-ccsd' ) method_type = METHOD_TYPE_CCSD case ( 'ccsd(t)' , 'ri-ccsd(t)' , 'df-ccsd(t)' ) method_type = METHOD_TYPE_CCSD_T case ( 'ccsd-f12' , 'ri-ccsd-f12' ) method_type = METHOD_TYPE_CCSD_F12 case ( 'ccsd(t)-f12' , 'ri-ccsd(t)-f12' ) method_type = METHOD_TYPE_CCSD_T_F12 case default method_type = METHOD_TYPE_UNKNOWN end select end function method_type_from_string pure function method_type_to_string ( method_type ) result ( method_str ) !! Convert method type integer constant to string !! !! Provides human-readable string representation of method type. integer ( int32 ), intent ( in ) :: method_type !! Input integer constant character ( len = :), allocatable :: method_str !! Output string representation select case ( method_type ) ! Semi-empirical case ( METHOD_TYPE_GFN1 ) method_str = \"gfn1\" case ( METHOD_TYPE_GFN2 ) method_str = \"gfn2\" ! SCF methods case ( METHOD_TYPE_HF ) method_str = \"hf\" case ( METHOD_TYPE_DFT ) method_str = \"dft\" ! Multi-reference case ( METHOD_TYPE_MCSCF ) method_str = \"mcscf\" ! Perturbation theory case ( METHOD_TYPE_MP2 ) method_str = \"mp2\" case ( METHOD_TYPE_MP2_F12 ) method_str = \"mp2-f12\" ! Coupled cluster case ( METHOD_TYPE_CCSD ) method_str = \"ccsd\" case ( METHOD_TYPE_CCSD_T ) method_str = \"ccsd(t)\" case ( METHOD_TYPE_CCSD_F12 ) method_str = \"ccsd-f12\" case ( METHOD_TYPE_CCSD_T_F12 ) method_str = \"ccsd(t)-f12\" case default method_str = \"unknown\" end select end function method_type_to_string end module mqc_method_types","tags":"","url":"sourcefile/mqc_method_types.f90.html"},{"title":"mqc_elements.f90 – metalquicha","text":"Periodic table data and element utilities Files dependent on this one sourcefile~~mqc_elements.f90~~AfferentGraph sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Periodic table data and element utilities module mqc_elements !! Provides atomic numbers, element symbols, and atomic masses for the complete !! periodic table (elements 1-118) with conversion functions between representations. use pic_ascii , only : to_upper , to_lower use pic_types , only : dp implicit none private public :: element_symbol_to_number !! Convert element symbol to atomic number public :: element_number_to_symbol !! Convert atomic number to element symbol public :: element_mass !! Get atomic mass by atomic number ! TODO: refactr to use findloc ! Periodic table data as module-level parameters integer , parameter :: n_elements = 118 character ( len = 2 ), parameter :: element_symbols ( n_elements ) = [ character ( len = 2 ) :: & !! Element symbols for the complete periodic table (H through Og) !! Ordered by atomic number from 1 to 118 ! for some reason this is how the formatted formats this (????) 'H' , 'He' , & 'Li' , 'Be' , 'B' , 'C' , 'N' , 'O' , 'F' , 'Ne' , & 'Na' , 'Mg' , 'Al' , 'Si' , 'P' , 'S' , 'Cl' , 'Ar' , & 'K' , 'Ca' , 'Sc' , 'Ti' , 'V' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , & 'Rb' , 'Sr' , 'Y' , 'Zr' , 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , 'In' , 'Sn' , 'Sb' , 'Te' , 'I' , 'Xe' , & 'Cs' , 'Ba' , 'La' , 'Ce' , 'Pr' , 'Nd' , 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , 'Lu' , & 'Hf' , 'Ta' , 'W' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , & 'Fr' , 'Ra' , 'Ac' , 'Th' , 'Pa' , 'U' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' , 'Es' , 'Fm' , 'Md' , 'No' , 'Lr' , & 'Rf' , 'Db' , 'Sg' , 'Bh' , 'Hs' , 'Mt' , 'Ds' , 'Rg' , 'Cn' , 'Nh' , 'Fl' , 'Mc' , 'Lv' , 'Ts' , 'Og' ] real ( dp ), parameter :: element_masses ( n_elements ) = [ & !! Standard atomic masses in atomic mass units (amu) !! Based on IUPAC standard atomic weights, ordered by atomic number ! for some reason this is how the formatted formats this (????) 1.008_dp , 4.0026_dp , & ! H-He 6.94_dp , 9.0122_dp , 1 0.81_dp , 1 2.011_dp , 1 4.007_dp , 1 5.999_dp , 1 8.998_dp , 2 0.180_dp , & ! Li-Ne 2 2.990_dp , 2 4.305_dp , 2 6.982_dp , 2 8.085_dp , 3 0.974_dp , 3 2.06_dp , 3 5.45_dp , 3 9.948_dp , & ! Na-Ar 3 9.098_dp , 4 0.078_dp , 4 4.956_dp , 4 7.867_dp , 5 0.942_dp , 5 1.996_dp , 5 4.938_dp , 5 5.845_dp , & ! K-Fe 5 8.933_dp , 5 8.693_dp , 6 3.546_dp , 6 5.38_dp , 6 9.723_dp , 7 2.630_dp , 7 4.922_dp , 7 8.971_dp , & ! Co-Se 7 9.904_dp , 8 3.798_dp , & ! Br-Kr 8 5.468_dp , 8 7.62_dp , 8 8.906_dp , 9 1.224_dp , 9 2.906_dp , 9 5.95_dp , 9 8.0_dp , 10 1.07_dp , & ! Rb-Ru 10 2.91_dp , 10 6.42_dp , 10 7.87_dp , 11 2.41_dp , 11 4.82_dp , 11 8.71_dp , 12 1.76_dp , 12 7.60_dp , & ! Rh-Te 12 6.90_dp , 13 1.29_dp , & ! I-Xe 13 2.91_dp , 13 7.33_dp , 13 8.91_dp , 14 0.12_dp , 14 0.91_dp , 14 4.24_dp , 14 5.0_dp , 15 0.36_dp , & ! Cs-Sm 15 1.96_dp , 15 7.25_dp , 15 8.93_dp , 16 2.50_dp , 16 4.93_dp , 16 7.26_dp , 16 8.93_dp , 17 3.05_dp , & ! Eu-Yb 17 4.97_dp , 17 8.49_dp , 18 0.95_dp , 18 3.84_dp , 18 6.21_dp , 19 0.23_dp , 19 2.22_dp , 19 5.08_dp , & ! Lu-Pt 19 6.97_dp , 20 0.59_dp , 20 4.38_dp , 20 7.2_dp , 20 8.98_dp , 20 9.0_dp , 21 0.0_dp , 22 2.0_dp , & ! Au-Rn 22 3.0_dp , 22 6.0_dp , 22 7.0_dp , 23 2.04_dp , 23 1.04_dp , 23 8.03_dp , 23 7.0_dp , 24 4.0_dp , & ! Fr-Pu 24 3.0_dp , 24 7.0_dp , 24 7.0_dp , 25 1.0_dp , 25 2.0_dp , 25 7.0_dp , 25 8.0_dp , 25 9.0_dp , & ! Am-No 26 2.0_dp , 26 7.0_dp , 26 8.0_dp , 27 1.0_dp , 27 2.0_dp , 27 0.0_dp , 27 6.0_dp , 28 1.0_dp , & ! Lr-Ds 28 0.0_dp , 28 5.0_dp , 28 4.0_dp , 28 9.0_dp , 28 8.0_dp , 29 3.0_dp , 29 4.0_dp , 29 4.0_dp ] ! Rg-Og contains pure function element_symbol_to_number ( symbol ) result ( atomic_number ) !! Convert element symbol to atomic number !! Covers the complete periodic table (elements 1-118) character ( len =* ), intent ( in ) :: symbol integer :: atomic_number character ( len = 2 ) :: sym ! Normalize: uppercase first letter, lowercase second sym = adjustl ( symbol ) if ( len_trim ( sym ) >= 1 ) sym ( 1 : 1 ) = to_upper ( sym ( 1 : 1 )) if ( len_trim ( sym ) >= 2 ) sym ( 2 : 2 ) = to_lower ( sym ( 2 : 2 )) ! Search for symbol in table atomic_number = findloc ( element_symbols , sym , dim = 1 ) end function element_symbol_to_number pure function element_number_to_symbol ( atomic_number ) result ( symbol ) !! Convert atomic number to element symbol !! Covers the complete periodic table (elements 1-118) integer , intent ( in ) :: atomic_number character ( len = 2 ) :: symbol select case ( atomic_number ) case ( 1 : 118 ) symbol = element_symbols ( atomic_number ) case default symbol = 'Xx' ! Unknown end select end function element_number_to_symbol pure function element_mass ( atomic_number ) result ( mass ) !! Return atomic mass in atomic mass units (amu) for a given atomic number !! Uses standard atomic weights from IUPAC integer , intent ( in ) :: atomic_number real ( dp ) :: mass select case ( atomic_number ) case ( 1 : 118 ) mass = element_masses ( atomic_number ) case default mass = 0.0_dp ! Unknown element end select end function element_mass end module mqc_elements","tags":"","url":"sourcefile/mqc_elements.f90.html"},{"title":"mqc_json.f90 – metalquicha","text":"JSON output utilities for multi-molecule calculations This file depends on sourcefile~~mqc_json.f90~~EfferentGraph sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_json.f90~~AfferentGraph sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! JSON output utilities for multi-molecule calculations module mqc_json use pic_logger , only : logger => global_logger use pic_io , only : to_char implicit none private public :: merge_multi_molecule_json contains subroutine merge_multi_molecule_json ( individual_files , nmol ) !! Merge individual molecule JSON files into a single combined file use mqc_io_helpers , only : get_molecule_name character ( len = 256 ), intent ( in ) :: individual_files (:) integer , intent ( in ) :: nmol integer :: imol , unit_in , unit_out , io_stat , slash_pos , dot_pos character ( len = 10000 ) :: line character ( len = 256 ) :: output_file , basename logical :: file_exists ! Determine combined output filename from first individual file ! Example: \"output_multi_structure_molecule_1.json\" -> \"output_multi_structure.json\" basename = individual_files ( 1 ) slash_pos = index ( basename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = basename ( slash_pos + 1 :) end if ! Remove \"_molecule_1\" or similar suffix dot_pos = index ( basename , '_molecule_' ) if ( dot_pos > 0 ) then output_file = basename ( 1 : dot_pos - 1 ) // \".json\" else output_file = \"output_combined.json\" end if ! Open combined output file open ( newunit = unit_out , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Merging \" // to_char ( nmol ) // \" molecule JSON files into \" // trim ( output_file )) ! Write opening brace and top-level key (basename without \"output_\" and \".json\") dot_pos = index ( output_file , '.json' ) if ( dot_pos > 0 ) then basename = output_file ( 8 : dot_pos - 1 ) ! Skip \"output_\" else basename = \"combined\" end if write ( unit_out , '(a)' ) \"{\" write ( unit_out , '(a)' ) '  \"' // trim ( basename ) // '\": {' ! Process each individual JSON file do imol = 1 , nmol inquire ( file = trim ( individual_files ( imol )), exist = file_exists ) if (. not . file_exists ) cycle open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) cycle ! Read all lines from the individual JSON file call read_json_content ( unit_in , imol , unit_out , individual_files ( imol )) close ( unit_in ) ! Delete individual file open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'readwrite' ) close ( unit_in , status = 'delete' ) end do ! Close last molecule write ( unit_out , '(a)' ) '    }' ! Close top-level key and file write ( unit_out , '(a)' ) '  }' write ( unit_out , '(a)' ) '}' close ( unit_out ) call logger % info ( \"Combined JSON written to \" // trim ( output_file )) end subroutine merge_multi_molecule_json subroutine read_json_content ( unit_in , mol_index , unit_out , filename ) !! Read and write JSON content from an individual molecule file !! Properly handles nested structures from fragmented calculations use mqc_io_helpers , only : get_molecule_name integer , intent ( in ) :: unit_in , mol_index , unit_out character ( len =* ), intent ( in ) :: filename character ( len = 10000 ), allocatable :: all_lines (:) character ( len = 10000 ) :: line integer :: io_stat , nlines , i ! Read all lines into memory allocate ( all_lines ( 1000 )) ! Reasonable size for most JSON files nlines = 0 do read ( unit_in , '(a)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit nlines = nlines + 1 if ( nlines > size ( all_lines )) then ! Reallocate if needed call logger % error ( \"JSON file too large: \" // trim ( filename )) return end if all_lines ( nlines ) = line end do ! Lines structure: ! 1: \"{\" ! 2: '  \"molecule_name\": {' ! 3..(n-2): content ! n-1: \"  }\" ! n: \"}\" if ( nlines < 3 ) then call logger % error ( \"Invalid JSON structure: \" // trim ( filename )) return end if ! Write molecule key (extracted from filename) if ( mol_index > 1 ) write ( unit_out , '(a)' ) '    },' write ( unit_out , '(a)' ) '    \"' // trim ( get_molecule_name ( filename )) // '\" : {' ! Write all content lines (from line 3 to line n-2) do i = 3 , nlines - 2 write ( unit_out , '(a)' ) '  ' // trim ( all_lines ( i )) ! Add 2 spaces for proper indentation end do deallocate ( all_lines ) end subroutine read_json_content end module mqc_json","tags":"","url":"sourcefile/mqc_json.f90.html"},{"title":"mqc_physical_fragment.f90 – metalquicha","text":"This file contains all routines and types to represent a “physical” fragment or molecule\ni.e., with atomic coordinates, element types, electronic properties, etc. This file depends on sourcefile~~mqc_physical_fragment.f90~~EfferentGraph sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_physical_fragment.f90~~AfferentGraph sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_json_writer.f90 mqc_json_writer.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json_writer.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_json_writer.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This file contains all routines and types to represent a \"physical\" fragment or molecule !! i.e., with atomic coordinates, element types, electronic properties, etc. module mqc_physical_fragment !! Physical molecular fragment representation and geometry handling !! !! Provides data structures and utilities for managing molecular fragments !! with atomic coordinates, electronic properties, and geometric operations. use pic_types , only : dp , default_int use mqc_geometry , only : geometry_type use mqc_xyz_reader , only : read_xyz_file use mqc_elements , only : element_symbol_to_number , element_number_to_symbol , element_mass use mqc_cgto , only : molecular_basis_type use mqc_config_parser , only : bond_t use mqc_error , only : error_t , ERROR_VALIDATION use mqc_physical_constants , only : BOHR_TO_ANGSTROM , ANGSTROM_TO_BOHR implicit none private public :: physical_fragment_t !! Single molecular fragment type public :: system_geometry_t !! Complete system geometry type public :: initialize_system_geometry !! System geometry initialization public :: build_fragment_from_indices !! Extract fragment from system public :: build_fragment_from_atom_list !! Build fragment from explicit atom indices (for intersections) public :: check_duplicate_atoms !! Validate fragment has no overlapping atoms ! TODO: in theory there should be a nice way to redistribute for a general matrix of any shape, need to think about this! public :: redistribute_cap_gradients !! Redistribute hydrogen cap gradients to original atoms public :: redistribute_cap_hessian !! Redistribute hydrogen cap Hessian to original atoms public :: redistribute_cap_dipole_derivatives !! Redistribute hydrogen cap dipole derivatives to original atoms public :: to_angstrom , to_bohr !! Unit conversion utilities public :: calculate_monomer_distance !! Calculate minimal distance between monomers in a fragment type :: physical_fragment_t !! Physical molecular fragment with atomic coordinates and properties !! !! Represents a molecular fragment containing atomic positions, element types, !! electronic structure information, and basis set data for quantum calculations. integer :: n_atoms !! Number of atoms in this fragment integer , allocatable :: element_numbers (:) !! Atomic numbers (Z values) real ( dp ), allocatable :: coordinates (:, :) !! Cartesian coordinates (3, n_atoms) in Bohr ! Electronic structure properties integer :: charge = 0 !! Net molecular charge (electrons) integer :: multiplicity = 1 !! Spin multiplicity (2S+1) integer :: nelec = 0 !! Total number of electrons ! Hydrogen capping for broken bonds integer :: n_caps = 0 !! Number of hydrogen caps added (always at end of atom list) integer , allocatable :: cap_replaces_atom (:) !! Original atom index that each cap replaces (size: n_caps) ! Gradient redistribution support integer , allocatable :: local_to_global (:) !! Map fragment atom index to system atom index (size: n_atoms - n_caps) ! Fragment distance (for screening) real ( dp ) :: distance = 0.0_dp !! Minimal atomic distance between monomers in fragment (Angstrom, 0 for monomers) ! Quantum chemistry basis set type ( molecular_basis_type ), allocatable :: basis !! Gaussian basis functions contains procedure :: destroy => fragment_destroy !! Memory cleanup procedure :: compute_nelec => fragment_compute_nelec !! Calculate electron count procedure :: set_basis => fragment_set_basis !! Assign basis set end type physical_fragment_t type :: system_geometry_t !! Complete molecular system geometry for fragment-based calculations !! !! Contains the full atomic structure of a molecular cluster organized !! by monomers for efficient fragment generation and MBE calculations. integer :: n_monomers !! Number of monomer units in system integer :: atoms_per_monomer !! Atoms in each monomer (0 if variable-sized) integer :: total_atoms !! Total number of atoms integer , allocatable :: element_numbers (:) !! Atomic numbers for all atoms real ( dp ), allocatable :: coordinates (:, :) !! All coordinates (3, total_atoms) in Bohr ! Electronic structure properties integer :: charge !! Net molecular charge (electrons) integer :: multiplicity !! Spin multiplicity (2S+1) ! For variable-sized fragments (explicit fragment definitions) integer , allocatable :: fragment_sizes (:) !! Number of atoms in each fragment (n_monomers) integer , allocatable :: fragment_atoms (:, :) !! Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer , allocatable :: fragment_charges (:) !! Charge for each fragment (n_monomers) integer , allocatable :: fragment_multiplicities (:) !! Multiplicity for each fragment (n_monomers) contains procedure :: destroy => system_destroy !! Memory cleanup end type system_geometry_t contains pure elemental function to_angstrom ( bohr_value ) result ( angstrom_value ) !! Convert coordinate from Bohr to Angstrom real ( dp ), intent ( in ) :: bohr_value real ( dp ) :: angstrom_value angstrom_value = bohr_value * BOHR_TO_ANGSTROM end function to_angstrom pure elemental function to_bohr ( angstrom_value ) result ( bohr_value ) !! Convert coordinate from Angstrom to Bohr real ( dp ), intent ( in ) :: angstrom_value real ( dp ) :: bohr_value bohr_value = angstrom_value * ANGSTROM_TO_BOHR end function to_bohr subroutine initialize_system_geometry ( full_geom_file , monomer_file , sys_geom , error ) !! Read full geometry and monomer template, initialize system_geometry_t character ( len =* ), intent ( in ) :: full_geom_file , monomer_file type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error type ( geometry_type ) :: full_geom , monomer_geom integer :: i call read_xyz_file ( full_geom_file , full_geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:initialize_system_geometry\" ) return end if ! Read monomer template ! this will be changed once we have a proper input file parsing call read_xyz_file ( monomer_file , monomer_geom , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:initialize_system_geometry\" ) call full_geom % destroy () return end if ! Validate that full geometry is a multiple of monomer size sys_geom % atoms_per_monomer = monomer_geom % natoms sys_geom % total_atoms = full_geom % natoms if ( mod ( sys_geom % total_atoms , sys_geom % atoms_per_monomer ) /= 0 ) then call error % set ( ERROR_VALIDATION , \"Full geometry atoms not a multiple of monomer atoms\" ) call full_geom % destroy () call monomer_geom % destroy () return end if sys_geom % n_monomers = sys_geom % total_atoms / sys_geom % atoms_per_monomer ! TODO JORGE: this can be a sys_geom%allocate() allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( full_geom % elements ( i )) end do ! Store coordinates in Bohr (convert from Angstroms) ! TODO JORGE: need a way to handle units sys_geom % coordinates = to_bohr ( full_geom % coords ) call full_geom % destroy () call monomer_geom % destroy () end subroutine initialize_system_geometry subroutine count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) !! Count how many hydrogen caps are needed for a fragment !! A cap is needed when exactly one atom of a broken bond is in the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ), optional :: bonds (:) integer , intent ( out ) :: n_caps integer :: ibond logical :: atom_i_in_frag , atom_j_in_frag n_caps = 0 if (. not . present ( bonds )) return do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle ! Check if exactly one atom of this bond is in the fragment atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) ! Add cap only if one atom in fragment, other not (XOR condition) if (( atom_i_in_frag . and . . not . atom_j_in_frag ) . or . & (. not . atom_i_in_frag . and . atom_j_in_frag )) then n_caps = n_caps + 1 end if end do end subroutine count_hydrogen_caps subroutine add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , base_atom_count ) !! Add hydrogen caps to fragment for broken bonds !! Caps are placed at the position of the atom outside the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ) :: bonds (:) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( physical_fragment_t ), intent ( inout ) :: fragment integer , intent ( in ) :: base_atom_count !! Number of non-cap atoms integer :: ibond , cap_idx logical :: atom_i_in_frag , atom_j_in_frag if ( fragment % n_caps == 0 ) return cap_idx = 0 do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) if ( atom_i_in_frag . and . . not . atom_j_in_frag ) then ! atom_i is in fragment, atom_j is not → cap at position of atom_j cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_j (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_j + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_j else if ( atom_j_in_frag . and . . not . atom_i_in_frag ) then ! atom_j is in fragment, atom_i is not → cap at position of atom_i cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_i (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_i + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_i end if end do end subroutine add_hydrogen_caps subroutine build_fragment_from_indices ( sys_geom , monomer_indices , fragment , error , bonds ) !! Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds !! !! Extracts atoms from specified monomers and adds hydrogen caps where bonds are broken. !! Caps are always added at the end of the atom list. !! Supports both fixed-size (identical monomers) and variable-sized fragments. !! !! Example: monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5 !!          If connectivity shows broken bonds, hydrogens are capped at positions of missing atoms type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) type ( physical_fragment_t ), intent ( out ) :: fragment type ( error_t ), intent ( out ) :: error type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity information for capping integer :: n_monomers_in_frag , atoms_per_monomer , n_atoms_no_caps integer :: i , j , mono_idx , atom_start , atom_end , frag_atom_idx integer :: atom_i , atom_j , n_caps integer , allocatable :: atoms_in_fragment (:) !! List of all atom indices in this fragment integer :: iatom , atom_global_idx logical :: use_explicit_fragments n_monomers_in_frag = size ( monomer_indices ) ! Determine if we're using explicit fragment definitions or regular monomer-based use_explicit_fragments = allocated ( sys_geom % fragment_atoms ) if ( use_explicit_fragments ) then ! Variable-sized fragments: count total atoms from fragment definitions n_atoms_no_caps = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) n_atoms_no_caps = n_atoms_no_caps + sys_geom % fragment_sizes ( mono_idx ) end do ! Build list of atom indices (0-indexed) from explicit fragment definitions allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) iatom = iatom + 1 atoms_in_fragment ( iatom ) = sys_geom % fragment_atoms ( j , mono_idx ) end do end do else ! Fixed-size monomers: use atoms_per_monomer atoms_per_monomer = sys_geom % atoms_per_monomer n_atoms_no_caps = n_monomers_in_frag * atoms_per_monomer ! Build list of atom indices in this fragment (0-indexed to match bond indices) allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer do atom_i = 0 , atoms_per_monomer - 1 iatom = iatom + 1 atoms_in_fragment ( iatom ) = atom_start + atom_i end do end do end if ! Count how many caps we need call count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms_no_caps + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms_no_caps )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping frag_atom_idx = 0 if ( use_explicit_fragments ) then ! Variable-sized: copy atoms based on explicit fragment definitions do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) frag_atom_idx = frag_atom_idx + 1 ! fragment_atoms is 0-indexed, so +1 for Fortran arrays atom_global_idx = sys_geom % fragment_atoms ( j , mono_idx ) + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( frag_atom_idx ) = atom_global_idx ! Store 1-indexed global position end do end do else ! Fixed-size: use atoms_per_monomer do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer + 1 atom_end = mono_idx * atoms_per_monomer ! Copy coordinates and elements do atom_i = atom_start , atom_end frag_atom_idx = frag_atom_idx + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_i ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_i ) fragment % local_to_global ( frag_atom_idx ) = atom_i ! Store 1-indexed global position end do end do end if ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , n_atoms_no_caps ) end if ! Set electronic structure properties from system geometry if ( use_explicit_fragments . and . allocated ( sys_geom % fragment_charges ) . and . & allocated ( sys_geom % fragment_multiplicities )) then ! Explicit fragments: sum charges and multiplicities from constituent fragments fragment % charge = 0 fragment % multiplicity = 1 ! Start with singlet assumption do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) fragment % charge = fragment % charge + sys_geom % fragment_charges ( mono_idx ) end do ! For single fragment, use its specific multiplicity if ( n_monomers_in_frag == 1 ) then fragment % multiplicity = sys_geom % fragment_multiplicities ( monomer_indices ( 1 )) else ! For multi-fragment composites, multiplicity needs careful treatment ! For now, default to system multiplicity (this may need refinement) fragment % multiplicity = sys_geom % multiplicity end if else ! Fixed-size monomers: use system defaults fragment % charge = sys_geom % charge fragment % multiplicity = sys_geom % multiplicity end if call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:build_fragment_from_indices\" ) return end if ! Calculate minimal distance between monomers in this fragment fragment % distance = calculate_monomer_distance ( sys_geom , monomer_indices ) deallocate ( atoms_in_fragment ) end subroutine build_fragment_from_indices subroutine build_fragment_from_atom_list ( sys_geom , atom_indices , n_atoms , fragment , error , bonds ) !! Build a fragment from explicit atom list (for GMBE intersection fragments) !! !! Similar to build_fragment_from_indices but takes atom indices directly instead of !! monomer indices. Used for building intersection fragments in GMBE calculations. !! Intersection fragments are ALWAYS NEUTRAL (charge=0, multiplicity=1). !! !! Example: atom_indices = [3, 4, 5] builds fragment from atoms 3, 4, 5 of the system type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: atom_indices (:) !! 0-indexed atom indices integer , intent ( in ) :: n_atoms !! Number of atoms in list type ( physical_fragment_t ), intent ( out ) :: fragment type ( error_t ), intent ( out ) :: error type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity for capping integer :: i , frag_atom_idx , atom_global_idx integer :: n_caps ! Count how many caps we need call count_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping (atom_indices are 0-indexed, add 1 for Fortran arrays) do i = 1 , n_atoms atom_global_idx = atom_indices ( i ) + 1 ! Convert to 1-indexed fragment % element_numbers ( i ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, i ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( i ) = atom_global_idx ! Store 1-indexed global position end do ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , sys_geom , fragment , n_atoms ) end if ! Intersection fragments are ALWAYS NEUTRAL ! Rationale: For polypeptides, intersections are backbone atoms; ! charged side chains are in non-overlapping regions fragment % charge = 0 fragment % multiplicity = 1 call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment , error ) if ( error % has_error ()) then call error % add_context ( \"mqc_physical_fragment:build_fragment_from_atom_list\" ) return end if end subroutine build_fragment_from_atom_list subroutine redistribute_cap_gradients ( fragment , fragment_gradient , system_gradient ) !! Redistribute hydrogen cap gradients to original atoms !! !! This subroutine handles gradient redistribution for fragments with hydrogen caps. !! Hydrogen caps are virtual atoms added at broken bonds - their gradients represent !! forces at the bond breakpoint and must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate gradient to system using local_to_global mapping !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap gradient to the original atom it replaces (from cap_replaces_atom) !! !! Example: !!   Fragment: [C, C, H_cap] where H_cap replaces atom 5 in system !!   Fragment gradient: [(3,1), (3,2), (3,3)] !!   - Atoms 1,2: accumulate to system using local_to_global !!   - Atom 3 (cap): add gradient to system atom 5 (cap_replaces_atom(1) + 1) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_gradient (:, :) !! (3, n_atoms_fragment) real ( dp ), intent ( inout ) :: system_gradient (:, :) !! (3, n_atoms_system) integer :: i , local_idx , global_idx integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate gradients for real atoms using local→global mapping do i = 1 , n_real_atoms global_idx = fragment % local_to_global ( i ) system_gradient (:, global_idx ) = system_gradient (:, global_idx ) + fragment_gradient (:, i ) end do ! Redistribute cap gradients to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap ! cap_replaces_atom is 0-indexed, add 1 for Fortran arrays global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Add cap gradient to the atom it replaces system_gradient (:, global_original_idx ) = system_gradient (:, global_original_idx ) + & fragment_gradient (:, local_cap_idx ) end do end if end subroutine redistribute_cap_gradients subroutine redistribute_cap_hessian ( fragment , fragment_hessian , system_hessian ) !! Redistribute hydrogen cap Hessian to original atoms !! !! This subroutine handles Hessian redistribution for fragments with hydrogen caps. !! The Hessian is a rank-2 tensor (3N × 3N) representing second derivatives of energy !! with respect to atomic coordinates. Similar to gradient redistribution, cap contributions !! must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate Hessian blocks to system using local_to_global mapping for both dimensions !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap Hessian blocks (row and column) to the original atom it replaces !! !! Note: Hessian is stored as a flattened 2D array (3*n_atoms, 3*n_atoms) !!       where rows and columns are grouped by atoms (x,y,z for atom 1, then x,y,z for atom 2, etc.) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_hessian (:, :) !! (3*n_atoms_fragment, 3*n_atoms_fragment) real ( dp ), intent ( inout ) :: system_hessian (:, :) !! (3*n_atoms_system, 3*n_atoms_system) integer :: i , j , local_i , local_j , global_i , global_j integer :: icart , jcart integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms integer :: i_cap_2 , local_cap_idx_2 , global_original_idx_2 n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate Hessian blocks for real atoms using local→global mapping ! Both row (i) and column (j) dimensions need mapping do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) ! Copy 3×3 block for atom pair (i,j) do icart = 0 , 2 ! x, y, z for atom i do jcart = 0 , 2 ! x, y, z for atom j system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do end do ! Redistribute cap Hessian blocks to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Cap rows: redistribute to original atom (cap derivatives w.r.t. all other atoms) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do ! Cap columns: redistribute to original atom (all other atoms' derivatives w.r.t. cap) do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( local_cap_idx - 1 ) + jcart + 1 ) end do end do end do ! Cap-cap blocks: redistribute to original atom diagonal block do i_cap_2 = 1 , fragment % n_caps local_cap_idx_2 = n_real_atoms + i_cap_2 global_original_idx_2 = fragment % cap_replaces_atom ( i_cap_2 ) + 1 do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( local_cap_idx_2 - 1 ) + jcart + 1 ) end do end do end do end do end if end subroutine redistribute_cap_hessian subroutine redistribute_cap_dipole_derivatives ( fragment , fragment_dipole_derivs , system_dipole_derivs ) !! Redistribute hydrogen cap dipole derivatives to original atoms !! !! Dipole derivatives have shape (3, 3*N_atoms) where each column corresponds to !! the derivative of the 3 dipole components w.r.t. one Cartesian coordinate. !! The mapping is similar to the column dimension of the Hessian. !! !! Algorithm: !!   1. For real atoms: accumulate to system using local_to_global mapping !!   2. For hydrogen caps: add to the original atom the cap replaces type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_dipole_derivs (:, :) !! (3, 3*n_atoms_fragment) real ( dp ), intent ( inout ) :: system_dipole_derivs (:, :) !! (3, 3*n_atoms_system) integer :: i , local_i , global_i , icart integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate dipole derivative columns for real atoms do i = 1 , n_real_atoms local_i = i global_i = fragment % local_to_global ( local_i ) if ( global_i <= 0 ) cycle do icart = 1 , 3 system_dipole_derivs (:, ( global_i - 1 ) * 3 + icart ) = & system_dipole_derivs (:, ( global_i - 1 ) * 3 + icart ) + & fragment_dipole_derivs (:, ( local_i - 1 ) * 3 + icart ) end do end do ! Redistribute cap contributions to their original atoms if ( fragment % n_caps > 0 . and . allocated ( fragment % cap_replaces_atom )) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap ! cap_replaces_atom is 0-indexed, add 1 for Fortran arrays global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 do icart = 1 , 3 system_dipole_derivs (:, ( global_original_idx - 1 ) * 3 + icart ) = & system_dipole_derivs (:, ( global_original_idx - 1 ) * 3 + icart ) + & fragment_dipole_derivs (:, ( local_cap_idx - 1 ) * 3 + icart ) end do end do end if end subroutine redistribute_cap_dipole_derivatives subroutine check_duplicate_atoms ( fragment , error ) !! Validate that fragment has no spatially overlapping atoms !! Checks if any two atoms are too close together (< 0.01 Bohr) !! This catches bugs in geometry construction or fragment building use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( physical_fragment_t ), intent ( in ) :: fragment type ( error_t ), intent ( out ) :: error integer :: i , j , n_atoms real ( dp ) :: distance , dx , dy , dz real ( dp ), parameter :: MIN_ATOM_DISTANCE = 0.01_dp !! Bohr - atoms closer than this are overlapping ! Only check non-cap atoms (caps can be close to replaced atoms) n_atoms = fragment % n_atoms - fragment % n_caps if ( n_atoms < 2 ) return do i = 1 , n_atoms - 1 do j = i + 1 , n_atoms dx = fragment % coordinates ( 1 , i ) - fragment % coordinates ( 1 , j ) dy = fragment % coordinates ( 2 , i ) - fragment % coordinates ( 2 , j ) dz = fragment % coordinates ( 3 , i ) - fragment % coordinates ( 3 , j ) distance = sqrt ( dx * dx + dy * dy + dz * dz ) if ( distance < MIN_ATOM_DISTANCE ) then ! Build detailed error message call error % set ( ERROR_VALIDATION , & \"Fragment contains overlapping atoms \" // to_char ( i ) // \" and \" // to_char ( j ) // & \" (distance: \" // to_char ( distance ) // \" Bohr). \" // & \"This indicates bad input geometry or a bug in fragment construction.\" ) ! Log detailed information for debugging call logger % error ( \"ERROR: Fragment contains overlapping atoms!\" ) call logger % error ( \"  Atoms \" // to_char ( i ) // \" and \" // to_char ( j ) // \" are too close together\" ) call logger % error ( \"  Distance: \" // to_char ( distance ) // \" Bohr (\" // & to_char ( distance * 0.529177_dp ) // \" Angstrom)\" ) call logger % error ( \"  Atom \" // to_char ( i ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( i )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , i )) // \", \" // & to_char ( fragment % coordinates ( 2 , i )) // \", \" // & to_char ( fragment % coordinates ( 3 , i )) // \") Bohr\" ) call logger % error ( \"  Atom \" // to_char ( j ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( j )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , j )) // \", \" // & to_char ( fragment % coordinates ( 2 , j )) // \", \" // & to_char ( fragment % coordinates ( 3 , j )) // \") Bohr\" ) return end if end do end do end subroutine check_duplicate_atoms subroutine fragment_destroy ( this ) !! Clean up allocated memory in physical_fragment_t class ( physical_fragment_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % cap_replaces_atom )) deallocate ( this % cap_replaces_atom ) if ( allocated ( this % local_to_global )) deallocate ( this % local_to_global ) if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if this % n_atoms = 0 this % charge = 0 this % multiplicity = 1 this % nelec = 0 this % n_caps = 0 end subroutine fragment_destroy subroutine fragment_compute_nelec ( this ) !! Compute number of electrons from atomic numbers and charge class ( physical_fragment_t ), intent ( inout ) :: this integer :: nuclear_charge nuclear_charge = sum ( this % element_numbers ) this % nelec = nuclear_charge - this % charge end subroutine fragment_compute_nelec subroutine fragment_set_basis ( this , basis ) !! Set the basis set for this fragment class ( physical_fragment_t ), intent ( inout ) :: this type ( molecular_basis_type ), intent ( in ) :: basis if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if allocate ( this % basis ) this % basis = basis end subroutine fragment_set_basis subroutine system_destroy ( this ) !! Clean up allocated memory in system_geometry_t class ( system_geometry_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % fragment_sizes )) deallocate ( this % fragment_sizes ) if ( allocated ( this % fragment_atoms )) deallocate ( this % fragment_atoms ) if ( allocated ( this % fragment_charges )) deallocate ( this % fragment_charges ) if ( allocated ( this % fragment_multiplicities )) deallocate ( this % fragment_multiplicities ) this % n_monomers = 0 this % atoms_per_monomer = 0 this % total_atoms = 0 end subroutine system_destroy pure function calculate_monomer_distance ( sys_geom , monomer_indices ) result ( min_distance ) !! Calculate minimal atomic distance between monomers in a fragment !! For single monomer (size 1), returns 0.0 !! For multi-monomer fragments, returns minimal distance between atoms in different monomers !! Result is in Angstrom type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) real ( dp ) :: min_distance integer :: n_monomers , i , j , iatom , jatom integer :: mon_i , mon_j integer :: atom_start_i , atom_end_i , atom_start_j , atom_end_j real ( dp ) :: dist , dx , dy , dz logical :: is_variable_size n_monomers = size ( monomer_indices ) ! Monomers have distance 0 if ( n_monomers == 1 ) then min_distance = 0.0_dp return end if ! Check if we have variable-sized fragments is_variable_size = allocated ( sys_geom % fragment_sizes ) ! Initialize with huge value min_distance = huge ( 1.0_dp ) ! Loop over all pairs of monomers do i = 1 , n_monomers - 1 mon_i = monomer_indices ( i ) do j = i + 1 , n_monomers mon_j = monomer_indices ( j ) if ( is_variable_size ) then ! Variable-sized fragments do iatom = 1 , sys_geom % fragment_sizes ( mon_i ) atom_start_i = sys_geom % fragment_atoms ( iatom , mon_i ) + 1 ! Convert to 1-indexed do jatom = 1 , sys_geom % fragment_sizes ( mon_j ) atom_start_j = sys_geom % fragment_atoms ( jatom , mon_j ) + 1 ! Convert to 1-indexed ! Calculate distance (coordinates in Bohr) dx = sys_geom % coordinates ( 1 , atom_start_i ) - sys_geom % coordinates ( 1 , atom_start_j ) dy = sys_geom % coordinates ( 2 , atom_start_i ) - sys_geom % coordinates ( 2 , atom_start_j ) dz = sys_geom % coordinates ( 3 , atom_start_i ) - sys_geom % coordinates ( 3 , atom_start_j ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_distance ) min_distance = dist end do end do else ! Fixed-sized monomers atom_start_i = ( mon_i - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_i = mon_i * sys_geom % atoms_per_monomer atom_start_j = ( mon_j - 1 ) * sys_geom % atoms_per_monomer + 1 atom_end_j = mon_j * sys_geom % atoms_per_monomer ! Loop over all atom pairs do iatom = atom_start_i , atom_end_i do jatom = atom_start_j , atom_end_j ! Calculate distance (coordinates in Bohr) dx = sys_geom % coordinates ( 1 , iatom ) - sys_geom % coordinates ( 1 , jatom ) dy = sys_geom % coordinates ( 2 , iatom ) - sys_geom % coordinates ( 2 , jatom ) dz = sys_geom % coordinates ( 3 , iatom ) - sys_geom % coordinates ( 3 , jatom ) dist = sqrt ( dx * dx + dy * dy + dz * dz ) if ( dist < min_distance ) min_distance = dist end do end do end if end do end do ! Convert from Bohr to Angstrom min_distance = to_angstrom ( min_distance ) end function calculate_monomer_distance end module mqc_physical_fragment","tags":"","url":"sourcefile/mqc_physical_fragment.f90.html"},{"title":"mqc_serial_fragment_processor.f90 – metalquicha","text":"This file depends on sourcefile~~mqc_serial_fragment_processor.f90~~EfferentGraph sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_error.f90 sourcefile~mqc_json_output_types.f90 mqc_json_output_types.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_json_output_types.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_config.f90 mqc_method_config.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_calculation_keywords.f90 mqc_calculation_keywords.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_calculation_keywords.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_error.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_json_output_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_program_limits.f90 mqc_program_limits.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_program_limits.f90 sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_config.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_config.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_hf.f90 sourcefile~mqc_method_mcscf.f90 mqc_method_mcscf.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_mcscf.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_mpi_comms.f90 mqc_mpi_comms.f90 sourcefile~mqc_resources.f90->sourcefile~mqc_mpi_comms.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_mcscf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_error.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_fragment_lookup.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( mqc_mbe_fragment_distribution_scheme ) mqc_serial_fragment_processor implicit none contains module subroutine serial_fragment_processor ( total_fragments , polymers , max_level , & sys_geom , method_config , calc_type , bonds , json_data ) !! Process all fragments serially in single-rank mode !! This is used when running with only 1 MPI rank use mqc_error , only : error_t use mqc_result_types , only : mbe_result_t use mqc_json_output_types , only : json_output_data_t integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: polymers (:, :), max_level type ( system_geometry_t ), intent ( in ) :: sys_geom type ( method_config_t ), intent ( in ) :: method_config !! Method configuration integer ( int32 ), intent ( in ) :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( json_output_data_t ), intent ( out ), optional :: json_data !! JSON output data integer ( int64 ) :: frag_idx integer :: fragment_size , current_log_level , iatom integer , allocatable :: fragment_indices (:) type ( calculation_result_t ), allocatable :: results (:) type ( mbe_result_t ) :: mbe_result type ( physical_fragment_t ) :: phys_frag type ( timer_type ) :: coord_timer integer ( int32 ) :: calc_type_local type ( error_t ) :: error calc_type_local = calc_type call logger % info ( \"Processing \" // to_char ( total_fragments ) // \" fragments serially...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type_local )) allocate ( results ( total_fragments )) call omp_set_num_threads ( 1 ) call coord_timer % start () do frag_idx = 1_int64 , total_fragments fragment_size = count ( polymers ( frag_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( frag_idx , 1 : fragment_size ) call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , error , bonds ) if ( error % has_error ()) then call logger % error ( error % get_full_trace ()) error stop \"Failed to build fragment in serial processing\" end if call do_fragment_work ( frag_idx , results ( frag_idx ), method_config , phys_frag , calc_type = calc_type_local ) ! Check for calculation errors if ( results ( frag_idx )% has_error ) then call logger % error ( \"Fragment \" // to_char ( frag_idx ) // \" calculation failed: \" // & results ( frag_idx )% error % get_message ()) error stop \"Fragment calculation failed in serial processing\" end if ! Debug output for gradients if ( calc_type_local == CALC_TYPE_GRADIENT . and . results ( frag_idx )% has_gradient ) then call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level ) then block character ( len = 512 ) :: debug_line integer :: iatom_local write ( debug_line , '(a,i0,a,*(i0,1x))' ) \"Fragment \" , frag_idx , \" monomers: \" , fragment_indices call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Energy: \" , results ( frag_idx )% energy % total () call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( results ( frag_idx )% gradient ** 2 )) call logger % verbose ( trim ( debug_line )) if ( size ( results ( frag_idx )% gradient , 2 ) <= 20 ) then call logger % verbose ( \"  Fragment gradient:\" ) do iatom_local = 1 , size ( results ( frag_idx )% gradient , 2 ) write ( debug_line , '(a,i3,a,3f20.12)' ) \"    Atom \" , iatom_local , \": \" , & results ( frag_idx )% gradient ( 1 , iatom_local ), & results ( frag_idx )% gradient ( 2 , iatom_local ), & results ( frag_idx )% gradient ( 3 , iatom_local ) call logger % verbose ( trim ( debug_line )) end do end if end block end if end if call phys_frag % destroy () deallocate ( fragment_indices ) if ( mod ( frag_idx , max ( 1_int64 , total_fragments / 10 )) == 0 . or . frag_idx == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( frag_idx ) // \"/\" // to_char ( total_fragments ) // & \" fragments [\" // to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call omp_set_num_threads ( omp_get_max_threads ()) call logger % info ( \"All fragments processed\" ) call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Allocate mbe_result components based on calc_type call mbe_result % allocate_dipole () ! Always compute dipole if ( calc_type_local == CALC_TYPE_HESSIAN ) then call mbe_result % allocate_gradient ( sys_geom % total_atoms ) call mbe_result % allocate_hessian ( sys_geom % total_atoms ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then call mbe_result % allocate_gradient ( sys_geom % total_atoms ) end if call compute_mbe ( polymers , total_fragments , max_level , results , mbe_result , sys_geom , bonds , json_data = json_data ) call mbe_result % destroy () call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) deallocate ( results ) end subroutine serial_fragment_processor end submodule mqc_serial_fragment_processor","tags":"","url":"sourcefile/mqc_serial_fragment_processor.f90.html"},{"title":"mqc_vibrational_analysis.f90 – metalquicha","text":"Vibrational frequency analysis from Hessian matrix This file depends on sourcefile~~mqc_vibrational_analysis.f90~~EfferentGraph sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_thermochemistry.f90 mqc_thermochemistry.f90 sourcefile~mqc_vibrational_analysis.f90->sourcefile~mqc_thermochemistry.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_thermochemistry.f90->sourcefile~mqc_physical_constants.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_vibrational_analysis.f90~~AfferentGraph sourcefile~mqc_vibrational_analysis.f90 mqc_vibrational_analysis.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_vibrational_analysis.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Vibrational frequency analysis from Hessian matrix module mqc_vibrational_analysis !! Computes vibrational frequencies from the mass-weighted Hessian matrix. !! Uses LAPACK eigenvalue decomposition via pic-blas interfaces. use pic_types , only : dp use pic_lapack_interfaces , only : pic_syev , pic_gesvd use pic_logger , only : use mqc_elements , only : element_mass , element_number_to_symbol use pic_logger , only : logger => global_logger use mqc_physical_constants , only : AU_TO_CM1 , AU_TO_MDYNE_ANG , AU_TO_KMMOL , AMU_TO_AU use mqc_thermochemistry , only : thermochemistry_result_t , compute_thermochemistry , print_thermochemistry implicit none private public :: compute_vibrational_frequencies public :: compute_vibrational_analysis public :: mass_weight_hessian public :: project_translation_rotation public :: compute_reduced_masses public :: compute_force_constants public :: compute_cartesian_displacements public :: compute_ir_intensities public :: print_vibrational_analysis contains subroutine compute_vibrational_frequencies ( hessian , element_numbers , frequencies , & eigenvalues_out , eigenvectors , & coordinates , project_trans_rot , & projected_hessian_out ) !! Compute vibrational frequencies from the Hessian matrix. !! !! Algorithm: !! 1. Mass-weight the Hessian: H_mw = M&#94;{-1/2} * H * M&#94;{-1/2} !! 2. Optionally project out translation/rotation modes !! 3. Diagonalize H_mw to get eigenvalues !! 4. Convert eigenvalues to frequencies in cm⁻¹ !! !! Negative eigenvalues produce negative frequencies (imaginary modes, !! indicating transition states or saddle points). real ( dp ), intent ( in ) :: hessian (:, :) !! Hessian matrix in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ (3*N modes, or 3*N-6 if projected) real ( dp ), allocatable , intent ( out ), optional :: eigenvalues_out (:) !! Raw eigenvalues from diagonalization (Hartree/Bohr²/amu) real ( dp ), allocatable , intent ( out ), optional :: eigenvectors (:, :) !! Normal mode eigenvectors (3*N x 3*N), columns are modes real ( dp ), intent ( in ), optional :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) - required for projection logical , intent ( in ), optional :: project_trans_rot !! If true, project out translation/rotation modes (requires coordinates) real ( dp ), allocatable , intent ( out ), optional :: projected_hessian_out (:, :) !! Mass-weighted Hessian after trans/rot projection (before diagonalization) real ( dp ), allocatable :: mw_hessian (:, :) real ( dp ), allocatable :: eigenvalues (:) integer :: n_coords , info , i logical :: do_projection n_coords = size ( hessian , 1 ) ! Check if projection is requested do_projection = . false . if ( present ( project_trans_rot )) then if ( project_trans_rot ) then if (. not . present ( coordinates )) then ! Cannot project without coordinates - fall back to no projection call logger % warning ( \"Missing coordinates, not projecting out tran/rot motions\" ) do_projection = . false . else do_projection = . true . end if end if end if ! Mass-weight the Hessian call mass_weight_hessian ( hessian , element_numbers , mw_hessian ) ! Optionally project out translation/rotation modes if ( do_projection ) then call project_translation_rotation ( mw_hessian , coordinates , element_numbers ) end if ! Return projected Hessian if requested (before diagonalization destroys it) if ( present ( projected_hessian_out )) then allocate ( projected_hessian_out ( n_coords , n_coords )) projected_hessian_out = mw_hessian end if ! Allocate eigenvalue storage allocate ( eigenvalues ( n_coords )) ! Diagonalize the mass-weighted Hessian ! pic_syev overwrites mw_hessian with eigenvectors (if jobz='V', default) call pic_syev ( mw_hessian , eigenvalues , info = info ) if ( info /= 0 ) then ! Eigenvalue decomposition failed call logger % error ( \"Eigenvalue decomposition in vibrational frequencies failed\" ) allocate ( frequencies ( n_coords )) frequencies = 0.0_dp return end if ! Convert eigenvalues to frequencies in cm⁻¹ allocate ( frequencies ( n_coords )) do i = 1 , n_coords if ( eigenvalues ( i ) >= 0.0_dp ) then ! Real frequency frequencies ( i ) = sqrt ( eigenvalues ( i ) * AU_TO_CM1 ) else ! Imaginary frequency (negative eigenvalue) - report as negative frequencies ( i ) = - sqrt ( abs ( eigenvalues ( i )) * AU_TO_CM1 ) end if end do ! Return eigenvalues if requested if ( present ( eigenvalues_out )) then allocate ( eigenvalues_out ( n_coords )) eigenvalues_out = eigenvalues end if ! Return eigenvectors if requested if ( present ( eigenvectors )) then allocate ( eigenvectors ( n_coords , n_coords )) eigenvectors = mw_hessian end if deallocate ( eigenvalues , mw_hessian ) end subroutine compute_vibrational_frequencies subroutine compute_vibrational_analysis ( hessian , element_numbers , frequencies , & reduced_masses , force_constants , & cartesian_displacements , & eigenvalues_out , eigenvectors_out , & coordinates , project_trans_rot , & force_constants_mdyne , & dipole_derivatives , ir_intensities ) !! Perform complete vibrational analysis from Hessian matrix. !! !! This is a convenience wrapper that computes: !! - Vibrational frequencies in cm⁻¹ !! - Reduced masses in amu !! - Force constants in Hartree/Bohr² (and optionally mdyne/Å) !! - Cartesian displacement vectors (normalized) !! - IR intensities in km/mol (if dipole_derivatives provided) !! !! Optionally projects out translation/rotation modes. real ( dp ), intent ( in ) :: hessian (:, :) !! Hessian matrix in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ real ( dp ), allocatable , intent ( out ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), allocatable , intent ( out ) :: force_constants (:) !! Force constants in Hartree/Bohr² real ( dp ), allocatable , intent ( out ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N) real ( dp ), allocatable , intent ( out ), optional :: eigenvalues_out (:) !! Raw eigenvalues from diagonalization real ( dp ), allocatable , intent ( out ), optional :: eigenvectors_out (:, :) !! Mass-weighted eigenvectors real ( dp ), intent ( in ), optional :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) - required for projection logical , intent ( in ), optional :: project_trans_rot !! If true, project out translation/rotation modes real ( dp ), allocatable , intent ( out ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å real ( dp ), intent ( in ), optional :: dipole_derivatives (:, :) !! Cartesian dipole derivatives (3, 3*N) in a.u. for IR intensities real ( dp ), allocatable , intent ( out ), optional :: ir_intensities (:) !! IR intensities in km/mol real ( dp ), allocatable :: eigenvalues (:) real ( dp ), allocatable :: eigenvectors (:, :) ! First compute frequencies and eigenvectors call compute_vibrational_frequencies ( hessian , element_numbers , frequencies , & eigenvalues_out = eigenvalues , & eigenvectors = eigenvectors , & coordinates = coordinates , & project_trans_rot = project_trans_rot ) ! Compute reduced masses from eigenvectors call compute_reduced_masses ( eigenvectors , element_numbers , reduced_masses ) ! Compute force constants from eigenvalues and reduced masses call compute_force_constants ( eigenvalues , reduced_masses , force_constants , & force_constants_mdyne ) ! Compute Cartesian displacements from eigenvectors call compute_cartesian_displacements ( eigenvectors , element_numbers , & cartesian_displacements ) ! Compute IR intensities if dipole derivatives are provided if ( present ( dipole_derivatives ) . and . present ( ir_intensities )) then call compute_ir_intensities ( dipole_derivatives , eigenvectors , element_numbers , & ir_intensities ) end if ! Optionally return eigenvalues and eigenvectors if ( present ( eigenvalues_out )) then allocate ( eigenvalues_out ( size ( eigenvalues ))) eigenvalues_out = eigenvalues end if if ( present ( eigenvectors_out )) then allocate ( eigenvectors_out ( size ( eigenvectors , 1 ), size ( eigenvectors , 2 ))) eigenvectors_out = eigenvectors end if deallocate ( eigenvalues , eigenvectors ) end subroutine compute_vibrational_analysis subroutine mass_weight_hessian ( hessian , element_numbers , mw_hessian ) !! Apply mass weighting to Hessian matrix. !! !! H_mw(i,j) = H(i,j) / sqrt(m_i * m_j) !! !! where m_i is the mass of the atom corresponding to coordinate i. !! Each atom contributes 3 coordinates (x, y, z). real ( dp ), intent ( in ) :: hessian (:, :) !! Input Hessian in Hartree/Bohr² (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: mw_hessian (:, :) !! Mass-weighted Hessian (3*N x 3*N) real ( dp ), allocatable :: inv_sqrt_mass (:) integer :: n_atoms , n_coords , iatom , icoord , i , j real ( dp ) :: mass n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms ! Build inverse square root mass vector (each mass repeated 3x for x,y,z) allocate ( inv_sqrt_mass ( n_coords )) do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) do icoord = 1 , 3 inv_sqrt_mass ( 3 * ( iatom - 1 ) + icoord ) = 1.0_dp / sqrt ( mass ) end do end do ! Apply mass weighting: H_mw(i,j) = H(i,j) * inv_sqrt_mass(i) * inv_sqrt_mass(j) allocate ( mw_hessian ( n_coords , n_coords )) do j = 1 , n_coords do i = 1 , n_coords mw_hessian ( i , j ) = hessian ( i , j ) * inv_sqrt_mass ( i ) * inv_sqrt_mass ( j ) end do end do deallocate ( inv_sqrt_mass ) end subroutine mass_weight_hessian subroutine project_translation_rotation ( mw_hessian , coordinates , element_numbers ) !! Project out translation and rotation modes from mass-weighted Hessian. !! !! Builds 6 vectors (3 translation + 3 rotation) in mass-weighted coordinates, !! orthonormalizes them using SVD, then projects them out: !!   H_proj = (I - D @ D&#94;T) @ H @ (I - D @ D&#94;T) !! !! This sets the 6 translation/rotation eigenvalues to exactly zero. real ( dp ), intent ( inout ) :: mw_hessian (:, :) !! Mass-weighted Hessian (modified in place) real ( dp ), intent ( in ) :: coordinates (:, :) !! Atomic coordinates in Bohr (3, N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable :: D (:, :) ! Translation/rotation vectors (3N, 6) real ( dp ), allocatable :: com (:) ! Center of mass real ( dp ), allocatable :: r (:, :) ! Coordinates relative to COM real ( dp ), allocatable :: sqrt_mass (:) ! sqrt(mass) for each atom real ( dp ), allocatable :: S (:) ! Singular values real ( dp ), allocatable :: U (:, :) ! Left singular vectors real ( dp ), allocatable :: VT (:, :) ! Right singular vectors (transposed) real ( dp ), allocatable :: D_orth (:, :) ! Orthonormalized D vectors real ( dp ), allocatable :: proj (:, :) ! Projector matrix real ( dp ), allocatable :: temp (:, :) ! Temporary matrix real ( dp ) :: total_mass , mass , norm integer :: n_atoms , n_coords , iatom , i , j , k , n_modes , info integer :: idx n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms ! Allocate arrays allocate ( D ( n_coords , 6 )) allocate ( com ( 3 )) allocate ( r ( 3 , n_atoms )) allocate ( sqrt_mass ( n_atoms )) ! Compute sqrt(mass) for each atom and total mass total_mass = 0.0_dp do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) sqrt_mass ( iatom ) = sqrt ( mass ) total_mass = total_mass + mass end do ! Compute center of mass com = 0.0_dp do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) com (:) = com (:) + mass * coordinates (:, iatom ) end do com = com / total_mass ! Compute coordinates relative to center of mass do iatom = 1 , n_atoms r (:, iatom ) = coordinates (:, iatom ) - com (:) end do ! Initialize D to zero D = 0.0_dp ! Build translation vectors (mass-weighted) ! D_trans_k: displacement along axis k, weighted by sqrt(mass) do iatom = 1 , n_atoms idx = 3 * ( iatom - 1 ) ! Translation along x D ( idx + 1 , 1 ) = sqrt_mass ( iatom ) ! Translation along y D ( idx + 2 , 2 ) = sqrt_mass ( iatom ) ! Translation along z D ( idx + 3 , 3 ) = sqrt_mass ( iatom ) end do ! Build rotation vectors (mass-weighted) ! D_rot_k: rotation around axis k, proportional to r × e_k, weighted by sqrt(mass) do iatom = 1 , n_atoms idx = 3 * ( iatom - 1 ) ! Rotation around x-axis: r × e_x = (0, r_z, -r_y) D ( idx + 2 , 4 ) = sqrt_mass ( iatom ) * r ( 3 , iatom ) D ( idx + 3 , 4 ) = - sqrt_mass ( iatom ) * r ( 2 , iatom ) ! Rotation around y-axis: r × e_y = (-r_z, 0, r_x) D ( idx + 1 , 5 ) = - sqrt_mass ( iatom ) * r ( 3 , iatom ) D ( idx + 3 , 5 ) = sqrt_mass ( iatom ) * r ( 1 , iatom ) ! Rotation around z-axis: r × e_z = (r_y, -r_x, 0) D ( idx + 1 , 6 ) = sqrt_mass ( iatom ) * r ( 2 , iatom ) D ( idx + 2 , 6 ) = - sqrt_mass ( iatom ) * r ( 1 , iatom ) end do ! Normalize each column of D do k = 1 , 6 norm = sqrt ( sum ( D (:, k ) ** 2 )) if ( norm > 1.0e-10_dp ) then D (:, k ) = D (:, k ) / norm end if end do ! Orthonormalize D using SVD: D = U @ S @ VT ! The orthonormal basis is given by the columns of U corresponding to non-zero singular values allocate ( S ( 6 )) allocate ( U ( n_coords , 6 )) allocate ( VT ( 6 , 6 )) ! pic_gesvd(A, S, U, VT, info) - A is input, U and VT are separate outputs call pic_gesvd ( D , S , U , VT , info = info ) ! Count non-zero singular values (determines number of modes to project) n_modes = 0 do k = 1 , 6 if ( S ( k ) > 1.0e-10_dp ) n_modes = n_modes + 1 end do ! Build orthonormalized D matrix from U (columns with non-zero singular values) allocate ( D_orth ( n_coords , n_modes )) j = 0 do k = 1 , 6 if ( S ( k ) > 1.0e-10_dp ) then j = j + 1 D_orth (:, j ) = U (:, k ) end if end do ! Build projector: P = I - D_orth @ D_orth&#94;T allocate ( proj ( n_coords , n_coords )) proj = 0.0_dp do i = 1 , n_coords proj ( i , i ) = 1.0_dp end do ! Subtract D_orth @ D_orth&#94;T do i = 1 , n_coords do j = 1 , n_coords do k = 1 , n_modes proj ( i , j ) = proj ( i , j ) - D_orth ( i , k ) * D_orth ( j , k ) end do end do end do ! Apply projection: H_proj = P @ H @ P allocate ( temp ( n_coords , n_coords )) ! temp = H @ P do i = 1 , n_coords do j = 1 , n_coords temp ( i , j ) = 0.0_dp do k = 1 , n_coords temp ( i , j ) = temp ( i , j ) + mw_hessian ( i , k ) * proj ( k , j ) end do end do end do ! H_proj = P @ temp do i = 1 , n_coords do j = 1 , n_coords mw_hessian ( i , j ) = 0.0_dp do k = 1 , n_coords mw_hessian ( i , j ) = mw_hessian ( i , j ) + proj ( i , k ) * temp ( k , j ) end do end do end do ! Cleanup deallocate ( D , com , r , sqrt_mass , S , U , VT , D_orth , proj , temp ) end subroutine project_translation_rotation subroutine compute_reduced_masses ( eigenvectors , element_numbers , reduced_masses ) !! Compute reduced masses for each normal mode. !! !! The reduced mass μ_k for mode k is defined as: !!   μ_k = 1 / Σ_i (L_mw_{i,k}² / m_i) !! !! where L_mw is the mass-weighted eigenvector (normalized to 1). !! This formula arises from the relationship Q_k = Σ_i √m_i * x_i * L_mw_{i,k} !! and ensures that the harmonic oscillator relation ω² = k/μ holds. real ( dp ), intent ( in ) :: eigenvectors (:, :) !! Mass-weighted eigenvectors from diagonalization (3*N x 3*N) !! Columns are normal modes, assumed normalized (Σ_i L²_{i,k} = 1) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: reduced_masses (:) !! Reduced masses in amu (one per mode) integer :: n_atoms , n_coords , iatom , icoord , k , idx real ( dp ) :: mass , sum_over_mass n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms allocate ( reduced_masses ( n_coords )) ! For each normal mode k do k = 1 , n_coords sum_over_mass = 0.0_dp ! Sum over all 3N coordinates: Σ_i (L²_{i,k} / m_i) do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) do icoord = 1 , 3 idx = 3 * ( iatom - 1 ) + icoord sum_over_mass = sum_over_mass + eigenvectors ( idx , k ) ** 2 / mass end do end do ! μ_k = 1 / Σ_i (L²_{i,k} / m_i) if ( sum_over_mass > 1.0e-14_dp ) then reduced_masses ( k ) = 1.0_dp / sum_over_mass else ! Near-zero contribution (e.g., trans/rot mode) - assign a large mass reduced_masses ( k ) = 1.0e10_dp end if end do end subroutine compute_reduced_masses subroutine compute_force_constants ( eigenvalues , reduced_masses , force_constants , & force_constants_mdyne ) !! Compute force constants for each normal mode. !! !! From the harmonic oscillator relation: !!   ω² = k/μ  →  k = ω² × μ = eigenvalue × μ !! !! Returns force constants in both atomic units (Hartree/Bohr²) and mdyne/Å. real ( dp ), intent ( in ) :: eigenvalues (:) !! Eigenvalues from mass-weighted Hessian diagonalization (1/amu) real ( dp ), intent ( in ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), allocatable , intent ( out ) :: force_constants (:) !! Force constants in atomic units (Hartree/Bohr²) real ( dp ), allocatable , intent ( out ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å (common experimental unit) integer :: n_modes , k n_modes = size ( eigenvalues ) allocate ( force_constants ( n_modes )) ! k = eigenvalue × μ (eigenvalue has units Hartree/(Bohr²·amu), μ in amu) ! So force_constant has units Hartree/Bohr² do k = 1 , n_modes if ( eigenvalues ( k ) >= 0.0_dp ) then force_constants ( k ) = eigenvalues ( k ) * reduced_masses ( k ) else ! Imaginary frequency mode - report absolute value force_constants ( k ) = - abs ( eigenvalues ( k )) * reduced_masses ( k ) end if end do ! Optionally convert to mdyne/Å if ( present ( force_constants_mdyne )) then allocate ( force_constants_mdyne ( n_modes )) force_constants_mdyne = force_constants * AU_TO_MDYNE_ANG end if end subroutine compute_force_constants subroutine compute_cartesian_displacements ( eigenvectors , element_numbers , & cartesian_displacements , normalize_max ) !! Convert mass-weighted eigenvectors to Cartesian displacements. !! !! The Cartesian displacement for coordinate i in mode k is: !!   x_{i,k} = L_mw_{i,k} / √(m_i) !! !! The output can be normalized in two ways: !! - normalize_max=.true. (default): normalize so max|x| = 1 for each mode (Gaussian convention) !! - normalize_max=.false.: normalize so Σ_i x²_{i,k} = 1 real ( dp ), intent ( in ) :: eigenvectors (:, :) !! Mass-weighted eigenvectors (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N), columns are modes logical , intent ( in ), optional :: normalize_max !! If true, normalize so max displacement = 1 (default: true) integer :: n_atoms , n_coords , iatom , icoord , k , idx real ( dp ) :: mass , inv_sqrt_mass , norm , max_disp logical :: use_max_norm n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms use_max_norm = . true . if ( present ( normalize_max )) use_max_norm = normalize_max allocate ( cartesian_displacements ( n_coords , n_coords )) ! Convert from mass-weighted to Cartesian: x = L_mw / √m do k = 1 , n_coords do iatom = 1 , n_atoms mass = element_mass ( element_numbers ( iatom )) inv_sqrt_mass = 1.0_dp / sqrt ( mass ) do icoord = 1 , 3 idx = 3 * ( iatom - 1 ) + icoord cartesian_displacements ( idx , k ) = eigenvectors ( idx , k ) * inv_sqrt_mass end do end do end do ! Normalize each mode do k = 1 , n_coords if ( use_max_norm ) then ! Gaussian convention: normalize so max |displacement| = 1 max_disp = maxval ( abs ( cartesian_displacements (:, k ))) if ( max_disp > 1.0e-14_dp ) then cartesian_displacements (:, k ) = cartesian_displacements (:, k ) / max_disp end if else ! Standard normalization: Σ_i x²_{i,k} = 1 norm = sqrt ( sum ( cartesian_displacements (:, k ) ** 2 )) if ( norm > 1.0e-14_dp ) then cartesian_displacements (:, k ) = cartesian_displacements (:, k ) / norm end if end if end do end subroutine compute_cartesian_displacements subroutine compute_ir_intensities ( dipole_derivatives , eigenvectors , element_numbers , ir_intensities ) !! Compute IR intensities from dipole derivatives and normal modes. !! !! IR intensities are computed by transforming Cartesian dipole derivatives !! to normal mode coordinates and computing the squared magnitude. !! !! For each normal mode i: !!   trdip(k) = Σ_j dipd(k,j) * L(j,i) * 1/√m_j !!   IR(i) = AU_TO_KMMOL * (trdip(1)² + trdip(2)² + trdip(3)²) !! !! where: !!   dipd(k,j) = ∂μ_k/∂x_j (Cartesian dipole derivative) !!   L(j,i) = mass-weighted eigenvector component !!   m_j = atomic mass for coordinate j !! real ( dp ), intent ( in ) :: dipole_derivatives (:, :) !! Cartesian dipole derivatives (3, 3*N) in atomic units real ( dp ), intent ( in ) :: eigenvectors (:, :) !! Mass-weighted eigenvectors from Hessian diagonalization (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom (N atoms) real ( dp ), allocatable , intent ( out ) :: ir_intensities (:) !! IR intensities in km/mol (one per mode) integer :: n_atoms , n_coords , iatom , i , j , k real ( dp ) :: mass , inv_sqrt_mass , trdip ( 3 ) n_atoms = size ( element_numbers ) n_coords = 3 * n_atoms allocate ( ir_intensities ( n_coords )) ! For each normal mode i do i = 1 , n_coords trdip = 0.0_dp ! Transform dipole derivative from Cartesian to normal mode coordinates ! trdip(k) = Σ_j dipd(k,j) * L(j,i) * amass_au(j) ! where amass_au(j) = 1/√(m_j in atomic units) = 1/√(m_amu * AMU_TO_AU) ! This matches xtb's formula in hessian.F90 lines 526-535 do j = 1 , n_coords iatom = ( j - 1 ) / 3 + 1 mass = element_mass ( element_numbers ( iatom )) ! Convert mass to atomic units (electron masses) before taking sqrt inv_sqrt_mass = 1.0_dp / sqrt ( mass * AMU_TO_AU ) do k = 1 , 3 ! x, y, z components of dipole trdip ( k ) = trdip ( k ) + dipole_derivatives ( k , j ) * eigenvectors ( j , i ) * inv_sqrt_mass end do end do ! IR intensity = |dμ/dQ|² * conversion factor ir_intensities ( i ) = AU_TO_KMMOL * ( trdip ( 1 ) ** 2 + trdip ( 2 ) ** 2 + trdip ( 3 ) ** 2 ) end do end subroutine compute_ir_intensities subroutine print_vibrational_analysis ( frequencies , reduced_masses , force_constants , & cartesian_displacements , element_numbers , & force_constants_mdyne , print_displacements , & n_atoms , ir_intensities , & coordinates , electronic_energy , & temperature , pressure ) !! Print vibrational analysis results in a formatted table. !! !! Output format is similar to Gaussian, with frequencies grouped in columns. !! Optionally prints Cartesian displacement vectors for each mode. !! If coordinates and electronic_energy are provided, also computes and prints !! thermochemistry using the RRHO approximation. real ( dp ), intent ( in ) :: frequencies (:) !! Vibrational frequencies in cm⁻¹ real ( dp ), intent ( in ) :: reduced_masses (:) !! Reduced masses in amu real ( dp ), intent ( in ) :: force_constants (:) !! Force constants in Hartree/Bohr² (or mdyne/Å if force_constants_mdyne provided) real ( dp ), intent ( in ) :: cartesian_displacements (:, :) !! Cartesian displacement vectors (3*N x 3*N) integer , intent ( in ) :: element_numbers (:) !! Atomic numbers for each atom real ( dp ), intent ( in ), optional :: force_constants_mdyne (:) !! Force constants in mdyne/Å (if provided, these are printed instead) logical , intent ( in ), optional :: print_displacements !! If true, print Cartesian displacement vectors (default: true) integer , intent ( in ), optional :: n_atoms !! Number of atoms (if not provided, derived from size of element_numbers) real ( dp ), intent ( in ), optional :: ir_intensities (:) !! IR intensities in km/mol real ( dp ), intent ( in ), optional :: coordinates (:, :) !! Atomic coordinates (3, n_atoms) in Bohr - needed for thermochemistry real ( dp ), intent ( in ), optional :: electronic_energy !! Electronic energy in Hartree - needed for thermochemistry real ( dp ), intent ( in ), optional :: temperature !! Temperature for thermochemistry in K (default: 298.15) real ( dp ), intent ( in ), optional :: pressure !! Pressure for thermochemistry in atm (default: 1.0) integer :: n_modes , n_at , n_groups , igroup , imode , iatom , icoord , k integer :: mode_start , mode_end , modes_in_group logical :: do_print_disp character ( len = 512 ) :: line character ( len = 16 ) :: freq_str , mass_str , fc_str , ir_str character ( len = 2 ) :: elem_sym character ( len = 3 ) :: coord_label real ( dp ) :: fc_value n_modes = size ( frequencies ) if ( present ( n_atoms )) then n_at = n_atoms else n_at = size ( element_numbers ) end if do_print_disp = . true . if ( present ( print_displacements )) do_print_disp = print_displacements call logger % info ( \" \" ) call logger % info ( \"============================================================\" ) call logger % info ( \"                  VIBRATIONAL ANALYSIS\" ) call logger % info ( \"============================================================\" ) call logger % info ( \" \" ) ! Print in groups of 3 modes (like Gaussian) n_groups = ( n_modes + 2 ) / 3 do igroup = 1 , n_groups mode_start = ( igroup - 1 ) * 3 + 1 mode_end = min ( igroup * 3 , n_modes ) modes_in_group = mode_end - mode_start + 1 ! Mode numbers header line = \"                    \" do k = mode_start , mode_end write ( freq_str , '(i12)' ) k line = trim ( line ) // freq_str end do call logger % info ( trim ( line )) ! Frequencies (show \"i\" only for significant imaginary frequencies) line = \" Frequencies --  \" do k = mode_start , mode_end if ( frequencies ( k ) < 0.0_dp . and . abs ( frequencies ( k )) > 1 0.0_dp ) then ! Significant imaginary frequency - show with \"i\" write ( freq_str , '(f12.4,a)' ) abs ( frequencies ( k )), \"i\" else ! Real or near-zero frequency write ( freq_str , '(f12.4)' ) abs ( frequencies ( k )) end if line = trim ( line ) // freq_str end do call logger % info ( trim ( line )) ! Reduced masses line = \" Red. masses --  \" do k = mode_start , mode_end write ( mass_str , '(f12.4)' ) reduced_masses ( k ) line = trim ( line ) // mass_str end do call logger % info ( trim ( line )) ! Force constants if ( present ( force_constants_mdyne )) then line = \" Frc consts  --  \" do k = mode_start , mode_end write ( fc_str , '(f12.4)' ) force_constants_mdyne ( k ) line = trim ( line ) // fc_str end do else line = \" Frc consts  --  \" do k = mode_start , mode_end write ( fc_str , '(f12.6)' ) force_constants ( k ) line = trim ( line ) // fc_str end do end if call logger % info ( trim ( line )) ! IR intensities (if provided) if ( present ( ir_intensities )) then line = \" IR Intens  --  \" do k = mode_start , mode_end write ( ir_str , '(f12.4)' ) ir_intensities ( k ) line = trim ( line ) // ir_str end do call logger % info ( trim ( line )) end if ! Cartesian displacements if ( do_print_disp ) then call logger % info ( \" Atom          X         Y         Z       X         Y         Z       X         Y         Z\" ) do iatom = 1 , n_at elem_sym = element_number_to_symbol ( element_numbers ( iatom )) ! Build line with atom info and displacements for each mode write ( line , '(i4,1x,a2)' ) iatom , elem_sym do k = mode_start , mode_end do icoord = 1 , 3 write ( freq_str , '(f10.5)' ) cartesian_displacements ( 3 * ( iatom - 1 ) + icoord , k ) line = trim ( line ) // freq_str end do end do call logger % info ( trim ( line )) end do end if call logger % info ( \" \" ) end do ! Summary statistics call logger % info ( \"------------------------------------------------------------\" ) call logger % info ( \" Summary:\" ) ! Count real vs imaginary frequencies block integer :: n_real , n_imag , n_zero real ( dp ) :: zero_thresh zero_thresh = 1 0.0_dp ! frequencies below 10 cm⁻¹ considered \"zero\" n_real = 0 n_imag = 0 n_zero = 0 do k = 1 , n_modes if ( abs ( frequencies ( k )) < zero_thresh ) then n_zero = n_zero + 1 else if ( frequencies ( k ) < 0.0_dp ) then n_imag = n_imag + 1 else n_real = n_real + 1 end if end do write ( line , '(a,i5)' ) \"   Total modes:              \" , n_modes call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Real frequencies:         \" , n_real call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Imaginary frequencies:    \" , n_imag call logger % info ( trim ( line )) write ( line , '(a,i5)' ) \"   Near-zero (trans/rot):    \" , n_zero call logger % info ( trim ( line )) if ( n_imag > 0 ) then call logger % warning ( \"System has imaginary frequencies - may be a transition state\" ) end if end block call logger % info ( \"============================================================\" ) call logger % info ( \" \" ) ! Compute and print thermochemistry if coordinates and energy are provided if ( present ( coordinates ) . and . present ( electronic_energy )) then block type ( thermochemistry_result_t ) :: thermo_result call compute_thermochemistry ( coordinates , element_numbers , frequencies , & n_at , n_modes , thermo_result , & temperature = temperature , pressure = pressure ) call print_thermochemistry ( thermo_result , electronic_energy ) end block end if end subroutine print_vibrational_analysis end module mqc_vibrational_analysis","tags":"","url":"sourcefile/mqc_vibrational_analysis.f90.html"},{"title":"mqc_method_dft.f90 – metalquicha","text":"Density Functional Theory (DFT) method implementation for metalquicha This file depends on sourcefile~~mqc_method_dft.f90~~EfferentGraph sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_dft.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_constants.f90 mqc_physical_constants.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_physical_constants.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_result_types.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_dft.f90~~AfferentGraph sourcefile~mqc_method_dft.f90 mqc_method_dft.f90 sourcefile~mqc_method_factory.f90 mqc_method_factory.F90 sourcefile~mqc_method_factory.f90->sourcefile~mqc_method_dft.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_method_factory.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Density Functional Theory (DFT) method implementation for metalquicha module mqc_method_dft !! Implements Kohn-Sham DFT quantum chemistry method !! Provides energy and gradient calculations using self-consistent field !! with exchange-correlation functionals. use pic_types , only : dp use mqc_method_base , only : qc_method_t use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: dft_method_t , dft_options_t type :: dft_options_t !! DFT calculation options character ( len = 32 ) :: basis_set = 'sto-3g' !! Basis set name character ( len = 32 ) :: functional = 'b3lyp' !! Exchange-correlation functional integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: energy_tol = 1.0e-8_dp !! Energy convergence threshold real ( dp ) :: density_tol = 1.0e-6_dp !! Density matrix convergence threshold logical :: spherical = . true . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . false . !! Print SCF iterations ! Grid settings character ( len = 16 ) :: grid_type = 'medium' !! Integration grid quality integer :: radial_points = 75 !! Number of radial grid points per atom integer :: angular_points = 302 !! Number of angular grid points (Lebedev) ! Density fitting logical :: use_density_fitting = . false . !! Use RI-J approximation character ( len = 32 ) :: aux_basis_set = '' !! Auxiliary basis set for density fitting ! Dispersion correction logical :: use_dispersion = . false . !! Add empirical dispersion correction character ( len = 8 ) :: dispersion_type = 'd3bj' !! Dispersion type: \"d3\", \"d3bj\", \"d4\" ! DIIS acceleration logical :: use_diis = . true . !! Use DIIS for SCF convergence integer :: diis_size = 8 !! Number of Fock matrices in DIIS end type dft_options_t type , extends ( qc_method_t ) :: dft_method_t !! DFT method implementation !! !! Kohn-Sham DFT with configurable exchange-correlation functional, !! integration grid, and optional density fitting. type ( dft_options_t ) :: options contains procedure :: calc_energy => dft_calc_energy procedure :: calc_gradient => dft_calc_gradient procedure :: calc_hessian => dft_calc_hessian end type dft_method_t contains subroutine dft_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Kohn-Sham DFT !! !! TODO: Implementation requires: !! 1. Build basis set from fragment geometry !! 2. Compute one-electron integrals (S, T, V) !! 3. Set up integration grid for XC !! 4. Initial density guess (SAD or core Hamiltonian) !! 5. SCF iterations: !!    a. Build Coulomb matrix J !!    b. Evaluate XC energy and potential on grid !!    c. Build Fock matrix F = H + J + Vxc !!    d. Apply DIIS if enabled !!    e. Diagonalize F -> new density !!    f. Check convergence !! 6. Compute final energy class ( dft_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result if ( this % options % verbose ) then print * , \"DFT: Calculating energy using \" , trim ( this % options % functional ) print * , \"DFT: Basis set: \" , trim ( this % options % basis_set ) print * , \"DFT: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"DFT: nelec =\" , fragment % nelec print * , \"DFT: charge =\" , fragment % charge print * , \"DFT: Grid type: \" , trim ( this % options % grid_type ) if ( this % options % use_density_fitting ) then print * , \"DFT: Using density fitting (RI-J)\" end if if ( this % options % use_dispersion ) then print * , \"DFT: Dispersion correction: \" , trim ( this % options % dispersion_type ) end if end if ! Placeholder: Return dummy energy ! TODO: Implement actual DFT calculation result % energy % scf = - 1.0_dp * fragment % n_atoms ! Placeholder result % has_energy = . true . if ( this % options % verbose ) then print * , \"DFT: [STUB] Energy =\" , result % energy % total () end if end subroutine dft_calc_energy subroutine dft_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Kohn-Sham DFT !! !! TODO: Implementation requires: !! 1. Converged SCF (call calc_energy to get density) !! 2. Compute gradient contributions: !!    a. One-electron integral derivatives !!    b. Two-electron integral derivatives (or RI-J) !!    c. XC potential derivatives (grid-based) !!    d. Overlap derivative (Pulay force) !! 3. Optional: dispersion gradient class ( dft_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result if ( this % options % verbose ) then print * , \"DFT: Calculating gradient using \" , trim ( this % options % functional ) end if ! First get energy (and converged density) call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . if ( this % options % verbose ) then print * , \"DFT: [STUB] Gradient computed\" end if end subroutine dft_calc_gradient subroutine dft_calc_hessian ( this , fragment , result ) !! Calculate energy Hessian using Kohn-Sham DFT !! !! TODO: Analytical Hessian requires: !! 1. Converged SCF and gradient !! 2. Coupled-perturbed Kohn-Sham (CPKS) equations !! 3. Second derivatives of integrals !! 4. XC kernel contributions !! Alternative: Use finite difference of gradients (via driver) class ( dft_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result if ( this % options % verbose ) then print * , \"DFT: Analytical Hessian not yet implemented\" print * , \"DFT: Use finite difference of gradients instead\" end if ! For now, just compute energy call this % calc_energy ( fragment , result ) result % has_hessian = . false . end subroutine dft_calc_hessian end module mqc_method_dft","tags":"","url":"sourcefile/mqc_method_dft.f90.html"},{"title":"mqc_resources.f90 – metalquicha","text":"Resources container for calculation methods This file depends on sourcefile~~mqc_resources.f90~~EfferentGraph sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~mqc_mpi_comms.f90 mqc_mpi_comms.f90 sourcefile~mqc_resources.f90->sourcefile~mqc_mpi_comms.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_resources.f90~~AfferentGraph sourcefile~mqc_resources.f90 mqc_resources.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_calculation_interface.f90 mqc_calculation_interface.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_calculation_interface.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_resources.f90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90 mqc_mbe_fragment_distribution_scheme_hessian.F90 sourcefile~mqc_mbe_fragment_distribution_scheme_hessian.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90 mqc_mbe_mpi_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_mpi_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_serial_fragment_processor.f90 mqc_serial_fragment_processor.f90 sourcefile~mqc_serial_fragment_processor.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_unfragmented_workflow.f90 mqc_unfragmented_workflow.f90 sourcefile~mqc_unfragmented_workflow.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Resources container for calculation methods module mqc_resources !! Container type for calculation resources - extensible for future needs use mqc_mpi_comms , only : mpi_comms_t implicit none private public :: resources_t type :: resources_t !! Container for calculation resources !! !! This type bundles all resources needed by calculation methods. !! Currently holds MPI communicators, but can be extended to include !! BLAS providers, basis readers, and other shared resources. type ( mpi_comms_t ) :: mpi_comms !! MPI communicators ! Future extensions: ! type(blas_provider_t), pointer :: blas => null() ! type(basis_reader_t), pointer :: basis_reader => null() ! type(memory_pool_t), pointer :: memory => null() end type resources_t end module mqc_resources","tags":"","url":"sourcefile/mqc_resources.f90.html"}]}