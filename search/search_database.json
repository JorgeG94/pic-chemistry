var tipuesearch = {"pages":[{"title":" metalquicha ","text":"metalquicha Metalquicha API Documentation Met’al q’uicha (metalquicha) Building Notes on Fortran compiler compatibility Building with the Fortran Package Manager (FPM) Obtaining the FPM Warning This API documentation is a work in progress. Metalquicha API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . Met’al q’uicha (metalquicha) Yes, this is AI generated (the image) if you know an artist, please let me know. Met’al q’uicha (the Huastec (tenek) word for sunflower), which I’ll just write as metalquicha, is a sample quantum chemistry backend\nwith focus on using the pic library and its derivatives: pic-mpi and pic-blas which are Fortran based implementations of commonly used routines such as sorting algorithms,\narray handling, strings, loggers, timers, etc. The documentation is hosted at readthedocs, here . Additionally, users can opt to try the vapaa backend for the mpi_f08 module\nto ensure cross compiler portability. Please report any issues associated here and in vapaa. Metalquicha implements a naive backend for unfragmented and fragmented quantum chemistry\ncalculations. Currently, metalquicha uses tblite as\nits chemistry engine which performs energy calculations. If you are interested in contributing, please see here . Pic is the main project here and all the contributions fall downstream. Building You will need an internet connection to download the dependencies. The main dependencies are: CMake A Fortran compiler An MPI installation A BLAS/LAPACK install TBLITE (will be downloaded automatically) You can then simply: mkdir build\ncd build\ncmake ../\nmake -j Notes on Fortran compiler compatibility If you enable tblite (enabled by default at the moment) you are going to be blocked by which compilers does tblite\nsupport. If you decide to not build tblite and just build the framework the code will work with most modern compilers. Building with the Fortran Package Manager (FPM) FPM will only work if you are building with openblas, since the linking step is hardcoded. Simply then just do: fpm install --prefix . --compiler mpifort --profile release Obtaining the FPM Install the FPM following the instructions and then simply: fpm install Developer Info Jorge Luis Galvez Vallejo","tags":"home","url":"index.html"},{"title":"hf_method_t – metalquicha ","text":"type, public, extends( qc_method_t ) :: hf_method_t Hartree-Fock method implementation Inherits type~~hf_method_t~~InheritsGraph type~hf_method_t hf_method_t type~hf_options_t hf_options_t type~hf_method_t->type~hf_options_t options type~qc_method_t qc_method_t type~hf_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( hf_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => hf_calc_energy private  subroutine hf_calc_energy (this, fragment, result) Calculate electronic energy using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_gradient => hf_calc_gradient private  subroutine hf_calc_gradient (this, fragment, result) Calculate energy gradient using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_hessian => null_hessian Placeholder for Hessian calculation private  subroutine null_hessian (this, fragment, result) Placeholder for Hessian calculation Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code type , extends ( qc_method_t ) :: hf_method_t !! Hartree-Fock method implementation type ( hf_options_t ) :: options contains procedure :: calc_energy => hf_calc_energy procedure :: calc_gradient => hf_calc_gradient procedure :: calc_hessian => null_hessian !! Placeholder for Hessian calculation end type hf_method_t","tags":"","url":"type/hf_method_t.html"},{"title":"hf_options_t – metalquicha ","text":"type, public :: hf_options_t Hartree-Fock calculation options Inherited by type~~hf_options_t~~InheritedByGraph type~hf_options_t hf_options_t type~hf_method_t hf_method_t type~hf_method_t->type~hf_options_t options Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: conv_tol = 1.0e-8_dp Energy convergence threshold integer, public :: max_iter = 100 Maximum SCF iterations logical, public :: spherical = .false. Use spherical (true) or Cartesian (false) basis logical, public :: verbose = .true. Print SCF iterations Source Code type :: hf_options_t !! Hartree-Fock calculation options integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: conv_tol = 1.0e-8_dp !! Energy convergence threshold logical :: spherical = . false . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . true . !! Print SCF iterations end type hf_options_t","tags":"","url":"type/hf_options_t.html"},{"title":"calculation_result_t – metalquicha ","text":"type, public :: calculation_result_t Container for quantum chemistry calculation results Stores computed quantities from QC calculations with flags\nindicating which properties have been computed. Inherits type~~calculation_result_t~~InheritsGraph type~calculation_result_t calculation_result_t type~energy_t energy_t type~calculation_result_t->type~energy_t energy type~cc_energy_t cc_energy_t type~energy_t->type~cc_energy_t cc type~mp2_energy_t mp2_energy_t type~energy_t->type~mp2_energy_t mp2 Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dipole (:) Dipole moment vector (3) (Debye) type( energy_t ), public :: energy Energy components (Hartree) real(kind=dp), public, allocatable :: gradient (:,:) Energy gradient (3, natoms) (Hartree/Bohr) logical, public :: has_dipole = .false. Dipole moment has been computed logical, public :: has_energy = .false. Energy has been computed logical, public :: has_gradient = .false. Gradient has been computed logical, public :: has_hessian = .false. Hessian has been computed logical, public :: has_sigma = .false. Stress tensor has been computed real(kind=dp), public, allocatable :: hessian (:,:) Energy hessian (future implementation) real(kind=dp), public, allocatable :: sigma (:,:) Stress tensor (3,3) (Hartree/Bohr&#94;3) Type-Bound Procedures procedure, public :: destroy => result_destroy Clean up allocated memory private  subroutine result_destroy (this) Clean up allocated memory in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this procedure, public :: reset => result_reset Reset all values and flags private  subroutine result_reset (this) Reset all values and flags in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Source Code type :: calculation_result_t !! Container for quantum chemistry calculation results !! !! Stores computed quantities from QC calculations with flags !! indicating which properties have been computed. type ( energy_t ) :: energy !! Energy components (Hartree) real ( dp ), allocatable :: gradient (:, :) !! Energy gradient (3, natoms) (Hartree/Bohr) real ( dp ), allocatable :: sigma (:, :) !! Stress tensor (3,3) (Hartree/Bohr&#94;3) real ( dp ), allocatable :: hessian (:, :) !! Energy hessian (future implementation) real ( dp ), allocatable :: dipole (:) !! Dipole moment vector (3) (Debye) ! Computation status flags logical :: has_energy = . false . !! Energy has been computed logical :: has_gradient = . false . !! Gradient has been computed logical :: has_sigma = . false . !! Stress tensor has been computed logical :: has_hessian = . false . !! Hessian has been computed logical :: has_dipole = . false . !! Dipole moment has been computed contains procedure :: destroy => result_destroy !! Clean up allocated memory procedure :: reset => result_reset !! Reset all values and flags end type calculation_result_t","tags":"","url":"type/calculation_result_t.html"},{"title":"cc_energy_t – metalquicha ","text":"type, public :: cc_energy_t Container for coupled cluster energy components Inherited by type~~cc_energy_t~~InheritedByGraph type~cc_energy_t cc_energy_t type~energy_t energy_t type~energy_t->type~cc_energy_t cc type~calculation_result_t calculation_result_t type~calculation_result_t->type~energy_t energy Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: doubles = 0.0_dp Doubles contribution (Hartree) real(kind=dp), public :: singles = 0.0_dp Singles contribution (Hartree) real(kind=dp), public :: triples = 0.0_dp Triples contribution (Hartree) Type-Bound Procedures procedure, public :: check_stability => cc_check_stability Check for positive energies (instability) private  subroutine cc_check_stability (this) Check for positive CC correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this procedure, public :: reset => cc_reset Reset all components to zero private  subroutine cc_reset (this) Reset all CC components to zero Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(inout) :: this procedure, public :: total => cc_total Compute total CC correlation private pure function cc_total (this) result(total) Compute total CC correlation energy Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code type :: cc_energy_t !! Container for coupled cluster energy components real ( dp ) :: singles = 0.0_dp !! Singles contribution (Hartree) real ( dp ) :: doubles = 0.0_dp !! Doubles contribution (Hartree) real ( dp ) :: triples = 0.0_dp !! Triples contribution (Hartree) contains procedure :: total => cc_total !! Compute total CC correlation procedure :: reset => cc_reset !! Reset all components to zero procedure :: check_stability => cc_check_stability !! Check for positive energies (instability) end type cc_energy_t","tags":"","url":"type/cc_energy_t.html"},{"title":"energy_t – metalquicha ","text":"type, public :: energy_t Container for quantum chemistry energy components Stores energy contributions from different levels of theory.\nTotal energy is computed as: scf + mp2%total() + cc%total() Inherits type~~energy_t~~InheritsGraph type~energy_t energy_t type~cc_energy_t cc_energy_t type~energy_t->type~cc_energy_t cc type~mp2_energy_t mp2_energy_t type~energy_t->type~mp2_energy_t mp2 Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~energy_t~~InheritedByGraph type~energy_t energy_t type~calculation_result_t calculation_result_t type~calculation_result_t->type~energy_t energy Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( cc_energy_t ), public :: cc Coupled cluster correlation components type( mp2_energy_t ), public :: mp2 MP2 correlation components real(kind=dp), public :: scf = 0.0_dp SCF/HF reference energy (Hartree) Type-Bound Procedures procedure, public :: reset => energy_reset Reset all components to zero private  subroutine energy_reset (this) Reset all energy components to zero Arguments Type Intent Optional Attributes Name class( energy_t ), intent(inout) :: this procedure, public :: total => energy_total Compute total energy from components private pure function energy_total (this) result(total) Compute total energy from all components Arguments Type Intent Optional Attributes Name class( energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code type :: energy_t !! Container for quantum chemistry energy components !! !! Stores energy contributions from different levels of theory. !! Total energy is computed as: scf + mp2%total() + cc%total() real ( dp ) :: scf = 0.0_dp !! SCF/HF reference energy (Hartree) type ( mp2_energy_t ) :: mp2 !! MP2 correlation components type ( cc_energy_t ) :: cc !! Coupled cluster correlation components ! add more as needed, also need to modify the total energy function contains procedure :: total => energy_total !! Compute total energy from components procedure :: reset => energy_reset !! Reset all components to zero end type energy_t","tags":"","url":"type/energy_t.html"},{"title":"mp2_energy_t – metalquicha ","text":"type, public :: mp2_energy_t Container for MP2 energy components (SS/OS) Inherited by type~~mp2_energy_t~~InheritedByGraph type~mp2_energy_t mp2_energy_t type~energy_t energy_t type~energy_t->type~mp2_energy_t mp2 type~calculation_result_t calculation_result_t type~calculation_result_t->type~energy_t energy Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: os = 0.0_dp Opposite-spin correlation energy (Hartree) real(kind=dp), public :: ss = 0.0_dp Same-spin correlation energy (Hartree) Type-Bound Procedures procedure, public :: check_stability => mp2_check_stability Check for positive energies (instability) private  subroutine mp2_check_stability (this) Check for positive MP2 correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this procedure, public :: reset => mp2_reset Reset both components to zero private  subroutine mp2_reset (this) Reset both MP2 components to zero Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(inout) :: this procedure, public :: scs => mp2_scs Compute SCS-MP2 correlation private pure function mp2_scs (this) result(scs_energy) Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy\nSCS-MP2 uses: E_SCS = (1/3) E_SS + 1.2 E_OS Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) procedure, public :: total => mp2_total Compute total MP2 correlation private pure function mp2_total (this) result(total) Compute total MP2 correlation energy Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code type :: mp2_energy_t !! Container for MP2 energy components (SS/OS) real ( dp ) :: ss = 0.0_dp !! Same-spin correlation energy (Hartree) real ( dp ) :: os = 0.0_dp !! Opposite-spin correlation energy (Hartree) contains procedure :: total => mp2_total !! Compute total MP2 correlation procedure :: scs => mp2_scs !! Compute SCS-MP2 correlation procedure :: reset => mp2_reset !! Reset both components to zero procedure :: check_stability => mp2_check_stability !! Check for positive energies (instability) end type mp2_energy_t","tags":"","url":"type/mp2_energy_t.html"},{"title":"qc_method_t – metalquicha ","text":"type, public, abstract :: qc_method_t Abstract base type for all quantum chemistry methods Defines the required interface for energy and gradient calculations\nthat must be implemented by all concrete method types (XTB, HF, etc.). Inherited by type~~qc_method_t~~InheritedByGraph type~qc_method_t qc_method_t type~hf_method_t hf_method_t type~hf_method_t->type~qc_method_t type~xtb_method_t xtb_method_t type~xtb_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( calc_energy_interface ), public, deferred :: calc_energy Energy calculation interface subroutine calc_energy_interface(this, fragment, result) Prototype Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results procedure( calc_gradient_interface ), public, deferred :: calc_gradient Gradient calculation interface subroutine calc_gradient_interface(this, fragment, result) Prototype Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result procedure( calc_hessian_interface ), public, deferred :: calc_hessian Hessian calculation interface subroutine calc_hessian_interface(this, fragment, result) Prototype Interface for energy, gradient, and Hessian calculations Computes electronic energy, nuclear gradients, and Hessian matrix for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Source Code type , abstract :: qc_method_t !! Abstract base type for all quantum chemistry methods !! !! Defines the required interface for energy and gradient calculations !! that must be implemented by all concrete method types (XTB, HF, etc.). contains procedure ( calc_energy_interface ), deferred :: calc_energy !! Energy calculation interface procedure ( calc_gradient_interface ), deferred :: calc_gradient !! Gradient calculation interface procedure ( calc_hessian_interface ), deferred :: calc_hessian !! Hessian calculation interface end type qc_method_t","tags":"","url":"type/qc_method_t.html"},{"title":"bond_t – metalquicha ","text":"type, public :: bond_t Bond definition with atom indices, order, and broken status Inherited by type~~bond_t~~InheritedByGraph type~bond_t bond_t type~molecule_t molecule_t type~molecule_t->type~bond_t bonds type~mqc_config_t mqc_config_t type~mqc_config_t->type~bond_t bonds type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: atom_i = 0 integer, public :: atom_j = 0 logical, public :: is_broken = .false. integer, public :: order = 1 Source Code type :: bond_t !! Bond definition with atom indices, order, and broken status integer :: atom_i = 0 integer :: atom_j = 0 integer :: order = 1 logical :: is_broken = . false . end type bond_t","tags":"","url":"type/bond_t.html"},{"title":"input_fragment_t – metalquicha ","text":"type, public :: input_fragment_t Input fragment definition with charge, multiplicity, and atom indices\nThis is the parsed representation from the input file, not the computational fragment Inherited by type~~input_fragment_t~~InheritedByGraph type~input_fragment_t input_fragment_t type~molecule_t molecule_t type~molecule_t->type~input_fragment_t fragments type~mqc_config_t mqc_config_t type~mqc_config_t->type~input_fragment_t fragments type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: charge = 0 integer, public, allocatable :: indices (:) Atom indices in this fragment integer, public :: multiplicity = 1 Type-Bound Procedures procedure, public :: destroy => input_fragment_destroy private  subroutine input_fragment_destroy (this) Clean up allocated memory in input_fragment_t Arguments Type Intent Optional Attributes Name class( input_fragment_t ), intent(inout) :: this Source Code type :: input_fragment_t !! Input fragment definition with charge, multiplicity, and atom indices !! This is the parsed representation from the input file, not the computational fragment integer :: charge = 0 integer :: multiplicity = 1 integer , allocatable :: indices (:) !! Atom indices in this fragment contains procedure :: destroy => input_fragment_destroy end type input_fragment_t","tags":"","url":"type/input_fragment_t.html"},{"title":"molecule_t – metalquicha ","text":"type, public :: molecule_t Single molecule definition with structure, geometry, fragments, and connectivity Inherits type~~molecule_t~~InheritsGraph type~molecule_t molecule_t type~bond_t bond_t type~molecule_t->type~bond_t bonds type~geometry_type geometry_type type~molecule_t->type~geometry_type geometry type~input_fragment_t input_fragment_t type~molecule_t->type~input_fragment_t fragments Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~molecule_t~~InheritedByGraph type~molecule_t molecule_t type~mqc_config_t mqc_config_t type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( bond_t ), public, allocatable :: bonds (:) integer, public :: charge = 0 type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry integer, public :: multiplicity = 1 character(len=:), public, allocatable :: name Optional molecule name integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 Type-Bound Procedures procedure, public :: destroy => molecule_destroy private  subroutine molecule_destroy (this) Clean up allocated memory in molecule_t Arguments Type Intent Optional Attributes Name class( molecule_t ), intent(inout) :: this Source Code type :: molecule_t !! Single molecule definition with structure, geometry, fragments, and connectivity character ( len = :), allocatable :: name !! Optional molecule name ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) contains procedure :: destroy => molecule_destroy end type molecule_t","tags":"","url":"type/molecule_t.html"},{"title":"mqc_config_t – metalquicha ","text":"type, public :: mqc_config_t Complete configuration from .mqc file Inherits type~~mqc_config_t~~InheritsGraph type~mqc_config_t mqc_config_t type~bond_t bond_t type~mqc_config_t->type~bond_t bonds type~geometry_type geometry_type type~mqc_config_t->type~geometry_type geometry type~input_fragment_t input_fragment_t type~mqc_config_t->type~input_fragment_t fragments type~molecule_t molecule_t type~mqc_config_t->type~molecule_t molecules type~molecule_t->type~bond_t bonds type~molecule_t->type~geometry_type geometry type~molecule_t->type~input_fragment_t fragments Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: allow_overlapping_fragments = .false. character(len=:), public, allocatable :: aux_basis character(len=:), public, allocatable :: basis type( bond_t ), public, allocatable :: bonds (:) integer(kind=int32), public :: calc_type = CALC_TYPE_ENERGY integer, public :: charge = 0 character(len=:), public, allocatable :: cutoff_method real(kind=dp), public :: dimer_cutoff = 0.0_dp character(len=:), public, allocatable :: distance_metric character(len=:), public, allocatable :: embedding integer, public :: frag_level = 1 character(len=:), public, allocatable :: frag_method MBE, etc. type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry integer, public :: index_base = 0 0-based or 1-based indexing character(len=:), public, allocatable :: log_level integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method = METHOD_TYPE_GFN2 type( molecule_t ), public, allocatable :: molecules (:) Array of molecules (if nmol > 0) integer, public :: multiplicity = 1 integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 integer, public :: nmol = 0 Number of molecules (0 = single molecule mode for backward compatibility) integer, public :: scf_maxiter = 300 real(kind=dp), public :: scf_tolerance = 1.0e-6_dp character(len=:), public, allocatable :: schema_name character(len=:), public, allocatable :: schema_version real(kind=dp), public :: trimer_cutoff = 0.0_dp character(len=:), public, allocatable :: units angstrom or bohr Type-Bound Procedures procedure, public :: destroy => config_destroy private  subroutine config_destroy (this) Clean up allocated memory in mqc_config_t Arguments Type Intent Optional Attributes Name class( mqc_config_t ), intent(inout) :: this Source Code type :: mqc_config_t !! Complete configuration from .mqc file ! Schema information character ( len = :), allocatable :: schema_name character ( len = :), allocatable :: schema_version integer :: index_base = 0 !! 0-based or 1-based indexing character ( len = :), allocatable :: units !! angstrom or bohr ! Model information integer ( int32 ) :: method = METHOD_TYPE_GFN2 character ( len = :), allocatable :: basis character ( len = :), allocatable :: aux_basis ! Driver information integer ( int32 ) :: calc_type = CALC_TYPE_ENERGY ! Multiple molecules support integer :: nmol = 0 !! Number of molecules (0 = single molecule mode for backward compatibility) type ( molecule_t ), allocatable :: molecules (:) !! Array of molecules (if nmol > 0) ! Single molecule fields (backward compatibility - used if nmol == 0) ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) ! SCF settings integer :: scf_maxiter = 300 real ( dp ) :: scf_tolerance = 1.0e-6_dp ! Fragmentation settings character ( len = :), allocatable :: frag_method !! MBE, etc. integer :: frag_level = 1 logical :: allow_overlapping_fragments = . false . integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) character ( len = :), allocatable :: embedding character ( len = :), allocatable :: cutoff_method character ( len = :), allocatable :: distance_metric real ( dp ) :: dimer_cutoff = 0.0_dp real ( dp ) :: trimer_cutoff = 0.0_dp ! Logger settings (kept for compatibility) character ( len = :), allocatable :: log_level contains procedure :: destroy => config_destroy end type mqc_config_t","tags":"","url":"type/mqc_config_t.html"},{"title":"physical_fragment_t – metalquicha ","text":"type, public :: physical_fragment_t Physical molecular fragment with atomic coordinates and properties Represents a molecular fragment containing atomic positions, element types,\nelectronic structure information, and basis set data for quantum calculations. Inherits type~~physical_fragment_t~~InheritsGraph type~physical_fragment_t physical_fragment_t type~molecular_basis_type molecular_basis_type type~physical_fragment_t->type~molecular_basis_type basis type~atomic_basis_type atomic_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~physical_fragment_t~~InheritedByGraph type~physical_fragment_t physical_fragment_t type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( molecular_basis_type ), public, allocatable :: basis Gaussian basis functions integer, public, allocatable :: cap_replaces_atom (:) Original atom index that each cap replaces (size: n_caps) integer, public :: charge = 0 Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) Cartesian coordinates (3, n_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers (Z values) integer, public, allocatable :: local_to_global (:) Map fragment atom index to system atom index (size: n_atoms - n_caps) integer, public :: multiplicity = 1 Spin multiplicity (2S+1) integer, public :: n_atoms Number of atoms in this fragment integer, public :: n_caps = 0 Number of hydrogen caps added (always at end of atom list) integer, public :: nelec = 0 Total number of electrons Type-Bound Procedures procedure, public :: compute_nelec => fragment_compute_nelec Calculate electron count private  subroutine fragment_compute_nelec (this) Compute number of electrons from atomic numbers and charge Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this procedure, public :: destroy => fragment_destroy Memory cleanup private  subroutine fragment_destroy (this) Clean up allocated memory in physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this procedure, public :: set_basis => fragment_set_basis Assign basis set private  subroutine fragment_set_basis (this, basis) Set the basis set for this fragment Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis Source Code type :: physical_fragment_t !! Physical molecular fragment with atomic coordinates and properties !! !! Represents a molecular fragment containing atomic positions, element types, !! electronic structure information, and basis set data for quantum calculations. integer :: n_atoms !! Number of atoms in this fragment integer , allocatable :: element_numbers (:) !! Atomic numbers (Z values) real ( dp ), allocatable :: coordinates (:, :) !! Cartesian coordinates (3, n_atoms) in Bohr ! Electronic structure properties integer :: charge = 0 !! Net molecular charge (electrons) integer :: multiplicity = 1 !! Spin multiplicity (2S+1) integer :: nelec = 0 !! Total number of electrons ! Hydrogen capping for broken bonds integer :: n_caps = 0 !! Number of hydrogen caps added (always at end of atom list) integer , allocatable :: cap_replaces_atom (:) !! Original atom index that each cap replaces (size: n_caps) ! Gradient redistribution support integer , allocatable :: local_to_global (:) !! Map fragment atom index to system atom index (size: n_atoms - n_caps) ! Quantum chemistry basis set type ( molecular_basis_type ), allocatable :: basis !! Gaussian basis functions contains procedure :: destroy => fragment_destroy !! Memory cleanup procedure :: compute_nelec => fragment_compute_nelec !! Calculate electron count procedure :: set_basis => fragment_set_basis !! Assign basis set end type physical_fragment_t","tags":"","url":"type/physical_fragment_t.html"},{"title":"system_geometry_t – metalquicha ","text":"type, public :: system_geometry_t Complete molecular system geometry for fragment-based calculations Contains the full atomic structure of a molecular cluster organized\nby monomers for efficient fragment generation and MBE calculations. Components Type Visibility Attributes Name Initial integer, public :: atoms_per_monomer Atoms in each monomer (0 if variable-sized) integer, public :: charge Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) All coordinates (3, total_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers for all atoms integer, public, allocatable :: fragment_atoms (:,:) Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer, public, allocatable :: fragment_charges (:) Charge for each fragment (n_monomers) integer, public, allocatable :: fragment_multiplicities (:) Multiplicity for each fragment (n_monomers) integer, public, allocatable :: fragment_sizes (:) Number of atoms in each fragment (n_monomers) integer, public :: multiplicity Spin multiplicity (2S+1) integer, public :: n_monomers Number of monomer units in system integer, public :: total_atoms Total number of atoms Type-Bound Procedures procedure, public :: destroy => system_destroy Memory cleanup private  subroutine system_destroy (this) Clean up allocated memory in system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this Source Code type :: system_geometry_t !! Complete molecular system geometry for fragment-based calculations !! !! Contains the full atomic structure of a molecular cluster organized !! by monomers for efficient fragment generation and MBE calculations. integer :: n_monomers !! Number of monomer units in system integer :: atoms_per_monomer !! Atoms in each monomer (0 if variable-sized) integer :: total_atoms !! Total number of atoms integer , allocatable :: element_numbers (:) !! Atomic numbers for all atoms real ( dp ), allocatable :: coordinates (:, :) !! All coordinates (3, total_atoms) in Bohr ! Electronic structure properties integer :: charge !! Net molecular charge (electrons) integer :: multiplicity !! Spin multiplicity (2S+1) ! For variable-sized fragments (explicit fragment definitions) integer , allocatable :: fragment_sizes (:) !! Number of atoms in each fragment (n_monomers) integer , allocatable :: fragment_atoms (:, :) !! Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer , allocatable :: fragment_charges (:) !! Charge for each fragment (n_monomers) integer , allocatable :: fragment_multiplicities (:) !! Multiplicity for each fragment (n_monomers) contains procedure :: destroy => system_destroy !! Memory cleanup end type system_geometry_t","tags":"","url":"type/system_geometry_t.html"},{"title":"atomic_basis_type – metalquicha ","text":"type, public :: atomic_basis_type Atomic basis set data structure Inherits type~~atomic_basis_type~~InheritsGraph type~atomic_basis_type atomic_basis_type type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~atomic_basis_type~~InheritedByGraph type~atomic_basis_type atomic_basis_type type~molecular_basis_type molecular_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: element element symbol integer, public :: nshells number of shells in type type( cgto_type ), public, allocatable :: shells (:) array of contracted shells Type-Bound Procedures procedure, public :: allocate_shells => allocate_basis_shells private pure subroutine allocate_basis_shells (self, nshells) Allocate array of shells in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells procedure, public :: destroy => atomic_basis_destroy private pure subroutine atomic_basis_destroy (self) Clean up allocated memory in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self procedure, public :: num_basis_functions => atomic_basis_num_basis_functions private pure function atomic_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for an atom Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer Source Code type :: atomic_basis_type !! Atomic basis set data structure character ( len = :), allocatable :: element !! element symbol type ( cgto_type ), allocatable :: shells (:) !! array of contracted shells integer :: nshells !! number of shells in type contains procedure :: allocate_shells => allocate_basis_shells procedure :: destroy => atomic_basis_destroy procedure :: num_basis_functions => atomic_basis_num_basis_functions end type atomic_basis_type","tags":"","url":"type/atomic_basis_type.html"},{"title":"cgto_type – metalquicha ","text":"type, public :: cgto_type Contracted Gaussian type orbital (CGTO) data structure Inherited by type~~cgto_type~~InheritedByGraph type~cgto_type cgto_type type~atomic_basis_type atomic_basis_type type~atomic_basis_type->type~cgto_type shells type~molecular_basis_type molecular_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: ang_mom Angular momentum quantum number (0=s, 1=p, 2=d, etc.) real(kind=dp), public, allocatable :: coefficients (:) Contraction coefficients real(kind=dp), public, allocatable :: exponents (:) Exponents (alpha values) integer, public :: nfunc Number of primitive Gaussians in the contraction Type-Bound Procedures procedure, public :: allocate_arrays => cgto_allocate_arrays private pure subroutine cgto_allocate_arrays (self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc procedure, public :: destroy => cgto_destroy private pure subroutine cgto_destroy (self) Clean up allocated memory in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self procedure, public :: num_basis_functions => cgto_num_basis_functions private pure function cgto_num_basis_functions (self) result(nbf) Get number of basis functions in a shell (Cartesian) Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer Source Code type :: cgto_type !! Contracted Gaussian type orbital (CGTO) data structure integer :: ang_mom !! Angular momentum quantum number (0=s, 1=p, 2=d, etc.) integer :: nfunc !! Number of primitive Gaussians in the contraction real ( dp ), allocatable :: exponents (:) !! Exponents (alpha values) real ( dp ), allocatable :: coefficients (:) !! Contraction coefficients contains procedure :: allocate_arrays => cgto_allocate_arrays procedure :: destroy => cgto_destroy procedure :: num_basis_functions => cgto_num_basis_functions end type cgto_type","tags":"","url":"type/cgto_type.html"},{"title":"molecular_basis_type – metalquicha ","text":"type, public :: molecular_basis_type Molecular basis set data structure (assembled basis) Inherits type~~molecular_basis_type~~InheritsGraph type~molecular_basis_type molecular_basis_type type~atomic_basis_type atomic_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~molecular_basis_type~~InheritedByGraph type~molecular_basis_type molecular_basis_type type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis type~displaced_geometry_t displaced_geometry_t type~displaced_geometry_t->type~physical_fragment_t geometry Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( atomic_basis_type ), public, allocatable :: elements (:) array of atomic basis types integer, public :: nelements total number of atoms/elements in a molecule Type-Bound Procedures procedure, public :: allocate_elements => basis_set_allocate_elements private pure subroutine basis_set_allocate_elements (self, nelements) Allocate array of atomic basis elements in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements procedure, public :: destroy => basis_set_destroy private pure subroutine basis_set_destroy (self) Clean up allocated memory in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self procedure, public :: num_basis_functions => molecular_basis_num_basis_functions private pure function molecular_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for the molecule Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Source Code type :: molecular_basis_type !! Molecular basis set data structure (assembled basis) type ( atomic_basis_type ), allocatable :: elements (:) !! array of atomic basis types integer :: nelements !! total number of atoms/elements in a molecule contains procedure :: allocate_elements => basis_set_allocate_elements procedure :: destroy => basis_set_destroy procedure :: num_basis_functions => molecular_basis_num_basis_functions end type molecular_basis_type","tags":"","url":"type/molecular_basis_type.html"},{"title":"basis_file_t – metalquicha ","text":"type, public :: basis_file_t Container for basis set file contents Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: data_section character(len=:), public, allocatable :: full_content Source Code type :: basis_file_t !! Container for basis set file contents character ( len = :), allocatable :: full_content character ( len = :), allocatable :: data_section end type basis_file_t","tags":"","url":"type/basis_file_t.html"},{"title":"fragment_lookup_t – metalquicha ","text":"type, public :: fragment_lookup_t Hash-based lookup table for O(1) fragment index retrieval Inherits type~~fragment_lookup_t~~InheritsGraph type~fragment_lookup_t fragment_lookup_t type~hash_entry_t hash_entry_t type~fragment_lookup_t->type~hash_entry_t table type~hash_entry_t->type~hash_entry_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: initialized = .false. integer(kind=int64), public :: n_entries = 0 type( hash_entry_t ), public, allocatable :: table (:) integer, public :: table_size = 0 Type-Bound Procedures procedure, public :: destroy => fragment_lookup_destroy private  subroutine fragment_lookup_destroy (this) Clean up hash table and all chains Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this procedure, public :: find => fragment_lookup_find private  function fragment_lookup_find (this, monomers, n) result(idx) Find fragment index for given monomer combination Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) procedure, public :: init => fragment_lookup_init private  subroutine fragment_lookup_init (this, estimated_entries) Initialize hash table with estimated size Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries procedure, public :: insert => fragment_lookup_insert private  subroutine fragment_lookup_insert (this, monomers, n, fragment_idx) Insert a monomer combination -> fragment index mapping Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx Source Code type :: fragment_lookup_t !! Hash-based lookup table for O(1) fragment index retrieval integer :: table_size = 0 type ( hash_entry_t ), allocatable :: table (:) integer ( int64 ) :: n_entries = 0 logical :: initialized = . false . contains procedure :: init => fragment_lookup_init procedure :: insert => fragment_lookup_insert procedure :: find => fragment_lookup_find procedure :: destroy => fragment_lookup_destroy end type fragment_lookup_t","tags":"","url":"type/fragment_lookup_t.html"},{"title":"hash_entry_t – metalquicha ","text":"type, private :: hash_entry_t Single entry in hash table (private helper type) Inherited by type~~hash_entry_t~~InheritedByGraph type~hash_entry_t hash_entry_t type~hash_entry_t->type~hash_entry_t next type~fragment_lookup_t fragment_lookup_t type~fragment_lookup_t->type~hash_entry_t table Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, allocatable :: key (:) Sorted monomer indices type( hash_entry_t ), public, pointer :: next => null() Chain for collisions integer(kind=int64), public :: value Fragment index Source Code type :: hash_entry_t !! Single entry in hash table (private helper type) integer , allocatable :: key (:) !! Sorted monomer indices integer ( int64 ) :: value !! Fragment index type ( hash_entry_t ), pointer :: next => null () !! Chain for collisions end type hash_entry_t","tags":"","url":"type/hash_entry_t.html"},{"title":"cli_args_type – metalquicha ","text":"type, public :: cli_args_type Container for parsed command line arguments Stores file paths and options extracted from command line,\nwith automatic memory management for string allocations. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: basis_name Basis set name (e.g., “6-31G”) character(len=:), public, allocatable :: xyz_file Input XYZ geometry file path Type-Bound Procedures procedure, public :: destroy => cli_args_destroy Memory cleanup private  subroutine cli_args_destroy (this) Clean up CLI args Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this Source Code type :: cli_args_type !! Container for parsed command line arguments !! !! Stores file paths and options extracted from command line, !! with automatic memory management for string allocations. character ( len = :), allocatable :: xyz_file !! Input XYZ geometry file path character ( len = :), allocatable :: basis_name !! Basis set name (e.g., \"6-31G\") contains procedure :: destroy => cli_args_destroy !! Memory cleanup end type cli_args_type","tags":"","url":"type/cli_args_type.html"},{"title":"displaced_geometry_t – metalquicha ","text":"type, public :: displaced_geometry_t Container for a single displaced geometry Inherits type~~displaced_geometry_t~~InheritsGraph type~displaced_geometry_t displaced_geometry_t type~physical_fragment_t physical_fragment_t type~displaced_geometry_t->type~physical_fragment_t geometry type~molecular_basis_type molecular_basis_type type~physical_fragment_t->type~molecular_basis_type basis type~atomic_basis_type atomic_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: atom_index Which atom was displaced (1-based) integer, public :: coordinate Which coordinate was displaced (1=x, 2=y, 3=z) integer, public :: direction +1 for forward, -1 for backward real(kind=dp), public :: displacement Displacement magnitude in Bohr type( physical_fragment_t ), public :: geometry The displaced geometry Type-Bound Procedures procedure, public :: destroy => displaced_geometry_destroy private  subroutine displaced_geometry_destroy (this) Clean up memory for displaced geometry Arguments Type Intent Optional Attributes Name class( displaced_geometry_t ), intent(inout) :: this Source Code type :: displaced_geometry_t !! Container for a single displaced geometry integer :: atom_index !! Which atom was displaced (1-based) integer :: coordinate !! Which coordinate was displaced (1=x, 2=y, 3=z) integer :: direction !! +1 for forward, -1 for backward real ( dp ) :: displacement !! Displacement magnitude in Bohr type ( physical_fragment_t ) :: geometry !! The displaced geometry contains procedure :: destroy => displaced_geometry_destroy end type displaced_geometry_t","tags":"","url":"type/displaced_geometry_t.html"},{"title":"xtb_method_t – metalquicha ","text":"type, public, extends( qc_method_t ) :: xtb_method_t Extended Tight-Binding (xTB) method implementation Concrete implementation of the abstract quantum chemistry method\ninterface for GFN1-xTB and GFN2-xTB calculations via tblite. Inherits type~~xtb_method_t~~InheritsGraph type~xtb_method_t xtb_method_t type~qc_method_t qc_method_t type~xtb_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=wp), public :: accuracy = 0.01_wp Numerical accuracy parameter real(kind=wp), public :: kt = 300.0_wp*3.166808578545117e-06_wp Electronic temperature (300 K) character(len=:), public, allocatable :: variant XTB variant: “gfn1” or “gfn2” logical, public :: verbose = .false. Print calculation details Type-Bound Procedures procedure, public :: calc_energy => xtb_calc_energy Energy-only calculation private  subroutine xtb_calc_energy (this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_gradient => xtb_calc_gradient Energy + gradient calculation private  subroutine xtb_calc_gradient (this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_hessian => xtb_calc_hessian Placeholder for Hessian calculation private  subroutine xtb_calc_hessian (this, fragment, result) Calculate Hessian using finite differences of gradients Read more… Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code type , extends ( qc_method_t ) :: xtb_method_t !! Extended Tight-Binding (xTB) method implementation !! !! Concrete implementation of the abstract quantum chemistry method !! interface for GFN1-xTB and GFN2-xTB calculations via tblite. character ( len = :), allocatable :: variant !! XTB variant: \"gfn1\" or \"gfn2\" logical :: verbose = . false . !! Print calculation details real ( wp ) :: accuracy = 0.01_wp !! Numerical accuracy parameter real ( wp ) :: kt = 30 0.0_wp * 3.166808578545117e-06_wp !! Electronic temperature (300 K) contains procedure :: calc_energy => xtb_calc_energy !! Energy-only calculation procedure :: calc_gradient => xtb_calc_gradient !! Energy + gradient calculation procedure :: calc_hessian => xtb_calc_hessian !! Placeholder for Hessian calculation end type xtb_method_t","tags":"","url":"type/xtb_method_t.html"},{"title":"geometry_type – metalquicha ","text":"type, public :: geometry_type Molecular geometry data structure Inherited by type~~geometry_type~~InheritedByGraph type~geometry_type geometry_type type~molecule_t molecule_t type~molecule_t->type~geometry_type geometry type~mqc_config_t mqc_config_t type~mqc_config_t->type~geometry_type geometry type~mqc_config_t->type~molecule_t molecules Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: comment real(kind=dp), public, allocatable :: coords (:,:) character(len=:), public, allocatable :: elements (:) integer, public :: natoms Type-Bound Procedures procedure, public :: destroy => geometry_destroy private  subroutine geometry_destroy (this) Clean up allocated memory in geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this Source Code type :: geometry_type !! Molecular geometry data structure integer :: natoms character ( len = :), allocatable :: elements (:) real ( dp ), allocatable :: coords (:, :) ! coords(3, natoms) character ( len = :), allocatable :: comment contains procedure :: destroy => geometry_destroy end type geometry_type","tags":"","url":"type/geometry_type.html"},{"title":"driver_config_t – metalquicha ","text":"type, public :: driver_config_t Components Type Visibility Attributes Name Initial logical, public :: allow_overlapping_fragments Enable GMBE for overlapping fragments integer(kind=int32), public :: calc_type Calculation type constant integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method QC method constant integer, public :: nlevel = 0 Fragmentation level (0 = unfragmented) Source Code type :: driver_config_t integer ( int32 ) :: method !! QC method constant integer ( int32 ) :: calc_type !! Calculation type constant integer :: nlevel = 0 !! Fragmentation level (0 = unfragmented) logical :: allow_overlapping_fragments !! Enable GMBE for overlapping fragments integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) end type driver_config_t","tags":"","url":"type/driver_config_t.html"},{"title":"error_t – metalquicha ","text":"type, public :: error_t Components Type Visibility Attributes Name Initial integer, public :: code = SUCCESS Error code (0 = no error) character(len=:), public, allocatable :: message Error message Type-Bound Procedures procedure, public :: clear => error_clear private pure subroutine error_clear (this) Clear the error state Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this procedure, public :: get_code => error_get_code private pure function error_get_code (this) result(code) Get the error code Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value integer procedure, public :: get_message => error_get_message private pure function error_get_message (this) result(message) Get the error message Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable procedure, public :: has_error => error_has_error private pure function error_has_error (this) result(has_err) Check if an error is set Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value logical procedure, public :: set => error_set private pure subroutine error_set (this, code, message) Set an error with code and message Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this integer, intent(in) :: code character(len=*), intent(in) :: message Source Code type :: error_t integer :: code = SUCCESS !! Error code (0 = no error) character ( len = :), allocatable :: message !! Error message contains procedure :: has_error => error_has_error procedure :: set => error_set procedure :: clear => error_clear procedure :: get_code => error_get_code procedure :: get_message => error_get_message end type error_t","tags":"","url":"type/error_t.html"},{"title":"calc_energy_interface – metalquicha","text":"interface private  subroutine calc_energy_interface(this, fragment, result) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results Description Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method.","tags":"","url":"interface/calc_energy_interface.html"},{"title":"calc_gradient_interface – metalquicha","text":"interface private  subroutine calc_gradient_interface(this, fragment, result) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Description Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method.","tags":"","url":"interface/calc_gradient_interface.html"},{"title":"calc_hessian_interface – metalquicha","text":"interface private  subroutine calc_hessian_interface(this, fragment, result) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Description Interface for energy, gradient, and Hessian calculations Computes electronic energy, nuclear gradients, and Hessian matrix for a\nmolecular fragment using the specified quantum chemistry method.","tags":"","url":"interface/calc_hessian_interface.html"},{"title":"hf_calc_energy – metalquicha","text":"private  subroutine hf_calc_energy(this, fragment, result) Calculate electronic energy using Hartree-Fock method Type Bound hf_method_t Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~hf_calc_energy~~CallsGraph proc~hf_calc_energy hf_method_t%hf_calc_energy proc~energy_total energy_t%energy_total proc~hf_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hf_calc_energy~~CalledByGraph proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_gradient->proc~hf_calc_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hf_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement actual HF calculation ! 1. Convert fragment%basis to libcint format ! 2. Build one-electron integrals (S, T, V) ! 3. Run SCF iterations ! 4. Calculate final energy print * , \"HF: Calculating energy for fragment with\" , fragment % n_atoms , \"atoms\" print * , \"HF: nelec =\" , fragment % nelec print * , \"HF: charge =\" , fragment % charge print * , \"HF: multiplicity =\" , fragment % multiplicity ! Dummy result result % energy % scf = - 1.0_dp ! Placeholder result % has_energy = . true . print * , \"HF: Dummy energy =\" , result % energy % total () end subroutine hf_calc_energy","tags":"","url":"proc/hf_calc_energy.html"},{"title":"hf_calc_gradient – metalquicha","text":"private  subroutine hf_calc_gradient(this, fragment, result) Calculate energy gradient using Hartree-Fock method Type Bound hf_method_t Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~hf_calc_gradient~~CallsGraph proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_gradient->proc~hf_calc_energy proc~energy_total energy_t%energy_total proc~hf_calc_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hf_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement gradient calculation ! 1. Calculate energy (call calc_energy) ! 2. Calculate gradient using integral derivatives print * , \"HF: Calculating gradient for fragment with\" , fragment % n_atoms , \"atoms\" ! First get energy call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . print * , \"HF: Dummy gradient allocated\" end subroutine hf_calc_gradient","tags":"","url":"proc/hf_calc_gradient.html"},{"title":"null_hessian – metalquicha","text":"private  subroutine null_hessian(this, fragment, result) Placeholder for Hessian calculation Type Bound hf_method_t Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code subroutine null_hessian ( this , fragment , result ) !! Placeholder for Hessian calculation class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result print * , \"HF: Hessian calculation not implemented yet.\" result % has_hessian = . false . end subroutine null_hessian","tags":"","url":"proc/null_hessian.html"},{"title":"binomial – metalquicha","text":"public pure function binomial(n, r) result(c) Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) Calculates “n choose r” using iterative algorithm to avoid\nfactorial overflow for large numbers.\nUses int64 to handle large combinatorial values that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n Total number of items integer(kind=default_int), intent(in) :: r Number of items to choose Return Value integer(kind=int64) Binomial coefficient result Called by proc~~binomial~~CalledByGraph proc~binomial binomial proc~get_nfrags get_nfrags proc~get_nfrags->proc~binomial proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~binomial proc~run_fragmented_calculation->proc~get_nfrags proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i Loop counter Source Code pure function binomial ( n , r ) result ( c ) !! Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) !! !! Calculates \"n choose r\" using iterative algorithm to avoid !! factorial overflow for large numbers. !! Uses int64 to handle large combinatorial values that overflow int32. integer ( default_int ), intent ( in ) :: n !! Total number of items integer ( default_int ), intent ( in ) :: r !! Number of items to choose integer ( int64 ) :: c !! Binomial coefficient result integer ( default_int ) :: i !! Loop counter if ( r == 0 . or . r == n ) then c = 1_int64 else if ( r > n ) then c = 0_int64 else c = 1_int64 do i = 1 , r c = c * int ( n - i + 1 , int64 ) / int ( i , int64 ) end do end if end function binomial","tags":"","url":"proc/binomial.html"},{"title":"get_nfrags – metalquicha","text":"public pure function get_nfrags(n_monomers, max_level) result(n_expected_fragments) Calculate total number of fragments for given system size and max level Computes the sum of binomial coefficients C(n,k) for k=1 to max_level,\nrepresenting all possible fragments from monomers to max_level-mers.\nUses int64 to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n_monomers Number of monomers in system integer(kind=default_int), intent(in) :: max_level Maximum fragment size Return Value integer(kind=int64) Total fragment count Calls proc~~get_nfrags~~CallsGraph proc~get_nfrags get_nfrags proc~binomial binomial proc~get_nfrags->proc~binomial Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nfrags~~CalledByGraph proc~get_nfrags get_nfrags proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~get_nfrags proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i Loop counter Source Code pure function get_nfrags ( n_monomers , max_level ) result ( n_expected_fragments ) !! Calculate total number of fragments for given system size and max level !! !! Computes the sum of binomial coefficients C(n,k) for k=1 to max_level, !! representing all possible fragments from monomers to max_level-mers. !! Uses int64 to handle large fragment counts that overflow int32. integer ( default_int ), intent ( in ) :: n_monomers !! Number of monomers in system integer ( default_int ), intent ( in ) :: max_level !! Maximum fragment size integer ( int64 ) :: n_expected_fragments !! Total fragment count integer ( default_int ) :: i !! Loop counter n_expected_fragments = 0_int64 do i = 1 , max_level n_expected_fragments = n_expected_fragments + binomial ( n_monomers , i ) end do end function get_nfrags","tags":"","url":"proc/get_nfrags.html"},{"title":"next_combination – metalquicha","text":"public  function next_combination(combination, k, n) result(has_next) Generate next combination in lexicographic order\nReturns .true. if there’s a next combination, .false. if we’ve exhausted all Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k integer, intent(in) :: n Return Value logical Variables Type Visibility Attributes Name Initial integer, private :: i Source Code function next_combination ( combination , k , n ) result ( has_next ) !! Generate next combination in lexicographic order !! Returns .true. if there's a next combination, .false. if we've exhausted all integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k , n logical :: has_next integer :: i has_next = . true . ! Find the rightmost element that can be incremented i = k do while ( i >= 1 ) if ( combination ( i ) < n - k + i ) then combination ( i ) = combination ( i ) + 1 ! Reset all elements to the right do while ( i < k ) i = i + 1 combination ( i ) = combination ( i - 1 ) + 1 end do return end if i = i - 1 end do ! No more combinations has_next = . false . end function next_combination","tags":"","url":"proc/next_combination.html"},{"title":"combine – metalquicha","text":"public recursive subroutine combine(arr, n, r, out_array, count) Generate all combinations of size r from array arr of size n\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count Calls proc~~combine~~CallsGraph proc~combine combine proc~combine_util combine_util proc~combine->proc~combine_util proc~combine_util->proc~combine_util Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~combine~~CalledByGraph proc~combine combine proc~generate_fragment_list generate_fragment_list proc~generate_fragment_list->proc~combine proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~combine proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: data (r) Source Code recursive subroutine combine ( arr , n , r , out_array , count ) !! Generate all combinations of size r from array arr of size n !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:) integer ( default_int ), intent ( in ) :: n , r integer ( default_int ), intent ( inout ) :: out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: data ( r ) call combine_util ( arr , n , r , 1 , data , 1 , out_array , count ) end subroutine combine","tags":"","url":"proc/combine.html"},{"title":"create_monomer_list – metalquicha","text":"public pure subroutine create_monomer_list(monomers) Generate a list of monomer indices from 1 to N Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(inout), allocatable :: monomers (:) Called by proc~~create_monomer_list~~CalledByGraph proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~create_monomer_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: length Source Code pure subroutine create_monomer_list ( monomers ) !! Generate a list of monomer indices from 1 to N integer ( default_int ), allocatable , intent ( inout ) :: monomers (:) integer ( default_int ) :: i , length length = size ( monomers , 1 ) do i = 1 , length monomers ( i ) = i end do end subroutine create_monomer_list","tags":"","url":"proc/create_monomer_list.html"},{"title":"generate_fragment_list – metalquicha","text":"public recursive subroutine generate_fragment_list(monomers, max_level, polymers, count) Generate all possible fragments (combinations of monomers) up to max_level\nUses int64 for count to handle large numbers of fragments that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: monomers (:) integer(kind=default_int), intent(in) :: max_level integer(kind=default_int), intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: count Calls proc~~generate_fragment_list~~CallsGraph proc~generate_fragment_list generate_fragment_list proc~combine combine proc~generate_fragment_list->proc~combine proc~combine_util combine_util proc~combine->proc~combine_util proc~combine_util->proc~combine_util Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_fragment_list~~CalledByGraph proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: n integer(kind=default_int), private :: r Source Code recursive subroutine generate_fragment_list ( monomers , max_level , polymers , count ) !! Generate all possible fragments (combinations of monomers) up to max_level !! Uses int64 for count to handle large numbers of fragments that overflow int32. integer ( default_int ), intent ( in ) :: monomers (:), max_level integer ( default_int ), intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: r , n n = size ( monomers , 1 ) do r = 2 , max_level call combine ( monomers , n , r , polymers , count ) end do end subroutine generate_fragment_list","tags":"","url":"proc/generate_fragment_list.html"},{"title":"get_next_combination – metalquicha","text":"public pure subroutine get_next_combination(indices, k, n, has_next) Generate next combination (updates indices in place)\nhas_next = .true. if there’s a next combination Arguments Type Intent Optional Attributes Name integer, intent(inout) :: indices (:) integer, intent(in) :: k integer, intent(in) :: n logical, intent(out) :: has_next Called by proc~~get_next_combination~~CalledByGraph proc~get_next_combination get_next_combination proc~compute_mbe compute_mbe proc~compute_mbe->proc~get_next_combination proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~get_next_combination proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~compute_mbe proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine get_next_combination ( indices , k , n , has_next ) !! Generate next combination (updates indices in place) !! has_next = .true. if there's a next combination integer , intent ( inout ) :: indices (:) integer , intent ( in ) :: k , n logical , intent ( out ) :: has_next integer :: i has_next = . true . i = k do while ( i >= 1 ) if ( indices ( i ) < n - k + i ) then indices ( i ) = indices ( i ) + 1 do while ( i < k ) i = i + 1 indices ( i ) = indices ( i - 1 ) + 1 end do return end if i = i - 1 end do has_next = . false . end subroutine get_next_combination","tags":"","url":"proc/get_next_combination.html"},{"title":"next_combination_init – metalquicha","text":"public  subroutine next_combination_init(combination, k) Initialize combination to [1, 2, …, k] Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine next_combination_init ( combination , k ) !! Initialize combination to [1, 2, ..., k] integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k integer :: i do i = 1 , k combination ( i ) = i end do end subroutine next_combination_init","tags":"","url":"proc/next_combination_init.html"},{"title":"print_combos – metalquicha","text":"public  subroutine print_combos(out_array, count, max_len) Print combinations stored in out_array\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: out_array (:,:) integer(kind=int64), intent(in) :: count integer(kind=default_int), intent(in) :: max_len Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: i integer(kind=default_int), private :: j Source Code subroutine print_combos ( out_array , count , max_len ) !! Print combinations stored in out_array !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: out_array (:, :), max_len integer ( int64 ), intent ( in ) :: count integer ( int64 ) :: i integer ( default_int ) :: j do i = 1_int64 , count do j = 1 , max_len if ( out_array ( i , j ) == 0 ) exit write ( * , '(I0)' , advance = 'no' ) out_array ( i , j ) if ( j < max_len . and . out_array ( i , j + 1 ) /= 0 ) then write ( * , '(A)' , advance = 'no' ) \":\" end if end do write ( * , * ) ! newline end do end subroutine print_combos","tags":"","url":"proc/print_combos.html"},{"title":"combine_util – metalquicha","text":"private recursive subroutine combine_util(arr, n, r, index, data, i, out_array, count) Utility for generating combinations recursively\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(in) :: index integer(kind=default_int), intent(inout) :: data (:) integer(kind=default_int), intent(in) :: i integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count Called by proc~~combine_util~~CalledByGraph proc~combine_util combine_util proc~combine_util->proc~combine_util proc~combine combine proc~combine->proc~combine_util proc~generate_fragment_list generate_fragment_list proc~generate_fragment_list->proc~combine proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~combine proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: j Source Code recursive subroutine combine_util ( arr , n , r , index , data , i , out_array , count ) !! Utility for generating combinations recursively !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:), n , r , index , i integer ( default_int ), intent ( inout ) :: data (:), out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: j if ( index > r ) then count = count + 1_int64 out_array ( count , 1 : r ) = data ( 1 : r ) return end if do j = i , n data ( index ) = arr ( j ) call combine_util ( arr , n , r , index + 1 , data , j + 1 , out_array , count ) end do end subroutine combine_util","tags":"","url":"proc/combine_util.html"},{"title":"cc_total – metalquicha","text":"private pure function cc_total(this) result(total) Compute total CC correlation energy Type Bound cc_energy_t Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code pure function cc_total ( this ) result ( total ) !! Compute total CC correlation energy class ( cc_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % singles + this % doubles + this % triples end function cc_total","tags":"","url":"proc/cc_total.html"},{"title":"energy_total – metalquicha","text":"private pure function energy_total(this) result(total) Compute total energy from all components Type Bound energy_t Arguments Type Intent Optional Attributes Name class( energy_t ), intent(in) :: this Return Value real(kind=dp) Calls proc~~energy_total~~CallsGraph proc~energy_total energy_t%energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~energy_total~~CalledByGraph proc~energy_total energy_t%energy_total proc~compute_gmbe_energy compute_gmbe_energy proc~compute_gmbe_energy->proc~energy_total proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~energy_total proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~energy_total proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~energy_total proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~energy_total proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~energy_total proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~energy_total proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~energy_total proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator->proc~print_unfragmented_json proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_coordinator->proc~xtb_calc_gradient proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_energy->proc~energy_total proc~print_gmbe_json print_gmbe_json proc~print_gmbe_json->proc~energy_total proc~print_unfragmented_json->proc~energy_total proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~do_fragment_work do_fragment_work proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~print_unfragmented_json proc~unfragmented_calculation->proc~do_fragment_work proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~xtb_calc_energy->proc~energy_total proc~xtb_calc_gradient->proc~energy_total proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->proc~hessian_worker proc~do_fragment_work->proc~xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~hessian_worker->proc~xtb_calc_gradient proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_gradient->proc~hf_calc_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~global_coordinator proc~node_worker node_worker proc~run_fragmented_calculation->proc~node_worker proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~node_worker->proc~do_fragment_work proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function energy_total ( this ) result ( total ) !! Compute total energy from all components class ( energy_t ), intent ( in ) :: this real ( dp ) :: total ! this line needs to me modified if more components are added total = this % scf + this % mp2 % total () + this % cc % total () end function energy_total","tags":"","url":"proc/energy_total.html"},{"title":"mp2_scs – metalquicha","text":"private pure function mp2_scs(this) result(scs_energy) Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy\nSCS-MP2 uses: E_SCS = (1/3) E_SS + 1.2 E_OS Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Source Code pure function mp2_scs ( this ) result ( scs_energy ) !! Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy !! SCS-MP2 uses: E_SCS = (1/3)*E_SS + 1.2*E_OS class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: scs_energy scs_energy = SCS_SS_SCALE * this % ss + SCS_OS_SCALE * this % os end function mp2_scs","tags":"","url":"proc/mp2_scs.html"},{"title":"mp2_total – metalquicha","text":"private pure function mp2_total(this) result(total) Compute total MP2 correlation energy Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Called by proc~~mp2_total~~CalledByGraph proc~mp2_total mp2_energy_t%mp2_total proc~energy_total energy_t%energy_total proc~energy_total->proc~mp2_total proc~compute_gmbe_energy compute_gmbe_energy proc~compute_gmbe_energy->proc~energy_total proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~energy_total proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~energy_total proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~energy_total proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~energy_total proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~energy_total proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~energy_total proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~energy_total proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator->proc~print_unfragmented_json proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_coordinator->proc~xtb_calc_gradient proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_energy->proc~energy_total proc~print_gmbe_json print_gmbe_json proc~print_gmbe_json->proc~energy_total proc~print_unfragmented_json->proc~energy_total proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~do_fragment_work do_fragment_work proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~energy_total proc~unfragmented_calculation->proc~print_unfragmented_json proc~unfragmented_calculation->proc~do_fragment_work proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~xtb_calc_energy->proc~energy_total proc~xtb_calc_gradient->proc~energy_total proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->proc~hessian_worker proc~do_fragment_work->proc~xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~hessian_worker->proc~xtb_calc_gradient proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_gradient->proc~hf_calc_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~global_coordinator proc~node_worker node_worker proc~run_fragmented_calculation->proc~node_worker proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~node_worker->proc~do_fragment_work proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function mp2_total ( this ) result ( total ) !! Compute total MP2 correlation energy class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % ss + this % os end function mp2_total","tags":"","url":"proc/mp2_total.html"},{"title":"result_irecv – metalquicha","text":"public  subroutine result_irecv(result, comm, source, tag, req) Receive calculation result over MPI (non-blocking)\nReceives SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(request_t), intent(out) :: req Calls proc~~result_irecv~~CallsGraph proc~result_irecv result_irecv irecv irecv proc~result_irecv->irecv recv recv proc~result_irecv->recv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_irecv~~CalledByGraph proc~result_irecv result_irecv proc~global_coordinator global_coordinator proc~global_coordinator->proc~result_irecv proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~result_irecv proc~node_coordinator node_coordinator proc~node_coordinator->proc~result_irecv proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~node_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(MPI_Status), private :: status Source Code subroutine result_irecv ( result , comm , source , tag , req ) !! Receive calculation result over MPI (non-blocking) !! Receives SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( request_t ), intent ( out ) :: req type ( MPI_Status ) :: status ! Receive SCF energy (non-blocking) call irecv ( comm , result % energy % scf , source , tag , req ) ! Receive other energy components (blocking to avoid needing multiple request handles) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive gradient flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if end subroutine result_irecv","tags":"","url":"proc/result_irecv.html"},{"title":"result_isend – metalquicha","text":"public  subroutine result_isend(result, comm, dest, tag, req) Send calculation result over MPI (non-blocking)\nSends SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag type(request_t), intent(out) :: req Calls proc~~result_isend~~CallsGraph proc~result_isend result_isend isend isend proc~result_isend->isend send send proc~result_isend->send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_isend~~CalledByGraph proc~result_isend result_isend proc~node_coordinator node_coordinator proc~node_coordinator->proc~result_isend proc~node_worker node_worker proc~node_worker->proc~result_isend proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_coordinator proc~run_fragmented_calculation->proc~node_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_isend ( result , comm , dest , tag , req ) !! Send calculation result over MPI (non-blocking) !! Sends SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag type ( request_t ), intent ( out ) :: req ! Send SCF energy (non-blocking) call isend ( comm , result % energy % scf , dest , tag , req ) ! Send other energy components (blocking to avoid needing multiple request handles) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send gradient flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if ! Send Hessian flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_hessian , dest , tag ) if ( result % has_hessian ) then call send ( comm , result % hessian , dest , tag ) end if end subroutine result_isend","tags":"","url":"proc/result_isend.html"},{"title":"result_recv – metalquicha","text":"public  subroutine result_recv(result, comm, source, tag, status) Receive calculation result over MPI (blocking)\nReceives energy components and conditionally receives gradient based on flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(MPI_Status), intent(out) :: status Calls proc~~result_recv~~CallsGraph proc~result_recv result_recv recv recv proc~result_recv->recv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_recv ( result , comm , source , tag , status ) !! Receive calculation result over MPI (blocking) !! Receives energy components and conditionally receives gradient based on flag type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( MPI_Status ), intent ( out ) :: status ! Receive energy components call recv ( comm , result % energy % scf , source , tag , status ) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive gradient flag and data if present call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data if present call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if end subroutine result_recv","tags":"","url":"proc/result_recv.html"},{"title":"result_send – metalquicha","text":"public  subroutine result_send(result, comm, dest, tag) Send calculation result over MPI (blocking)\nSends energy components and conditionally sends gradient based on has_gradient flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag Calls proc~~result_send~~CallsGraph proc~result_send result_send send send proc~result_send->send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_send ( result , comm , dest , tag ) !! Send calculation result over MPI (blocking) !! Sends energy components and conditionally sends gradient based on has_gradient flag type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag ! Send energy components call send ( comm , result % energy % scf , dest , tag ) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send gradient flag and data if present call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if end subroutine result_send","tags":"","url":"proc/result_send.html"},{"title":"cc_check_stability – metalquicha","text":"private  subroutine cc_check_stability(this) Uses pic_logger proc~~cc_check_stability~~UsesGraph proc~cc_check_stability cc_energy_t%cc_check_stability pic_logger pic_logger proc~cc_check_stability->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Check for positive CC correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Type Bound cc_energy_t Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Calls proc~~cc_check_stability~~CallsGraph proc~cc_check_stability cc_energy_t%cc_check_stability warning warning proc~cc_check_stability->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine cc_check_stability ( this ) !! Check for positive CC correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( cc_energy_t ), intent ( in ) :: this if ( this % singles > 0.0_dp ) then call logger % warning ( \"CC singles correlation energy is positive - possible instability!\" ) end if if ( this % doubles > 0.0_dp ) then call logger % warning ( \"CC doubles correlation energy is positive - possible instability!\" ) end if if ( this % triples > 0.0_dp ) then call logger % warning ( \"CC triples correlation energy is positive - possible instability!\" ) end if end subroutine cc_check_stability","tags":"","url":"proc/cc_check_stability.html"},{"title":"cc_reset – metalquicha","text":"private  subroutine cc_reset(this) Reset all CC components to zero Type Bound cc_energy_t Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(inout) :: this Source Code subroutine cc_reset ( this ) !! Reset all CC components to zero class ( cc_energy_t ), intent ( inout ) :: this this % singles = 0.0_dp this % doubles = 0.0_dp this % triples = 0.0_dp end subroutine cc_reset","tags":"","url":"proc/cc_reset.html"},{"title":"energy_reset – metalquicha","text":"private  subroutine energy_reset(this) Reset all energy components to zero Type Bound energy_t Arguments Type Intent Optional Attributes Name class( energy_t ), intent(inout) :: this Calls proc~~energy_reset~~CallsGraph proc~energy_reset energy_t%energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~energy_reset~~CalledByGraph proc~energy_reset energy_t%energy_reset proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~energy_reset proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~result_reset calculation_result_t%result_reset proc~result_reset->proc~energy_reset proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~result_destroy calculation_result_t%result_destroy proc~result_destroy->proc~result_reset proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~unfragmented_calculation->proc~result_destroy proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~xtb_calc_hessian->proc~result_destroy proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine energy_reset ( this ) !! Reset all energy components to zero class ( energy_t ), intent ( inout ) :: this this % scf = 0.0_dp call this % mp2 % reset () call this % cc % reset () end subroutine energy_reset","tags":"","url":"proc/energy_reset.html"},{"title":"mp2_check_stability – metalquicha","text":"private  subroutine mp2_check_stability(this) Uses pic_logger proc~~mp2_check_stability~~UsesGraph proc~mp2_check_stability mp2_energy_t%mp2_check_stability pic_logger pic_logger proc~mp2_check_stability->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Check for positive MP2 correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Calls proc~~mp2_check_stability~~CallsGraph proc~mp2_check_stability mp2_energy_t%mp2_check_stability warning warning proc~mp2_check_stability->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mp2_check_stability ( this ) !! Check for positive MP2 correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( mp2_energy_t ), intent ( in ) :: this if ( this % ss > 0.0_dp ) then call logger % warning ( \"MP2 same-spin correlation energy is positive - possible instability!\" ) end if if ( this % os > 0.0_dp ) then call logger % warning ( \"MP2 opposite-spin correlation energy is positive - possible instability!\" ) end if end subroutine mp2_check_stability","tags":"","url":"proc/mp2_check_stability.html"},{"title":"mp2_reset – metalquicha","text":"private  subroutine mp2_reset(this) Reset both MP2 components to zero Type Bound mp2_energy_t Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(inout) :: this Called by proc~~mp2_reset~~CalledByGraph proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset energy_t%energy_reset proc~energy_reset->proc~mp2_reset proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~energy_reset proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~result_reset calculation_result_t%result_reset proc~result_reset->proc~energy_reset proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~result_destroy calculation_result_t%result_destroy proc~result_destroy->proc~result_reset proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~unfragmented_calculation->proc~result_destroy proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~xtb_calc_hessian->proc~result_destroy proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mp2_reset ( this ) !! Reset both MP2 components to zero class ( mp2_energy_t ), intent ( inout ) :: this this % ss = 0.0_dp this % os = 0.0_dp end subroutine mp2_reset","tags":"","url":"proc/mp2_reset.html"},{"title":"result_destroy – metalquicha","text":"private  subroutine result_destroy(this) Clean up allocated memory in calculation_result_t Type Bound calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Calls proc~~result_destroy~~CallsGraph proc~result_destroy calculation_result_t%result_destroy proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_destroy~~CalledByGraph proc~result_destroy calculation_result_t%result_destroy proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~result_destroy proc~do_fragment_work do_fragment_work proc~unfragmented_calculation->proc~do_fragment_work proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~result_destroy proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_worker proc~do_fragment_work->proc~xtb_calc_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_destroy ( this ) !! Clean up allocated memory in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % sigma )) deallocate ( this % sigma ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) call this % reset () end subroutine result_destroy","tags":"","url":"proc/result_destroy.html"},{"title":"result_reset – metalquicha","text":"private  subroutine result_reset(this) Reset all values and flags in calculation_result_t Type Bound calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Calls proc~~result_reset~~CallsGraph proc~result_reset calculation_result_t%result_reset proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_reset~~CalledByGraph proc~result_reset calculation_result_t%result_reset proc~result_destroy calculation_result_t%result_destroy proc~result_destroy->proc~result_reset proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~result_destroy proc~hessian_worker hessian_worker proc~hessian_worker->proc~result_destroy proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~result_destroy proc~do_fragment_work do_fragment_work proc~unfragmented_calculation->proc~do_fragment_work proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~result_destroy proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_worker proc~do_fragment_work->proc~xtb_calc_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_reset ( this ) !! Reset all values and flags in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this call this % energy % reset () this % has_energy = . false . this % has_gradient = . false . this % has_sigma = . false . this % has_hessian = . false . this % has_dipole = . false . end subroutine result_reset","tags":"","url":"proc/result_reset.html"},{"title":"get_frag_level_name – metalquicha","text":"private  function get_frag_level_name(frag_level) result(level_name) Map body level (n-mer) to descriptive name\nSupports up to decamers (10-mers), then falls back to “N-mers” format Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag_level Return Value character(len=32) Called by proc~~get_frag_level_name~~CalledByGraph proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown print_detailed_breakdown proc~print_detailed_breakdown->proc~get_frag_level_name proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~print_detailed_breakdown_json proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_frag_level_name ( frag_level ) result ( level_name ) !! Map body level (n-mer) to descriptive name !! Supports up to decamers (10-mers), then falls back to \"N-mers\" format integer , intent ( in ) :: frag_level character ( len = 32 ) :: level_name select case ( frag_level ) case ( 1 ) level_name = \"monomers\" case ( 2 ) level_name = \"dimers\" case ( 3 ) level_name = \"trimers\" case ( 4 ) level_name = \"tetramers\" case ( 5 ) level_name = \"pentamers\" case ( 6 ) level_name = \"hexamers\" case ( 7 ) level_name = \"heptamers\" case ( 8 ) level_name = \"octamers\" case ( 9 ) level_name = \"nonamers\" case ( 10 ) level_name = \"decamers\" case default ! For levels > 10, use generic format write ( level_name , '(i0,a)' ) frag_level , \"-mers\" end select end function get_frag_level_name","tags":"","url":"proc/get_frag_level_name.html"},{"title":"print_detailed_breakdown – metalquicha","text":"public  subroutine print_detailed_breakdown(polymers, fragment_count, max_level, energies, delta_energies) Print detailed energy breakdown for each fragment\nShows full energy and deltaE correction for all monomers, dimers, trimers, etc.\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) Calls proc~~print_detailed_breakdown~~CallsGraph proc~print_detailed_breakdown print_detailed_breakdown header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name verbose verbose proc~print_detailed_breakdown->verbose warning warning proc~print_detailed_breakdown->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_detailed_breakdown~~CalledByGraph proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~print_detailed_breakdown proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: count_by_level character(len=512), private :: energy_line integer, private :: frag_level integer, private :: fragment_size character(len=512), private :: fragment_str integer(kind=int64), private :: i integer, private :: j Source Code subroutine print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) !! Print detailed energy breakdown for each fragment !! Shows full energy and deltaE correction for all monomers, dimers, trimers, etc. !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) integer ( int64 ) :: i integer :: fragment_size , j , frag_level character ( len = 512 ) :: fragment_str , energy_line integer ( int64 ) :: count_by_level call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) call logger % verbose ( \"Detailed Energy Breakdown by Fragment\" ) call logger % verbose ( \"============================================\" ) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). Using generic N-mers notation.\" ) end if do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then call logger % verbose ( \" \" ) block character ( len = 256 ) :: header character ( len = 32 ) :: level_name level_name = get_frag_level_name ( frag_level ) write ( header , '(a,a,i0,a)' ) trim ( level_name ), \" (\" , count_by_level , \" fragments):\" ! Capitalize first letter if ( len_trim ( level_name ) > 0 ) then if ( level_name ( 1 : 1 ) >= 'a' . and . level_name ( 1 : 1 ) <= 'z' ) then header ( 1 : 1 ) = achar ( iachar ( header ( 1 : 1 )) - 32 ) end if end if call logger % verbose ( trim ( header )) end block call logger % verbose ( \"--------------------------------------------\" ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then fragment_str = \"[\" do j = 1 , fragment_size if ( j > 1 ) then write ( fragment_str , '(a,a,i0)' ) trim ( fragment_str ), \",\" , polymers ( i , j ) else write ( fragment_str , '(a,i0)' ) trim ( fragment_str ), polymers ( i , j ) end if end do write ( fragment_str , '(a,a)' ) trim ( fragment_str ), \"]\" if ( frag_level == 1 ) then write ( energy_line , '(a,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ) else write ( energy_line , '(a,a,f20.10,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ), & \"   deltaE: \" , delta_energies ( i ) end if call logger % verbose ( trim ( energy_line )) end if end do end if end do call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) end subroutine print_detailed_breakdown","tags":"","url":"proc/print_detailed_breakdown.html"},{"title":"print_detailed_breakdown_json – metalquicha","text":"public  subroutine print_detailed_breakdown_json(polymers, fragment_count, max_level, energies, delta_energies, sum_by_level, total_energy, total_gradient, total_hessian) Write detailed energy breakdown to results.json file\nOutputs structured JSON with all fragment energies and deltaE corrections\nOptionally includes total gradient and Hessian if provided\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) real(kind=dp), intent(in) :: sum_by_level (:) real(kind=dp), intent(in) :: total_energy real(kind=dp), intent(in), optional :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(in), optional :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) Calls proc~~print_detailed_breakdown_json~~CallsGraph proc~print_detailed_breakdown_json print_detailed_breakdown_json error error proc~print_detailed_breakdown_json->error info info proc~print_detailed_breakdown_json->info proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename warning warning proc~print_detailed_breakdown_json->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_detailed_breakdown_json~~CalledByGraph proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~print_detailed_breakdown_json proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename integer(kind=int64), private :: count_by_level logical, private :: first_fragment logical, private :: first_level integer, private :: frag_level integer, private :: fragment_size integer(kind=int64), private :: i integer, private :: iatom integer, private :: io_stat integer, private :: j character(len=512), private :: json_line character(len=32), private :: level_name character(len=256), private :: output_file integer, private :: total_atoms integer, private :: unit Source Code subroutine print_detailed_breakdown_json ( polymers , fragment_count , max_level , & energies , delta_energies , sum_by_level , total_energy , & total_gradient , total_hessian ) !! Write detailed energy breakdown to results.json file !! Outputs structured JSON with all fragment energies and deltaE corrections !! Optionally includes total gradient and Hessian if provided !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) real ( dp ), intent ( in ) :: sum_by_level (:), total_energy real ( dp ), intent ( in ), optional :: total_gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( in ), optional :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) integer ( int64 ) :: i integer :: fragment_size , j , frag_level , unit , io_stat , iatom character ( len = 512 ) :: json_line integer ( int64 ) :: count_by_level logical :: first_level , first_fragment character ( len = 32 ) :: level_name integer :: total_atoms character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing JSON output to \" // trim ( output_file )) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). JSON will use generic N-mers notation.\" ) end if write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '    \"levels\": [' first_level = . true . do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then if (. not . first_level ) then write ( unit , '(a)' ) '      },' end if first_level = . false . write ( unit , '(a)' ) '      {' level_name = get_frag_level_name ( frag_level ) write ( json_line , '(a,i0,a)' ) '        \"frag_level\": ' , frag_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,a,a)' ) '        \"name\": \"' , trim ( level_name ), '\",' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '        \"count\": ' , count_by_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '        \"total_energy\": ' , sum_by_level ( frag_level ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '        \"fragments\": [' first_fragment = . true . do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then if (. not . first_fragment ) then write ( unit , '(a)' ) '          },' end if first_fragment = . false . write ( unit , '(a)' ) '          {' json_line = '            \"indices\": [' do j = 1 , fragment_size if ( j > 1 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , polymers ( i , j ) else write ( json_line , '(a,i0)' ) trim ( json_line ), polymers ( i , j ) end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '            \"energy\": ' , energies ( i ) if ( frag_level > 1 ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '            \"delta_energy\": ' , delta_energies ( i ) end if write ( unit , '(a)' ) trim ( json_line ) end if end do if (. not . first_fragment ) then write ( unit , '(a)' ) '          }' end if write ( unit , '(a)' ) '        ]' end if end do if (. not . first_level ) then write ( unit , '(a)' ) '      }' end if ! Close levels array (with comma if we have more fields) if ( present ( total_gradient ) . or . present ( total_hessian )) then write ( unit , '(a)' ) '    ],' else write ( unit , '(a)' ) '    ]' end if ! Add gradient norm if present (inside basename object) if ( present ( total_gradient )) then write ( json_line , '(a,f20.10)' ) '    \"gradient_norm\": ' , sqrt ( sum ( total_gradient ** 2 )) if ( present ( total_hessian )) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian Frobenius norm if present (inside basename object) if ( present ( total_hessian )) then write ( json_line , '(a,f20.10)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( total_hessian ** 2 )) write ( unit , '(a)' ) trim ( json_line ) end if ! Close basename object write ( unit , '(a)' ) '  }' ! Close outer object write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine print_detailed_breakdown_json","tags":"","url":"proc/print_detailed_breakdown_json.html"},{"title":"print_fragment_xyz – metalquicha","text":"public  subroutine print_fragment_xyz(fragment_idx, phys_frag) Print fragment geometry in XYZ format Arguments Type Intent Optional Attributes Name integer, intent(in) :: fragment_idx type( physical_fragment_t ), intent(in) :: phys_frag Calls proc~~print_fragment_xyz~~CallsGraph proc~print_fragment_xyz print_fragment_xyz info info proc~print_fragment_xyz->info proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom to_char to_char proc~print_fragment_xyz->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_fragment_xyz~~CalledByGraph proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: coord_line integer, private :: i character(len=2), private :: symbol Source Code subroutine print_fragment_xyz ( fragment_idx , phys_frag ) !! Print fragment geometry in XYZ format integer , intent ( in ) :: fragment_idx type ( physical_fragment_t ), intent ( in ) :: phys_frag integer :: i character ( len = 2 ) :: symbol character ( len = 256 ) :: coord_line call logger % info ( \"=========================================\" ) call logger % info ( \" Fragment \" // to_char ( fragment_idx )) call logger % info ( \" Number of atoms: \" // to_char ( phys_frag % n_atoms )) call logger % info ( \" Coordinates in Angstroms:\" ) call logger % info ( \"-----------------------------------------\" ) do i = 1 , phys_frag % n_atoms symbol = element_number_to_symbol ( phys_frag % element_numbers ( i )) ! Convert from Bohr back to Angstroms for printing write ( coord_line , '(a2,3f15.8)' ) symbol , to_angstrom ( phys_frag % coordinates ( 1 : 3 , i )) call logger % info ( trim ( coord_line )) end do call logger % info ( \"=========================================\" ) end subroutine print_fragment_xyz","tags":"","url":"proc/print_fragment_xyz.html"},{"title":"print_gmbe_json – metalquicha","text":"public  subroutine print_gmbe_json(n_monomers, monomer_indices, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, total_energy) Write GMBE calculation results to output JSON file\nOutputs structured JSON with monomers, intersections, and total energy\nIntersection parameters are optional and should be omitted when n_intersections=0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_monomers integer, intent(in) :: monomer_indices (:) type( calculation_result_t ), intent(in) :: monomer_results (:) integer, intent(in) :: n_intersections type( calculation_result_t ), intent(in), optional :: intersection_results (:) integer, intent(in), optional :: intersection_sets (:,:) (n_monomers, n_intersections) integer, intent(in), optional :: intersection_levels (:) real(kind=dp), intent(in) :: total_energy Calls proc~~print_gmbe_json~~CallsGraph proc~print_gmbe_json print_gmbe_json error error proc~print_gmbe_json->error info info proc~print_gmbe_json->info proc~energy_total energy_t%energy_total proc~print_gmbe_json->proc~energy_total proc~get_basename get_basename proc~print_gmbe_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_json->proc~get_output_json_filename proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename logical, private :: first_intersection logical, private :: first_level integer, private :: i integer, private :: io_stat integer, private :: j character(len=512), private :: json_line integer, private :: k integer, private :: level_count integer, private :: max_level character(len=256), private :: output_file integer, private :: unit Source Code subroutine print_gmbe_json ( n_monomers , monomer_indices , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , total_energy ) !! Write GMBE calculation results to output JSON file !! Outputs structured JSON with monomers, intersections, and total energy !! Intersection parameters are optional and should be omitted when n_intersections=0 integer , intent ( in ) :: n_monomers integer , intent ( in ) :: monomer_indices (:) type ( calculation_result_t ), intent ( in ) :: monomer_results (:) integer , intent ( in ) :: n_intersections type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) integer , intent ( in ), optional :: intersection_sets (:, :) !! (n_monomers, n_intersections) integer , intent ( in ), optional :: intersection_levels (:) real ( dp ), intent ( in ) :: total_energy integer :: i , j , k , max_level , unit , io_stat character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename logical :: first_level , first_intersection integer :: level_count output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing GMBE JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) ! Monomers section write ( unit , '(a)' ) '    \"monomers\": {' write ( json_line , '(a,i0,a)' ) '      \"count\": ' , n_monomers , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"fragments\": [' do i = 1 , n_monomers write ( unit , '(a)' ) '        {' write ( json_line , '(a,i0,a)' ) '          \"index\": ' , monomer_indices ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '          \"energy\": ' , monomer_results ( i )% energy % total () write ( unit , '(a)' ) trim ( json_line ) if ( i < n_monomers ) then write ( unit , '(a)' ) '        },' else write ( unit , '(a)' ) '        }' end if end do write ( unit , '(a)' ) '      ]' ! Add comma after monomers if we have intersections if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then write ( unit , '(a)' ) '    },' else write ( unit , '(a)' ) '    }' end if ! Intersections section if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then max_level = maxval ( intersection_levels ) write ( unit , '(a)' ) '    \"intersections\": {' write ( json_line , '(a,i0,a)' ) '      \"total_count\": ' , n_intersections , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"levels\": [' first_level = . true . do k = 2 , max_level ! Count intersections at this level level_count = 0 do i = 1 , n_intersections if ( intersection_levels ( i ) == k ) level_count = level_count + 1 end do if ( level_count > 0 ) then if (. not . first_level ) then write ( unit , '(a)' ) '        },' end if first_level = . false . write ( unit , '(a)' ) '        {' write ( json_line , '(a,i0,a)' ) '          \"level\": ' , k , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '          \"count\": ' , level_count , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '          \"fragments\": [' first_intersection = . true . do i = 1 , n_intersections if ( intersection_levels ( i ) == k ) then if (. not . first_intersection ) then write ( unit , '(a)' ) '            },' end if first_intersection = . false . write ( unit , '(a)' ) '            {' ! Write indices json_line = '              \"indices\": [' do j = 1 , n_monomers if ( intersection_sets ( j , i ) > 0 ) then if ( j > 1 . and . intersection_sets ( j - 1 , i ) > 0 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , intersection_sets ( j , i ) else write ( json_line , '(a,i0)' ) trim ( json_line ), intersection_sets ( j , i ) end if end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '              \"energy\": ' , intersection_results ( i )% energy % total () write ( unit , '(a)' ) trim ( json_line ) end if end do if (. not . first_intersection ) then write ( unit , '(a)' ) '            }' end if write ( unit , '(a)' ) '          ]' end if end do if (. not . first_level ) then write ( unit , '(a)' ) '        }' end if write ( unit , '(a)' ) '      ]' write ( unit , '(a)' ) '    }' end if write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"GMBE JSON output written successfully to \" // trim ( output_file )) end subroutine print_gmbe_json","tags":"","url":"proc/print_gmbe_json.html"},{"title":"print_gmbe_pie_json – metalquicha","text":"public  subroutine print_gmbe_pie_json(pie_atom_sets, pie_coefficients, pie_energies, n_pie_terms, total_energy, total_gradient, total_hessian) Write GMBE PIE calculation results to output JSON file\nOutputs structured JSON with PIE terms (atom sets with coefficients and energies)\nOptionally includes total gradient and Hessian norms Arguments Type Intent Optional Attributes Name integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term real(kind=dp), intent(in) :: pie_energies (:) Raw energy for each term integer, intent(in) :: n_pie_terms real(kind=dp), intent(in) :: total_energy real(kind=dp), intent(in), optional :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(in), optional :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) Calls proc~~print_gmbe_pie_json~~CallsGraph proc~print_gmbe_pie_json print_gmbe_pie_json error error proc~print_gmbe_pie_json->error info info proc~print_gmbe_pie_json->info proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_pie_json->proc~get_output_json_filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_gmbe_pie_json~~CalledByGraph proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename logical, private :: first_term integer, private :: i integer, private :: io_stat integer, private :: j character(len=512), private :: json_line integer, private :: max_atoms integer, private :: n_atoms integer, private :: n_nonzero_terms character(len=256), private :: output_file integer, private :: unit Source Code subroutine print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) !! Write GMBE PIE calculation results to output JSON file !! Outputs structured JSON with PIE terms (atom sets with coefficients and energies) !! Optionally includes total gradient and Hessian norms integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term real ( dp ), intent ( in ) :: pie_energies (:) !! Raw energy for each term integer , intent ( in ) :: n_pie_terms real ( dp ), intent ( in ) :: total_energy real ( dp ), intent ( in ), optional :: total_gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( in ), optional :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) integer :: i , j , max_atoms , n_atoms integer :: unit , io_stat integer :: n_nonzero_terms logical :: first_term character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing GMBE PIE JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) ! Add gradient if present if ( present ( total_gradient )) then write ( json_line , '(a,f20.10,a)' ) '    \"gradient_norm\": ' , sqrt ( sum ( total_gradient ** 2 )), ',' write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian if present if ( present ( total_hessian )) then write ( json_line , '(a,f20.10,a)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( total_hessian ** 2 )), ',' write ( unit , '(a)' ) trim ( json_line ) end if ! PIE terms section ! First count non-zero coefficient terms n_nonzero_terms = 0 do i = 1 , n_pie_terms if ( pie_coefficients ( i ) /= 0 ) n_nonzero_terms = n_nonzero_terms + 1 end do write ( unit , '(a)' ) '    \"pie_terms\": {' write ( json_line , '(a,i0,a)' ) '      \"count\": ' , n_nonzero_terms , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"terms\": [' max_atoms = size ( pie_atom_sets , 1 ) first_term = . true . do i = 1 , n_pie_terms ! Skip terms with zero coefficient if ( pie_coefficients ( i ) == 0 ) cycle if (. not . first_term ) write ( unit , '(a)' ) '        },' first_term = . false . write ( unit , '(a)' ) '        {' ! Extract atom list size n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , i ) >= 0 ) n_atoms = n_atoms + 1 end do ! Write atom indices json_line = '          \"atom_indices\": [' do j = 1 , n_atoms if ( j > 1 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , pie_atom_sets ( j , i ) else write ( json_line , '(a,i0)' ) trim ( json_line ), pie_atom_sets ( j , i ) end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '          \"coefficient\": ' , pie_coefficients ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '          \"energy\": ' , pie_energies ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '          \"weighted_energy\": ' , & real ( pie_coefficients ( i ), dp ) * pie_energies ( i ) write ( unit , '(a)' ) trim ( json_line ) end do if (. not . first_term ) write ( unit , '(a)' ) '        }' write ( unit , '(a)' ) '      ]' write ( unit , '(a)' ) '    }' write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"GMBE PIE JSON output written successfully to \" // trim ( output_file )) end subroutine print_gmbe_pie_json","tags":"","url":"proc/print_gmbe_pie_json.html"},{"title":"print_unfragmented_json – metalquicha","text":"public  subroutine print_unfragmented_json(result) Write unfragmented calculation results to output JSON file\nOutputs structured JSON with energy and optionally gradient Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result Calls proc~~print_unfragmented_json~~CallsGraph proc~print_unfragmented_json print_unfragmented_json error error proc~print_unfragmented_json->error info info proc~print_unfragmented_json->info proc~energy_total energy_t%energy_total proc~print_unfragmented_json->proc~energy_total proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_unfragmented_json~~CalledByGraph proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~print_unfragmented_json proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~print_unfragmented_json proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename integer, private :: iatom integer, private :: io_stat character(len=512), private :: json_line character(len=256), private :: output_file integer, private :: total_atoms integer, private :: unit Source Code subroutine print_unfragmented_json ( result ) !! Write unfragmented calculation results to output JSON file !! Outputs structured JSON with energy and optionally gradient type ( calculation_result_t ), intent ( in ) :: result integer :: unit , io_stat , iatom , total_atoms character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) if ( result % has_energy ) then write ( json_line , '(a,f25.15)' ) '    \"total_energy\": ' , result % energy % total () if ( result % has_gradient . or . result % has_hessian ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add gradient norm if present if ( result % has_gradient ) then write ( json_line , '(a,f25.15)' ) '    \"gradient_norm\": ' , sqrt ( sum ( result % gradient ** 2 )) if ( result % has_hessian ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian Frobenius norm if present if ( result % has_hessian ) then write ( json_line , '(a,f25.15)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( result % hessian ** 2 )) write ( unit , '(a)' ) trim ( json_line ) end if write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine print_unfragmented_json","tags":"","url":"proc/print_unfragmented_json.html"},{"title":"element_mass – metalquicha","text":"public pure function element_mass(atomic_number) result(mass) Return atomic mass in atomic mass units (amu) for a given atomic number\nUses standard atomic weights from IUPAC Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value real(kind=dp) Called by proc~~element_mass~~CalledByGraph proc~element_mass element_mass proc~fragment_center_of_mass fragment_center_of_mass proc~fragment_center_of_mass->proc~element_mass proc~distance_between_fragments distance_between_fragments proc~distance_between_fragments->proc~fragment_center_of_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function element_mass ( atomic_number ) result ( mass ) !! Return atomic mass in atomic mass units (amu) for a given atomic number !! Uses standard atomic weights from IUPAC integer , intent ( in ) :: atomic_number real ( dp ) :: mass select case ( atomic_number ) case ( 1 : 118 ) mass = element_masses ( atomic_number ) case default mass = 0.0_dp ! Unknown element end select end function element_mass","tags":"","url":"proc/element_mass.html"},{"title":"element_number_to_symbol – metalquicha","text":"public pure function element_number_to_symbol(atomic_number) result(symbol) Convert atomic number to element symbol\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value character(len=2) Called by proc~~element_number_to_symbol~~CalledByGraph proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms check_duplicate_atoms proc~check_duplicate_atoms->proc~element_number_to_symbol proc~print_fragment_xyz print_fragment_xyz proc~print_fragment_xyz->proc~element_number_to_symbol proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~do_fragment_work proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~build_fragment_from_indices proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~build_fragment_from_indices proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~node_worker->proc~do_fragment_work proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~do_fragment_work proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function element_number_to_symbol ( atomic_number ) result ( symbol ) !! Convert atomic number to element symbol !! Covers the complete periodic table (elements 1-118) integer , intent ( in ) :: atomic_number character ( len = 2 ) :: symbol select case ( atomic_number ) case ( 1 : 118 ) symbol = element_symbols ( atomic_number ) case default symbol = 'Xx' ! Unknown end select end function element_number_to_symbol","tags":"","url":"proc/element_number_to_symbol.html"},{"title":"element_symbol_to_number – metalquicha","text":"public pure function element_symbol_to_number(symbol) result(atomic_number) Convert element symbol to atomic number\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Return Value integer Calls proc~~element_symbol_to_number~~CallsGraph proc~element_symbol_to_number element_symbol_to_number to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~element_symbol_to_number~~CalledByGraph proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~element_symbol_to_number proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=2), private :: sym Source Code pure function element_symbol_to_number ( symbol ) result ( atomic_number ) !! Convert element symbol to atomic number !! Covers the complete periodic table (elements 1-118) character ( len =* ), intent ( in ) :: symbol integer :: atomic_number character ( len = 2 ) :: sym ! Normalize: uppercase first letter, lowercase second sym = adjustl ( symbol ) if ( len_trim ( sym ) >= 1 ) sym ( 1 : 1 ) = to_upper ( sym ( 1 : 1 )) if ( len_trim ( sym ) >= 2 ) sym ( 2 : 2 ) = to_lower ( sym ( 2 : 2 )) ! Search for symbol in table atomic_number = findloc ( element_symbols , sym , dim = 1 ) end function element_symbol_to_number","tags":"","url":"proc/element_symbol_to_number.html"},{"title":"parse_method_string – metalquicha","text":"private  function parse_method_string(method_str) result(method_type) Parse method string from input file (e.g., “XTB-GFN1” -> gfn1) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Return Value integer(kind=int32) Calls proc~~parse_method_string~~CallsGraph proc~parse_method_string parse_method_string proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_method_string~~CalledByGraph proc~parse_method_string parse_method_string proc~parse_model_section parse_model_section proc~parse_model_section->proc~parse_method_string proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_model_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: dash_pos integer, private :: i character(len=:), private, allocatable :: lower_str character(len=:), private, allocatable :: method_part Source Code function parse_method_string ( method_str ) result ( method_type ) !! Parse method string from input file (e.g., \"XTB-GFN1\" -> gfn1) character ( len =* ), intent ( in ) :: method_str integer ( int32 ) :: method_type character ( len = :), allocatable :: lower_str , method_part integer :: dash_pos , i ! Convert to lowercase allocate ( character ( len = len_trim ( method_str )) :: lower_str ) lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Handle \"XTB-GFN1\" format -> extract \"gfn1\" if ( index ( lower_str , 'xtb' ) > 0 ) then dash_pos = index ( lower_str , '-' ) if ( dash_pos > 0 ) then method_part = lower_str ( dash_pos + 1 :) else method_part = lower_str end if else method_part = lower_str end if method_type = method_type_from_string ( method_part ) end function parse_method_string","tags":"","url":"proc/parse_method_string.html"},{"title":"strip_comment – metalquicha","text":"private pure function strip_comment(line) result(stripped) Remove comments (! or #) from a line and trim result Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value character(len=:), allocatable Called by proc~~strip_comment~~CalledByGraph proc~strip_comment strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~parse_driver_section parse_driver_section proc~parse_driver_section->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragment->proc~strip_comment proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~strip_comment proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~strip_comment proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_generic->proc~skip_to_end proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_generic->proc~strip_comment proc~parse_model_section parse_model_section proc~parse_model_section->proc~strip_comment proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~strip_comment proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~skip_to_end proc~parse_scf_section parse_scf_section proc~parse_scf_section->proc~strip_comment proc~parse_schema_section parse_schema_section proc~parse_schema_section->proc~strip_comment proc~parse_single_molecule->proc~strip_comment proc~parse_single_molecule->proc~skip_to_end proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic parse_structure_generic proc~parse_structure_generic->proc~strip_comment proc~parse_system_section parse_system_section proc~parse_system_section->proc~strip_comment proc~skip_to_end->proc~strip_comment proc~parse_connectivity_section parse_connectivity_section proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_section parse_geometry_section proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_structure_section parse_structure_section proc~parse_structure_section->proc~parse_structure_generic proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_driver_section proc~read_mqc_file->proc~parse_fragmentation_section proc~read_mqc_file->proc~parse_model_section proc~read_mqc_file->proc~parse_molecules_section proc~read_mqc_file->proc~parse_scf_section proc~read_mqc_file->proc~parse_schema_section proc~read_mqc_file->proc~parse_system_section proc~read_mqc_file->proc~skip_to_end proc~read_mqc_file->proc~parse_connectivity_section proc~read_mqc_file->proc~parse_fragments_section proc~read_mqc_file->proc~parse_geometry_section proc~read_mqc_file->proc~parse_structure_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: comment_pos Source Code pure function strip_comment ( line ) result ( stripped ) !! Remove comments (! or #) from a line and trim result character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: stripped integer :: comment_pos ! Find first occurrence of ! or # comment_pos = index ( line , '!' ) if ( comment_pos == 0 ) comment_pos = index ( line , '#' ) if ( comment_pos > 0 ) then ! Comment found - take everything before it stripped = trim ( adjustl ( line ( 1 : comment_pos - 1 ))) else ! No comment - use full line stripped = trim ( adjustl ( line )) end if end function strip_comment","tags":"","url":"proc/strip_comment.html"},{"title":"read_mqc_file – metalquicha","text":"public  subroutine read_mqc_file(filename, config, error) Read and parse a .mqc format input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( mqc_config_t ), intent(out) :: config type( error_t ), intent(out) :: error Calls proc~~read_mqc_file~~CallsGraph proc~read_mqc_file read_mqc_file proc~error_has_error error_t%error_has_error proc~read_mqc_file->proc~error_has_error proc~error_set error_t%error_set proc~read_mqc_file->proc~error_set proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_driver_section parse_driver_section proc~read_mqc_file->proc~parse_driver_section proc~parse_fragmentation_section parse_fragmentation_section proc~read_mqc_file->proc~parse_fragmentation_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_geometry_section parse_geometry_section proc~read_mqc_file->proc~parse_geometry_section proc~parse_model_section parse_model_section proc~read_mqc_file->proc~parse_model_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_scf_section parse_scf_section proc~read_mqc_file->proc~parse_scf_section proc~parse_schema_section parse_schema_section proc~read_mqc_file->proc~parse_schema_section proc~parse_structure_section parse_structure_section proc~read_mqc_file->proc~parse_structure_section proc~parse_system_section parse_system_section proc~read_mqc_file->proc~parse_system_section proc~skip_to_end skip_to_end proc~read_mqc_file->proc~skip_to_end proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_driver_section->proc~error_set proc~calc_type_from_string calc_type_from_string proc~parse_driver_section->proc~calc_type_from_string proc~strip_comment strip_comment proc~parse_driver_section->proc~strip_comment proc~parse_fragmentation_section->proc~error_set proc~parse_fragmentation_section->proc~strip_comment proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_model_section->proc~error_set proc~parse_method_string parse_method_string proc~parse_model_section->proc~parse_method_string proc~parse_model_section->proc~strip_comment proc~parse_molecules_section->proc~error_has_error proc~parse_molecules_section->proc~error_set proc~parse_molecules_section->proc~skip_to_end proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~strip_comment proc~parse_scf_section->proc~error_set proc~parse_scf_section->proc~strip_comment proc~parse_schema_section->proc~error_set proc~parse_schema_section->proc~strip_comment proc~parse_structure_generic parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~parse_system_section->proc~error_set proc~parse_system_section->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string proc~parse_single_molecule->proc~error_has_error proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_single_molecule->proc~strip_comment proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_mqc_file~~CalledByGraph proc~read_mqc_file read_mqc_file program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: file_exists integer, private :: io_stat character(len=MAX_LINE_LEN), private :: line type( error_t ), private :: parse_error integer, private :: unit Source Code subroutine read_mqc_file ( filename , config , error ) !! Read and parse a .mqc format input file character ( len =* ), intent ( in ) :: filename type ( mqc_config_t ), intent ( out ) :: config type ( error_t ), intent ( out ) :: error integer :: unit , io_stat character ( len = MAX_LINE_LEN ) :: line logical :: file_exists type ( error_t ) :: parse_error inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"Input file not found: \" // trim ( filename )) return end if open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening input file: \" // trim ( filename )) return end if ! Set defaults config % log_level = \"info\" ! Read file line by line and dispatch to section parsers do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for section start if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%schema' ) call parse_schema_section ( unit , config , parse_error ) case ( '%model' ) call parse_model_section ( unit , config , parse_error ) case ( '%driver' ) call parse_driver_section ( unit , config , parse_error ) case ( '%structure' ) call parse_structure_section ( unit , config , parse_error ) case ( '%geometry' ) call parse_geometry_section ( unit , config , parse_error ) case ( '%fragments' ) call parse_fragments_section ( unit , config , parse_error ) case ( '%connectivity' ) call parse_connectivity_section ( unit , config , parse_error ) case ( '%scf' ) call parse_scf_section ( unit , config , parse_error ) case ( '%fragmentation' ) call parse_fragmentation_section ( unit , config , parse_error ) case ( '%system' ) call parse_system_section ( unit , config , parse_error ) case ( '%molecules' ) call parse_molecules_section ( unit , config , parse_error ) case default ! Skip unknown sections call skip_to_end ( unit , parse_error ) end select if ( parse_error % has_error ()) then error = parse_error close ( unit ) return end if end if end do close ( unit ) ! Validate required fields if (. not . allocated ( config % schema_name )) then call error % set ( ERROR_VALIDATION , \"Missing required section: %schema\" ) return end if ! Validate geometry: required for single-molecule mode, not for multi-molecule mode if ( config % nmol == 0 ) then ! Single molecule mode: require top-level geometry if (. not . allocated ( config % geometry % coords ) . or . config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"Missing required section: %geometry\" ) return end if else ! Multi-molecule mode: each molecule must have geometry (validated during parsing) ! No additional validation needed here end if end subroutine read_mqc_file","tags":"","url":"proc/read_mqc_file.html"},{"title":"config_destroy – metalquicha","text":"private  subroutine config_destroy(this) Clean up allocated memory in mqc_config_t Type Bound mqc_config_t Arguments Type Intent Optional Attributes Name class( mqc_config_t ), intent(inout) :: this Calls proc~~config_destroy~~CallsGraph proc~config_destroy mqc_config_t%config_destroy proc~geometry_destroy geometry_type%geometry_destroy proc~config_destroy->proc~geometry_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine config_destroy ( this ) !! Clean up allocated memory in mqc_config_t class ( mqc_config_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % schema_name )) deallocate ( this % schema_name ) if ( allocated ( this % schema_version )) deallocate ( this % schema_version ) if ( allocated ( this % units )) deallocate ( this % units ) if ( allocated ( this % basis )) deallocate ( this % basis ) if ( allocated ( this % aux_basis )) deallocate ( this % aux_basis ) if ( allocated ( this % log_level )) deallocate ( this % log_level ) if ( allocated ( this % frag_method )) deallocate ( this % frag_method ) if ( allocated ( this % embedding )) deallocate ( this % embedding ) if ( allocated ( this % cutoff_method )) deallocate ( this % cutoff_method ) if ( allocated ( this % distance_metric )) deallocate ( this % distance_metric ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) ! Clean up molecules array (multi-molecule mode) if ( allocated ( this % molecules )) then do i = 1 , size ( this % molecules ) call this % molecules ( i )% destroy () end do deallocate ( this % molecules ) end if end subroutine config_destroy","tags":"","url":"proc/config_destroy.html"},{"title":"input_fragment_destroy – metalquicha","text":"private  subroutine input_fragment_destroy(this) Clean up allocated memory in input_fragment_t Type Bound input_fragment_t Arguments Type Intent Optional Attributes Name class( input_fragment_t ), intent(inout) :: this Source Code subroutine input_fragment_destroy ( this ) !! Clean up allocated memory in input_fragment_t class ( input_fragment_t ), intent ( inout ) :: this if ( allocated ( this % indices )) deallocate ( this % indices ) end subroutine input_fragment_destroy","tags":"","url":"proc/input_fragment_destroy.html"},{"title":"molecule_destroy – metalquicha","text":"private  subroutine molecule_destroy(this) Clean up allocated memory in molecule_t Type Bound molecule_t Arguments Type Intent Optional Attributes Name class( molecule_t ), intent(inout) :: this Calls proc~~molecule_destroy~~CallsGraph proc~molecule_destroy molecule_t%molecule_destroy proc~geometry_destroy geometry_type%geometry_destroy proc~molecule_destroy->proc~geometry_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine molecule_destroy ( this ) !! Clean up allocated memory in molecule_t class ( molecule_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % name )) deallocate ( this % name ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) end subroutine molecule_destroy","tags":"","url":"proc/molecule_destroy.html"},{"title":"parse_connectivity_generic – metalquicha","text":"private  subroutine parse_connectivity_generic(unit, nbonds, nbroken, bonds, error) Generic parser for %connectivity section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nbonds integer, intent(inout) :: nbroken type( bond_t ), intent(inout), allocatable :: bonds (:) type( error_t ), intent(out) :: error Calls proc~~parse_connectivity_generic~~CallsGraph proc~parse_connectivity_generic parse_connectivity_generic proc~error_set error_t%error_set proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_connectivity_generic~~CalledByGraph proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section parse_connectivity_section proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_connectivity proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_connectivity_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_i integer, private :: atom_j integer, private :: eq_pos integer, private :: ibond integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line integer, private :: nbonds_local integer, private :: order character(len=MAX_LINE_LEN), private :: status_str character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_connectivity_generic ( unit , nbonds , nbroken , bonds , error ) !! Generic parser for %connectivity section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nbonds , nbroken type ( bond_t ), allocatable , intent ( inout ) :: bonds (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value , status_str integer :: io_stat , eq_pos , nbonds_local , ibond integer :: atom_i , atom_j , order nbonds_local = 0 ! First pass: read nbonds do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %connectivity section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbonds' ) then read ( value , * , iostat = io_stat ) nbonds_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nbonds value\" ) return end if exit end if end if end do if ( nbonds_local == 0 ) then ! No bonds, just skip to end call skip_to_end ( unit , error ) return end if nbonds = nbonds_local allocate ( bonds ( nbonds )) ! Read bonds ibond = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for key=value pairs (like nbroken=9) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbroken' ) then read ( value , * , iostat = io_stat ) nbroken end if cycle end if if ( trim ( strip_comment ( line )) == 'end' ) exit ! Parse bond line: atom_i atom_j order broken/preserved read ( line , * , iostat = io_stat ) atom_i , atom_j , order , status_str if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid bond format in %connectivity section\" ) return end if ibond = ibond + 1 if ( ibond > nbonds ) then call error % set ( ERROR_PARSE , \"More bonds than declared nbonds\" ) return end if bonds ( ibond )% atom_i = atom_i bonds ( ibond )% atom_j = atom_j bonds ( ibond )% order = order bonds ( ibond )% is_broken = ( trim ( status_str ) == 'broken' ) end do end subroutine parse_connectivity_generic","tags":"","url":"proc/parse_connectivity_generic.html"},{"title":"parse_connectivity_section – metalquicha","text":"private  subroutine parse_connectivity_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_connectivity_section~~CallsGraph proc~parse_connectivity_section parse_connectivity_section proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section->proc~parse_connectivity_generic proc~error_set error_t%error_set proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_connectivity_section~~CalledByGraph proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_connectivity_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_connectivity_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , config % nbonds , config % nbroken , config % bonds , error ) end subroutine parse_connectivity_section","tags":"","url":"proc/parse_connectivity_section.html"},{"title":"parse_driver_section – metalquicha","text":"private  subroutine parse_driver_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_driver_section~~CallsGraph proc~parse_driver_section parse_driver_section proc~calc_type_from_string calc_type_from_string proc~parse_driver_section->proc~calc_type_from_string proc~error_set error_t%error_set proc~parse_driver_section->proc~error_set proc~strip_comment strip_comment proc~parse_driver_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_driver_section~~CalledByGraph proc~parse_driver_section parse_driver_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_driver_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_driver_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %driver section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'type' ) config % calc_type = calc_type_from_string ( trim ( value )) if ( config % calc_type == CALC_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid calc_type: \" // trim ( value )) return end if case default call error % set ( ERROR_PARSE , \"Unknown key in %driver section: \" // trim ( key )) return end select end do end subroutine parse_driver_section","tags":"","url":"proc/parse_driver_section.html"},{"title":"parse_fragment – metalquicha","text":"private  subroutine parse_fragment(unit, fragment, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error Calls proc~~parse_fragment~~CallsGraph proc~parse_fragment parse_fragment proc~error_has_error error_t%error_has_error proc~parse_fragment->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragment->proc~error_set proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~strip_comment strip_comment proc~parse_fragment->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragment~~CalledByGraph proc~parse_fragment parse_fragment proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments parse_molecule_fragments proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos logical, private :: in_indices integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_fragment ( unit , fragment , error ) integer , intent ( in ) :: unit type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_indices in_indices = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragment\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_indices ) then in_indices = . false . cycle else exit end if end if if ( trim ( line ) == '%indices' ) then in_indices = . true . cycle end if if ( in_indices ) then ! Read indices call parse_indices_line ( line , fragment , error ) if ( error % has_error ()) return else eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) fragment % charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) fragment % multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in fragment properties: \" // trim ( key )) return end select end if end if end do end subroutine parse_fragment","tags":"","url":"proc/parse_fragment.html"},{"title":"parse_fragmentation_section – metalquicha","text":"private  subroutine parse_fragmentation_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_fragmentation_section~~CallsGraph proc~parse_fragmentation_section parse_fragmentation_section proc~error_set error_t%error_set proc~parse_fragmentation_section->proc~error_set proc~strip_comment strip_comment proc~parse_fragmentation_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragmentation_section~~CalledByGraph proc~parse_fragmentation_section parse_fragmentation_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragmentation_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos logical, private :: in_cutoffs integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_fragmentation_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_cutoffs in_cutoffs = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragmentation section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_cutoffs ) then in_cutoffs = . false . cycle else exit end if end if if ( trim ( line ) == '%cutoffs' ) then in_cutoffs = . true . cycle end if eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( in_cutoffs ) then select case ( trim ( key )) case ( 'dimer' ) read ( value , * , iostat = io_stat ) config % dimer_cutoff case ( 'trimer' ) read ( value , * , iostat = io_stat ) config % trimer_cutoff case default call error % set ( ERROR_PARSE , \"Unknown key in %fragmentation cutoffs subsection: \" // trim ( key )) return end select else select case ( trim ( key )) case ( 'method' ) config % frag_method = trim ( value ) case ( 'level' ) read ( value , * , iostat = io_stat ) config % frag_level case ( 'allow_overlapping_fragments' ) config % allow_overlapping_fragments = ( trim ( value ) == 'true' ) case ( 'max_intersection_level' ) read ( value , * , iostat = io_stat ) config % max_intersection_level case ( 'embedding' ) config % embedding = trim ( value ) case ( 'cutoff_method' ) config % cutoff_method = trim ( value ) case ( 'distance_metric' ) config % distance_metric = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %fragmentation section: \" // trim ( key )) return end select end if end do end subroutine parse_fragmentation_section","tags":"","url":"proc/parse_fragmentation_section.html"},{"title":"parse_fragments_generic – metalquicha","text":"private  subroutine parse_fragments_generic(unit, nfrag, fragments, error) Generic parser for %fragments section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nfrag type( input_fragment_t ), intent(inout), allocatable :: fragments (:) type( error_t ), intent(out) :: error Calls proc~~parse_fragments_generic~~CallsGraph proc~parse_fragments_generic parse_fragments_generic proc~error_has_error error_t%error_has_error proc~parse_fragments_generic->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragments_generic->proc~error_set proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~skip_to_end skip_to_end proc~parse_fragments_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragments_generic~~CalledByGraph proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments parse_molecule_fragments proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: ifrag integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=256), private :: msg integer, private :: nfrag_local character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_fragments_generic ( unit , nfrag , fragments , error ) !! Generic parser for %fragments section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nfrag type ( input_fragment_t ), allocatable , intent ( inout ) :: fragments (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nfrag_local , ifrag nfrag_local = 0 ! First pass: read nfrag do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragments section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nfrag' ) then read ( value , * , iostat = io_stat ) nfrag_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nfrag value\" ) return end if exit end if end if end do if ( nfrag_local == 0 ) then ! No fragments, just skip to end call skip_to_end ( unit , error ) return end if nfrag = nfrag_local allocate ( fragments ( nfrag )) ! Parse individual fragments ifrag = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%fragment' ) then ifrag = ifrag + 1 if ( ifrag > nfrag ) then call error % set ( ERROR_PARSE , \"More fragments than declared nfrag\" ) return end if call parse_fragment ( unit , fragments ( ifrag ), error ) if ( error % has_error ()) return end if end do if ( ifrag /= nfrag ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nfrag , \" fragments, found \" , ifrag call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_fragments_generic","tags":"","url":"proc/parse_fragments_generic.html"},{"title":"parse_fragments_section – metalquicha","text":"private  subroutine parse_fragments_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_fragments_section~~CallsGraph proc~parse_fragments_section parse_fragments_section proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~error_has_error error_t%error_has_error proc~parse_fragments_generic->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragments_generic->proc~error_set proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~skip_to_end skip_to_end proc~parse_fragments_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_fragments_section~~CalledByGraph proc~parse_fragments_section parse_fragments_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_fragments_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , config % nfrag , config % fragments , error ) end subroutine parse_fragments_section","tags":"","url":"proc/parse_fragments_section.html"},{"title":"parse_geometry_generic – metalquicha","text":"private  subroutine parse_geometry_generic(unit, geom, error) Generic parser for %geometry section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( geometry_type ), intent(inout) :: geom type( error_t ), intent(out) :: error Calls proc~~parse_geometry_generic~~CallsGraph proc~parse_geometry_generic parse_geometry_generic proc~error_set error_t%error_set proc~parse_geometry_generic->proc~error_set proc~strip_comment strip_comment proc~parse_geometry_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_geometry_generic~~CalledByGraph proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section parse_geometry_section proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_molecule_geometry parse_molecule_geometry proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_geometry proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_geometry_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=MAX_LINE_LEN), private :: elem integer, private :: i integer, private :: io_stat character(len=MAX_LINE_LEN), private :: line integer, private :: natoms real(kind=dp), private :: x real(kind=dp), private :: y real(kind=dp), private :: z Source Code subroutine parse_geometry_generic ( unit , geom , error ) !! Generic parser for %geometry section (works for both config and molecule) integer , intent ( in ) :: unit type ( geometry_type ), intent ( inout ) :: geom type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , elem integer :: io_stat , natoms , i real ( dp ) :: x , y , z ! Read number of atoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading natoms in %geometry section\" ) return end if read ( line , * , iostat = io_stat ) natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid natoms in %geometry section\" ) return end if geom % natoms = natoms ! Read blank line (comment line in XYZ format) read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading comment line in %geometry section\" ) return end if geom % comment = trim ( line ) ! Allocate arrays allocate ( character ( len = 4 ) :: geom % elements ( natoms )) allocate ( geom % coords ( 3 , natoms )) ! Read coordinates do i = 1 , natoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry coordinates\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) then call error % set ( ERROR_PARSE , \"Unexpected 'end' while reading geometry\" ) return end if read ( line , * , iostat = io_stat ) elem , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid coordinate format in %geometry section\" ) return end if geom % elements ( i ) = trim ( elem ) geom % coords ( 1 , i ) = x geom % coords ( 2 , i ) = y geom % coords ( 3 , i ) = z end do ! Read 'end' marker read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_VALIDATION , \"Missing 'end' in %geometry section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) /= 'end' ) then call error % set ( ERROR_PARSE , \"Expected 'end' after geometry coordinates\" ) return end if end subroutine parse_geometry_generic","tags":"","url":"proc/parse_geometry_generic.html"},{"title":"parse_geometry_section – metalquicha","text":"private  subroutine parse_geometry_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_geometry_section~~CallsGraph proc~parse_geometry_section parse_geometry_section proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~error_set error_t%error_set proc~parse_geometry_generic->proc~error_set proc~strip_comment strip_comment proc~parse_geometry_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_geometry_section~~CalledByGraph proc~parse_geometry_section parse_geometry_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_geometry_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_geometry_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , config % geometry , error ) end subroutine parse_geometry_section","tags":"","url":"proc/parse_geometry_section.html"},{"title":"parse_indices_line – metalquicha","text":"private  subroutine parse_indices_line(line, fragment, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error Calls proc~~parse_indices_line~~CallsGraph proc~parse_indices_line parse_indices_line proc~error_set error_t%error_set proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_indices_line~~CalledByGraph proc~parse_indices_line parse_indices_line proc~parse_fragment parse_fragment proc~parse_fragment->proc~parse_indices_line proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_section parse_fragments_section proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments parse_molecule_fragments proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_fragments_section proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: count integer, private :: i integer, private :: idx integer, private :: io_stat integer, private, allocatable :: new_indices (:) integer, private :: pos integer, private, allocatable :: temp_indices (:) character(len=MAX_LINE_LEN), private :: temp_line Source Code subroutine parse_indices_line ( line , fragment , error ) character ( len =* ), intent ( in ) :: line type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error integer :: io_stat , pos , count , i , idx character ( len = MAX_LINE_LEN ) :: temp_line integer , allocatable :: temp_indices (:), new_indices (:) temp_line = line ! Count how many integers count = 0 do read ( temp_line , * , iostat = io_stat ) idx if ( io_stat /= 0 ) exit count = count + 1 ! Remove the read integer from temp_line pos = scan ( temp_line , ' ' ) if ( pos == 0 ) exit temp_line = adjustl ( temp_line ( pos :)) end do if ( count == 0 ) return ! Allocate temporary array allocate ( temp_indices ( count )) ! Read the integers read ( line , * , iostat = io_stat ) temp_indices if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading fragment indices\" ) deallocate ( temp_indices ) return end if ! Append to existing indices if ( allocated ( fragment % indices )) then allocate ( new_indices ( size ( fragment % indices ) + count )) new_indices ( 1 : size ( fragment % indices )) = fragment % indices new_indices ( size ( fragment % indices ) + 1 :) = temp_indices call move_alloc ( new_indices , fragment % indices ) else call move_alloc ( temp_indices , fragment % indices ) end if end subroutine parse_indices_line","tags":"","url":"proc/parse_indices_line.html"},{"title":"parse_model_section – metalquicha","text":"private  subroutine parse_model_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_model_section~~CallsGraph proc~parse_model_section parse_model_section proc~error_set error_t%error_set proc~parse_model_section->proc~error_set proc~parse_method_string parse_method_string proc~parse_model_section->proc~parse_method_string proc~strip_comment strip_comment proc~parse_model_section->proc~strip_comment proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_model_section~~CalledByGraph proc~parse_model_section parse_model_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_model_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_model_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %model section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'method' ) ! Parse method string (e.g., \"XTB-GFN1\" -> \"gfn1\") config % method = parse_method_string ( trim ( value )) if ( config % method == METHOD_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid method: \" // trim ( value )) return end if case ( 'basis' ) config % basis = trim ( value ) case ( 'aux_basis' ) config % aux_basis = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %model section: \" // trim ( key )) return end select end do end subroutine parse_model_section","tags":"","url":"proc/parse_model_section.html"},{"title":"parse_molecule_connectivity – metalquicha","text":"private  subroutine parse_molecule_connectivity(unit, mol, error) Parse %connectivity section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_connectivity~~CallsGraph proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_connectivity_generic parse_connectivity_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~error_set error_t%error_set proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_connectivity_generic->proc~strip_comment proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_connectivity~~CalledByGraph proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_connectivity ( unit , mol , error ) !! Parse %connectivity section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , mol % nbonds , mol % nbroken , mol % bonds , error ) end subroutine parse_molecule_connectivity","tags":"","url":"proc/parse_molecule_connectivity.html"},{"title":"parse_molecule_fragments – metalquicha","text":"private  subroutine parse_molecule_fragments(unit, mol, error) Parse %fragments section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_fragments~~CallsGraph proc~parse_molecule_fragments parse_molecule_fragments proc~parse_fragments_generic parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~error_has_error error_t%error_has_error proc~parse_fragments_generic->proc~error_has_error proc~error_set error_t%error_set proc~parse_fragments_generic->proc~error_set proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~skip_to_end skip_to_end proc~parse_fragments_generic->proc~skip_to_end proc~strip_comment strip_comment proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_fragments~~CalledByGraph proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_fragments ( unit , mol , error ) !! Parse %fragments section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , mol % nfrag , mol % fragments , error ) end subroutine parse_molecule_fragments","tags":"","url":"proc/parse_molecule_fragments.html"},{"title":"parse_molecule_geometry – metalquicha","text":"private  subroutine parse_molecule_geometry(unit, mol, error) Parse %geometry section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_geometry~~CallsGraph proc~parse_molecule_geometry parse_molecule_geometry proc~parse_geometry_generic parse_geometry_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~error_set error_t%error_set proc~parse_geometry_generic->proc~error_set proc~strip_comment strip_comment proc~parse_geometry_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_geometry~~CalledByGraph proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_geometry ( unit , mol , error ) !! Parse %geometry section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , mol % geometry , error ) end subroutine parse_molecule_geometry","tags":"","url":"proc/parse_molecule_geometry.html"},{"title":"parse_molecule_structure – metalquicha","text":"private  subroutine parse_molecule_structure(unit, mol, error) Parse %structure section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_molecule_structure~~CallsGraph proc~parse_molecule_structure parse_molecule_structure proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~error_set error_t%error_set proc~parse_structure_generic->proc~error_set proc~strip_comment strip_comment proc~parse_structure_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecule_structure~~CalledByGraph proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_molecule_structure ( unit , mol , error ) !! Parse %structure section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , mol % charge , mol % multiplicity , error ) end subroutine parse_molecule_structure","tags":"","url":"proc/parse_molecule_structure.html"},{"title":"parse_molecules_section – metalquicha","text":"private  subroutine parse_molecules_section(unit, config, error) Parse %molecules section containing multiple %molecule blocks Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_molecules_section~~CallsGraph proc~parse_molecules_section parse_molecules_section proc~error_has_error error_t%error_has_error proc~parse_molecules_section->proc~error_has_error proc~error_set error_t%error_set proc~parse_molecules_section->proc~error_set proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~skip_to_end skip_to_end proc~parse_molecules_section->proc~skip_to_end proc~strip_comment strip_comment proc~parse_molecules_section->proc~strip_comment proc~parse_single_molecule->proc~error_has_error proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_single_molecule->proc~strip_comment proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_fragments_generic parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_molecules_section~~CalledByGraph proc~parse_molecules_section parse_molecules_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: imol integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=256), private :: msg integer, private :: nmol character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_molecules_section ( unit , config , error ) !! Parse %molecules section containing multiple %molecule blocks integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nmol , imol nmol = 0 ! First pass: read nmol do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecules section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nmol' ) then read ( value , * , iostat = io_stat ) nmol if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nmol value\" ) return end if exit end if end if end do if ( nmol == 0 ) then ! No molecules, just skip to end call skip_to_end ( unit , error ) return end if config % nmol = nmol allocate ( config % molecules ( nmol )) ! Parse individual molecules imol = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%molecule' ) then imol = imol + 1 if ( imol > nmol ) then call error % set ( ERROR_PARSE , \"More molecules than declared nmol\" ) return end if call parse_single_molecule ( unit , config % molecules ( imol ), error ) if ( error % has_error ()) return end if end do if ( imol /= nmol ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nmol , \" molecules, found \" , imol call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_molecules_section","tags":"","url":"proc/parse_molecules_section.html"},{"title":"parse_scf_section – metalquicha","text":"private  subroutine parse_scf_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_scf_section~~CallsGraph proc~parse_scf_section parse_scf_section proc~error_set error_t%error_set proc~parse_scf_section->proc~error_set proc~strip_comment strip_comment proc~parse_scf_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_scf_section~~CalledByGraph proc~parse_scf_section parse_scf_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_scf_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_scf_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %scf section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'maxiter' ) read ( value , * , iostat = io_stat ) config % scf_maxiter case ( 'tolerance' ) read ( value , * , iostat = io_stat ) config % scf_tolerance case default call error % set ( ERROR_PARSE , \"Unknown key in %scf section: \" // trim ( key )) return end select end do end subroutine parse_scf_section","tags":"","url":"proc/parse_scf_section.html"},{"title":"parse_schema_section – metalquicha","text":"private  subroutine parse_schema_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_schema_section~~CallsGraph proc~parse_schema_section parse_schema_section proc~error_set error_t%error_set proc~parse_schema_section->proc~error_set proc~strip_comment strip_comment proc~parse_schema_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_schema_section~~CalledByGraph proc~parse_schema_section parse_schema_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_schema_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_schema_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Unexpected end of file in %schema section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'name' ) config % schema_name = trim ( value ) case ( 'version' ) config % schema_version = trim ( value ) case ( 'index_base' ) read ( value , * , iostat = io_stat ) config % index_base case ( 'units' ) config % units = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %schema section: \" // trim ( key )) return end select end do end subroutine parse_schema_section","tags":"","url":"proc/parse_schema_section.html"},{"title":"parse_single_molecule – metalquicha","text":"private  subroutine parse_single_molecule(unit, mol, error) Parse a single %molecule block with its sections Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error Calls proc~~parse_single_molecule~~CallsGraph proc~parse_single_molecule parse_single_molecule proc~error_has_error error_t%error_has_error proc~parse_single_molecule->proc~error_has_error proc~error_set error_t%error_set proc~parse_single_molecule->proc~error_set proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~skip_to_end skip_to_end proc~parse_single_molecule->proc~skip_to_end proc~strip_comment strip_comment proc~parse_single_molecule->proc~strip_comment proc~parse_connectivity_generic parse_connectivity_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_fragments_generic parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_indices_line->proc~error_set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_single_molecule~~CalledByGraph proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_molecules_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_single_molecule ( unit , mol , error ) !! Parse a single %molecule block with its sections integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecule\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit ! Check for key=value pairs (like name) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'name' ) then mol % name = trim ( value ) cycle end if end if ! Check for subsections if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%structure' ) call parse_molecule_structure ( unit , mol , error ) case ( '%geometry' ) call parse_molecule_geometry ( unit , mol , error ) case ( '%fragments' ) call parse_molecule_fragments ( unit , mol , error ) case ( '%connectivity' ) call parse_molecule_connectivity ( unit , mol , error ) case default ! Skip unknown subsections call skip_to_end ( unit , error ) end select if ( error % has_error ()) return end if end do end subroutine parse_single_molecule","tags":"","url":"proc/parse_single_molecule.html"},{"title":"parse_structure_generic – metalquicha","text":"private  subroutine parse_structure_generic(unit, charge, multiplicity, error) Generic parser for %structure section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: charge integer, intent(inout) :: multiplicity type( error_t ), intent(out) :: error Calls proc~~parse_structure_generic~~CallsGraph proc~parse_structure_generic parse_structure_generic proc~error_set error_t%error_set proc~parse_structure_generic->proc~error_set proc~strip_comment strip_comment proc~parse_structure_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_structure_generic~~CalledByGraph proc~parse_structure_generic parse_structure_generic proc~parse_molecule_structure parse_molecule_structure proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_structure_section parse_structure_section proc~parse_structure_section->proc~parse_structure_generic proc~parse_single_molecule parse_single_molecule proc~parse_single_molecule->proc~parse_molecule_structure proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_structure_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_molecules_section->proc~parse_single_molecule program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_structure_generic ( unit , charge , multiplicity , error ) !! Generic parser for %structure section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: charge , multiplicity type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %structure section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in %structure section: \" // trim ( key )) return end select end do end subroutine parse_structure_generic","tags":"","url":"proc/parse_structure_generic.html"},{"title":"parse_structure_section – metalquicha","text":"private  subroutine parse_structure_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_structure_section~~CallsGraph proc~parse_structure_section parse_structure_section proc~parse_structure_generic parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~error_set error_t%error_set proc~parse_structure_generic->proc~error_set proc~strip_comment strip_comment proc~parse_structure_generic->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_structure_section~~CalledByGraph proc~parse_structure_section parse_structure_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_structure_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_structure_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , config % charge , config % multiplicity , error ) end subroutine parse_structure_section","tags":"","url":"proc/parse_structure_section.html"},{"title":"parse_system_section – metalquicha","text":"private  subroutine parse_system_section(unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error Calls proc~~parse_system_section~~CallsGraph proc~parse_system_section parse_system_section proc~error_set error_t%error_set proc~parse_system_section->proc~error_set proc~strip_comment strip_comment proc~parse_system_section->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_system_section~~CalledByGraph proc~parse_system_section parse_system_section proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_system_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos integer, private :: io_stat character(len=MAX_LINE_LEN), private :: key character(len=MAX_LINE_LEN), private :: line character(len=MAX_LINE_LEN), private :: value Source Code subroutine parse_system_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %system section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'log_level' ) config % log_level = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %system section: \" // trim ( key )) return end select end do end subroutine parse_system_section","tags":"","url":"proc/parse_system_section.html"},{"title":"skip_to_end – metalquicha","text":"private  subroutine skip_to_end(unit, error) Skip lines until ‘end’ marker is found Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( error_t ), intent(out) :: error Calls proc~~skip_to_end~~CallsGraph proc~skip_to_end skip_to_end proc~error_set error_t%error_set proc~skip_to_end->proc~error_set proc~strip_comment strip_comment proc~skip_to_end->proc~strip_comment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~skip_to_end~~CalledByGraph proc~skip_to_end skip_to_end proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_generic->proc~skip_to_end proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~skip_to_end proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~skip_to_end proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_single_molecule->proc~skip_to_end proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~skip_to_end proc~read_mqc_file->proc~parse_molecules_section proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: io_stat character(len=MAX_LINE_LEN), private :: line Source Code subroutine skip_to_end ( unit , error ) !! Skip lines until 'end' marker is found integer , intent ( in ) :: unit type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line integer :: io_stat do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file while skipping section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) exit end do end subroutine skip_to_end","tags":"","url":"proc/skip_to_end.html"},{"title":"distance_between_fragments – metalquicha","text":"public pure function distance_between_fragments(frag1, frag2, use_com) result(distance) Calculate distance between two fragments\nIf use_com is .true., uses center of mass; otherwise uses centroid\nDistance is in the same units as the fragment coordinates (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: frag1 type( physical_fragment_t ), intent(in) :: frag2 logical, intent(in) :: use_com Return Value real(kind=dp) Calls proc~~distance_between_fragments~~CallsGraph proc~distance_between_fragments distance_between_fragments proc~distance_between_points distance_between_points proc~distance_between_fragments->proc~distance_between_points proc~fragment_center_of_mass fragment_center_of_mass proc~distance_between_fragments->proc~fragment_center_of_mass proc~fragment_centroid fragment_centroid proc~distance_between_fragments->proc~fragment_centroid proc~element_mass element_mass proc~fragment_center_of_mass->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: point1 (3) real(kind=dp), private :: point2 (3) Source Code pure function distance_between_fragments ( frag1 , frag2 , use_com ) result ( distance ) !! Calculate distance between two fragments !! If use_com is .true., uses center of mass; otherwise uses centroid !! Distance is in the same units as the fragment coordinates (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: frag1 , frag2 logical , intent ( in ) :: use_com real ( dp ) :: distance real ( dp ) :: point1 ( 3 ), point2 ( 3 ) if ( use_com ) then point1 = fragment_center_of_mass ( frag1 ) point2 = fragment_center_of_mass ( frag2 ) else point1 = fragment_centroid ( frag1 ) point2 = fragment_centroid ( frag2 ) end if distance = distance_between_points ( point1 , point2 ) end function distance_between_fragments","tags":"","url":"proc/distance_between_fragments.html"},{"title":"distance_between_points – metalquicha","text":"public pure function distance_between_points(point1, point2) result(distance) Calculate Euclidean distance between two 3D points\nPoints should be in the same units (typically Bohr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: point1 (3) real(kind=dp), intent(in) :: point2 (3) Return Value real(kind=dp) Called by proc~~distance_between_points~~CalledByGraph proc~distance_between_points distance_between_points proc~distance_between_fragments distance_between_fragments proc~distance_between_fragments->proc~distance_between_points proc~minimal_distance_between_fragments minimal_distance_between_fragments proc~minimal_distance_between_fragments->proc~distance_between_points Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: diff (3) Source Code pure function distance_between_points ( point1 , point2 ) result ( distance ) !! Calculate Euclidean distance between two 3D points !! Points should be in the same units (typically Bohr) real ( dp ), intent ( in ) :: point1 ( 3 ), point2 ( 3 ) real ( dp ) :: distance real ( dp ) :: diff ( 3 ) diff = point2 - point1 distance = sqrt ( dot_product ( diff , diff )) end function distance_between_points","tags":"","url":"proc/distance_between_points.html"},{"title":"fragment_center_of_mass – metalquicha","text":"public pure function fragment_center_of_mass(fragment) result(com) Calculate the center of mass of a fragment\nWeights each atomic position by its atomic mass\nReturns coordinates in the same units as the fragment (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment Return Value real(kind=dp), (3) Calls proc~~fragment_center_of_mass~~CallsGraph proc~fragment_center_of_mass fragment_center_of_mass proc~element_mass element_mass proc~fragment_center_of_mass->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_center_of_mass~~CalledByGraph proc~fragment_center_of_mass fragment_center_of_mass proc~distance_between_fragments distance_between_fragments proc~distance_between_fragments->proc~fragment_center_of_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: atom_mass integer, private :: i real(kind=dp), private :: total_mass Source Code pure function fragment_center_of_mass ( fragment ) result ( com ) !! Calculate the center of mass of a fragment !! Weights each atomic position by its atomic mass !! Returns coordinates in the same units as the fragment (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ) :: com ( 3 ) real ( dp ) :: total_mass , atom_mass integer :: i com = 0.0_dp total_mass = 0.0_dp do i = 1 , fragment % n_atoms atom_mass = element_mass ( fragment % element_numbers ( i )) com = com + atom_mass * fragment % coordinates (:, i ) total_mass = total_mass + atom_mass end do com = com / total_mass end function fragment_center_of_mass","tags":"","url":"proc/fragment_center_of_mass.html"},{"title":"fragment_centroid – metalquicha","text":"public pure function fragment_centroid(fragment) result(centroid) Calculate the geometric centroid (center of geometry) of a fragment\nThis is the simple average of all atomic coordinates\nReturns coordinates in the same units as the fragment (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment Return Value real(kind=dp), (3) Called by proc~~fragment_centroid~~CalledByGraph proc~fragment_centroid fragment_centroid proc~distance_between_fragments distance_between_fragments proc~distance_between_fragments->proc~fragment_centroid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure function fragment_centroid ( fragment ) result ( centroid ) !! Calculate the geometric centroid (center of geometry) of a fragment !! This is the simple average of all atomic coordinates !! Returns coordinates in the same units as the fragment (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ) :: centroid ( 3 ) integer :: i centroid = 0.0_dp do i = 1 , fragment % n_atoms centroid = centroid + fragment % coordinates (:, i ) end do centroid = centroid / real ( fragment % n_atoms , dp ) end function fragment_centroid","tags":"","url":"proc/fragment_centroid.html"},{"title":"minimal_distance_between_fragments – metalquicha","text":"public pure function minimal_distance_between_fragments(frag1, frag2) result(min_distance) Calculate the minimal distance between any two atoms in two fragments\nThis iterates over all atom pairs and finds the closest pair\nDistance is in the same units as the fragment coordinates (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: frag1 type( physical_fragment_t ), intent(in) :: frag2 Return Value real(kind=dp) Calls proc~~minimal_distance_between_fragments~~CallsGraph proc~minimal_distance_between_fragments minimal_distance_between_fragments proc~distance_between_points distance_between_points proc~minimal_distance_between_fragments->proc~distance_between_points Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: current_distance integer, private :: i integer, private :: j Source Code pure function minimal_distance_between_fragments ( frag1 , frag2 ) result ( min_distance ) !! Calculate the minimal distance between any two atoms in two fragments !! This iterates over all atom pairs and finds the closest pair !! Distance is in the same units as the fragment coordinates (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: frag1 , frag2 real ( dp ) :: min_distance real ( dp ) :: current_distance integer :: i , j ! Initialize with a very large value min_distance = huge ( 1.0_dp ) do i = 1 , frag1 % n_atoms do j = 1 , frag2 % n_atoms current_distance = distance_between_points ( frag1 % coordinates (:, i ), & frag2 % coordinates (:, j )) if ( current_distance < min_distance ) then min_distance = current_distance end if end do end do end function minimal_distance_between_fragments","tags":"","url":"proc/minimal_distance_between_fragments.html"},{"title":"to_angstrom – metalquicha","text":"public pure elemental function to_angstrom(bohr_value) result(angstrom_value) Convert coordinate from Bohr to Angstrom Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: bohr_value Return Value real(kind=dp) Called by proc~~to_angstrom~~CalledByGraph proc~to_angstrom to_angstrom proc~print_fragment_xyz print_fragment_xyz proc~print_fragment_xyz->proc~to_angstrom proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental function to_angstrom ( bohr_value ) result ( angstrom_value ) !! Convert coordinate from Bohr to Angstrom real ( dp ), intent ( in ) :: bohr_value real ( dp ) :: angstrom_value angstrom_value = bohr_value * bohr_radius end function to_angstrom","tags":"","url":"proc/to_angstrom.html"},{"title":"to_bohr – metalquicha","text":"public pure elemental function to_bohr(angstrom_value) result(bohr_value) Convert coordinate from Angstrom to Bohr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: angstrom_value Return Value real(kind=dp) Called by proc~~to_bohr~~CalledByGraph proc~to_bohr to_bohr proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~geometry_to_system_unfragmented->proc~to_bohr proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~to_bohr proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~to_bohr proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental function to_bohr ( angstrom_value ) result ( bohr_value ) !! Convert coordinate from Angstrom to Bohr real ( dp ), intent ( in ) :: angstrom_value real ( dp ) :: bohr_value bohr_value = angstrom_value / bohr_radius end function to_bohr","tags":"","url":"proc/to_bohr.html"},{"title":"build_fragment_from_atom_list – metalquicha","text":"public  subroutine build_fragment_from_atom_list(sys_geom, atom_indices, n_atoms, fragment, bonds) Build a fragment from explicit atom list (for GMBE intersection fragments) Similar to build_fragment_from_indices but takes atom indices directly instead of\nmonomer indices. Used for building intersection fragments in GMBE calculations.\nIntersection fragments are ALWAYS NEUTRAL (charge=0, multiplicity=1). Example: atom_indices = [3, 4, 5] builds fragment from atoms 3, 4, 5 of the system Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: atom_indices (:) 0-indexed atom indices integer, intent(in) :: n_atoms Number of atoms in list type( physical_fragment_t ), intent(out) :: fragment type( bond_t ), intent(in), optional :: bonds (:) Connectivity for capping Calls proc~~build_fragment_from_atom_list~~CallsGraph proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol to_char to_char proc~check_duplicate_atoms->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_fragment_from_atom_list~~CalledByGraph proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_global_idx integer, private :: frag_atom_idx integer, private :: i integer, private :: n_caps Source Code subroutine build_fragment_from_atom_list ( sys_geom , atom_indices , n_atoms , fragment , bonds ) !! Build a fragment from explicit atom list (for GMBE intersection fragments) !! !! Similar to build_fragment_from_indices but takes atom indices directly instead of !! monomer indices. Used for building intersection fragments in GMBE calculations. !! Intersection fragments are ALWAYS NEUTRAL (charge=0, multiplicity=1). !! !! Example: atom_indices = [3, 4, 5] builds fragment from atoms 3, 4, 5 of the system type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: atom_indices (:) !! 0-indexed atom indices integer , intent ( in ) :: n_atoms !! Number of atoms in list type ( physical_fragment_t ), intent ( out ) :: fragment type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity for capping integer :: i , frag_atom_idx , atom_global_idx integer :: n_caps ! Count how many caps we need call count_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping (atom_indices are 0-indexed, add 1 for Fortran arrays) do i = 1 , n_atoms atom_global_idx = atom_indices ( i ) + 1 ! Convert to 1-indexed fragment % element_numbers ( i ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, i ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( i ) = atom_global_idx ! Store 1-indexed global position end do ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , sys_geom , fragment , n_atoms ) end if ! Intersection fragments are ALWAYS NEUTRAL ! Rationale: For polypeptides, intersections are backbone atoms; ! charged side chains are in non-overlapping regions fragment % charge = 0 fragment % multiplicity = 1 call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment ) end subroutine build_fragment_from_atom_list","tags":"","url":"proc/build_fragment_from_atom_list.html"},{"title":"build_fragment_from_indices – metalquicha","text":"public  subroutine build_fragment_from_indices(sys_geom, monomer_indices, fragment, bonds) Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds Extracts atoms from specified monomers and adds hydrogen caps where bonds are broken.\nCaps are always added at the end of the atom list.\nSupports both fixed-size (identical monomers) and variable-sized fragments. Example: monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5\n         If connectivity shows broken bonds, hydrogens are capped at positions of missing atoms Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) type( physical_fragment_t ), intent(out) :: fragment type( bond_t ), intent(in), optional :: bonds (:) Connectivity information for capping Calls proc~~build_fragment_from_indices~~CallsGraph proc~build_fragment_from_indices build_fragment_from_indices proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol to_char to_char proc~check_duplicate_atoms->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_fragment_from_indices~~CalledByGraph proc~build_fragment_from_indices build_fragment_from_indices proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~build_fragment_from_indices proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_indices proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_end integer, private :: atom_global_idx integer, private :: atom_i integer, private :: atom_j integer, private :: atom_start integer, private, allocatable :: atoms_in_fragment (:) List of all atom indices in this fragment integer, private :: atoms_per_monomer integer, private :: frag_atom_idx integer, private :: i integer, private :: iatom integer, private :: j integer, private :: mono_idx integer, private :: n_atoms_no_caps integer, private :: n_caps integer, private :: n_monomers_in_frag logical, private :: use_explicit_fragments Source Code subroutine build_fragment_from_indices ( sys_geom , monomer_indices , fragment , bonds ) !! Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds !! !! Extracts atoms from specified monomers and adds hydrogen caps where bonds are broken. !! Caps are always added at the end of the atom list. !! Supports both fixed-size (identical monomers) and variable-sized fragments. !! !! Example: monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5 !!          If connectivity shows broken bonds, hydrogens are capped at positions of missing atoms type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) type ( physical_fragment_t ), intent ( out ) :: fragment type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity information for capping integer :: n_monomers_in_frag , atoms_per_monomer , n_atoms_no_caps integer :: i , j , mono_idx , atom_start , atom_end , frag_atom_idx integer :: atom_i , atom_j , n_caps integer , allocatable :: atoms_in_fragment (:) !! List of all atom indices in this fragment integer :: iatom , atom_global_idx logical :: use_explicit_fragments n_monomers_in_frag = size ( monomer_indices ) ! Determine if we're using explicit fragment definitions or regular monomer-based use_explicit_fragments = allocated ( sys_geom % fragment_atoms ) if ( use_explicit_fragments ) then ! Variable-sized fragments: count total atoms from fragment definitions n_atoms_no_caps = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) n_atoms_no_caps = n_atoms_no_caps + sys_geom % fragment_sizes ( mono_idx ) end do ! Build list of atom indices (0-indexed) from explicit fragment definitions allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) iatom = iatom + 1 atoms_in_fragment ( iatom ) = sys_geom % fragment_atoms ( j , mono_idx ) end do end do else ! Fixed-size monomers: use atoms_per_monomer atoms_per_monomer = sys_geom % atoms_per_monomer n_atoms_no_caps = n_monomers_in_frag * atoms_per_monomer ! Build list of atom indices in this fragment (0-indexed to match bond indices) allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer do atom_i = 0 , atoms_per_monomer - 1 iatom = iatom + 1 atoms_in_fragment ( iatom ) = atom_start + atom_i end do end do end if ! Count how many caps we need call count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms_no_caps + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms_no_caps )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping frag_atom_idx = 0 if ( use_explicit_fragments ) then ! Variable-sized: copy atoms based on explicit fragment definitions do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) frag_atom_idx = frag_atom_idx + 1 ! fragment_atoms is 0-indexed, so +1 for Fortran arrays atom_global_idx = sys_geom % fragment_atoms ( j , mono_idx ) + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( frag_atom_idx ) = atom_global_idx ! Store 1-indexed global position end do end do else ! Fixed-size: use atoms_per_monomer do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer + 1 atom_end = mono_idx * atoms_per_monomer ! Copy coordinates and elements do atom_i = atom_start , atom_end frag_atom_idx = frag_atom_idx + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_i ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_i ) fragment % local_to_global ( frag_atom_idx ) = atom_i ! Store 1-indexed global position end do end do end if ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , n_atoms_no_caps ) end if ! Set electronic structure properties from system geometry if ( use_explicit_fragments . and . allocated ( sys_geom % fragment_charges ) . and . & allocated ( sys_geom % fragment_multiplicities )) then ! Explicit fragments: sum charges and multiplicities from constituent fragments fragment % charge = 0 fragment % multiplicity = 1 ! Start with singlet assumption do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) fragment % charge = fragment % charge + sys_geom % fragment_charges ( mono_idx ) end do ! For single fragment, use its specific multiplicity if ( n_monomers_in_frag == 1 ) then fragment % multiplicity = sys_geom % fragment_multiplicities ( monomer_indices ( 1 )) else ! For multi-fragment composites, multiplicity needs careful treatment ! For now, default to system multiplicity (this may need refinement) fragment % multiplicity = sys_geom % multiplicity end if else ! Fixed-size monomers: use system defaults fragment % charge = sys_geom % charge fragment % multiplicity = sys_geom % multiplicity end if call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment ) deallocate ( atoms_in_fragment ) end subroutine build_fragment_from_indices","tags":"","url":"proc/build_fragment_from_indices.html"},{"title":"check_duplicate_atoms – metalquicha","text":"public  subroutine check_duplicate_atoms(fragment) Uses pic_logger pic_io proc~~check_duplicate_atoms~~UsesGraph proc~check_duplicate_atoms check_duplicate_atoms pic_io pic_io proc~check_duplicate_atoms->pic_io pic_logger pic_logger proc~check_duplicate_atoms->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Validate that fragment has no spatially overlapping atoms\nChecks if any two atoms are too close together (< 0.01 Bohr)\nThis catches bugs in geometry construction or fragment building Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment Calls proc~~check_duplicate_atoms~~CallsGraph proc~check_duplicate_atoms check_duplicate_atoms error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol to_char to_char proc~check_duplicate_atoms->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_duplicate_atoms~~CalledByGraph proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~check_duplicate_atoms proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~build_fragment_from_indices proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~build_fragment_from_indices proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: MIN_ATOM_DISTANCE = 0.01_dp Bohr - atoms closer than this are overlapping real(kind=dp), private :: distance real(kind=dp), private :: dx real(kind=dp), private :: dy real(kind=dp), private :: dz integer, private :: i integer, private :: j integer, private :: n_atoms Source Code subroutine check_duplicate_atoms ( fragment ) !! Validate that fragment has no spatially overlapping atoms !! Checks if any two atoms are too close together (< 0.01 Bohr) !! This catches bugs in geometry construction or fragment building use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( physical_fragment_t ), intent ( in ) :: fragment integer :: i , j , n_atoms real ( dp ) :: distance , dx , dy , dz real ( dp ), parameter :: MIN_ATOM_DISTANCE = 0.01_dp !! Bohr - atoms closer than this are overlapping ! Only check non-cap atoms (caps can be close to replaced atoms) n_atoms = fragment % n_atoms - fragment % n_caps if ( n_atoms < 2 ) return do i = 1 , n_atoms - 1 do j = i + 1 , n_atoms dx = fragment % coordinates ( 1 , i ) - fragment % coordinates ( 1 , j ) dy = fragment % coordinates ( 2 , i ) - fragment % coordinates ( 2 , j ) dz = fragment % coordinates ( 3 , i ) - fragment % coordinates ( 3 , j ) distance = sqrt ( dx * dx + dy * dy + dz * dz ) if ( distance < MIN_ATOM_DISTANCE ) then call logger % error ( \"ERROR: Fragment contains overlapping atoms!\" ) call logger % error ( \"  Atoms \" // to_char ( i ) // \" and \" // to_char ( j ) // \" are too close together\" ) call logger % error ( \"  Distance: \" // to_char ( distance ) // \" Bohr (\" // & to_char ( distance * 0.529177_dp ) // \" Angstrom)\" ) call logger % error ( \"  Atom \" // to_char ( i ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( i )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , i )) // \", \" // & to_char ( fragment % coordinates ( 2 , i )) // \", \" // & to_char ( fragment % coordinates ( 3 , i )) // \") Bohr\" ) call logger % error ( \"  Atom \" // to_char ( j ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( j )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , j )) // \", \" // & to_char ( fragment % coordinates ( 2 , j )) // \", \" // & to_char ( fragment % coordinates ( 3 , j )) // \") Bohr\" ) call logger % error ( \" \" ) call logger % error ( \"This indicates either:\" ) call logger % error ( \"  1. Bad input geometry (atoms on top of each other)\" ) call logger % error ( \"  2. Bug in fragment construction (duplicate atoms)\" ) error stop \"Overlapping atoms in fragment\" end if end do end do end subroutine check_duplicate_atoms","tags":"","url":"proc/check_duplicate_atoms.html"},{"title":"initialize_system_geometry – metalquicha","text":"public  subroutine initialize_system_geometry(full_geom_file, monomer_file, sys_geom, error) Read full geometry and monomer template, initialize system_geometry_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full_geom_file character(len=*), intent(in) :: monomer_file type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error Calls proc~~initialize_system_geometry~~CallsGraph proc~initialize_system_geometry initialize_system_geometry proc~element_symbol_to_number element_symbol_to_number proc~initialize_system_geometry->proc~element_symbol_to_number proc~error_has_error error_t%error_has_error proc~initialize_system_geometry->proc~error_has_error proc~error_set error_t%error_set proc~initialize_system_geometry->proc~error_set proc~geometry_destroy geometry_type%geometry_destroy proc~initialize_system_geometry->proc~geometry_destroy proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~to_bohr to_bohr proc~initialize_system_geometry->proc~to_bohr to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~read_xyz_file->proc~error_set proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~read_xyz_string->proc~error_set proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( geometry_type ), private :: full_geom integer, private :: i type( geometry_type ), private :: monomer_geom Source Code subroutine initialize_system_geometry ( full_geom_file , monomer_file , sys_geom , error ) !! Read full geometry and monomer template, initialize system_geometry_t character ( len =* ), intent ( in ) :: full_geom_file , monomer_file type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error type ( geometry_type ) :: full_geom , monomer_geom integer :: i call read_xyz_file ( full_geom_file , full_geom , error ) if ( error % has_error ()) return ! Read monomer template ! this will be changed once we have a proper input file parsing call read_xyz_file ( monomer_file , monomer_geom , error ) if ( error % has_error ()) then call full_geom % destroy () return end if ! Validate that full geometry is a multiple of monomer size sys_geom % atoms_per_monomer = monomer_geom % natoms sys_geom % total_atoms = full_geom % natoms if ( mod ( sys_geom % total_atoms , sys_geom % atoms_per_monomer ) /= 0 ) then call error % set ( ERROR_VALIDATION , \"Full geometry atoms not a multiple of monomer atoms\" ) call full_geom % destroy () call monomer_geom % destroy () return end if sys_geom % n_monomers = sys_geom % total_atoms / sys_geom % atoms_per_monomer ! TODO JORGE: this can be a sys_geom%allocate() allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( full_geom % elements ( i )) end do ! Store coordinates in Bohr (convert from Angstroms) ! TODO JORGE: need a way to handle units sys_geom % coordinates = to_bohr ( full_geom % coords ) call full_geom % destroy () call monomer_geom % destroy () end subroutine initialize_system_geometry","tags":"","url":"proc/initialize_system_geometry.html"},{"title":"redistribute_cap_gradients – metalquicha","text":"public  subroutine redistribute_cap_gradients(fragment, fragment_gradient, system_gradient) Redistribute hydrogen cap gradients to original atoms This subroutine handles gradient redistribution for fragments with hydrogen caps.\nHydrogen caps are virtual atoms added at broken bonds - their gradients represent\nforces at the bond breakpoint and must be transferred to the original atoms they replace. Algorithm:\n  1. For real atoms (indices 1 to n_atoms - n_caps):\n     Accumulate gradient to system using local_to_global mapping\n  2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms):\n     Add cap gradient to the original atom it replaces (from cap_replaces_atom) Example:\n  Fragment: [C, C, H_cap] where H_cap replaces atom 5 in system\n  Fragment gradient: [(3,1), (3,2), (3,3)]\n  - Atoms 1,2: accumulate to system using local_to_global\n  - Atom 3 (cap): add gradient to system atom 5 (cap_replaces_atom(1) + 1) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_gradient (:,:) (3, n_atoms_fragment) real(kind=dp), intent(inout) :: system_gradient (:,:) (3, n_atoms_system) Called by proc~~redistribute_cap_gradients~~CalledByGraph proc~redistribute_cap_gradients redistribute_cap_gradients proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~redistribute_cap_gradients proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~redistribute_cap_gradients proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->proc~serial_fragment_processor proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: global_idx integer, private :: global_original_idx integer, private :: i integer, private :: i_cap integer, private :: local_cap_idx integer, private :: local_idx integer, private :: n_real_atoms Source Code subroutine redistribute_cap_gradients ( fragment , fragment_gradient , system_gradient ) !! Redistribute hydrogen cap gradients to original atoms !! !! This subroutine handles gradient redistribution for fragments with hydrogen caps. !! Hydrogen caps are virtual atoms added at broken bonds - their gradients represent !! forces at the bond breakpoint and must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate gradient to system using local_to_global mapping !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap gradient to the original atom it replaces (from cap_replaces_atom) !! !! Example: !!   Fragment: [C, C, H_cap] where H_cap replaces atom 5 in system !!   Fragment gradient: [(3,1), (3,2), (3,3)] !!   - Atoms 1,2: accumulate to system using local_to_global !!   - Atom 3 (cap): add gradient to system atom 5 (cap_replaces_atom(1) + 1) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_gradient (:, :) !! (3, n_atoms_fragment) real ( dp ), intent ( inout ) :: system_gradient (:, :) !! (3, n_atoms_system) integer :: i , local_idx , global_idx integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate gradients for real atoms using local→global mapping do i = 1 , n_real_atoms global_idx = fragment % local_to_global ( i ) system_gradient (:, global_idx ) = system_gradient (:, global_idx ) + fragment_gradient (:, i ) end do ! Redistribute cap gradients to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap ! cap_replaces_atom is 0-indexed, add 1 for Fortran arrays global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Add cap gradient to the atom it replaces system_gradient (:, global_original_idx ) = system_gradient (:, global_original_idx ) + & fragment_gradient (:, local_cap_idx ) end do end if end subroutine redistribute_cap_gradients","tags":"","url":"proc/redistribute_cap_gradients.html"},{"title":"redistribute_cap_hessian – metalquicha","text":"public  subroutine redistribute_cap_hessian(fragment, fragment_hessian, system_hessian) Redistribute hydrogen cap Hessian to original atoms This subroutine handles Hessian redistribution for fragments with hydrogen caps.\nThe Hessian is a rank-2 tensor (3N × 3N) representing second derivatives of energy\nwith respect to atomic coordinates. Similar to gradient redistribution, cap contributions\nmust be transferred to the original atoms they replace. Algorithm:\n  1. For real atoms (indices 1 to n_atoms - n_caps):\n     Accumulate Hessian blocks to system using local_to_global mapping for both dimensions\n  2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms):\n     Add cap Hessian blocks (row and column) to the original atom it replaces Note: Hessian is stored as a flattened 2D array (3 n_atoms, 3 n_atoms)\n      where rows and columns are grouped by atoms (x,y,z for atom 1, then x,y,z for atom 2, etc.) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_hessian (:,:) (3 n_atoms_fragment, 3 n_atoms_fragment) real(kind=dp), intent(inout) :: system_hessian (:,:) (3 n_atoms_system, 3 n_atoms_system) Called by proc~~redistribute_cap_hessian~~CalledByGraph proc~redistribute_cap_hessian redistribute_cap_hessian proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~redistribute_cap_hessian proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->proc~serial_fragment_processor proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: global_i integer, private :: global_j integer, private :: global_original_idx integer, private :: global_original_idx_2 integer, private :: i integer, private :: i_cap integer, private :: i_cap_2 integer, private :: icart integer, private :: j integer, private :: jcart integer, private :: local_cap_idx integer, private :: local_cap_idx_2 integer, private :: local_i integer, private :: local_j integer, private :: n_real_atoms Source Code subroutine redistribute_cap_hessian ( fragment , fragment_hessian , system_hessian ) !! Redistribute hydrogen cap Hessian to original atoms !! !! This subroutine handles Hessian redistribution for fragments with hydrogen caps. !! The Hessian is a rank-2 tensor (3N × 3N) representing second derivatives of energy !! with respect to atomic coordinates. Similar to gradient redistribution, cap contributions !! must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate Hessian blocks to system using local_to_global mapping for both dimensions !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap Hessian blocks (row and column) to the original atom it replaces !! !! Note: Hessian is stored as a flattened 2D array (3*n_atoms, 3*n_atoms) !!       where rows and columns are grouped by atoms (x,y,z for atom 1, then x,y,z for atom 2, etc.) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_hessian (:, :) !! (3*n_atoms_fragment, 3*n_atoms_fragment) real ( dp ), intent ( inout ) :: system_hessian (:, :) !! (3*n_atoms_system, 3*n_atoms_system) integer :: i , j , local_i , local_j , global_i , global_j integer :: icart , jcart integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms integer :: i_cap_2 , local_cap_idx_2 , global_original_idx_2 n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate Hessian blocks for real atoms using local→global mapping ! Both row (i) and column (j) dimensions need mapping do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) ! Copy 3×3 block for atom pair (i,j) do icart = 0 , 2 ! x, y, z for atom i do jcart = 0 , 2 ! x, y, z for atom j system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do end do ! Redistribute cap Hessian blocks to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Cap rows: redistribute to original atom (cap derivatives w.r.t. all other atoms) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do ! Cap columns: redistribute to original atom (all other atoms' derivatives w.r.t. cap) do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( local_cap_idx - 1 ) + jcart + 1 ) end do end do end do ! Cap-cap blocks: redistribute to original atom diagonal block do i_cap_2 = 1 , fragment % n_caps local_cap_idx_2 = n_real_atoms + i_cap_2 global_original_idx_2 = fragment % cap_replaces_atom ( i_cap_2 ) + 1 do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( local_cap_idx_2 - 1 ) + jcart + 1 ) end do end do end do end do end if end subroutine redistribute_cap_hessian","tags":"","url":"proc/redistribute_cap_hessian.html"},{"title":"add_hydrogen_caps – metalquicha","text":"private  subroutine add_hydrogen_caps(atoms_in_fragment, bonds, sys_geom, fragment, base_atom_count) Add hydrogen caps to fragment for broken bonds\nCaps are placed at the position of the atom outside the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in) :: bonds (:) type( system_geometry_t ), intent(in) :: sys_geom type( physical_fragment_t ), intent(inout) :: fragment integer, intent(in) :: base_atom_count Number of non-cap atoms Called by proc~~add_hydrogen_caps~~CalledByGraph proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~build_fragment_from_indices proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~build_fragment_from_indices proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: atom_i_in_frag logical, private :: atom_j_in_frag integer, private :: cap_idx integer, private :: ibond Source Code subroutine add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , base_atom_count ) !! Add hydrogen caps to fragment for broken bonds !! Caps are placed at the position of the atom outside the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ) :: bonds (:) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( physical_fragment_t ), intent ( inout ) :: fragment integer , intent ( in ) :: base_atom_count !! Number of non-cap atoms integer :: ibond , cap_idx logical :: atom_i_in_frag , atom_j_in_frag if ( fragment % n_caps == 0 ) return cap_idx = 0 do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) if ( atom_i_in_frag . and . . not . atom_j_in_frag ) then ! atom_i is in fragment, atom_j is not → cap at position of atom_j cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_j (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_j + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_j else if ( atom_j_in_frag . and . . not . atom_i_in_frag ) then ! atom_j is in fragment, atom_i is not → cap at position of atom_i cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_i (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_i + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_i end if end do end subroutine add_hydrogen_caps","tags":"","url":"proc/add_hydrogen_caps.html"},{"title":"count_hydrogen_caps – metalquicha","text":"private  subroutine count_hydrogen_caps(atoms_in_fragment, bonds, n_caps) Count how many hydrogen caps are needed for a fragment\nA cap is needed when exactly one atom of a broken bond is in the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in), optional :: bonds (:) integer, intent(out) :: n_caps Called by proc~~count_hydrogen_caps~~CalledByGraph proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~build_fragment_from_indices proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~build_fragment_from_indices proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: atom_i_in_frag logical, private :: atom_j_in_frag integer, private :: ibond Source Code subroutine count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) !! Count how many hydrogen caps are needed for a fragment !! A cap is needed when exactly one atom of a broken bond is in the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ), optional :: bonds (:) integer , intent ( out ) :: n_caps integer :: ibond logical :: atom_i_in_frag , atom_j_in_frag n_caps = 0 if (. not . present ( bonds )) return do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle ! Check if exactly one atom of this bond is in the fragment atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) ! Add cap only if one atom in fragment, other not (XOR condition) if (( atom_i_in_frag . and . . not . atom_j_in_frag ) . or . & (. not . atom_i_in_frag . and . atom_j_in_frag )) then n_caps = n_caps + 1 end if end do end subroutine count_hydrogen_caps","tags":"","url":"proc/count_hydrogen_caps.html"},{"title":"fragment_compute_nelec – metalquicha","text":"private  subroutine fragment_compute_nelec(this) Compute number of electrons from atomic numbers and charge Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this Called by proc~~fragment_compute_nelec~~CalledByGraph proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~build_fragment_from_indices build_fragment_from_indices proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~fragment_compute_nelec proc~hessian_worker hessian_worker proc~hessian_worker->proc~fragment_compute_nelec proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~fragment_compute_nelec proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~build_fragment_from_indices proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~build_fragment_from_indices proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_worker proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_indices proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: nuclear_charge Source Code subroutine fragment_compute_nelec ( this ) !! Compute number of electrons from atomic numbers and charge class ( physical_fragment_t ), intent ( inout ) :: this integer :: nuclear_charge nuclear_charge = sum ( this % element_numbers ) this % nelec = nuclear_charge - this % charge end subroutine fragment_compute_nelec","tags":"","url":"proc/fragment_compute_nelec.html"},{"title":"fragment_destroy – metalquicha","text":"private  subroutine fragment_destroy(this) Clean up allocated memory in physical_fragment_t Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this Calls proc~~fragment_destroy~~CallsGraph proc~fragment_destroy physical_fragment_t%fragment_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_destroy~~CalledByGraph proc~fragment_destroy physical_fragment_t%fragment_destroy proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~fragment_destroy proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~fragment_destroy proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fragment_destroy ( this ) !! Clean up allocated memory in physical_fragment_t class ( physical_fragment_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % cap_replaces_atom )) deallocate ( this % cap_replaces_atom ) if ( allocated ( this % local_to_global )) deallocate ( this % local_to_global ) if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if this % n_atoms = 0 this % charge = 0 this % multiplicity = 1 this % nelec = 0 this % n_caps = 0 end subroutine fragment_destroy","tags":"","url":"proc/fragment_destroy.html"},{"title":"fragment_set_basis – metalquicha","text":"private  subroutine fragment_set_basis(this, basis) Set the basis set for this fragment Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis Calls proc~~fragment_set_basis~~CallsGraph proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_set_basis->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fragment_set_basis ( this , basis ) !! Set the basis set for this fragment class ( physical_fragment_t ), intent ( inout ) :: this type ( molecular_basis_type ), intent ( in ) :: basis if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if allocate ( this % basis ) this % basis = basis end subroutine fragment_set_basis","tags":"","url":"proc/fragment_set_basis.html"},{"title":"system_destroy – metalquicha","text":"private  subroutine system_destroy(this) Clean up allocated memory in system_geometry_t Type Bound system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this Called by proc~~system_destroy~~CalledByGraph proc~system_destroy system_geometry_t%system_destroy proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~system_destroy program~main main program~main->proc~system_destroy program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine system_destroy ( this ) !! Clean up allocated memory in system_geometry_t class ( system_geometry_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % fragment_sizes )) deallocate ( this % fragment_sizes ) if ( allocated ( this % fragment_atoms )) deallocate ( this % fragment_atoms ) if ( allocated ( this % fragment_charges )) deallocate ( this % fragment_charges ) if ( allocated ( this % fragment_multiplicities )) deallocate ( this % fragment_multiplicities ) this % n_monomers = 0 this % atoms_per_monomer = 0 this % total_atoms = 0 end subroutine system_destroy","tags":"","url":"proc/system_destroy.html"},{"title":"int_to_string – metalquicha","text":"private pure function int_to_string(i) result(str) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Called by proc~~int_to_string~~CalledByGraph proc~int_to_string int_to_string proc~read_xyz_string read_xyz_string proc~read_xyz_string->proc~int_to_string proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: buffer Source Code pure function int_to_string ( i ) result ( str ) !! Convert integer to string integer , intent ( in ) :: i character ( len = :), allocatable :: str character ( len = 20 ) :: buffer write ( buffer , '(I0)' ) i str = trim ( adjustl ( buffer )) end function int_to_string","tags":"","url":"proc/int_to_string.html"},{"title":"read_xyz_file – metalquicha","text":"public  subroutine read_xyz_file(filename, geom, error) Read molecular geometry from XYZ format file Parses standard XYZ files with format:\nLine 1: Number of atoms\nLine 2: Comment/title line\nLines 3+: Element X Y Z (coordinates in Angstrom) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Path to XYZ file type( geometry_type ), intent(out) :: geom Parsed molecular geometry type( error_t ), intent(out) :: error Error handling Calls proc~~read_xyz_file~~CallsGraph proc~read_xyz_file read_xyz_file proc~error_set error_t%error_set proc~read_xyz_file->proc~error_set proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~read_xyz_string->proc~error_set proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_xyz_file~~CalledByGraph proc~read_xyz_file read_xyz_file proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: file_contents Full file content buffer logical, private :: file_exists Whether file exists on disk integer, private :: file_size File size in bytes integer, private :: io_stat I/O operation status integer, private :: unit File unit number Source Code subroutine read_xyz_file ( filename , geom , error ) !! Read molecular geometry from XYZ format file !! !! Parses standard XYZ files with format: !! Line 1: Number of atoms !! Line 2: Comment/title line !! Lines 3+: Element X Y Z (coordinates in Angstrom) character ( len =* ), intent ( in ) :: filename !! Path to XYZ file type ( geometry_type ), intent ( out ) :: geom !! Parsed molecular geometry type ( error_t ), intent ( out ) :: error !! Error handling integer :: unit !! File unit number integer :: io_stat !! I/O operation status integer :: file_size !! File size in bytes logical :: file_exists !! Whether file exists on disk character ( len = :), allocatable :: file_contents !! Full file content buffer ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"XYZ file not found: \" // trim ( filename )) return end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: file_contents ) ! Open and read entire file as stream open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening file: \" // trim ( filename )) return end if read ( unit , iostat = io_stat ) file_contents close ( unit ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error reading file: \" // trim ( filename )) return end if ! Parse the contents call read_xyz_string ( file_contents , geom , error ) end subroutine read_xyz_file","tags":"","url":"proc/read_xyz_file.html"},{"title":"read_xyz_string – metalquicha","text":"public pure subroutine read_xyz_string(xyz_string, geom, error) Parse molecular geometry from XYZ format string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xyz_string type( geometry_type ), intent(out) :: geom type( error_t ), intent(out) :: error Calls proc~~read_xyz_string~~CallsGraph proc~read_xyz_string read_xyz_string proc~error_set error_t%error_set proc~read_xyz_string->proc~error_set proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_xyz_string~~CalledByGraph proc~read_xyz_string read_xyz_string proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: element integer, private :: iatom integer, private :: io_stat character(len=:), private, allocatable :: lines (:) integer, private :: nlines real(kind=dp), private :: x real(kind=dp), private :: y real(kind=dp), private :: z Source Code pure subroutine read_xyz_string ( xyz_string , geom , error ) !! Parse molecular geometry from XYZ format string character ( len =* ), intent ( in ) :: xyz_string type ( geometry_type ), intent ( out ) :: geom type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: lines (:) integer :: nlines , iatom , io_stat character ( len = 256 ) :: element real ( dp ) :: x , y , z ! Split into lines call split_lines ( xyz_string , lines , nlines ) if ( nlines < 2 ) then call error % set ( ERROR_PARSE , \"XYZ file must have at least 2 lines (natoms + comment)\" ) return end if ! Read number of atoms from first line read ( lines ( 1 ), * , iostat = io_stat ) geom % natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to read number of atoms from first line\" ) return end if if ( geom % natoms < 0 ) then call error % set ( ERROR_PARSE , \"Number of atoms must be non-negative\" ) return end if ! Store comment line geom % comment = trim ( adjustl ( lines ( 2 ))) ! Check we have enough lines if ( nlines < 2 + geom % natoms ) then call error % set ( ERROR_PARSE , \"XYZ file has insufficient lines: expected \" // & trim ( int_to_string ( 2 + geom % natoms )) // \", got \" // & trim ( int_to_string ( nlines ))) return end if ! Allocate arrays allocate ( character ( len = MAX_ELEMENT_SYMBOL_LEN ) :: geom % elements ( geom % natoms )) allocate ( geom % coords ( 3 , geom % natoms )) ! Read atom data do iatom = 1 , geom % natoms read ( lines ( 2 + iatom ), * , iostat = io_stat ) element , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse atom data on line \" // & trim ( int_to_string ( 2 + iatom )) // \": '\" // & trim ( lines ( 2 + iatom )) // \"'\" ) return end if geom % elements ( iatom ) = trim ( adjustl ( element )) geom % coords ( 1 , iatom ) = x geom % coords ( 2 , iatom ) = y geom % coords ( 3 , iatom ) = z end do end subroutine read_xyz_string","tags":"","url":"proc/read_xyz_string.html"},{"title":"split_lines – metalquicha","text":"public pure subroutine split_lines(text, lines, nlines) Split input text into lines based on CR, LF, or CRLF line endings\nTrailing newlines do not create empty lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text character(len=:), intent(out), allocatable :: lines (:) integer, intent(out) :: nlines Called by proc~~split_lines~~CalledByGraph proc~split_lines split_lines proc~read_xyz_string read_xyz_string proc~read_xyz_string->proc~split_lines proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: line_end integer, private :: line_start integer, private :: max_line_len character(len=:), private, allocatable :: temp_lines (:) Source Code pure subroutine split_lines ( text , lines , nlines ) !! Split input text into lines based on CR, LF, or CRLF line endings !! Trailing newlines do not create empty lines character ( len =* ), intent ( in ) :: text character ( len = :), allocatable , intent ( out ) :: lines (:) integer , intent ( out ) :: nlines integer :: i , line_start , line_end , max_line_len character ( len = :), allocatable :: temp_lines (:) if ( len ( text ) == 0 ) then nlines = 0 allocate ( character ( len = 1 ) :: lines ( 0 )) return end if ! Pass 1: Count lines and find maximum line length nlines = 0 max_line_len = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 ! Skip both CR and LF else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 max_line_len = max ( max_line_len , len ( text ) - line_start + 1 ) end if ! Handle empty text or ensure at least length 1 if ( max_line_len == 0 ) max_line_len = 1 ! Allocate output array allocate ( character ( len = max_line_len ) :: temp_lines ( nlines )) ! Pass 2: Extract lines nlines = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = len ( text ) - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if ! Copy to output (use explicit loop for Intel compiler compatibility) allocate ( character ( len = max_line_len ) :: lines ( nlines )) block integer :: iline do iline = 1 , nlines lines ( iline ) = temp_lines ( iline ) end do end block end subroutine split_lines","tags":"","url":"proc/split_lines.html"},{"title":"atomic_basis_num_basis_functions – metalquicha","text":"private pure function atomic_basis_num_basis_functions(self) result(nbf) Get total number of basis functions for an atom Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer Calls proc~~atomic_basis_num_basis_functions~~CallsGraph proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~atomic_basis_num_basis_functions~~CalledByGraph proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ishell Source Code pure function atomic_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for an atom class ( atomic_basis_type ), intent ( in ) :: self integer :: nbf integer :: ishell nbf = 0 do ishell = 1 , self % nshells nbf = nbf + self % shells ( ishell )% num_basis_functions () end do end function atomic_basis_num_basis_functions","tags":"","url":"proc/atomic_basis_num_basis_functions.html"},{"title":"cgto_num_basis_functions – metalquicha","text":"private pure function cgto_num_basis_functions(self) result(nbf) Get number of basis functions in a shell (Cartesian) Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer Called by proc~~cgto_num_basis_functions~~CalledByGraph proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function cgto_num_basis_functions ( self ) result ( nbf ) !! Get number of basis functions in a shell (Cartesian) class ( cgto_type ), intent ( in ) :: self integer :: nbf ! Cartesian: (ang_mom+1)*(ang_mom+2)/2 nbf = ( self % ang_mom + 1 ) * ( self % ang_mom + 2 ) / 2 end function cgto_num_basis_functions","tags":"","url":"proc/cgto_num_basis_functions.html"},{"title":"molecular_basis_num_basis_functions – metalquicha","text":"private pure function molecular_basis_num_basis_functions(self) result(nbf) Get total number of basis functions for the molecule Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Calls proc~~molecular_basis_num_basis_functions~~CallsGraph proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom Source Code pure function molecular_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for the molecule class ( molecular_basis_type ), intent ( in ) :: self integer :: nbf integer :: iatom nbf = 0 do iatom = 1 , self % nelements nbf = nbf + self % elements ( iatom )% num_basis_functions () end do end function molecular_basis_num_basis_functions","tags":"","url":"proc/molecular_basis_num_basis_functions.html"},{"title":"allocate_basis_shells – metalquicha","text":"private pure subroutine allocate_basis_shells(self, nshells) Allocate array of shells in an atomic basis Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells Called by proc~~allocate_basis_shells~~CalledByGraph proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis copy_atomic_basis proc~copy_atomic_basis->proc~allocate_basis_shells proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~allocate_basis_shells proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine allocate_basis_shells ( self , nshells ) !! Allocate array of shells in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nshells self % nshells = nshells allocate ( self % shells ( nshells )) end subroutine allocate_basis_shells","tags":"","url":"proc/allocate_basis_shells.html"},{"title":"atomic_basis_destroy – metalquicha","text":"private pure subroutine atomic_basis_destroy(self) Clean up allocated memory in an atomic basis Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self Calls proc~~atomic_basis_destroy~~CallsGraph proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~atomic_basis_destroy~~CalledByGraph proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~atomic_basis_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~fragment_destroy proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~fragment_destroy proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine atomic_basis_destroy ( self ) !! Clean up allocated memory in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % shells )) then do i = 1 , self % nshells call self % shells ( i )% destroy () end do deallocate ( self % shells ) end if if ( allocated ( self % element )) deallocate ( self % element ) self % nshells = 0 end subroutine atomic_basis_destroy","tags":"","url":"proc/atomic_basis_destroy.html"},{"title":"basis_set_allocate_elements – metalquicha","text":"private pure subroutine basis_set_allocate_elements(self, nelements) Allocate array of atomic basis elements in a molecular basis set Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements Called by proc~~basis_set_allocate_elements~~CalledByGraph proc~basis_set_allocate_elements molecular_basis_type%basis_set_allocate_elements proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~basis_set_allocate_elements Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine basis_set_allocate_elements ( self , nelements ) !! Allocate array of atomic basis elements in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nelements self % nelements = nelements allocate ( self % elements ( nelements )) end subroutine basis_set_allocate_elements","tags":"","url":"proc/basis_set_allocate_elements.html"},{"title":"basis_set_destroy – metalquicha","text":"private pure subroutine basis_set_destroy(self) Clean up allocated memory in a molecular basis set Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self Calls proc~~basis_set_destroy~~CallsGraph proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_set_destroy~~CalledByGraph proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~fragment_destroy proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~fragment_destroy proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine basis_set_destroy ( self ) !! Clean up allocated memory in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % elements )) then do i = 1 , self % nelements call self % elements ( i )% destroy () end do deallocate ( self % elements ) end if self % nelements = 0 end subroutine basis_set_destroy","tags":"","url":"proc/basis_set_destroy.html"},{"title":"cgto_allocate_arrays – metalquicha","text":"private pure subroutine cgto_allocate_arrays(self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc Called by proc~~cgto_allocate_arrays~~CalledByGraph proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis copy_atomic_basis proc~copy_atomic_basis->proc~cgto_allocate_arrays proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~cgto_allocate_arrays proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~parse_element_basis->proc~fill_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine cgto_allocate_arrays ( self , nfunc ) !! Allocate arrays for exponents and coefficients in a CGTO class ( cgto_type ), intent ( inout ) :: self integer , intent ( in ) :: nfunc self % nfunc = nfunc allocate ( self % exponents ( nfunc )) allocate ( self % coefficients ( nfunc )) end subroutine cgto_allocate_arrays","tags":"","url":"proc/cgto_allocate_arrays.html"},{"title":"cgto_destroy – metalquicha","text":"private pure subroutine cgto_destroy(self) Clean up allocated memory in a CGTO Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self Called by proc~~cgto_destroy~~CalledByGraph proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~atomic_basis_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->proc~fragment_destroy proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->proc~fragment_destroy proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~fragment_destroy proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine cgto_destroy ( self ) !! Clean up allocated memory in a CGTO class ( cgto_type ), intent ( inout ) :: self if ( allocated ( self % exponents )) deallocate ( self % exponents ) if ( allocated ( self % coefficients )) deallocate ( self % coefficients ) self % nfunc = 0 self % ang_mom = 0 end subroutine cgto_destroy","tags":"","url":"proc/cgto_destroy.html"},{"title":"normalize_basis_name – metalquicha","text":"public pure function normalize_basis_name(basis_name) result(normalized) Normalize basis set name to filename-safe format Rules:\n  * -> s\n  + -> p\n  Remove parentheses and commas Examples:\n  6-31G -> 6-31Gs\n  6-31+G -> 6-31pGs\n  6-31G(d)    -> 6-31Gd\n  6-311G(d,p) -> 6-311Gdp\n  6-311++G**  -> 6-311ppGss\n  cc-pVDZ     -> cc-pVDZ (unchanged) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name Return Value character(len=:), allocatable Called by proc~~normalize_basis_name~~CalledByGraph proc~normalize_basis_name normalize_basis_name proc~find_basis_file find_basis_file proc~find_basis_file->proc~normalize_basis_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: buffer integer, private :: i logical, private :: in_parens integer, private :: out_pos Source Code pure function normalize_basis_name ( basis_name ) result ( normalized ) !! Normalize basis set name to filename-safe format !! !! Rules: !!   * -> s !!   + -> p !!   Remove parentheses and commas !! !! Examples: !!   6-31G*      -> 6-31Gs !!   6-31+G*     -> 6-31pGs !!   6-31G(d)    -> 6-31Gd !!   6-311G(d,p) -> 6-311Gdp !!   6-311++G**  -> 6-311ppGss !!   cc-pVDZ     -> cc-pVDZ (unchanged) character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable :: normalized integer :: i , out_pos character ( len = 256 ) :: buffer logical :: in_parens buffer = \"\" out_pos = 0 in_parens = . false . do i = 1 , len_trim ( basis_name ) select case ( basis_name ( i : i )) case ( '*' ) ! Star becomes 's' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 's' case ( '+' ) ! Plus becomes 'p' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 'p' case ( '(' ) ! Start of parentheses - we'll extract contents in_parens = . true . case ( ')' ) ! End of parentheses in_parens = . false . case ( ',' , ' ' ) ! Skip commas and spaces (inside or outside parentheses) continue case default ! Copy character as-is out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = basis_name ( i : i ) end select end do normalized = trim ( buffer ( 1 : out_pos )) end function normalize_basis_name","tags":"","url":"proc/normalize_basis_name.html"},{"title":"find_basis_file – metalquicha","text":"public  subroutine find_basis_file(basis_name, filename, error) Find basis set file using normalized name Search strategy:\n  1. Normalize the basis name (e.g., 6-31G* -> 6-31Gs)\n  2. Look for basis_sets/{normalized}.txt\n  3. If not found, return error This is a simple, straightforward approach that assumes\nthe JSON/mqc input provides the correct basis set name. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name character(len=:), intent(out), allocatable :: filename type( error_t ), intent(out) :: error Calls proc~~find_basis_file~~CallsGraph proc~find_basis_file find_basis_file proc~error_set error_t%error_set proc~find_basis_file->proc~error_set proc~normalize_basis_name normalize_basis_name proc~find_basis_file->proc~normalize_basis_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: file_exists character(len=512), private :: filepath character(len=:), private, allocatable :: normalized Source Code subroutine find_basis_file ( basis_name , filename , error ) !! Find basis set file using normalized name !! !! Search strategy: !!   1. Normalize the basis name (e.g., 6-31G* -> 6-31Gs) !!   2. Look for basis_sets/{normalized}.txt !!   3. If not found, return error !! !! This is a simple, straightforward approach that assumes !! the JSON/mqc input provides the correct basis set name. character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable , intent ( out ) :: filename type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: normalized logical :: file_exists character ( len = 512 ) :: filepath ! Normalize the basis name normalized = normalize_basis_name ( basis_name ) ! Construct file path: basis_sets/{normalized}.txt filepath = \"basis_sets/\" // trim ( normalized ) // \".txt\" ! Check if file exists inquire ( file = trim ( filepath ), exist = file_exists ) if ( file_exists ) then filename = trim ( filepath ) else call error % set ( ERROR_IO , \"Basis set file not found: \" // trim ( filepath ) // & \" (from basis name: \" // trim ( basis_name ) // \")\" ) end if end subroutine find_basis_file","tags":"","url":"proc/find_basis_file.html"},{"title":"print_logo – metalquicha","text":"public  subroutine print_logo() Print the PIC Chemistry ASCII sunflower logo Arguments None Called by proc~~print_logo~~CalledByGraph proc~print_logo print_logo program~main main program~main->proc~print_logo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine print_logo () !! Print the PIC Chemistry ASCII sunflower logo write ( * , '(A)' ) ' ' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                        __   __' write ( * , '(A)' ) '                     .-(  ''.''  )-.' write ( * , '(A)' ) '                    (   \\  |  /   )' write ( * , '(A)' ) '                   ( ''`-.;;;;;.-''` )' write ( * , '(A)' ) '                  ( :-==;;;;;;;==-: )' write ( * , '(A)' ) '                   (  .-'';;;;;''-.  )' write ( * , '(A)' ) '                    (``  /  |  \\  ``)' write ( * , '(A)' ) '                     ''-(__.''.__)-''' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                      (Art by jgs)' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '    ╔═══════════════════════════════════════════════╗' write ( * , '(A)' ) '    ║              Met\"al q\"uicha                   ║' write ( * , '(A)' ) '    ║                (Sunflower)                    ║' write ( * , '(A)' ) '    ║     A hastily put together framework for      ║' write ( * , '(A)' ) '    ║   Fortran Based High Performance Computing    ║' write ( * , '(A)' ) '    ║                                               ║' write ( * , '(A)' ) '    ║        Case study: quantum chemistry          ║' write ( * , '(A)' ) '    ╚═══════════════════════════════════════════════╝' write ( * , '(A)' ) ' ' end subroutine print_logo","tags":"","url":"proc/print_logo.html"},{"title":"compute_mbe – metalquicha","text":"private  function compute_mbe(fragment_idx, fragment, lookup, energies, delta_energies, n) result(delta_E) Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas)\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all subset deltaE values\nAll subsets must have been computed already (guaranteed by processing fragments in order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Index of this fragment (already known) integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup Pre-built hash table for lookups real(kind=dp), intent(in) :: energies (:) Pre-computed delta values real(kind=dp), intent(in) :: delta_energies (:) Pre-computed delta values integer, intent(in) :: n Return Value real(kind=dp) Calls proc~~compute_mbe~~CallsGraph proc~compute_mbe compute_mbe proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe~~CalledByGraph proc~compute_mbe compute_mbe proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~compute_mbe proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: has_next integer, private :: i integer, private, allocatable :: indices (:) integer, private, allocatable :: subset (:) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code function compute_mbe ( fragment_idx , fragment , lookup , energies , delta_energies , n ) result ( delta_E ) !! Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas) !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all subset deltaE values !! All subsets must have been computed already (guaranteed by processing fragments in order) integer ( int64 ), intent ( in ) :: fragment_idx !! Index of this fragment (already known) integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup !! Pre-built hash table for lookups real ( dp ), intent ( in ) :: energies (:), delta_energies (:) !! Pre-computed delta values real ( dp ) :: delta_E integer :: subset_size , i integer , allocatable :: indices (:), subset (:) integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer energy delta_E = energies ( fragment_idx ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 allocate ( indices ( subset_size )) allocate ( subset ( subset_size )) ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset , subset_size ) if ( subset_idx < 0 ) error stop \"Subset not found in bottom-up MBE!\" ! Subtract pre-computed delta energy delta_E = delta_E - delta_energies ( subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do deallocate ( indices , subset ) end do end function compute_mbe","tags":"","url":"proc/compute_mbe.html"},{"title":"compute_gmbe_energy – metalquicha","text":"public  subroutine compute_gmbe_energy(monomers, n_monomers, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, total_energy) Uses mqc_result_types proc~~compute_gmbe_energy~~UsesGraph proc~compute_gmbe_energy compute_gmbe_energy module~mqc_result_types mqc_result_types proc~compute_gmbe_energy->module~mqc_result_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib pic_types pic_types module~mqc_result_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute GMBE (Generalized Many-Body Expansion) energy with full inclusion-exclusion For overlapping fragments, the GMBE formula follows the inclusion-exclusion principle:\n  E_total = sum(E_monomers)\n            - sum(E_2-way_intersections)\n            + sum(E_3-way_intersections)\n            - sum(E_4-way_intersections)\n            + … Example for three overlapping fragments (gly0, gly1, gly2):\n  E = E(gly0) + E(gly1) + E(gly2)\n      - E(gly0∩gly1) - E(gly0∩gly2) - E(gly1∩gly2)\n      + E(gly0∩gly1∩gly2) This correctly accounts for all overlapping regions following inclusion-exclusion. Arguments Type Intent Optional Attributes Name integer, intent(in) :: monomers (:) Monomer indices (1-based) integer, intent(in) :: n_monomers Number of monomers type( calculation_result_t ), intent(in) :: monomer_results (:) Monomer energies integer, intent(in) :: n_intersections Number of intersection fragments type( calculation_result_t ), intent(in), optional :: intersection_results (:) Intersection energies integer, intent(in), optional :: intersection_sets (:,:) k-tuples that created each intersection (n_monomers, n_intersections) integer, intent(in), optional :: intersection_levels (:) Level k of each intersection real(kind=dp), intent(out) :: total_energy Total GMBE energy Calls proc~~compute_gmbe_energy~~CallsGraph proc~compute_gmbe_energy compute_gmbe_energy debug debug proc~compute_gmbe_energy->debug info info proc~compute_gmbe_energy->info proc~energy_total energy_t%energy_total proc~compute_gmbe_energy->proc~energy_total proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: k integer, private, allocatable :: level_counts (:) real(kind=dp), private, allocatable :: level_energies (:) integer, private :: max_level real(kind=dp), private :: monomer_energy real(kind=dp), private :: sign_factor Source Code subroutine compute_gmbe_energy ( monomers , n_monomers , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , total_energy ) !! Compute GMBE (Generalized Many-Body Expansion) energy with full inclusion-exclusion !! !! For overlapping fragments, the GMBE formula follows the inclusion-exclusion principle: !!   E_total = sum(E_monomers) !!             - sum(E_2-way_intersections) !!             + sum(E_3-way_intersections) !!             - sum(E_4-way_intersections) !!             + ... !! !! Example for three overlapping fragments (gly0, gly1, gly2): !!   E = E(gly0) + E(gly1) + E(gly2) !!       - E(gly0∩gly1) - E(gly0∩gly2) - E(gly1∩gly2) !!       + E(gly0∩gly1∩gly2) !! !! This correctly accounts for all overlapping regions following inclusion-exclusion. use mqc_result_types , only : calculation_result_t integer , intent ( in ) :: monomers (:) !! Monomer indices (1-based) integer , intent ( in ) :: n_monomers !! Number of monomers type ( calculation_result_t ), intent ( in ) :: monomer_results (:) !! Monomer energies integer , intent ( in ) :: n_intersections !! Number of intersection fragments type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) !! Intersection energies integer , intent ( in ), optional :: intersection_sets (:, :) !! k-tuples that created each intersection (n_monomers, n_intersections) integer , intent ( in ), optional :: intersection_levels (:) !! Level k of each intersection real ( dp ), intent ( out ) :: total_energy !! Total GMBE energy integer :: i , k , max_level real ( dp ) :: monomer_energy real ( dp ), allocatable :: level_energies (:) integer , allocatable :: level_counts (:) real ( dp ) :: sign_factor ! Sum monomer energies monomer_energy = 0.0_dp do i = 1 , n_monomers monomer_energy = monomer_energy + monomer_results ( i )% energy % total () end do ! Start with monomer contribution total_energy = monomer_energy if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then ! Find maximum intersection level max_level = maxval ( intersection_levels ) ! Allocate arrays to track contributions by level allocate ( level_energies ( 2 : max_level )) allocate ( level_counts ( 2 : max_level )) level_energies = 0.0_dp level_counts = 0 ! Sum intersection energies by level with alternating signs do i = 1 , n_intersections k = intersection_levels ( i ) level_energies ( k ) = level_energies ( k ) + intersection_results ( i )% energy % total () level_counts ( k ) = level_counts ( k ) + 1 end do ! Apply inclusion-exclusion: sign is (-1)&#94;(k+1) for k-way intersections do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) total_energy = total_energy + sign_factor * level_energies ( k ) end if end do ! Print breakdown call logger % info ( \"GMBE Energy breakdown (Inclusion-Exclusion Principle):\" ) block character ( len = 256 ) :: line write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"):  \" , monomer_energy call logger % info ( trim ( line )) do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) if ( sign_factor > 0.0_dp ) then write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  +\" , level_energies ( k ) else write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  \" , level_energies ( k ) end if call logger % info ( trim ( line )) end if end do write ( line , '(a,f20.10)' ) \"  Total GMBE:      \" , total_energy call logger % info ( trim ( line )) end block ! Print detailed intersection info at debug level if ( n_intersections > 0 ) then call logger % debug ( \"GMBE intersection details:\" ) do i = 1 , n_intersections block character ( len = 512 ) :: detail_line character ( len = 256 ) :: set_str integer :: j , set_size ! Build string of fragment indices in this intersection set_str = \"(\" set_size = 0 do j = 1 , n_monomers if ( intersection_sets ( j , i ) > 0 ) then if ( set_size > 0 ) set_str = trim ( set_str ) // \",\" write ( set_str , '(a,i0)' ) trim ( set_str ), intersection_sets ( j , i ) set_size = set_size + 1 end if end do set_str = trim ( set_str ) // \")\" sign_factor = real (( - 1 ) ** ( intersection_levels ( i ) + 1 ), dp ) write ( detail_line , '(a,i0,a,i0,a,a,a,f16.8)' ) & \"  Intersection \" , i , \": level=\" , intersection_levels ( i ), & \" fragments=\" , trim ( set_str ), \" energy=\" , intersection_results ( i )% energy % total () call logger % debug ( trim ( detail_line )) end block end do end if deallocate ( level_energies , level_counts ) else ! No intersections - just report monomer sum call logger % info ( \"GMBE Energy breakdown:\" ) block character ( len = 256 ) :: line write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"): \" , monomer_energy call logger % info ( trim ( line )) write ( line , '(a,f20.10)' ) \"  Total GMBE:  \" , total_energy call logger % info ( trim ( line )) end block end if end subroutine compute_gmbe_energy","tags":"","url":"proc/compute_gmbe_energy.html"},{"title":"compute_gmbe_energy_gradient – metalquicha","text":"public  subroutine compute_gmbe_energy_gradient(monomers, n_monomers, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, sys_geom, total_energy, total_gradient, bonds) Uses mqc_physical_fragment mqc_config_parser pic_logger mqc_result_types proc~~compute_gmbe_energy_gradient~~UsesGraph proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient module~mqc_config_parser mqc_config_parser proc~compute_gmbe_energy_gradient->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment proc~compute_gmbe_energy_gradient->module~mqc_physical_fragment module~mqc_result_types mqc_result_types proc~compute_gmbe_energy_gradient->module~mqc_result_types pic_logger pic_logger proc~compute_gmbe_energy_gradient->pic_logger module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute GMBE (Generalized Many-Body Expansion) energy and gradient with full inclusion-exclusion Extends compute_gmbe_energy to also compute gradients for overlapping fragments.\nGradient redistribution handles hydrogen caps at broken bonds. For overlapping fragments, the GMBE formula follows the inclusion-exclusion principle:\n  E_total = sum(E_monomers) - sum(E_2-way) + sum(E_3-way) - …\n  ∇E_total = sum(∇E_monomers) - sum(∇E_2-way) + sum(∇E_3-way) - … Arguments Type Intent Optional Attributes Name integer, intent(in) :: monomers (:) Monomer indices (1-based) integer, intent(in) :: n_monomers Number of monomers type( calculation_result_t ), intent(in) :: monomer_results (:) Monomer energies and gradients integer, intent(in) :: n_intersections Number of intersection fragments type( calculation_result_t ), intent(in), optional :: intersection_results (:) Intersection energies and gradients integer, intent(in), optional :: intersection_sets (:,:) k-tuples that created each intersection (n_monomers, n_intersections) integer, intent(in), optional :: intersection_levels (:) Level k of each intersection type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: total_energy Total GMBE energy real(kind=dp), intent(out) :: total_gradient (:,:) Total GMBE gradient (3, total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps Calls proc~~compute_gmbe_energy_gradient~~CallsGraph proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient configuration configuration proc~compute_gmbe_energy_gradient->configuration info info proc~compute_gmbe_energy_gradient->info proc~build_fragment_from_indices build_fragment_from_indices proc~compute_gmbe_energy_gradient->proc~build_fragment_from_indices proc~energy_total energy_t%energy_total proc~compute_gmbe_energy_gradient->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~compute_gmbe_energy_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~compute_gmbe_energy_gradient->proc~redistribute_cap_gradients to_char to_char proc~compute_gmbe_energy_gradient->to_char warning warning proc~compute_gmbe_energy_gradient->warning proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->to_char error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: current_log_level type( physical_fragment_t ), private :: fragment integer, private :: i integer, private :: k integer, private, allocatable :: level_counts (:) real(kind=dp), private, allocatable :: level_energies (:) integer, private :: max_level real(kind=dp), private :: monomer_energy integer, private, allocatable :: monomer_idx (:) real(kind=dp), private :: sign_factor Source Code subroutine compute_gmbe_energy_gradient ( monomers , n_monomers , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , & sys_geom , total_energy , total_gradient , bonds ) !! Compute GMBE (Generalized Many-Body Expansion) energy and gradient with full inclusion-exclusion !! !! Extends compute_gmbe_energy to also compute gradients for overlapping fragments. !! Gradient redistribution handles hydrogen caps at broken bonds. !! !! For overlapping fragments, the GMBE formula follows the inclusion-exclusion principle: !!   E_total = sum(E_monomers) - sum(E_2-way) + sum(E_3-way) - ... !!   ∇E_total = sum(∇E_monomers) - sum(∇E_2-way) + sum(∇E_3-way) - ... use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_indices , build_fragment_from_atom_list , & redistribute_cap_gradients use mqc_config_parser , only : bond_t use pic_logger , only : info_level integer , intent ( in ) :: monomers (:) !! Monomer indices (1-based) integer , intent ( in ) :: n_monomers !! Number of monomers type ( calculation_result_t ), intent ( in ) :: monomer_results (:) !! Monomer energies and gradients integer , intent ( in ) :: n_intersections !! Number of intersection fragments type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) !! Intersection energies and gradients integer , intent ( in ), optional :: intersection_sets (:, :) !! k-tuples that created each intersection (n_monomers, n_intersections) integer , intent ( in ), optional :: intersection_levels (:) !! Level k of each intersection type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: total_energy !! Total GMBE energy real ( dp ), intent ( out ) :: total_gradient (:, :) !! Total GMBE gradient (3, total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps integer :: i , k , max_level , current_log_level real ( dp ) :: monomer_energy real ( dp ), allocatable :: level_energies (:) integer , allocatable :: level_counts (:) real ( dp ) :: sign_factor type ( physical_fragment_t ) :: fragment integer , allocatable :: monomer_idx (:) ! Zero out total gradient total_gradient = 0.0_dp ! Sum monomer energies and gradients monomer_energy = 0.0_dp do i = 1 , n_monomers monomer_energy = monomer_energy + monomer_results ( i )% energy % total () ! Accumulate monomer gradients if ( monomer_results ( i )% has_gradient ) then ! Rebuild fragment to get local→global mapping allocate ( monomer_idx ( 1 )) monomer_idx ( 1 ) = monomers ( i ) call build_fragment_from_indices ( sys_geom , monomer_idx , fragment , bonds ) call redistribute_cap_gradients ( fragment , monomer_results ( i )% gradient , total_gradient ) call fragment % destroy () deallocate ( monomer_idx ) end if end do ! Start with monomer contribution total_energy = monomer_energy if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then ! Find maximum intersection level max_level = maxval ( intersection_levels ) ! Allocate arrays to track contributions by level allocate ( level_energies ( 2 : max_level )) allocate ( level_counts ( 2 : max_level )) level_energies = 0.0_dp level_counts = 0 ! Sum intersection energies by level with alternating signs do i = 1 , n_intersections k = intersection_levels ( i ) sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) level_energies ( k ) = level_energies ( k ) + intersection_results ( i )% energy % total () level_counts ( k ) = level_counts ( k ) + 1 ! Accumulate intersection gradients with sign if ( intersection_results ( i )% has_gradient ) then ! Intersection gradients are accumulated with the same sign as energy ! Note: We don't need to rebuild intersection fragments here because ! the gradient redistribution was already done during fragment calculation ! via build_fragment_from_atom_list ! TODO: This needs to be implemented properly - we need the fragment geometry ! to get the local→global mapping. For now, log a warning. call logger % warning ( \"GMBE gradient with intersections not fully implemented yet!\" ) call logger % warning ( \"Intersection gradient redistribution requires storing fragment geometry\" ) end if end do ! Apply inclusion-exclusion to energy: sign is (-1)&#94;(k+1) for k-way intersections do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) total_energy = total_energy + sign_factor * level_energies ( k ) end if end do ! Print breakdown call logger % info ( \"GMBE Energy breakdown (Inclusion-Exclusion Principle):\" ) block character ( len = 256 ) :: line write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"):  \" , monomer_energy call logger % info ( trim ( line )) do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) if ( sign_factor > 0.0_dp ) then write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  +\" , level_energies ( k ) else write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  \" , level_energies ( k ) end if call logger % info ( trim ( line )) end if end do write ( line , '(a,f20.10)' ) \"  Total GMBE:      \" , total_energy call logger % info ( trim ( line )) end block deallocate ( level_energies , level_counts ) else ! No intersections - just report monomer sum call logger % info ( \"GMBE Energy breakdown:\" ) block character ( len = 256 ) :: line write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"): \" , monomer_energy call logger % info ( trim ( line )) write ( line , '(a,f20.10)' ) \"  Total GMBE:  \" , total_energy call logger % info ( trim ( line )) end block end if ! Print gradient info (same format as MBE) call logger % info ( \"GMBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE Gradient (Hartree/Bohr):\" ) do i = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , i , \": \" , & total_gradient ( 1 , i ), total_gradient ( 2 , i ), total_gradient ( 3 , i ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end subroutine compute_gmbe_energy_gradient","tags":"","url":"proc/compute_gmbe_energy_gradient.html"},{"title":"compute_gmbe_energy_gradient_hessian – metalquicha","text":"public  subroutine compute_gmbe_energy_gradient_hessian(monomers, n_monomers, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, sys_geom, total_energy, total_gradient, total_hessian, bonds) Uses mqc_physical_fragment mqc_config_parser pic_logger mqc_result_types proc~~compute_gmbe_energy_gradient_hessian~~UsesGraph proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian module~mqc_config_parser mqc_config_parser proc~compute_gmbe_energy_gradient_hessian->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment proc~compute_gmbe_energy_gradient_hessian->module~mqc_physical_fragment module~mqc_result_types mqc_result_types proc~compute_gmbe_energy_gradient_hessian->module~mqc_result_types pic_logger pic_logger proc~compute_gmbe_energy_gradient_hessian->pic_logger module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute GMBE energy, gradient, and Hessian with full inclusion-exclusion\nTODO: Full implementation with intersection Hessians pending Arguments Type Intent Optional Attributes Name integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers type( calculation_result_t ), intent(in) :: monomer_results (:) integer, intent(in) :: n_intersections type( calculation_result_t ), intent(in), optional :: intersection_results (:) integer, intent(in), optional :: intersection_sets (:,:) integer, intent(in), optional :: intersection_levels (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: total_energy real(kind=dp), intent(out) :: total_gradient (:,:) real(kind=dp), intent(out) :: total_hessian (:,:) type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~compute_gmbe_energy_gradient_hessian~~CallsGraph proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian info info proc~compute_gmbe_energy_gradient_hessian->info proc~build_fragment_from_indices build_fragment_from_indices proc~compute_gmbe_energy_gradient_hessian->proc~build_fragment_from_indices proc~energy_total energy_t%energy_total proc~compute_gmbe_energy_gradient_hessian->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~compute_gmbe_energy_gradient_hessian->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~compute_gmbe_energy_gradient_hessian->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~compute_gmbe_energy_gradient_hessian->proc~redistribute_cap_hessian to_char to_char proc~compute_gmbe_energy_gradient_hessian->to_char warning warning proc~compute_gmbe_energy_gradient_hessian->warning proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->to_char error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: current_log_level type( physical_fragment_t ), private :: fragment integer, private :: hess_dim integer, private :: i integer, private :: k integer, private, allocatable :: level_counts (:) real(kind=dp), private, allocatable :: level_energies (:) integer, private :: max_level real(kind=dp), private :: monomer_energy integer, private, allocatable :: monomer_idx (:) real(kind=dp), private :: sign_factor Source Code subroutine compute_gmbe_energy_gradient_hessian ( monomers , n_monomers , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , & sys_geom , total_energy , total_gradient , total_hessian , bonds ) !! Compute GMBE energy, gradient, and Hessian with full inclusion-exclusion !! TODO: Full implementation with intersection Hessians pending use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_gradients , & redistribute_cap_hessian use mqc_config_parser , only : bond_t use pic_logger , only : info_level integer , intent ( in ) :: monomers (:) integer , intent ( in ) :: n_monomers type ( calculation_result_t ), intent ( in ) :: monomer_results (:) integer , intent ( in ) :: n_intersections type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) integer , intent ( in ), optional :: intersection_sets (:, :) integer , intent ( in ), optional :: intersection_levels (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: total_energy real ( dp ), intent ( out ) :: total_gradient (:, :) real ( dp ), intent ( out ) :: total_hessian (:, :) type ( bond_t ), intent ( in ), optional :: bonds (:) integer :: i , k , max_level , current_log_level , hess_dim real ( dp ) :: monomer_energy real ( dp ), allocatable :: level_energies (:) integer , allocatable :: level_counts (:) real ( dp ) :: sign_factor type ( physical_fragment_t ) :: fragment integer , allocatable :: monomer_idx (:) ! Zero out outputs total_gradient = 0.0_dp total_hessian = 0.0_dp hess_dim = 3 * sys_geom % total_atoms ! Sum monomer energies, gradients, and Hessians monomer_energy = 0.0_dp do i = 1 , n_monomers monomer_energy = monomer_energy + monomer_results ( i )% energy % total () ! Accumulate monomer gradients if ( monomer_results ( i )% has_gradient ) then allocate ( monomer_idx ( 1 )) monomer_idx ( 1 ) = monomers ( i ) call build_fragment_from_indices ( sys_geom , monomer_idx , fragment , bonds ) call redistribute_cap_gradients ( fragment , monomer_results ( i )% gradient , total_gradient ) if ( monomer_results ( i )% has_hessian ) then call redistribute_cap_hessian ( fragment , monomer_results ( i )% hessian , total_hessian ) end if call fragment % destroy () deallocate ( monomer_idx ) end if end do total_energy = monomer_energy ! Intersection Hessians not yet implemented if ( n_intersections > 0 . and . present ( intersection_results )) then call logger % warning ( \"GMBE Hessian with intersections not yet fully implemented!\" ) call logger % warning ( \"Only monomer Hessians will be included\" ) end if ! Print info call logger % info ( \"GMBE Energy breakdown:\" ) call logger % info ( \"  Monomers (\" // to_char ( n_monomers ) // \"): \" // to_char ( monomer_energy )) call logger % info ( \"  Total GMBE:  \" // to_char ( total_energy )) call logger % info ( \"GMBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) call logger % info ( \"GMBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) end subroutine compute_gmbe_energy_gradient_hessian","tags":"","url":"proc/compute_gmbe_energy_gradient_hessian.html"},{"title":"compute_mbe_energy – metalquicha","text":"public  subroutine compute_mbe_energy(polymers, fragment_count, max_level, results, total_energy) Uses mqc_result_types proc~~compute_mbe_energy~~UsesGraph proc~compute_mbe_energy compute_mbe_energy module~mqc_result_types mqc_result_types proc~compute_mbe_energy->module~mqc_result_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib pic_types pic_types module~mqc_result_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute the many-body expansion (MBE) energy\nTotal = sum(E(i)) + sum(deltaE(ij)) + sum(deltaE(ijk)) + …\nGeneral n-body correction:\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all lower-order terms\nUses int64 for fragment_count to handle large fragment counts that overflow int32.\nDetailed breakdown is printed only if logger level is verbose or higher. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(out) :: total_energy Calls proc~~compute_mbe_energy~~CallsGraph proc~compute_mbe_energy compute_mbe_energy configuration configuration proc~compute_mbe_energy->configuration debug debug proc~compute_mbe_energy->debug get_elapsed_time get_elapsed_time proc~compute_mbe_energy->get_elapsed_time info info proc~compute_mbe_energy->info proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~energy_total energy_t%energy_total proc~compute_mbe_energy->proc~energy_total proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json start start proc~compute_mbe_energy->start to_char to_char proc~compute_mbe_energy->to_char proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name verbose verbose proc~print_detailed_breakdown->verbose warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->info error error proc~print_detailed_breakdown_json->error proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->warning proc~fragment_lookup_find->fnv_1a_hash proc~fragment_lookup_find->sort proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_energy~~CalledByGraph proc~compute_mbe_energy compute_mbe_energy proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: body_level integer, private :: current_log_level real(kind=dp), private :: delta_E real(kind=dp), private, allocatable :: delta_energies (:) logical, private :: do_detailed_print real(kind=dp), private, allocatable :: energies (:) integer, private :: fragment_size integer(kind=int64), private :: i type( fragment_lookup_t ), private :: lookup type(timer_type), private :: lookup_timer real(kind=dp), private, allocatable :: sum_by_level (:) Source Code subroutine compute_mbe_energy ( polymers , fragment_count , max_level , results , total_energy ) !! Compute the many-body expansion (MBE) energy !! Total = sum(E(i)) + sum(deltaE(ij)) + sum(deltaE(ijk)) + ... !! General n-body correction: !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all lower-order terms !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. !! Detailed breakdown is printed only if logger level is verbose or higher. use mqc_result_types , only : calculation_result_t integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( out ) :: total_energy integer ( int64 ) :: i integer :: fragment_size , body_level , current_log_level real ( dp ), allocatable :: sum_by_level (:), delta_energies (:), energies (:) real ( dp ) :: delta_E logical :: do_detailed_print type ( fragment_lookup_t ) :: lookup type ( timer_type ) :: lookup_timer call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) allocate ( energies ( fragment_count )) sum_by_level = 0.0_dp delta_energies = 0.0_dp ! Extract total energies from results do i = 1_int64 , fragment_count energies ( i ) = results ( i )% energy % total () end do ! Build hash table for fast fragment lookups call lookup_timer % start () call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) call lookup % insert ( polymers ( i , :), fragment_size , i ) end do call lookup_timer % stop () call logger % debug ( \"Time to build lookup table: \" // to_char ( lookup_timer % get_elapsed_time ()) // \" s\" ) call logger % debug ( \"Hash table size: \" // to_char ( lookup % table_size ) // & \", entries: \" // to_char ( lookup % n_entries )) ! Bottom-up computation: process fragments by size (1-body, then 2-body, then 3-body, etc.) ! This eliminates recursion and redundant subset computations do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == 1 ) then ! 1-body: deltaE = E (no subsets to subtract) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: deltaE = E - sum(all subset deltaEs) ! All subsets have already been computed in previous iterations delta_E = compute_mbe ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E end if end do ! Clean up lookup table call lookup % destroy () total_energy = sum ( sum_by_level ) ! Print text summary to console call logger % info ( \"MBE Energy breakdown:\" ) do body_level = 1 , max_level if ( abs ( sum_by_level ( body_level )) > 1e-15_dp ) then block character ( len = 256 ) :: energy_line write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , body_level , \"-body:  \" , sum_by_level ( body_level ) call logger % info ( trim ( energy_line )) end block end if end do block character ( len = 256 ) :: total_line write ( total_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( total_line )) end block ! Print detailed breakdown if requested if ( do_detailed_print ) then call print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) end if ! Always write JSON file for machine-readable output call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy ) deallocate ( sum_by_level , delta_energies , energies ) end subroutine compute_mbe_energy","tags":"","url":"proc/compute_mbe_energy.html"},{"title":"compute_mbe_energy_gradient – metalquicha","text":"public  subroutine compute_mbe_energy_gradient(polymers, fragment_count, max_level, results, sys_geom, total_energy, total_gradient, bonds) Uses mqc_config_parser mqc_result_types proc~~compute_mbe_energy_gradient~~UsesGraph proc~compute_mbe_energy_gradient compute_mbe_energy_gradient module~mqc_config_parser mqc_config_parser proc~compute_mbe_energy_gradient->module~mqc_config_parser module~mqc_result_types mqc_result_types proc~compute_mbe_energy_gradient->module~mqc_result_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute both MBE energy and gradient in a single pass\nThis is more efficient than calling compute_mbe_energy and compute_mbe_gradient separately\nas it only builds the lookup table once and processes all fragments in one loop Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( calculation_result_t ), intent(in) :: results (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: total_energy real(kind=dp), intent(out) :: total_gradient (:,:) (3, total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps Calls proc~~compute_mbe_energy_gradient~~CallsGraph proc~compute_mbe_energy_gradient compute_mbe_energy_gradient configuration configuration proc~compute_mbe_energy_gradient->configuration debug debug proc~compute_mbe_energy_gradient->debug error error proc~compute_mbe_energy_gradient->error get_elapsed_time get_elapsed_time proc~compute_mbe_energy_gradient->get_elapsed_time info info proc~compute_mbe_energy_gradient->info proc~compute_mbe compute_mbe proc~compute_mbe_energy_gradient->proc~compute_mbe proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~energy_total energy_t%energy_total proc~compute_mbe_energy_gradient->proc~energy_total proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy_gradient->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy_gradient->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy_gradient->proc~fragment_lookup_insert proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown_json start start proc~compute_mbe_energy_gradient->start to_char to_char proc~compute_mbe_energy_gradient->to_char proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->debug proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name verbose verbose proc~print_detailed_breakdown->verbose warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->info proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->warning proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_lookup_find->fnv_1a_hash proc~fragment_lookup_find->sort proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_energy_gradient~~CalledByGraph proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: body_level integer, private :: current_log_level real(kind=dp), private :: delta_E real(kind=dp), private, allocatable :: delta_energies (:) real(kind=dp), private, allocatable :: delta_gradients (:,:,:) (3, total_atoms, fragment_count) logical, private :: do_detailed_print real(kind=dp), private, allocatable :: energies (:) integer, private :: fragment_size integer(kind=int64), private :: i integer, private :: iatom type( fragment_lookup_t ), private :: lookup type(timer_type), private :: lookup_timer real(kind=dp), private, allocatable :: sum_by_level (:) Source Code subroutine compute_mbe_energy_gradient ( polymers , fragment_count , max_level , results , sys_geom , & total_energy , total_gradient , bonds ) !! Compute both MBE energy and gradient in a single pass !! This is more efficient than calling compute_mbe_energy and compute_mbe_gradient separately !! as it only builds the lookup table once and processes all fragments in one loop use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level type ( calculation_result_t ), intent ( in ) :: results (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: total_energy real ( dp ), intent ( out ) :: total_gradient (:, :) !! (3, total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps integer ( int64 ) :: i integer :: fragment_size , body_level , current_log_level , iatom real ( dp ), allocatable :: sum_by_level (:), delta_energies (:), energies (:) real ( dp ), allocatable :: delta_gradients (:, :, :) !! (3, total_atoms, fragment_count) real ( dp ) :: delta_E logical :: do_detailed_print type ( fragment_lookup_t ) :: lookup type ( timer_type ) :: lookup_timer ! Validate that all fragments have gradients do i = 1_int64 , fragment_count if (. not . results ( i )% has_gradient ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have gradient!\" ) error stop \"Missing gradient in compute_mbe_energy_gradient\" end if end do call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) ! Allocate arrays for energy allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) allocate ( energies ( fragment_count )) sum_by_level = 0.0_dp delta_energies = 0.0_dp ! Extract total energies from results do i = 1_int64 , fragment_count energies ( i ) = results ( i )% energy % total () end do ! Allocate arrays for gradient allocate ( delta_gradients ( 3 , sys_geom % total_atoms , fragment_count )) delta_gradients = 0.0_dp total_gradient = 0.0_dp ! Build hash table for fast fragment lookups (shared for both energy and gradient) call lookup_timer % start () call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) call lookup % insert ( polymers ( i , :), fragment_size , i ) end do call lookup_timer % stop () call logger % debug ( \"Time to build lookup table: \" // to_char ( lookup_timer % get_elapsed_time ()) // \" s\" ) call logger % debug ( \"Hash table size: \" // to_char ( lookup % table_size ) // & \", entries: \" // to_char ( lookup % n_entries )) ! Bottom-up computation: process fragments by size (1-body, 2-body, 3-body, etc.) ! Compute both energy and gradient deltas in the same loop do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == 1 ) then ! 1-body: deltaE = E, deltaG = G (no subsets to subtract) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) ! Map fragment gradient to system coordinates call map_fragment_to_system_gradient ( results ( i )% gradient , polymers ( i , 1 : fragment_size ), & sys_geom , delta_gradients (:, :, i ), bonds ) else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: deltaE = E - sum(all subset deltaEs), deltaG = G - sum(all subset deltaGs) ! Energy delta delta_E = compute_mbe ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E ! Gradient delta call compute_mbe_gradient ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_gradients , fragment_size , sys_geom , bonds ) end if end do ! Clean up lookup table call lookup % destroy () ! Compute total energy total_energy = sum ( sum_by_level ) ! Compute total gradient do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then total_gradient = total_gradient + delta_gradients (:, :, i ) end if end do ! Print energy breakdown call logger % info ( \"MBE Energy breakdown:\" ) do body_level = 1 , max_level if ( abs ( sum_by_level ( body_level )) > 1e-15_dp ) then block character ( len = 256 ) :: energy_line write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , body_level , \"-body:  \" , sum_by_level ( body_level ) call logger % info ( trim ( energy_line )) end block end if end do block character ( len = 256 ) :: total_line write ( total_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( total_line )) end block ! Print gradient info call logger % info ( \"MBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if verbose and small system if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total MBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if ! Print detailed breakdown if requested if ( do_detailed_print ) then call print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) end if ! Always write JSON file for machine-readable output (include gradient) call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy , total_gradient ) deallocate ( sum_by_level , delta_energies , energies , delta_gradients ) end subroutine compute_mbe_energy_gradient","tags":"","url":"proc/compute_mbe_energy_gradient.html"},{"title":"compute_mbe_energy_gradient_hessian – metalquicha","text":"public  subroutine compute_mbe_energy_gradient_hessian(polymers, fragment_count, max_level, results, sys_geom, total_energy, total_gradient, total_hessian, bonds) Uses mqc_physical_fragment mqc_config_parser mqc_result_types proc~~compute_mbe_energy_gradient_hessian~~UsesGraph proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian module~mqc_config_parser mqc_config_parser proc~compute_mbe_energy_gradient_hessian->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment proc~compute_mbe_energy_gradient_hessian->module~mqc_physical_fragment module~mqc_result_types mqc_result_types proc~compute_mbe_energy_gradient_hessian->module~mqc_result_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute MBE energy, gradient, and Hessian in a single pass\nMost efficient for simultaneous energy+gradient+Hessian calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( calculation_result_t ), intent(in) :: results (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: total_energy real(kind=dp), intent(out) :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(out) :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~compute_mbe_energy_gradient_hessian~~CallsGraph proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian configuration configuration proc~compute_mbe_energy_gradient_hessian->configuration error error proc~compute_mbe_energy_gradient_hessian->error info info proc~compute_mbe_energy_gradient_hessian->info proc~compute_mbe compute_mbe proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~energy_total energy_t%energy_total proc~compute_mbe_energy_gradient_hessian->proc~energy_total proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_insert proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy_gradient_hessian->proc~print_detailed_breakdown_json to_char to_char proc~compute_mbe_energy_gradient_hessian->to_char proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort proc~map_fragment_to_system_gradient->configuration debug debug proc~map_fragment_to_system_gradient->debug proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->info proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename warning warning proc~print_detailed_breakdown_json->warning proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_lookup_find->fnv_1a_hash proc~fragment_lookup_find->sort proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_energy_gradient_hessian~~CalledByGraph proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: body_level integer, private :: current_log_level real(kind=dp), private :: delta_E real(kind=dp), private, allocatable :: delta_energies (:) real(kind=dp), private, allocatable :: delta_gradients (:,:,:) real(kind=dp), private, allocatable :: delta_hessians (:,:,:) logical, private :: do_detailed_print real(kind=dp), private, allocatable :: energies (:) type( physical_fragment_t ), private :: fragment integer, private :: fragment_size integer, private :: hess_dim integer(kind=int64), private :: i integer, private :: iatom type( fragment_lookup_t ), private :: lookup real(kind=dp), private, allocatable :: sum_by_level (:) real(kind=dp), private, allocatable :: temp_hess (:,:) Source Code subroutine compute_mbe_energy_gradient_hessian ( polymers , fragment_count , max_level , results , sys_geom , & total_energy , total_gradient , total_hessian , bonds ) !! Compute MBE energy, gradient, and Hessian in a single pass !! Most efficient for simultaneous energy+gradient+Hessian calculations use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_gradients , & redistribute_cap_hessian integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level type ( calculation_result_t ), intent ( in ) :: results (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: total_energy real ( dp ), intent ( out ) :: total_gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( out ) :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int64 ) :: i integer :: fragment_size , body_level , current_log_level , iatom real ( dp ), allocatable :: sum_by_level (:), delta_energies (:), energies (:) real ( dp ), allocatable :: delta_gradients (:, :, :), delta_hessians (:, :, :) type ( fragment_lookup_t ) :: lookup logical :: do_detailed_print integer :: hess_dim type ( physical_fragment_t ) :: fragment real ( dp ), allocatable :: temp_hess (:, :) real ( dp ) :: delta_E hess_dim = 3 * sys_geom % total_atoms ! Validate all fragments have Hessians do i = 1 , fragment_count if (. not . results ( i )% has_hessian ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have Hessian!\" ) error stop \"Missing Hessian in compute_mbe_energy_gradient_hessian\" end if end do call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) allocate ( energies ( fragment_count )) allocate ( delta_gradients ( 3 , sys_geom % total_atoms , fragment_count )) allocate ( delta_hessians ( hess_dim , hess_dim , fragment_count )) allocate ( temp_hess ( hess_dim , hess_dim )) sum_by_level = 0.0_dp delta_energies = 0.0_dp energies = 0.0_dp delta_gradients = 0.0_dp delta_hessians = 0.0_dp total_gradient = 0.0_dp total_hessian = 0.0_dp ! Build lookup table for fragment indices call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size > 0 . and . fragment_size <= max_level ) then call lookup % insert ( polymers ( i , 1 : fragment_size ), fragment_size , i ) end if end do ! Compute delta energies, gradients, and Hessians for each fragment do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) energies ( i ) = results ( i )% energy % total () if ( fragment_size == 1 ) then ! 1-body: delta = value (no subsets) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) ! Map fragment gradient and Hessian to system coordinates call map_fragment_to_system_gradient ( results ( i )% gradient , polymers ( i , 1 : fragment_size ), & sys_geom , delta_gradients (:, :, i ), bonds ) call map_fragment_to_system_hessian ( results ( i )% hessian , polymers ( i , 1 : fragment_size ), & sys_geom , delta_hessians (:, :, i ), bonds ) else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: delta = value - sum(all subset deltas) delta_E = compute_mbe ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E ! Gradient delta call compute_mbe_gradient ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_gradients , fragment_size , sys_geom , bonds ) ! Hessian delta call compute_mbe_hessian ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_hessians , fragment_size , sys_geom , bonds ) end if end do ! Clean up lookup table call lookup % destroy () ! Compute total energy, gradient, and Hessian total_energy = sum ( sum_by_level ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then total_gradient = total_gradient + delta_gradients (:, :, i ) total_hessian = total_hessian + delta_hessians (:, :, i ) end if end do ! Print energy breakdown call logger % info ( \"MBE Energy breakdown:\" ) do body_level = 1 , max_level if ( abs ( sum_by_level ( body_level )) > 1e-15_dp ) then block character ( len = 256 ) :: energy_line write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , body_level , \"-body:  \" , sum_by_level ( body_level ) call logger % info ( trim ( energy_line )) end block end if end do block character ( len = 256 ) :: total_line write ( total_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( total_line )) end block ! Print gradient and Hessian info call logger % info ( \"MBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) call logger % info ( \"MBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Print detailed gradient if verbose and small system if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total MBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if ! Always write JSON file for machine-readable output (include gradient and Hessian) call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy , total_gradient , total_hessian ) deallocate ( sum_by_level , delta_energies , energies , delta_gradients , delta_hessians , temp_hess ) end subroutine compute_mbe_energy_gradient_hessian","tags":"","url":"proc/compute_mbe_energy_gradient_hessian.html"},{"title":"compute_mbe_gradient – metalquicha","text":"private  subroutine compute_mbe_gradient(fragment_idx, fragment, lookup, results, delta_gradients, n, sys_geom, bonds) Uses mqc_config_parser mqc_result_types proc~~compute_mbe_gradient~~UsesGraph proc~compute_mbe_gradient compute_mbe_gradient module~mqc_config_parser mqc_config_parser proc~compute_mbe_gradient->module~mqc_config_parser module~mqc_result_types mqc_result_types proc~compute_mbe_gradient->module~mqc_result_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Bottom-up computation of n-body gradient correction\nExactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs)\nAll gradients are in system coordinates, so subtraction is simple Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_gradients (:,:,:) (3, total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps Calls proc~~compute_mbe_gradient~~CallsGraph proc~compute_mbe_gradient compute_mbe_gradient proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_gradient->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_gradient->proc~get_next_combination proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort configuration configuration proc~map_fragment_to_system_gradient->configuration debug debug proc~map_fragment_to_system_gradient->debug proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_gradient~~CalledByGraph proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: has_next integer, private :: i integer, private, allocatable :: indices (:) integer, private, allocatable :: subset (:) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code subroutine compute_mbe_gradient ( fragment_idx , fragment , lookup , results , delta_gradients , n , sys_geom , bonds ) !! Bottom-up computation of n-body gradient correction !! Exactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs) !! All gradients are in system coordinates, so subtraction is simple use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_gradients (:, :, :) !! (3, total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps integer :: subset_size , i integer , allocatable :: indices (:), subset (:) integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer gradient mapped to system coordinates call map_fragment_to_system_gradient ( results ( fragment_idx )% gradient , fragment , & sys_geom , delta_gradients (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) ! This is EXACTLY like the energy calculation, but for each gradient component do subset_size = 1 , n - 1 allocate ( indices ( subset_size )) allocate ( subset ( subset_size )) ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset , subset_size ) if ( subset_idx < 0 ) error stop \"Subset not found in MBE gradient!\" ! Subtract pre-computed delta gradient (simple array subtraction in system coords) delta_gradients (:, :, fragment_idx ) = delta_gradients (:, :, fragment_idx ) - & delta_gradients (:, :, subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do deallocate ( indices , subset ) end do end subroutine compute_mbe_gradient","tags":"","url":"proc/compute_mbe_gradient.html"},{"title":"compute_mbe_hessian – metalquicha","text":"private  subroutine compute_mbe_hessian(fragment_idx, fragment, lookup, results, delta_hessians, n, sys_geom, bonds) Uses mqc_config_parser mqc_result_types proc~~compute_mbe_hessian~~UsesGraph proc~compute_mbe_hessian compute_mbe_hessian module~mqc_config_parser mqc_config_parser proc~compute_mbe_hessian->module~mqc_config_parser module~mqc_result_types mqc_result_types proc~compute_mbe_hessian->module~mqc_result_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Bottom-up computation of n-body Hessian correction\nMirrors MBE gradient logic but for second derivatives Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_hessians (:,:,:) (3 total_atoms, 3 total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~compute_mbe_hessian~~CallsGraph proc~compute_mbe_hessian compute_mbe_hessian proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe_hessian->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe_hessian->proc~get_next_combination proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_hessian~~CalledByGraph proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: has_next integer, private :: hess_dim integer, private :: i integer, private, allocatable :: indices (:) integer, private, allocatable :: subset (:) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code subroutine compute_mbe_hessian ( fragment_idx , fragment , lookup , results , delta_hessians , n , sys_geom , bonds ) !! Bottom-up computation of n-body Hessian correction !! Mirrors MBE gradient logic but for second derivatives use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_hessians (:, :, :) !! (3*total_atoms, 3*total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) integer :: subset_size , i , hess_dim integer , allocatable :: indices (:), subset (:) integer ( int64 ) :: subset_idx logical :: has_next hess_dim = 3 * sys_geom % total_atoms ! Start with the full n-mer Hessian mapped to system coordinates call map_fragment_to_system_hessian ( results ( fragment_idx )% hessian , fragment , & sys_geom , delta_hessians (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 allocate ( indices ( subset_size )) indices = [( i , i = 1 , subset_size )] allocate ( subset ( subset_size )) has_next = . true . do while ( has_next ) subset = fragment ( indices ) subset_idx = lookup % find ( subset , subset_size ) if ( subset_idx > 0 ) then ! Subtract this subset's delta Hessian delta_hessians (:, :, fragment_idx ) = delta_hessians (:, :, fragment_idx ) - & delta_hessians (:, :, subset_idx ) end if call get_next_combination ( indices , subset_size , n , has_next ) end do deallocate ( indices , subset ) end do end subroutine compute_mbe_hessian","tags":"","url":"proc/compute_mbe_hessian.html"},{"title":"map_fragment_to_system_gradient – metalquicha","text":"private  subroutine map_fragment_to_system_gradient(frag_grad, monomers, sys_geom, sys_grad, bonds) Uses mqc_physical_fragment mqc_config_parser pic_logger proc~~map_fragment_to_system_gradient~~UsesGraph proc~map_fragment_to_system_gradient map_fragment_to_system_gradient module~mqc_config_parser mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment proc~map_fragment_to_system_gradient->module~mqc_physical_fragment pic_logger pic_logger proc~map_fragment_to_system_gradient->pic_logger module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Map fragment gradient to system gradient coordinates with hydrogen cap redistribution This function rebuilds the fragment to get local→global mappings and cap information,\nthen redistributes gradients including hydrogen caps to their original atoms. If bonds are not present, uses the old simple mapping (no caps possible). Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_grad (:,:) (3, natoms_frag) integer, intent(in) :: monomers (:) Monomer indices in fragment type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_grad (:,:) (3, total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps Calls proc~~map_fragment_to_system_gradient~~CallsGraph proc~map_fragment_to_system_gradient map_fragment_to_system_gradient configuration configuration proc~map_fragment_to_system_gradient->configuration debug debug proc~map_fragment_to_system_gradient->debug proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~map_fragment_to_system_gradient~~CalledByGraph proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: current_log_level integer, private :: frag_atom_idx type( physical_fragment_t ), private :: fragment integer, private :: i_atom integer, private :: i_mon integer, private :: sys_atom_idx Source Code subroutine map_fragment_to_system_gradient ( frag_grad , monomers , sys_geom , sys_grad , bonds ) !! Map fragment gradient to system gradient coordinates with hydrogen cap redistribution !! !! This function rebuilds the fragment to get local→global mappings and cap information, !! then redistributes gradients including hydrogen caps to their original atoms. !! !! If bonds are not present, uses the old simple mapping (no caps possible). use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_gradients use mqc_config_parser , only : bond_t use pic_logger , only : verbose_level real ( dp ), intent ( in ) :: frag_grad (:, :) !! (3, natoms_frag) integer , intent ( in ) :: monomers (:) !! Monomer indices in fragment type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_grad (:, :) !! (3, total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps type ( physical_fragment_t ) :: fragment integer :: i_mon , i_atom , frag_atom_idx , sys_atom_idx integer :: current_log_level ! Explicitly zero out the entire sys_grad array sys_grad = 0.0_dp ! Debug output call logger % configuration ( level = current_log_level ) if ( current_log_level >= debug_level ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,*(i0,1x))' ) \"  Mapping fragment with \" , size ( monomers ), \" monomers: \" , monomers call logger % debug ( trim ( debug_msg )) write ( debug_msg , '(a,i0,a)' ) \"  Fragment has \" , size ( frag_grad , 2 ), \" atoms\" call logger % debug ( trim ( debug_msg )) end block end if if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , bonds ) ! Use new gradient redistribution with cap handling call redistribute_cap_gradients ( fragment , frag_grad , sys_grad ) ! Clean up call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment gradient to system positions (fixed-size monomers only) frag_atom_idx = 0 do i_mon = 1 , size ( monomers ) do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_idx = frag_atom_idx + 1 sys_atom_idx = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom if ( current_log_level >= debug_level . and . i_atom == 1 ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,i0,a,i0)' ) & \"    Monomer \" , monomers ( i_mon ), \": frag atoms \" , & frag_atom_idx , \" -> sys atom \" , sys_atom_idx call logger % debug ( trim ( debug_msg )) end block end if sys_grad (:, sys_atom_idx ) = frag_grad (:, frag_atom_idx ) end do end do end if end subroutine map_fragment_to_system_gradient","tags":"","url":"proc/map_fragment_to_system_gradient.html"},{"title":"map_fragment_to_system_hessian – metalquicha","text":"private  subroutine map_fragment_to_system_hessian(frag_hess, monomers, sys_geom, sys_hess, bonds) Uses mqc_physical_fragment mqc_config_parser proc~~map_fragment_to_system_hessian~~UsesGraph proc~map_fragment_to_system_hessian map_fragment_to_system_hessian module~mqc_config_parser mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment proc~map_fragment_to_system_hessian->module~mqc_physical_fragment module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_hess (:,:) (3 natoms_frag, 3 natoms_frag) integer, intent(in) :: monomers (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_hess (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~map_fragment_to_system_hessian~~CallsGraph proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy error error proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol to_char to_char proc~check_duplicate_atoms->to_char proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~map_fragment_to_system_hessian~~CalledByGraph proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( physical_fragment_t ), private :: fragment Source Code subroutine map_fragment_to_system_hessian ( frag_hess , monomers , sys_geom , sys_hess , bonds ) !! Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_hessian use mqc_config_parser , only : bond_t real ( dp ), intent ( in ) :: frag_hess (:, :) !! (3*natoms_frag, 3*natoms_frag) integer , intent ( in ) :: monomers (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_hess (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: fragment ! Zero out sys_hess = 0.0_dp if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , bonds ) call redistribute_cap_hessian ( fragment , frag_hess , sys_hess ) call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment Hessian to system positions (fixed-size monomers only) block integer :: i_mon , j_mon , i_atom , j_atom integer :: frag_atom_i , frag_atom_j , sys_atom_i , sys_atom_j integer :: frag_row_start , frag_col_start , sys_row_start , sys_col_start integer :: n_monomers n_monomers = size ( monomers ) frag_atom_i = 0 ! Map each monomer's atoms do i_mon = 1 , n_monomers do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_i = frag_atom_i + 1 sys_atom_i = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom frag_row_start = ( frag_atom_i - 1 ) * 3 + 1 sys_row_start = ( sys_atom_i - 1 ) * 3 + 1 ! Map this atom's Hessian blocks with all other atoms in fragment frag_atom_j = 0 do j_mon = 1 , n_monomers do j_atom = 1 , sys_geom % atoms_per_monomer frag_atom_j = frag_atom_j + 1 sys_atom_j = ( monomers ( j_mon ) - 1 ) * sys_geom % atoms_per_monomer + j_atom frag_col_start = ( frag_atom_j - 1 ) * 3 + 1 sys_col_start = ( sys_atom_j - 1 ) * 3 + 1 ! Copy the 3×3 block for this atom pair sys_hess ( sys_row_start : sys_row_start + 2 , sys_col_start : sys_col_start + 2 ) = & frag_hess ( frag_row_start : frag_row_start + 2 , frag_col_start : frag_col_start + 2 ) end do end do end do end do end block end if end subroutine map_fragment_to_system_hessian","tags":"","url":"proc/map_fragment_to_system_hessian.html"},{"title":"extract_element – metalquicha","text":"public  function extract_element(basis_file, element) result(element_content) Extract the basis set data for a specific element from the basis file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(in) :: basis_file character(len=*), intent(in) :: element Return Value character(len=:), allocatable Calls proc~~extract_element~~CallsGraph proc~extract_element extract_element proc~is_letter is_letter proc~extract_element->proc~is_letter proc~is_uppercase_letter is_uppercase_letter proc~extract_element->proc~is_uppercase_letter proc~uppercase uppercase proc~extract_element->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: at_line_start integer, private :: end_pos integer, private :: i character(len=:), private, allocatable :: search_element integer, private :: start_pos Source Code function extract_element ( basis_file , element ) result ( element_content ) !! Extract the basis set data for a specific element from the basis file type ( basis_file_t ), intent ( in ) :: basis_file character ( len =* ), intent ( in ) :: element character ( len = :), allocatable :: element_content integer :: start_pos , end_pos , i character ( len = :), allocatable :: search_element logical :: at_line_start ! Convert element to uppercase for searching search_element = uppercase ( trim ( element )) ! Find the element name (it appears on its own line) start_pos = index ( basis_file % data_section , new_line ( 'a' ) // trim ( search_element ) // new_line ( 'a' )) if ( start_pos == 0 ) then ! Try without leading newline (might be first element after $DATA) if ( index ( basis_file % data_section , trim ( search_element ) // new_line ( 'a' )) == 1 ) then start_pos = 1 else error stop \"Element not found in basis set file: \" // element end if else start_pos = start_pos + 1 ! Skip the leading newline end if ! Find the next element by looking for a line that: ! - Starts with an uppercase letter ! - Has a second character that is also a letter (not a space or number) ! This distinguishes \"CARBON\" from \"S   3\" end_pos = len ( basis_file % data_section ) at_line_start = . false . i = start_pos + len ( search_element ) + 1 do while ( i < len ( basis_file % data_section )) if ( basis_file % data_section ( i : i ) == new_line ( 'a' )) then at_line_start = . true . i = i + 1 cycle end if if ( at_line_start ) then ! We're at the start of a new line if ( is_uppercase_letter ( basis_file % data_section ( i : i ))) then ! Check if next character is also a letter if ( i + 1 <= len ( basis_file % data_section )) then if ( is_letter ( basis_file % data_section ( i + 1 : i + 1 ))) then ! Found next element! end_pos = i - 1 exit end if end if end if at_line_start = . false . end if i = i + 1 end do ! Extract the section element_content = basis_file % data_section ( start_pos : end_pos ) end function extract_element","tags":"","url":"proc/extract_element.html"},{"title":"strings_equal – metalquicha","text":"public pure function strings_equal(str1, str2) result(equal) Compare two strings after trimming and adjusting (removing leading/trailing whitespace)\nCompare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical Called by proc~~strings_equal~~CalledByGraph proc~strings_equal strings_equal proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~strings_equal proc~find_unique_strings find_unique_strings proc~build_molecular_basis->proc~find_unique_strings proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~strings_equal proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~strings_equal proc~find_unique_strings->proc~strings_equal proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function strings_equal ( str1 , str2 ) result ( equal ) !! Compare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) character ( len =* ), intent ( in ) :: str1 , str2 logical :: equal equal = trim ( adjustl ( str1 )) == trim ( adjustl ( str2 )) end function strings_equal","tags":"","url":"proc/strings_equal.html"},{"title":"is_letter – metalquicha","text":"private pure function is_letter(c) result(is_alpha) Check if character is a letter (A-Z or a-z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_letter~~CalledByGraph proc~is_letter is_letter proc~extract_element extract_element proc~extract_element->proc~is_letter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code pure function is_letter ( c ) result ( is_alpha ) !! Check if character is a letter (A-Z or a-z) character ( len = 1 ), intent ( in ) :: c logical :: is_alpha integer :: ic ic = iachar ( c ) is_alpha = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) . or . & ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) end function is_letter","tags":"","url":"proc/is_letter.html"},{"title":"is_uppercase_letter – metalquicha","text":"private pure function is_uppercase_letter(c) result(is_upper) Check if character is an uppercase letter (A-Z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_uppercase_letter~~CalledByGraph proc~is_uppercase_letter is_uppercase_letter proc~extract_element extract_element proc~extract_element->proc~is_uppercase_letter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code pure function is_uppercase_letter ( c ) result ( is_upper ) !! Check if character is an uppercase letter (A-Z) character ( len = 1 ), intent ( in ) :: c logical :: is_upper integer :: ic ic = iachar ( c ) is_upper = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) end function is_uppercase_letter","tags":"","url":"proc/is_uppercase_letter.html"},{"title":"uppercase – metalquicha","text":"private pure function uppercase(str) result(upper) Convert a string to uppercase, should use pic_ascii! Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:), allocatable Called by proc~~uppercase~~CalledByGraph proc~uppercase uppercase proc~extract_element extract_element proc~extract_element->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: ic Source Code pure function uppercase ( str ) result ( upper ) !! Convert a string to uppercase, should use pic_ascii! character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: upper integer :: i , ic allocate ( character ( len = len ( str )) :: upper ) upper = str do i = 1 , len ( str ) ic = iachar ( str ( i : i )) if ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) then upper ( i : i ) = achar ( ic - 32 ) end if end do end function uppercase","tags":"","url":"proc/uppercase.html"},{"title":"open_basis_file – metalquicha","text":"public  subroutine open_basis_file(basis_file, filename) Open and read a GAMESS formatted basis set file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(out) :: basis_file character(len=*), intent(in) :: filename Variables Type Visibility Attributes Name Initial integer, private :: data_end integer, private :: data_start logical, private :: file_exists integer, private :: file_size integer, private :: iostat integer, private :: unit Source Code subroutine open_basis_file ( basis_file , filename ) !! Open and read a GAMESS formatted basis set file type ( basis_file_t ), intent ( out ) :: basis_file character ( len =* ), intent ( in ) :: filename integer :: unit , iostat , file_size logical :: file_exists integer :: data_start , data_end ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then error stop \"Basis set file not found: \" // filename end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: basis_file % full_content ) ! Open and read entire file open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = iostat ) if ( iostat /= 0 ) error stop \"Error opening file: \" // filename read ( unit , iostat = iostat ) basis_file % full_content if ( iostat /= 0 ) error stop \"Error reading file: \" // filename close ( unit ) ! Extract the $DATA section data_start = index ( basis_file % full_content , \"$DATA\" ) if ( data_start == 0 ) then error stop \"Could not find $DATA section in basis set file\" end if data_end = index ( basis_file % full_content ( data_start :), \"$END\" ) if ( data_end == 0 ) then error stop \"Could not find $END marker in basis set file\" end if ! Store just the data section (between $DATA and $END) basis_file % data_section = basis_file % full_content ( data_start + 5 : data_start + data_end - 2 ) end subroutine open_basis_file","tags":"","url":"proc/open_basis_file.html"},{"title":"arrays_equal_internal – metalquicha","text":"private pure function arrays_equal_internal(a, b, n) result(equal) Check if two arrays are equal Arguments Type Intent Optional Attributes Name integer, intent(in) :: a (:) integer, intent(in) :: b (:) integer, intent(in) :: n Return Value logical Called by proc~~arrays_equal_internal~~CalledByGraph proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~fragment_lookup_find->proc~arrays_equal_internal proc~compute_mbe compute_mbe proc~compute_mbe->proc~fragment_lookup_find proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~compute_mbe proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure function arrays_equal_internal ( a , b , n ) result ( equal ) !! Check if two arrays are equal integer , intent ( in ) :: a (:), b (:), n logical :: equal integer :: i equal = . true . if ( size ( a ) /= n . or . size ( b ) /= n ) then equal = . false . return end if do i = 1 , n if ( a ( i ) /= b ( i )) then equal = . false . return end if end do end function arrays_equal_internal","tags":"","url":"proc/arrays_equal_internal.html"},{"title":"fragment_lookup_find – metalquicha","text":"private  function fragment_lookup_find(this, monomers, n) result(idx) Find fragment index for given monomer combination Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) Calls proc~~fragment_lookup_find~~CallsGraph proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_find~~CalledByGraph proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe compute_mbe proc~compute_mbe->proc~fragment_lookup_find proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~compute_mbe proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: bucket type( hash_entry_t ), private, pointer :: entry integer(kind=int32), private :: hash_val integer, private :: sorted_key (n) Source Code function fragment_lookup_find ( this , monomers , n ) result ( idx ) !! Find fragment index for given monomer combination class ( fragment_lookup_t ), intent ( in ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ) :: idx integer ( int32 ) :: hash_val integer :: bucket , sorted_key ( n ) type ( hash_entry_t ), pointer :: entry ! Sort monomers for canonical key sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Search chain if ( allocated ( this % table ( bucket )% key )) then if ( arrays_equal_internal ( this % table ( bucket )% key , sorted_key , n )) then idx = this % table ( bucket )% value return end if entry => this % table ( bucket )% next do while ( associated ( entry )) if ( arrays_equal_internal ( entry % key , sorted_key , n )) then idx = entry % value return end if entry => entry % next end do end if ! Not found idx = - 1 end function fragment_lookup_find","tags":"","url":"proc/fragment_lookup_find.html"},{"title":"next_prime_internal – metalquicha","text":"private pure function next_prime_internal(n) result(p) Find next prime number >= n (simple implementation) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer Called by proc~~next_prime_internal~~CalledByGraph proc~next_prime_internal next_prime_internal proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~fragment_lookup_init->proc~next_prime_internal proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~fragment_lookup_init proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~fragment_lookup_init proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_init proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i logical, private :: is_prime Source Code pure function next_prime_internal ( n ) result ( p ) !! Find next prime number >= n (simple implementation) integer , intent ( in ) :: n integer :: p , i logical :: is_prime p = max ( n , 2 ) if ( modulo ( p , 2 ) == 0 ) p = p + 1 do is_prime = . true . do i = 3 , int ( sqrt ( real ( p ))) + 1 , 2 if ( modulo ( p , i ) == 0 ) then is_prime = . false . exit end if end do if ( is_prime ) return p = p + 2 end do end function next_prime_internal","tags":"","url":"proc/next_prime_internal.html"},{"title":"fragment_lookup_destroy – metalquicha","text":"private  subroutine fragment_lookup_destroy(this) Clean up hash table and all chains Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this Called by proc~~fragment_lookup_destroy~~CalledByGraph proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_destroy proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( hash_entry_t ), private, pointer :: entry integer, private :: i type( hash_entry_t ), private, pointer :: next_entry Source Code subroutine fragment_lookup_destroy ( this ) !! Clean up hash table and all chains class ( fragment_lookup_t ), intent ( inout ) :: this integer :: i type ( hash_entry_t ), pointer :: entry , next_entry if (. not . this % initialized ) return do i = 1 , this % table_size ! Free chain entry => this % table ( i )% next do while ( associated ( entry )) next_entry => entry % next if ( allocated ( entry % key )) deallocate ( entry % key ) deallocate ( entry ) entry => next_entry end do ! Free bucket head if ( allocated ( this % table ( i )% key )) deallocate ( this % table ( i )% key ) end do deallocate ( this % table ) this % initialized = . false . end subroutine fragment_lookup_destroy","tags":"","url":"proc/fragment_lookup_destroy.html"},{"title":"fragment_lookup_init – metalquicha","text":"private  subroutine fragment_lookup_init(this, estimated_entries) Initialize hash table with estimated size Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries Calls proc~~fragment_lookup_init~~CallsGraph proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_init~~CalledByGraph proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~fragment_lookup_init proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~fragment_lookup_init proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_init proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine fragment_lookup_init ( this , estimated_entries ) !! Initialize hash table with estimated size class ( fragment_lookup_t ), intent ( inout ) :: this integer ( int64 ), intent ( in ) :: estimated_entries integer :: i ! Use prime number close to estimated size for better distribution this % table_size = next_prime_internal ( int ( estimated_entries * 1.3_dp )) allocate ( this % table ( this % table_size )) ! Initialize all entries as empty do i = 1 , this % table_size nullify ( this % table ( i )% next ) end do this % n_entries = 0 this % initialized = . true . end subroutine fragment_lookup_init","tags":"","url":"proc/fragment_lookup_init.html"},{"title":"fragment_lookup_insert – metalquicha","text":"private  subroutine fragment_lookup_insert(this, monomers, n, fragment_idx) Insert a monomer combination -> fragment index mapping Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx Calls proc~~fragment_lookup_insert~~CallsGraph proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_insert~~CalledByGraph proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~fragment_lookup_insert proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~fragment_lookup_insert proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_insert proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: bucket integer(kind=int32), private :: hash_val type( hash_entry_t ), private, pointer :: new_entry integer, private, allocatable :: sorted_key (:) Source Code subroutine fragment_lookup_insert ( this , monomers , n , fragment_idx ) !! Insert a monomer combination -> fragment index mapping class ( fragment_lookup_t ), intent ( inout ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ), intent ( in ) :: fragment_idx integer ( int32 ) :: hash_val integer :: bucket type ( hash_entry_t ), pointer :: new_entry integer , allocatable :: sorted_key (:) if (. not . this % initialized ) error stop \"Hash table not initialized\" ! Sort monomers for canonical key allocate ( sorted_key ( n )) sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Check if this is the first entry in bucket if (. not . allocated ( this % table ( bucket )% key )) then ! First entry in this bucket - use the head entry allocate ( this % table ( bucket )% key ( n )) this % table ( bucket )% key = sorted_key this % table ( bucket )% value = fragment_idx this % n_entries = this % n_entries + 1 else ! Bucket already has entries - chain new entry allocate ( new_entry ) allocate ( new_entry % key ( n )) new_entry % key = sorted_key new_entry % value = fragment_idx new_entry % next => this % table ( bucket )% next this % table ( bucket )% next => new_entry this % n_entries = this % n_entries + 1 end if deallocate ( sorted_key ) end subroutine fragment_lookup_insert","tags":"","url":"proc/fragment_lookup_insert.html"},{"title":"parse_command_line – metalquicha","text":"public  subroutine parse_command_line(args, error) Parse command line arguments for geometry file and basis set Extracts XYZ file path and basis set name from command line,\nvalidates arguments, and handles help requests. Arguments Type Intent Optional Attributes Name type( cli_args_type ), intent(out) :: args Parsed argument container type( error_t ), intent(out) :: error Error object Calls proc~~parse_command_line~~CallsGraph proc~parse_command_line parse_command_line proc~error_set error_t%error_set proc~parse_command_line->proc~error_set proc~print_usage print_usage proc~parse_command_line->proc~print_usage Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: arg_buffer Temporary argument buffer integer, private :: arg_len Length of current argument integer, private :: nargs Number of command line arguments integer, private :: stat Local status for intrinsic calls Source Code subroutine parse_command_line ( args , error ) !! Parse command line arguments for geometry file and basis set !! !! Extracts XYZ file path and basis set name from command line, !! validates arguments, and handles help requests. type ( cli_args_type ), intent ( out ) :: args !! Parsed argument container type ( error_t ), intent ( out ) :: error !! Error object integer :: nargs !! Number of command line arguments character ( len = 256 ) :: arg_buffer !! Temporary argument buffer integer :: arg_len !! Length of current argument integer :: stat !! Local status for intrinsic calls ! Get number of command line arguments nargs = command_argument_count () ! Check for help flag if ( nargs >= 1 ) then call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading command line argument 1\" ) return end if arg_buffer = trim ( arg_buffer ) if ( arg_buffer == \"-h\" . or . arg_buffer == \"--help\" ) then call print_usage () call error % set ( ERROR_PARSE , \"HELP_REQUESTED\" ) ! Special marker for help return end if end if ! Validate number of arguments if ( nargs < 2 ) then call error % set ( ERROR_PARSE , \"Error: Insufficient arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if if ( nargs > 2 ) then call error % set ( ERROR_PARSE , \"Error: Too many arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if ! Parse argument 1: XYZ file call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry file argument\" ) return end if args % xyz_file = trim ( arg_buffer ) ! Parse argument 2: Basis set name call get_command_argument ( 2 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading basis set name argument\" ) return end if args % basis_name = trim ( arg_buffer ) end subroutine parse_command_line","tags":"","url":"proc/parse_command_line.html"},{"title":"print_usage – metalquicha","text":"public  subroutine print_usage() Print usage information Arguments None Called by proc~~print_usage~~CalledByGraph proc~print_usage print_usage proc~parse_command_line parse_command_line proc~parse_command_line->proc~print_usage Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: prog_name integer, private :: stat Source Code subroutine print_usage () character ( len = 256 ) :: prog_name integer :: stat call get_command_argument ( 0 , prog_name , status = stat ) if ( stat /= 0 ) prog_name = \"pic_basis_reader\" print * print * , \"Usage: \" , trim ( prog_name ), \" <geometry.xyz> <basis_name>\" print * print * , \"Arguments:\" print * , \"  geometry.xyz   XYZ format molecular geometry file\" print * , \"  basis_name     Name of basis set (e.g., 6-31G, 6-311G**)\" print * print * , \"Options:\" print * , \"  -h, --help     Show this help message\" print * print * , \"Example:\" print * , \"  \" , trim ( prog_name ), \" water.xyz 6-31G\" print * end subroutine print_usage","tags":"","url":"proc/print_usage.html"},{"title":"cli_args_destroy – metalquicha","text":"private  subroutine cli_args_destroy(this) Clean up CLI args Type Bound cli_args_type Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this Source Code subroutine cli_args_destroy ( this ) class ( cli_args_type ), intent ( inout ) :: this if ( allocated ( this % xyz_file )) deallocate ( this % xyz_file ) if ( allocated ( this % basis_name )) deallocate ( this % basis_name ) end subroutine cli_args_destroy","tags":"","url":"proc/cli_args_destroy.html"},{"title":"copy_and_displace_geometry – metalquicha","text":"public  subroutine copy_and_displace_geometry(reference_geom, atom_idx, coord_idx, displacement, displaced_geom) Create a copy of reference geometry with one coordinate displaced Args:\n  reference_geom: Original geometry to copy\n  atom_idx: Atom to displace (1-based)\n  coord_idx: Coordinate to displace (1=x, 2=y, 3=z)\n  displacement: Amount to displace in Bohr (positive or negative)\n  displaced_geom: Output displaced geometry Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom integer, intent(in) :: atom_idx integer, intent(in) :: coord_idx real(kind=dp), intent(in) :: displacement type( physical_fragment_t ), intent(out) :: displaced_geom Called by proc~~copy_and_displace_geometry~~CalledByGraph proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries generate_perturbed_geometries proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~hessian_worker hessian_worker proc~hessian_worker->proc~copy_and_displace_geometry proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_worker proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine copy_and_displace_geometry ( reference_geom , atom_idx , coord_idx , displacement , displaced_geom ) !! Create a copy of reference geometry with one coordinate displaced !! !! Args: !!   reference_geom: Original geometry to copy !!   atom_idx: Atom to displace (1-based) !!   coord_idx: Coordinate to displace (1=x, 2=y, 3=z) !!   displacement: Amount to displace in Bohr (positive or negative) !!   displaced_geom: Output displaced geometry type ( physical_fragment_t ), intent ( in ) :: reference_geom integer , intent ( in ) :: atom_idx , coord_idx real ( dp ), intent ( in ) :: displacement type ( physical_fragment_t ), intent ( out ) :: displaced_geom ! Copy basic properties displaced_geom % n_atoms = reference_geom % n_atoms displaced_geom % charge = reference_geom % charge displaced_geom % multiplicity = reference_geom % multiplicity displaced_geom % nelec = reference_geom % nelec displaced_geom % n_caps = reference_geom % n_caps ! Allocate and copy arrays allocate ( displaced_geom % element_numbers ( displaced_geom % n_atoms )) allocate ( displaced_geom % coordinates ( 3 , displaced_geom % n_atoms )) displaced_geom % element_numbers = reference_geom % element_numbers displaced_geom % coordinates = reference_geom % coordinates ! Copy hydrogen cap information if present if ( reference_geom % n_caps > 0 ) then allocate ( displaced_geom % cap_replaces_atom ( displaced_geom % n_caps )) displaced_geom % cap_replaces_atom = reference_geom % cap_replaces_atom end if ! Copy gradient redistribution mapping if present if ( allocated ( reference_geom % local_to_global )) then allocate ( displaced_geom % local_to_global ( size ( reference_geom % local_to_global ))) displaced_geom % local_to_global = reference_geom % local_to_global end if ! Apply displacement to specified coordinate displaced_geom % coordinates ( coord_idx , atom_idx ) = & displaced_geom % coordinates ( coord_idx , atom_idx ) + displacement ! Copy basis set if present (same basis, just different geometry) if ( allocated ( reference_geom % basis )) then ! Note: Basis set will need to be rebuilt with new coordinates ! For now, we don't copy it - it should be set up during calculation end if end subroutine copy_and_displace_geometry","tags":"","url":"proc/copy_and_displace_geometry.html"},{"title":"finite_diff_hessian_from_gradients – metalquicha","text":"public  subroutine finite_diff_hessian_from_gradients(reference_geom, forward_gradients, backward_gradients, displacement, hessian) Compute Hessian matrix from finite differences of gradients Uses central finite differences: H_ij = (grad_i(+h) - grad_i(-h)) / (2h) Args:\n  reference_geom: Reference geometry (for dimensioning)\n  forward_gradients: Gradients at forward-displaced geometries (3 n_atoms, 3, n_atoms)\n  backward_gradients: Gradients at backward-displaced geometries (3 n_atoms, 3, n_atoms)\n  displacement: Step size used in Bohr\n  hessian: Output Hessian matrix (3 n_atoms, 3 n_atoms) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: forward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: backward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: displacement real(kind=dp), intent(out), allocatable :: hessian (:,:) (3 n_atoms, 3 n_atoms) Called by proc~~finite_diff_hessian_from_gradients~~CalledByGraph proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_hessian proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation->proc~do_fragment_work proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: disp_idx integer, private :: i_global integer, private :: iatom integer, private :: icoord integer, private :: j_global integer, private :: jatom integer, private :: jcoord integer, private :: n_atoms integer, private :: n_coords Source Code subroutine finite_diff_hessian_from_gradients ( reference_geom , forward_gradients , backward_gradients , & displacement , hessian ) !! Compute Hessian matrix from finite differences of gradients !! !! Uses central finite differences: H_ij = (grad_i(+h) - grad_i(-h)) / (2h) !! !! Args: !!   reference_geom: Reference geometry (for dimensioning) !!   forward_gradients: Gradients at forward-displaced geometries (3*n_atoms, 3, n_atoms) !!   backward_gradients: Gradients at backward-displaced geometries (3*n_atoms, 3, n_atoms) !!   displacement: Step size used in Bohr !!   hessian: Output Hessian matrix (3*n_atoms, 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: forward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: backward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: displacement real ( dp ), intent ( out ), allocatable :: hessian (:, :) !! (3*n_atoms, 3*n_atoms) integer :: n_atoms , n_coords integer :: iatom , jatom , icoord , jcoord integer :: i_global , j_global integer :: disp_idx n_atoms = reference_geom % n_atoms n_coords = 3 * n_atoms allocate ( hessian ( n_coords , n_coords )) hessian = 0.0_dp ! Build Hessian using central differences ! H[i,j] = d²E/(dx_i dx_j) = (dE/dx_j at x_i+h - dE/dx_j at x_i-h) / (2h) disp_idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 disp_idx = disp_idx + 1 i_global = 3 * ( iatom - 1 ) + icoord ! For each displacement, compute derivatives of all gradient components do jatom = 1 , n_atoms do jcoord = 1 , 3 j_global = 3 * ( jatom - 1 ) + jcoord ! Central difference: (grad_j(+h) - grad_j(-h)) / (2h) hessian ( i_global , j_global ) = & ( forward_gradients ( disp_idx , jcoord , jatom ) - & backward_gradients ( disp_idx , jcoord , jatom )) / ( 2.0_dp * displacement ) end do end do end do end do end subroutine finite_diff_hessian_from_gradients","tags":"","url":"proc/finite_diff_hessian_from_gradients.html"},{"title":"generate_perturbed_geometries – metalquicha","text":"public  subroutine generate_perturbed_geometries(reference_geom, displacement, forward_geoms, backward_geoms) Generate all forward and backward displaced geometries for finite difference calculations For a system with N atoms, this generates:\n  - 3N forward-displaced geometries (+x, +y, +z for each atom)\n  - 3N backward-displaced geometries (-x, -y, -z for each atom) These can be used to compute:\n  - Gradient: from energies at ±displacement\n  - Hessian: from gradients at ±displacement Args:\n  reference_geom: The reference geometry to perturb\n  displacement: Step size in Bohr (typical: 0.001 Bohr)\n  forward_geoms: Output array of forward-displaced geometries (size: 3 n_atoms)\n  backward_geoms: Output array of backward-displaced geometries (size: 3 n_atoms) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: displacement type( displaced_geometry_t ), intent(out), allocatable :: forward_geoms (:) type( displaced_geometry_t ), intent(out), allocatable :: backward_geoms (:) Calls proc~~generate_perturbed_geometries~~CallsGraph proc~generate_perturbed_geometries generate_perturbed_geometries proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_perturbed_geometries~~CalledByGraph proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_hessian proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: iatom integer, private :: icoord integer, private :: idx integer, private :: n_atoms integer, private :: n_displacements Source Code subroutine generate_perturbed_geometries ( reference_geom , displacement , forward_geoms , backward_geoms ) !! Generate all forward and backward displaced geometries for finite difference calculations !! !! For a system with N atoms, this generates: !!   - 3N forward-displaced geometries (+x, +y, +z for each atom) !!   - 3N backward-displaced geometries (-x, -y, -z for each atom) !! !! These can be used to compute: !!   - Gradient: from energies at ±displacement !!   - Hessian: from gradients at ±displacement !! !! Args: !!   reference_geom: The reference geometry to perturb !!   displacement: Step size in Bohr (typical: 0.001 Bohr) !!   forward_geoms: Output array of forward-displaced geometries (size: 3*n_atoms) !!   backward_geoms: Output array of backward-displaced geometries (size: 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: displacement type ( displaced_geometry_t ), intent ( out ), allocatable :: forward_geoms (:) type ( displaced_geometry_t ), intent ( out ), allocatable :: backward_geoms (:) integer :: n_atoms , n_displacements integer :: iatom , icoord , idx integer :: i n_atoms = reference_geom % n_atoms n_displacements = 3 * n_atoms ! x, y, z for each atom allocate ( forward_geoms ( n_displacements )) allocate ( backward_geoms ( n_displacements )) ! Generate all displaced geometries idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 ! x, y, z idx = idx + 1 ! Forward displacement (+h) forward_geoms ( idx )% atom_index = iatom forward_geoms ( idx )% coordinate = icoord forward_geoms ( idx )% direction = + 1 forward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , + displacement , & forward_geoms ( idx )% geometry ) ! Backward displacement (-h) backward_geoms ( idx )% atom_index = iatom backward_geoms ( idx )% coordinate = icoord backward_geoms ( idx )% direction = - 1 backward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , - displacement , & backward_geoms ( idx )% geometry ) end do end do end subroutine generate_perturbed_geometries","tags":"","url":"proc/generate_perturbed_geometries.html"},{"title":"displaced_geometry_destroy – metalquicha","text":"private  subroutine displaced_geometry_destroy(this) Clean up memory for displaced geometry Type Bound displaced_geometry_t Arguments Type Intent Optional Attributes Name class( displaced_geometry_t ), intent(inout) :: this Calls proc~~displaced_geometry_destroy~~CallsGraph proc~displaced_geometry_destroy displaced_geometry_t%displaced_geometry_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~displaced_geometry_destroy->proc~fragment_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine displaced_geometry_destroy ( this ) !! Clean up memory for displaced geometry class ( displaced_geometry_t ), intent ( inout ) :: this call this % geometry % destroy () end subroutine displaced_geometry_destroy","tags":"","url":"proc/displaced_geometry_destroy.html"},{"title":"calc_type_from_string – metalquicha","text":"public pure function calc_type_from_string(calc_type_str) result(calc_type) Convert calculation type string to integer constant Performs case-insensitive comparison and returns appropriate constant.\nReturns CALC_TYPE_UNKNOWN for unrecognized strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: calc_type_str Input string (e.g., “energy”, “gradient”) Return Value integer(kind=int32) Output integer constant Called by proc~~calc_type_from_string~~CalledByGraph proc~calc_type_from_string calc_type_from_string proc~parse_driver_section parse_driver_section proc~parse_driver_section->proc~calc_type_from_string proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_driver_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=len_trim), private :: lower_str Source Code pure function calc_type_from_string ( calc_type_str ) result ( calc_type ) !! Convert calculation type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns CALC_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: calc_type_str !! Input string (e.g., \"energy\", \"gradient\") integer ( int32 ) :: calc_type !! Output integer constant character ( len = len_trim ( calc_type_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( calc_type_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) case ( 'energy' ) calc_type = CALC_TYPE_ENERGY case ( 'gradient' ) calc_type = CALC_TYPE_GRADIENT case ( 'hessian' ) calc_type = CALC_TYPE_HESSIAN case default calc_type = CALC_TYPE_UNKNOWN end select end function calc_type_from_string","tags":"","url":"proc/calc_type_from_string.html"},{"title":"calc_type_to_string – metalquicha","text":"public pure function calc_type_to_string(calc_type) result(calc_type_str) Convert calculation type integer constant to string Provides human-readable string representation of calculation type. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: calc_type Input integer constant Return Value character(len=:), allocatable Output string representation Called by proc~~calc_type_to_string~~CalledByGraph proc~calc_type_to_string calc_type_to_string proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~calc_type_to_string proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~calc_type_to_string proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~node_worker proc~unfragmented_calculation->proc~do_fragment_work proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function calc_type_to_string ( calc_type ) result ( calc_type_str ) !! Convert calculation type integer constant to string !! !! Provides human-readable string representation of calculation type. integer ( int32 ), intent ( in ) :: calc_type !! Input integer constant character ( len = :), allocatable :: calc_type_str !! Output string representation select case ( calc_type ) case ( CALC_TYPE_ENERGY ) calc_type_str = \"energy\" case ( CALC_TYPE_GRADIENT ) calc_type_str = \"gradient\" case ( CALC_TYPE_HESSIAN ) calc_type_str = \"hessian\" case default calc_type_str = \"unknown\" end select end function calc_type_to_string","tags":"","url":"proc/calc_type_to_string.html"},{"title":"run_calculation – metalquicha","text":"public  subroutine run_calculation(world_comm, node_comm, config, sys_geom, bonds) Main calculation dispatcher - routes to fragmented or unfragmented calculation Determines calculation type based on nlevel and dispatches to appropriate\ncalculation routine with proper MPI setup and validation. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator type( driver_config_t ), intent(in) :: config Driver configuration type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information Calls proc~~run_calculation~~CallsGraph proc~run_calculation run_calculation info info proc~run_calculation->info omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation to_char to_char proc~run_calculation->to_char warning warning proc~run_calculation->warning proc~run_fragmented_calculation->info proc~run_fragmented_calculation->omp_set_num_threads proc~run_fragmented_calculation->to_char allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~node_coordinator node_coordinator proc~run_fragmented_calculation->proc~node_coordinator proc~node_worker node_worker proc~run_fragmented_calculation->proc~node_worker proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->proc~serial_fragment_processor proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor verbose verbose proc~run_fragmented_calculation->verbose proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_unfragmented_calculation->verbose proc~combine_util combine_util proc~combine->proc~combine_util barrier barrier proc~distributed_unfragmented_hessian->barrier proc~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->proc~hessian_worker proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->verbose debug debug proc~global_coordinator->debug error error proc~global_coordinator->error get_elapsed_time get_elapsed_time proc~global_coordinator->get_elapsed_time iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe_energy compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~result_irecv result_irecv proc~global_coordinator->proc~result_irecv proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker start start proc~global_coordinator->start proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->to_char atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose configuration configuration proc~gmbe_pie_coordinator->configuration proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->get_elapsed_time proc~gmbe_pie_coordinator->iprobe proc~gmbe_pie_coordinator->irecv proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker proc~gmbe_pie_coordinator->start proc~node_coordinator->to_char proc~node_coordinator->error proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->to_char proc~node_worker->error proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~do_fragment_work do_fragment_work proc~node_worker->proc~do_fragment_work proc~node_worker->proc~fragment_destroy proc~node_worker->proc~result_isend proc~node_worker->recv proc~serial_fragment_processor->info proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->to_char proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->verbose proc~serial_fragment_processor->configuration proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~do_fragment_work proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char proc~unfragmented_calculation->configuration proc~unfragmented_calculation->error proc~check_duplicate_atoms check_duplicate_atoms proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~do_fragment_work proc~unfragmented_calculation->proc~energy_total proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~combine_util->proc~combine_util proc~compute_mbe_energy->info proc~compute_mbe_energy->to_char proc~compute_mbe_energy->configuration proc~compute_mbe_energy->debug proc~compute_mbe_energy->get_elapsed_time proc~compute_mbe_energy->proc~energy_total proc~compute_mbe_energy->start proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient->info proc~compute_mbe_energy_gradient->to_char proc~compute_mbe_energy_gradient->configuration proc~compute_mbe_energy_gradient->debug proc~compute_mbe_energy_gradient->error proc~compute_mbe_energy_gradient->get_elapsed_time proc~compute_mbe_energy_gradient->proc~energy_total proc~compute_mbe_energy_gradient->start proc~compute_mbe_energy_gradient->proc~compute_mbe proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient->proc~fragment_lookup_init proc~compute_mbe_energy_gradient->proc~fragment_lookup_insert proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient_hessian->info proc~compute_mbe_energy_gradient_hessian->to_char proc~compute_mbe_energy_gradient_hessian->configuration proc~compute_mbe_energy_gradient_hessian->error proc~compute_mbe_energy_gradient_hessian->proc~energy_total proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_init proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_insert proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~print_detailed_breakdown_json proc~dfs_pie_accumulate->to_char proc~dfs_pie_accumulate->error proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->configuration proc~do_fragment_work->error proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~hessian_coordinator->info proc~hessian_coordinator->to_char proc~hessian_coordinator->configuration proc~hessian_coordinator->get_elapsed_time proc~hessian_coordinator->iprobe proc~hessian_coordinator->irecv proc~hessian_coordinator->isend proc~hessian_coordinator->proc~energy_total proc~hessian_coordinator->proc~fragment_compute_nelec proc~hessian_coordinator->proc~print_unfragmented_json proc~hessian_coordinator->proc~result_destroy proc~hessian_coordinator->recv proc~hessian_coordinator->start proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~method_type_to_string proc~hessian_coordinator->proc~xtb_calc_gradient proc~hessian_worker->to_char proc~hessian_worker->error proc~hessian_worker->irecv proc~hessian_worker->isend proc~hessian_worker->proc~fragment_compute_nelec proc~hessian_worker->proc~result_destroy abort_comm abort_comm proc~hessian_worker->abort_comm proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~hessian_worker->proc~method_type_to_string proc~hessian_worker->proc~xtb_calc_gradient send send proc~hessian_worker->send proc~print_gmbe_pie_json->info proc~print_gmbe_pie_json->error proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_pie_json->proc~get_output_json_filename proc~print_unfragmented_json->info proc~print_unfragmented_json->error proc~print_unfragmented_json->proc~energy_total proc~print_unfragmented_json->proc~get_basename proc~print_unfragmented_json->proc~get_output_json_filename proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~result_irecv->irecv proc~result_irecv->recv proc~result_isend->isend proc~result_isend->send proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->debug proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->warning proc~print_detailed_breakdown->verbose header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name proc~print_detailed_breakdown_json->info proc~print_detailed_breakdown_json->warning proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~result_reset->proc~energy_reset proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->info proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->error proc~xtb_calc_hessian->proc~result_destroy proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_calculation~~CalledByGraph proc~run_calculation run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Loop counter integer, private :: max_level Maximum fragment level (nlevel from config) Source Code subroutine run_calculation ( world_comm , node_comm , config , sys_geom , bonds ) !! Main calculation dispatcher - routes to fragmented or unfragmented calculation !! !! Determines calculation type based on nlevel and dispatches to appropriate !! calculation routine with proper MPI setup and validation. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator type ( driver_config_t ), intent ( in ) :: config !! Driver configuration type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information ! Local variables integer :: max_level !! Maximum fragment level (nlevel from config) integer :: i !! Loop counter ! Set max_level from config max_level = config % nlevel if ( world_comm % rank () == 0 ) then call logger % info ( \"============================================\" ) call logger % info ( \"Loaded geometry:\" ) call logger % info ( \"  Total monomers: \" // to_char ( sys_geom % n_monomers )) call logger % info ( \"  Atoms per monomer: \" // to_char ( sys_geom % atoms_per_monomer )) call logger % info ( \"  Total atoms: \" // to_char ( sys_geom % total_atoms )) call logger % info ( \"  Fragment level: \" // to_char ( max_level )) call logger % info ( \"============================================\" ) end if ! Warn if overlapping fragments flag is set but nlevel=0 if ( config % allow_overlapping_fragments . and . max_level == 0 ) then if ( world_comm % rank () == 0 ) then call logger % warning ( \"allow_overlapping_fragments is set to true, but nlevel=0\" ) call logger % warning ( \"Running unfragmented calculation - overlapping fragments flag will be ignored\" ) end if end if ! GMBE (overlapping fragments) with inclusion-exclusion principle ! GMBE(1): Base fragments are monomers ! GMBE(N): Base fragments are N-mers (e.g., dimers for N=2) ! Algorithm: Generate primaries, use DFS to enumerate overlapping cliques, ! accumulate PIE coefficients per unique atom set, evaluate each once if ( max_level == 0 ) then call omp_set_num_threads ( 1 ) call run_unfragmented_calculation ( world_comm , sys_geom , config % method , config % calc_type , bonds ) else call run_fragmented_calculation ( world_comm , node_comm , config % method , config % calc_type , sys_geom , max_level , & config % allow_overlapping_fragments , & config % max_intersection_level , bonds ) end if end subroutine run_calculation","tags":"","url":"proc/run_calculation.html"},{"title":"run_multi_molecule_calculations – metalquicha","text":"public  subroutine run_multi_molecule_calculations(world_comm, node_comm, mqc_config) Uses mqc_error mqc_json mqc_io_helpers mqc_config_parser mqc_config_adapter proc~~run_multi_molecule_calculations~~UsesGraph proc~run_multi_molecule_calculations run_multi_molecule_calculations module~mqc_config_adapter mqc_config_adapter proc~run_multi_molecule_calculations->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_parser module~mqc_error mqc_error proc~run_multi_molecule_calculations->module~mqc_error module~mqc_io_helpers mqc_io_helpers proc~run_multi_molecule_calculations->module~mqc_io_helpers module~mqc_json mqc_json proc~run_multi_molecule_calculations->module~mqc_json module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_error module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types pic_io pic_io module~mqc_json->pic_io pic_logger pic_logger module~mqc_json->pic_logger module~mqc_calc_types->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Run calculations for multiple molecules with MPI parallelization\nEach molecule is independent, so assign one molecule per rank Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm type( mqc_config_t ), intent(in) :: mqc_config Calls proc~~run_multi_molecule_calculations~~CallsGraph proc~run_multi_molecule_calculations run_multi_molecule_calculations abort_comm abort_comm proc~run_multi_molecule_calculations->abort_comm barrier barrier proc~run_multi_molecule_calculations->barrier error error proc~run_multi_molecule_calculations->error info info proc~run_multi_molecule_calculations->info proc~config_to_driver config_to_driver proc~run_multi_molecule_calculations->proc~config_to_driver proc~config_to_system_geometry config_to_system_geometry proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~error_get_message error_t%error_get_message proc~run_multi_molecule_calculations->proc~error_get_message proc~error_has_error error_t%error_has_error proc~run_multi_molecule_calculations->proc~error_has_error proc~get_output_json_filename get_output_json_filename proc~run_multi_molecule_calculations->proc~get_output_json_filename proc~merge_multi_molecule_json merge_multi_molecule_json proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~set_molecule_suffix set_molecule_suffix proc~run_multi_molecule_calculations->proc~set_molecule_suffix proc~system_destroy system_geometry_t%system_destroy proc~run_multi_molecule_calculations->proc~system_destroy to_char to_char proc~run_multi_molecule_calculations->to_char verbose verbose proc~run_multi_molecule_calculations->verbose proc~config_to_system_geometry->proc~error_has_error proc~error_set error_t%error_set proc~config_to_system_geometry->proc~error_set proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~merge_multi_molecule_json->error proc~merge_multi_molecule_json->info proc~merge_multi_molecule_json->to_char proc~read_json_content read_json_content proc~merge_multi_molecule_json->proc~read_json_content proc~run_calculation->info proc~run_calculation->to_char omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation warning warning proc~run_calculation->warning proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~molecule_to_system_geometry->proc~error_set proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name proc~run_fragmented_calculation->info proc~run_fragmented_calculation->to_char proc~run_fragmented_calculation->verbose proc~run_fragmented_calculation->omp_set_num_threads allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~node_coordinator node_coordinator proc~run_fragmented_calculation->proc~node_coordinator proc~node_worker node_worker proc~run_fragmented_calculation->proc~node_worker proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->proc~serial_fragment_processor proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char proc~run_unfragmented_calculation->verbose proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~combine_util combine_util proc~combine->proc~combine_util proc~distributed_unfragmented_hessian->barrier proc~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->proc~hessian_worker to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~global_coordinator->error proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->verbose debug debug proc~global_coordinator->debug get_elapsed_time get_elapsed_time proc~global_coordinator->get_elapsed_time iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe_energy compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~result_irecv result_irecv proc~global_coordinator->proc~result_irecv proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker start start proc~global_coordinator->start proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->to_char atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose configuration configuration proc~gmbe_pie_coordinator->configuration proc~gmbe_pie_coordinator->get_elapsed_time proc~gmbe_pie_coordinator->iprobe proc~gmbe_pie_coordinator->irecv proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker proc~gmbe_pie_coordinator->start proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~node_coordinator->error proc~node_coordinator->to_char proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->error proc~node_worker->to_char proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~do_fragment_work do_fragment_work proc~node_worker->proc~do_fragment_work proc~node_worker->proc~fragment_destroy proc~node_worker->proc~result_isend proc~node_worker->recv proc~serial_fragment_processor->info proc~serial_fragment_processor->to_char proc~serial_fragment_processor->verbose proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->configuration proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~do_fragment_work proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~unfragmented_calculation->error proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char proc~unfragmented_calculation->configuration proc~check_duplicate_atoms check_duplicate_atoms proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~do_fragment_work proc~unfragmented_calculation->proc~energy_total proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~check_fragment_overlap->to_char proc~check_fragment_overlap->proc~error_set proc~combine_util->proc~combine_util proc~compute_mbe_energy->info proc~compute_mbe_energy->to_char proc~compute_mbe_energy->configuration proc~compute_mbe_energy->debug proc~compute_mbe_energy->get_elapsed_time proc~compute_mbe_energy->proc~energy_total proc~compute_mbe_energy->start proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient->error proc~compute_mbe_energy_gradient->info proc~compute_mbe_energy_gradient->to_char proc~compute_mbe_energy_gradient->configuration proc~compute_mbe_energy_gradient->debug proc~compute_mbe_energy_gradient->get_elapsed_time proc~compute_mbe_energy_gradient->proc~energy_total proc~compute_mbe_energy_gradient->start proc~compute_mbe_energy_gradient->proc~compute_mbe proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient->proc~fragment_lookup_init proc~compute_mbe_energy_gradient->proc~fragment_lookup_insert proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient_hessian->error proc~compute_mbe_energy_gradient_hessian->info proc~compute_mbe_energy_gradient_hessian->to_char proc~compute_mbe_energy_gradient_hessian->configuration proc~compute_mbe_energy_gradient_hessian->proc~energy_total proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_init proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_insert proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~print_detailed_breakdown_json proc~dfs_pie_accumulate->error proc~dfs_pie_accumulate->to_char proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~do_fragment_work->error proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->configuration proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~hessian_coordinator->info proc~hessian_coordinator->to_char proc~hessian_coordinator->configuration proc~hessian_coordinator->get_elapsed_time proc~hessian_coordinator->iprobe proc~hessian_coordinator->irecv proc~hessian_coordinator->isend proc~hessian_coordinator->proc~energy_total proc~hessian_coordinator->proc~fragment_compute_nelec proc~hessian_coordinator->proc~print_unfragmented_json proc~hessian_coordinator->proc~result_destroy proc~hessian_coordinator->recv proc~hessian_coordinator->start proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~method_type_to_string proc~hessian_coordinator->proc~xtb_calc_gradient proc~hessian_worker->abort_comm proc~hessian_worker->error proc~hessian_worker->to_char proc~hessian_worker->irecv proc~hessian_worker->isend proc~hessian_worker->proc~fragment_compute_nelec proc~hessian_worker->proc~result_destroy proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~hessian_worker->proc~method_type_to_string proc~hessian_worker->proc~xtb_calc_gradient send send proc~hessian_worker->send proc~print_gmbe_pie_json->error proc~print_gmbe_pie_json->info proc~print_gmbe_pie_json->proc~get_output_json_filename proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~print_unfragmented_json->error proc~print_unfragmented_json->info proc~print_unfragmented_json->proc~get_output_json_filename proc~print_unfragmented_json->proc~energy_total proc~print_unfragmented_json->proc~get_basename proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~result_irecv->irecv proc~result_irecv->recv proc~result_isend->isend proc~result_isend->send proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_multi_molecule_calculations~~CalledByGraph proc~run_multi_molecule_calculations run_multi_molecule_calculations program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: color type( driver_config_t ), private :: config type( error_t ), private :: error logical, private :: has_fragmented_molecules integer, private :: imol character(len=256), private, allocatable :: individual_json_files (:) type(comm_t), private :: mol_comm character(len=:), private, allocatable :: mol_name type(comm_t), private :: mol_node_comm integer, private :: molecules_processed integer, private :: my_rank integer, private :: num_ranks type( system_geometry_t ), private :: sys_geom Source Code subroutine run_multi_molecule_calculations ( world_comm , node_comm , mqc_config ) !! Run calculations for multiple molecules with MPI parallelization !! Each molecule is independent, so assign one molecule per rank use mqc_config_parser , only : mqc_config_t use mqc_config_adapter , only : config_to_system_geometry use mqc_error , only : error_t use mqc_io_helpers , only : set_molecule_suffix , get_output_json_filename use mqc_json , only : merge_multi_molecule_json type ( comm_t ), intent ( in ) :: world_comm type ( comm_t ), intent ( in ) :: node_comm type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ) :: config type ( system_geometry_t ) :: sys_geom type ( comm_t ) :: mol_comm , mol_node_comm type ( error_t ) :: error integer :: imol , my_rank , num_ranks , color integer :: molecules_processed character ( len = :), allocatable :: mol_name logical :: has_fragmented_molecules character ( len = 256 ), allocatable :: individual_json_files (:) my_rank = world_comm % rank () num_ranks = world_comm % size () ! Allocate array to track individual JSON files for merging allocate ( individual_json_files ( mqc_config % nmol )) ! Check if any molecules have fragments (nlevel > 0) has_fragmented_molecules = . false . do imol = 1 , mqc_config % nmol if ( mqc_config % molecules ( imol )% nfrag > 0 ) then has_fragmented_molecules = . true . exit end if end do if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"Multi-molecule mode: \" // to_char ( mqc_config % nmol ) // \" molecules\" ) call logger % info ( \"MPI ranks: \" // to_char ( num_ranks )) if ( has_fragmented_molecules ) then call logger % info ( \"Mode: Sequential execution (fragmented molecules detected)\" ) call logger % info ( \"  Each molecule will use all \" // to_char ( num_ranks ) // \" rank(s) for its calculation\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Mode: Sequential execution (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) call logger % info ( \"Note: More ranks than molecules - ranks \" // to_char ( mqc_config % nmol ) // & \" to \" // to_char ( num_ranks - 1 ) // \" will be idle\" ) else call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) end if call logger % info ( \"============================================\" ) call logger % info ( \" \" ) end if ! Determine execution mode: ! 1. Sequential: Single rank OR fragmented molecules (each molecule needs all ranks) ! 2. Parallel: Multiple ranks AND unfragmented molecules (distribute molecules across ranks) molecules_processed = 0 if ( num_ranks == 1 . or . has_fragmented_molecules ) then ! Sequential mode: process all molecules one after another ! Each molecule uses all available ranks for its calculation do imol = 1 , mqc_config % nmol ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Processing molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) end if ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then if ( my_rank == 0 ) then call logger % error ( \"Error converting geometry for \" // mol_name // \": \" // error % get_message ()) end if call abort_comm ( world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % molecules ( imol )% bonds ) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () if ( my_rank == 0 ) then call logger % info ( \"Completed molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) end if molecules_processed = molecules_processed + 1 end do else ! Multiple ranks: distribute molecules across ranks (one per rank) if ( my_rank < mqc_config % nmol ) then imol = my_rank + 1 ! This rank has a molecule to process ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Processing molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then call logger % error ( \"Rank \" // to_char ( my_rank ) // \": Error converting geometry for \" // mol_name // \": \" // error % get_message ()) call abort_comm ( world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % molecules ( imol )% bonds ) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Completed molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) molecules_processed = 1 else ! Idle rank - no molecule assigned call logger % verbose ( \"Rank \" // to_char ( my_rank ) // \": No molecule assigned (idle)\" ) end if end if ! Synchronize all ranks call world_comm % barrier () ! Merge individual JSON files into one combined file (rank 0 only) if ( my_rank == 0 ) then call merge_multi_molecule_json ( individual_json_files , mqc_config % nmol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"All \" // to_char ( mqc_config % nmol ) // \" molecules completed\" ) if ( has_fragmented_molecules ) then call logger % info ( \"Execution: Sequential (each molecule used all ranks)\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Execution: Sequential (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Execution: Parallel (active ranks: \" // to_char ( mqc_config % nmol ) // \"/\" // to_char ( num_ranks ) // \")\" ) else call logger % info ( \"Execution: Parallel (all ranks active)\" ) end if call logger % info ( \"============================================\" ) end if end subroutine run_multi_molecule_calculations","tags":"","url":"proc/run_multi_molecule_calculations.html"},{"title":"run_fragmented_calculation – metalquicha","text":"private  subroutine run_fragmented_calculation(world_comm, node_comm, method, calc_type, sys_geom, max_level, allow_overlapping_fragments, max_intersection_level, bonds) Handle fragmented calculation (nlevel > 0) Generates fragments, distributes work across MPI processes organized in nodes,\nand coordinates many-body expansion calculation using hierarchical parallelism.\nIf allow_overlapping_fragments=true, uses GMBE with intersection correction. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator integer(kind=int32), intent(in) :: method Quantum chemistry method integer(kind=int32), intent(in) :: calc_type Calculation type type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info integer, intent(in) :: max_level Maximum fragment level for MBE logical, intent(in) :: allow_overlapping_fragments Use GMBE for overlapping fragments integer, intent(in) :: max_intersection_level Maximum k-way intersection depth for GMBE type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information Calls proc~~run_fragmented_calculation~~CallsGraph proc~run_fragmented_calculation run_fragmented_calculation allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast info info proc~run_fragmented_calculation->info leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads omp_set_num_threads omp_set_num_threads proc~run_fragmented_calculation->omp_set_num_threads proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~node_coordinator node_coordinator proc~run_fragmented_calculation->proc~node_coordinator proc~node_worker node_worker proc~run_fragmented_calculation->proc~node_worker proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->proc~serial_fragment_processor proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor to_char to_char proc~run_fragmented_calculation->to_char verbose verbose proc~run_fragmented_calculation->verbose proc~combine_util combine_util proc~combine->proc~combine_util proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->verbose debug debug proc~global_coordinator->debug error error proc~global_coordinator->error get_elapsed_time get_elapsed_time proc~global_coordinator->get_elapsed_time iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe_energy compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~result_irecv result_irecv proc~global_coordinator->proc~result_irecv proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker start start proc~global_coordinator->start proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->to_char atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose configuration configuration proc~gmbe_pie_coordinator->configuration proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->get_elapsed_time proc~gmbe_pie_coordinator->iprobe proc~gmbe_pie_coordinator->irecv proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker proc~gmbe_pie_coordinator->start proc~node_coordinator->to_char proc~node_coordinator->error proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->to_char proc~node_worker->error proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~do_fragment_work do_fragment_work proc~node_worker->proc~do_fragment_work proc~node_worker->proc~fragment_destroy proc~node_worker->proc~result_isend proc~node_worker->recv proc~serial_fragment_processor->info proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->to_char proc~serial_fragment_processor->verbose proc~serial_fragment_processor->configuration proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->proc~build_fragment_from_indices proc~calc_type_to_string calc_type_to_string proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~do_fragment_work proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~combine_util->proc~combine_util proc~compute_mbe_energy->info proc~compute_mbe_energy->to_char proc~compute_mbe_energy->configuration proc~compute_mbe_energy->debug proc~compute_mbe_energy->get_elapsed_time proc~compute_mbe_energy->proc~energy_total proc~compute_mbe_energy->start proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient->info proc~compute_mbe_energy_gradient->to_char proc~compute_mbe_energy_gradient->configuration proc~compute_mbe_energy_gradient->debug proc~compute_mbe_energy_gradient->error proc~compute_mbe_energy_gradient->get_elapsed_time proc~compute_mbe_energy_gradient->proc~energy_total proc~compute_mbe_energy_gradient->start proc~compute_mbe_energy_gradient->proc~compute_mbe proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient->proc~fragment_lookup_init proc~compute_mbe_energy_gradient->proc~fragment_lookup_insert proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient_hessian->info proc~compute_mbe_energy_gradient_hessian->to_char proc~compute_mbe_energy_gradient_hessian->configuration proc~compute_mbe_energy_gradient_hessian->error proc~compute_mbe_energy_gradient_hessian->proc~energy_total proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_init proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_insert proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~print_detailed_breakdown_json proc~dfs_pie_accumulate->to_char proc~dfs_pie_accumulate->error proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~do_fragment_work->configuration proc~do_fragment_work->error proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~print_gmbe_pie_json->info proc~print_gmbe_pie_json->error proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_pie_json->proc~get_output_json_filename proc~result_irecv->irecv proc~result_irecv->recv proc~result_isend->isend send send proc~result_isend->send proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->debug proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->verbose header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->info proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~print_detailed_breakdown_json->warning proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->info proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->error proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~fragment_lookup_find->fnv_1a_hash proc~fragment_lookup_find->sort proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_fragmented_calculation~~CalledByGraph proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: all_node_leader_ranks (:) Node leader status for all ranks integer, private :: global_node_rank Global rank if this process leads a node, -1 otherwise integer, private :: i Loop counters integer, private, allocatable :: intersection_levels (:) Level k of each intersection (n_intersections) integer, private, allocatable :: intersection_sets (:,:) k-tuples for each intersection (n_monomers, n_intersections) integer, private, allocatable :: intersections (:,:) Intersection atom lists (max_atoms, n_intersections) integer, private :: j Loop counters integer, private, allocatable :: monomers (:) Temporary monomer list for fragment generation integer(kind=int64), private :: n_expected_frags Expected number of fragments based on combinatorics (int64 to handle large systems) integer, private :: n_intersections Counts for GMBE integer, private :: n_monomers Counts for GMBE integer, private :: n_pie_terms Number of unique PIE terms integer, private :: n_primaries Number of primary polymers integer(kind=int64), private :: n_primaries_i64 For binomial calculation integer(kind=int64), private :: n_rows Number of rows needed for polymers array (int64 to handle large systems) integer, private, allocatable :: node_leader_ranks (:) Ranks of processes that lead each node integer, private :: num_nodes Number of compute nodes integer, private, allocatable :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, private, allocatable :: pie_coefficients (:) PIE coefficient for each term integer, private, allocatable :: polymers (:,:) Fragment composition array (fragment, monomer_indices) integer(kind=int64), private :: total_fragments Total number of fragments generated (int64 to handle large systems) Source Code subroutine run_fragmented_calculation ( world_comm , node_comm , method , calc_type , sys_geom , max_level , & allow_overlapping_fragments , max_intersection_level , bonds ) !! Handle fragmented calculation (nlevel > 0) !! !! Generates fragments, distributes work across MPI processes organized in nodes, !! and coordinates many-body expansion calculation using hierarchical parallelism. !! If allow_overlapping_fragments=true, uses GMBE with intersection correction. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator integer ( int32 ), intent ( in ) :: method !! Quantum chemistry method integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info integer , intent ( in ) :: max_level !! Maximum fragment level for MBE logical , intent ( in ) :: allow_overlapping_fragments !! Use GMBE for overlapping fragments integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth for GMBE type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information integer ( int64 ) :: total_fragments !! Total number of fragments generated (int64 to handle large systems) integer , allocatable :: polymers (:, :) !! Fragment composition array (fragment, monomer_indices) integer :: num_nodes !! Number of compute nodes integer :: i , j !! Loop counters integer , allocatable :: node_leader_ranks (:) !! Ranks of processes that lead each node integer , allocatable :: monomers (:) !! Temporary monomer list for fragment generation integer ( int64 ) :: n_expected_frags !! Expected number of fragments based on combinatorics (int64 to handle large systems) integer ( int64 ) :: n_rows !! Number of rows needed for polymers array (int64 to handle large systems) integer :: global_node_rank !! Global rank if this process leads a node, -1 otherwise integer , allocatable :: all_node_leader_ranks (:) !! Node leader status for all ranks ! GMBE-specific variables (old approach - kept for compatibility) integer , allocatable :: intersections (:, :) !! Intersection atom lists (max_atoms, n_intersections) integer , allocatable :: intersection_sets (:, :) !! k-tuples for each intersection (n_monomers, n_intersections) integer , allocatable :: intersection_levels (:) !! Level k of each intersection (n_intersections) integer :: n_intersections , n_monomers !! Counts for GMBE ! GMBE PIE-based variables (new approach) integer :: n_primaries !! Number of primary polymers integer ( int64 ) :: n_primaries_i64 !! For binomial calculation integer , allocatable :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , allocatable :: pie_coefficients (:) !! PIE coefficient for each term integer :: n_pie_terms !! Number of unique PIE terms ! Generate fragments if ( world_comm % rank () == 0 ) then if ( allow_overlapping_fragments ) then ! GMBE mode: PIE-based inclusion-exclusion ! GMBE(1): primaries are monomers ! GMBE(N): primaries are N-mers (e.g., dimers for N=2) ! Generate primaries if ( max_level == 1 ) then ! GMBE(1): primaries are base monomers n_primaries = sys_geom % n_monomers allocate ( polymers ( n_primaries , 1 )) do i = 1 , n_primaries polymers ( i , 1 ) = i end do else ! GMBE(N): primaries are all C(M, N) N-tuples n_primaries_i64 = binomial ( sys_geom % n_monomers , max_level ) n_primaries = int ( n_primaries_i64 ) allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_primaries , max_level )) polymers = 0 call create_monomer_list ( monomers ) total_fragments = 0_int64 call combine ( monomers , sys_geom % n_monomers , max_level , polymers , total_fragments ) n_primaries = int ( total_fragments ) deallocate ( monomers ) end if call logger % info ( \"Generated \" // to_char ( n_primaries ) // \" primary \" // to_char ( max_level ) // \"-mers for GMBE(\" // & to_char ( max_level ) // \")\" ) ! Use DFS to enumerate PIE terms with coefficients call gmbe_enumerate_pie_terms ( sys_geom , polymers , n_primaries , max_level , max_intersection_level , & pie_atom_sets , pie_coefficients , n_pie_terms ) call logger % info ( \"GMBE PIE enumeration complete: \" // to_char ( n_pie_terms ) // \" unique subsystems to evaluate\" ) ! For now: total_fragments = n_pie_terms (each PIE term is a subsystem to evaluate) total_fragments = int ( n_pie_terms , int64 ) else ! Standard MBE mode ! Calculate expected number of fragments n_expected_frags = get_nfrags ( sys_geom % n_monomers , max_level ) n_rows = n_expected_frags ! Allocate monomer list and polymers array allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_rows , max_level )) polymers = 0 ! Create monomer list [1, 2, 3, ..., n_monomers] call create_monomer_list ( monomers ) ! Generate all fragments (includes monomers in polymers array) total_fragments = 0_int64 ! First add monomers do i = 1 , sys_geom % n_monomers total_fragments = total_fragments + 1_int64 polymers ( total_fragments , 1 ) = i end do ! Then add n-mers for n >= 2 call generate_fragment_list ( monomers , max_level , polymers , total_fragments ) deallocate ( monomers ) call logger % info ( \"Generated fragments:\" ) call logger % info ( \"  Total fragments: \" // to_char ( total_fragments )) call logger % info ( \"  Max level: \" // to_char ( max_level )) end if end if ! Broadcast total_fragments to all ranks call bcast ( world_comm , total_fragments , 1 , 0 ) ! Determine node leaders global_node_rank = - 1 if ( node_comm % rank () == 0 ) global_node_rank = world_comm % rank () allocate ( all_node_leader_ranks ( world_comm % size ())) call allgather ( world_comm , global_node_rank , all_node_leader_ranks ) num_nodes = count ( all_node_leader_ranks /= - 1 ) if ( world_comm % rank () == 0 ) then call logger % info ( \"Running with \" // to_char ( num_nodes ) // \" node(s)\" ) end if allocate ( node_leader_ranks ( num_nodes )) i = 0 do j = 1 , world_comm % size () if ( all_node_leader_ranks ( j ) /= - 1 ) then i = i + 1 node_leader_ranks ( i ) = all_node_leader_ranks ( j ) end if end do deallocate ( all_node_leader_ranks ) ! Execute appropriate role if ( world_comm % size () == 1 ) then ! Single rank: process fragments serially call logger % info ( \"Running in serial mode (single MPI rank)\" ) if ( allow_overlapping_fragments ) then ! GMBE serial processing with PIE coefficients call serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , sys_geom , method , calc_type , bonds ) else ! Standard MBE serial processing call serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method , calc_type , bonds ) end if else if ( world_comm % leader () . and . node_comm % leader ()) then ! Global coordinator (rank 0, node leader on node 0) call omp_set_num_threads ( omp_get_max_threads ()) call logger % verbose ( \"Rank 0: Acting as global coordinator\" ) if ( allow_overlapping_fragments ) then ! GMBE MPI processing - PIE-based approach call gmbe_pie_coordinator ( world_comm , node_comm , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method , calc_type , bonds ) else ! Standard MBE MPI processing call global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , calc_type , bonds ) end if else if ( node_comm % leader ()) then ! Node coordinator (node leader on other nodes) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as node coordinator\" ) ! Node coordinator works for both MBE and GMBE (receives fragments from global coordinator) call node_coordinator ( world_comm , node_comm , calc_type ) else ! Worker call omp_set_num_threads ( 1 ) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as worker\" ) ! Worker processes work for both MBE and GMBE (fragment_type distinguishes them) call node_worker ( world_comm , node_comm , sys_geom , method , calc_type , bonds ) end if ! Cleanup if ( world_comm % rank () == 0 ) then if ( allocated ( polymers )) deallocate ( polymers ) if ( allocated ( node_leader_ranks )) deallocate ( node_leader_ranks ) if ( allocated ( intersections )) deallocate ( intersections ) if ( allocated ( intersection_sets )) deallocate ( intersection_sets ) if ( allocated ( intersection_levels )) deallocate ( intersection_levels ) if ( allocated ( pie_atom_sets )) deallocate ( pie_atom_sets ) if ( allocated ( pie_coefficients )) deallocate ( pie_coefficients ) end if end subroutine run_fragmented_calculation","tags":"","url":"proc/run_fragmented_calculation.html"},{"title":"run_unfragmented_calculation – metalquicha","text":"private  subroutine run_unfragmented_calculation(world_comm, sys_geom, method, calc_type, bonds) Handle unfragmented calculation (nlevel=0) For single-molecule mode: Only rank 0 runs (validates single rank)\nFor multi-molecule mode: ALL ranks can run (each with their own molecule)\nFor Hessian calculations with multiple ranks: Uses distributed parallelization Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type( system_geometry_t ), intent(in) :: sys_geom Complete system geometry integer(kind=int32), intent(in) :: method Quantum chemistry method integer(kind=int32), intent(in) :: calc_type Calculation type type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information Calls proc~~run_unfragmented_calculation~~CallsGraph proc~run_unfragmented_calculation run_unfragmented_calculation info info proc~run_unfragmented_calculation->info proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation to_char to_char proc~run_unfragmented_calculation->to_char verbose verbose proc~run_unfragmented_calculation->verbose barrier barrier proc~distributed_unfragmented_hessian->barrier proc~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->proc~hessian_worker proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char configuration configuration proc~unfragmented_calculation->configuration error error proc~unfragmented_calculation->error proc~check_duplicate_atoms check_duplicate_atoms proc~unfragmented_calculation->proc~check_duplicate_atoms proc~do_fragment_work do_fragment_work proc~unfragmented_calculation->proc~do_fragment_work proc~energy_total energy_t%energy_total proc~unfragmented_calculation->proc~energy_total proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->configuration proc~do_fragment_work->error proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~hessian_coordinator->info proc~hessian_coordinator->to_char proc~hessian_coordinator->configuration proc~hessian_coordinator->proc~energy_total proc~hessian_coordinator->proc~fragment_compute_nelec proc~hessian_coordinator->proc~print_unfragmented_json proc~hessian_coordinator->proc~result_destroy get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time iprobe iprobe proc~hessian_coordinator->iprobe irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~method_type_to_string proc~hessian_coordinator->proc~xtb_calc_gradient recv recv proc~hessian_coordinator->recv start start proc~hessian_coordinator->start proc~hessian_worker->to_char proc~hessian_worker->error proc~hessian_worker->proc~fragment_compute_nelec proc~hessian_worker->proc~result_destroy abort_comm abort_comm proc~hessian_worker->abort_comm proc~hessian_worker->irecv proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~hessian_worker->proc~method_type_to_string proc~hessian_worker->proc~xtb_calc_gradient send send proc~hessian_worker->send proc~print_unfragmented_json->info proc~print_unfragmented_json->error proc~print_unfragmented_json->proc~energy_total proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~result_reset->proc~energy_reset proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->info proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->error proc~xtb_calc_hessian->proc~result_destroy proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~generate_perturbed_geometries->proc~copy_and_displace_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_unfragmented_calculation~~CalledByGraph proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine run_unfragmented_calculation ( world_comm , sys_geom , method , calc_type , bonds ) !! Handle unfragmented calculation (nlevel=0) !! !! For single-molecule mode: Only rank 0 runs (validates single rank) !! For multi-molecule mode: ALL ranks can run (each with their own molecule) !! For Hessian calculations with multiple ranks: Uses distributed parallelization type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( system_geometry_t ), intent ( in ) :: sys_geom !! Complete system geometry integer ( int32 ), intent ( in ) :: method !! Quantum chemistry method integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information ! For Hessian calculations with multiple ranks, use distributed approach if ( calc_type == CALC_TYPE_HESSIAN . and . world_comm % size () > 1 ) then if ( world_comm % rank () == 0 ) then call logger % info ( \" \" ) call logger % info ( \"Running distributed unfragmented Hessian calculation\" ) call logger % info ( \"  MPI ranks: \" // to_char ( world_comm % size ())) call logger % info ( \" \" ) end if call distributed_unfragmented_hessian ( world_comm , sys_geom , method ) return end if ! Check if this is multi-molecule mode or single-molecule mode ! In multi-molecule mode, each rank processes its own molecule ! In single-molecule mode, only rank 0 should work if ( world_comm % size () == 1 . or . world_comm % rank () == 0 ) then ! Either single-rank calculation, or rank 0 in multi-rank setup call logger % info ( \" \" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) call logger % info ( \" \" ) call unfragmented_calculation ( sys_geom , method , calc_type , bonds ) else if ( sys_geom % total_atoms > 0 ) then ! Multi-molecule mode: non-zero rank with a molecule call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Running unfragmented calculation\" ) call unfragmented_calculation ( sys_geom , method , calc_type , bonds ) end if end subroutine run_unfragmented_calculation","tags":"","url":"proc/run_unfragmented_calculation.html"},{"title":"xtb_calc_energy – metalquicha","text":"private  subroutine xtb_calc_energy(this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Type Bound xtb_method_t Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~xtb_calc_energy~~CallsGraph proc~xtb_calc_energy xtb_method_t%xtb_calc_energy new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_energy->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~xtb_calc_energy~~CalledByGraph proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_energy proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(xtb_calculator), private :: calc type(context_type), private :: ctx real(kind=wp), private :: energy type(error_type), private, allocatable :: error type(structure_type), private :: mol integer, private, allocatable :: num (:) integer, private :: verbosity type(wavefunction_type), private :: wfn real(kind=wp), private, allocatable :: xyz (:,:) Source Code subroutine xtb_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity if ( this % verbose ) then print * , \"XTB: Calculating energy using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure ! charge is real(wp), multiplicity converted to uhf (unpaired electrons) call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default error stop \"Unknown XTB variant: \" // this % variant end select if ( allocated ( error )) then error stop \"Failed to create XTB calculator\" end if ! Create wavefunction and run single point calculation call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt ) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , verbosity = verbosity ) ! Store result (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () end if deallocate ( num , xyz ) end subroutine xtb_calc_energy","tags":"","url":"proc/xtb_calc_energy.html"},{"title":"xtb_calc_gradient – metalquicha","text":"private  subroutine xtb_calc_gradient(this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Type Bound xtb_method_t Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~xtb_calc_gradient~~CallsGraph proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_gradient->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~xtb_calc_gradient~~CalledByGraph proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~xtb_calc_gradient proc~hessian_worker hessian_worker proc~hessian_worker->proc~xtb_calc_gradient proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_worker proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(xtb_calculator), private :: calc type(context_type), private :: ctx real(kind=wp), private :: energy type(error_type), private, allocatable :: error real(kind=wp), private, allocatable :: gradient (:,:) type(structure_type), private :: mol integer, private, allocatable :: num (:) real(kind=wp), private, allocatable :: sigma (:,:) integer, private :: verbosity type(wavefunction_type), private :: wfn real(kind=wp), private, allocatable :: xyz (:,:) Source Code subroutine xtb_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity real ( wp ), allocatable :: gradient (:, :) real ( wp ), allocatable :: sigma (:, :) if ( this % verbose ) then print * , \"XTB: Calculating gradient using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default error stop \"Unknown XTB variant: \" // this % variant end select if ( allocated ( error )) then error stop \"Failed to create XTB calculator\" end if ! Allocate gradient and sigma arrays allocate ( gradient ( 3 , fragment % n_atoms )) allocate ( sigma ( 3 , 3 )) ! Create wavefunction and run single point calculation with gradient call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt , grad = . true .) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , & gradient = gradient , sigma = sigma , verbosity = verbosity ) ! Store results (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . ! Store gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = real ( gradient , dp ) result % has_gradient = . true . ! Store sigma (stress tensor) allocate ( result % sigma ( 3 , 3 )) result % sigma = real ( sigma , dp ) result % has_sigma = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () print * , \"XTB: Gradient norm =\" , sqrt ( sum ( result % gradient ** 2 )) print * , \"XTB: Gradient calculation complete\" end if deallocate ( num , xyz , gradient , sigma ) end subroutine xtb_calc_gradient","tags":"","url":"proc/xtb_calc_gradient.html"},{"title":"xtb_calc_hessian – metalquicha","text":"private  subroutine xtb_calc_hessian(this, fragment, result) Uses mqc_finite_differences pic_logger pic_io proc~~xtb_calc_hessian~~UsesGraph proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian module~mqc_finite_differences mqc_finite_differences proc~xtb_calc_hessian->module~mqc_finite_differences pic_io pic_io proc~xtb_calc_hessian->pic_io pic_logger pic_logger proc~xtb_calc_hessian->pic_logger module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calculate Hessian using finite differences of gradients Since tblite does not natively support analytic Hessians, this routine\ncomputes the Hessian numerically via central finite differences:\n  H[i,j] = (grad_j(x_i + h) - grad_j(x_i - h)) / (2h) This requires 6N gradient calculations (forward and backward for each coordinate) Type Bound xtb_method_t Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~xtb_calc_hessian~~CallsGraph proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian error error proc~xtb_calc_hessian->error info info proc~xtb_calc_hessian->info proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~xtb_calc_hessian->proc~xtb_calc_gradient to_char to_char proc~xtb_calc_hessian->to_char proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_gradient->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~xtb_calc_hessian~~CalledByGraph proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_hessian proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( displaced_geometry_t ), private, allocatable :: backward_geoms (:) real(kind=dp), private, allocatable :: backward_gradients (:,:,:) type( calculation_result_t ), private :: disp_result real(kind=dp), private :: displacement type( displaced_geometry_t ), private, allocatable :: forward_geoms (:) real(kind=dp), private, allocatable :: forward_gradients (:,:,:) integer, private :: i integer, private :: n_atoms integer, private :: n_displacements Source Code subroutine xtb_calc_hessian ( this , fragment , result ) !! Calculate Hessian using finite differences of gradients !! !! Since tblite does not natively support analytic Hessians, this routine !! computes the Hessian numerically via central finite differences: !!   H[i,j] = (grad_j(x_i + h) - grad_j(x_i - h)) / (2h) !! !! This requires 6N gradient calculations (forward and backward for each coordinate) use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT use pic_logger , only : logger => global_logger use pic_io , only : to_char class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result type ( displaced_geometry_t ), allocatable :: forward_geoms (:), backward_geoms (:) real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) type ( calculation_result_t ) :: disp_result real ( dp ) :: displacement integer :: n_atoms , n_displacements , i n_atoms = fragment % n_atoms n_displacements = 3 * n_atoms if ( this % verbose ) then call logger % info ( \"XTB: Computing Hessian via finite differences\" ) call logger % info ( \"  Method: Central differences of gradients\" ) call logger % info ( \"  Atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) end if ! Use default displacement (0.001 Bohr ~ 0.0005 Angstrom) displacement = DEFAULT_DISPLACEMENT ! Generate all perturbed geometries call generate_perturbed_geometries ( fragment , displacement , forward_geoms , backward_geoms ) ! Allocate storage for gradients at displaced geometries allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) ! Compute gradients at all forward-displaced geometries if ( this % verbose ) then call logger % info ( \"  Computing forward-displaced gradients...\" ) end if do i = 1 , n_displacements ! Forward call this % calc_gradient ( forward_geoms ( i )% geometry , disp_result ) if (. not . disp_result % has_gradient ) then call logger % error ( \"Failed to compute gradient for forward displacement \" // to_char ( i )) error stop \"Finite difference Hessian: gradient calculation failed\" end if forward_gradients ( i , :, :) = disp_result % gradient call disp_result % destroy () ! Backward call this % calc_gradient ( backward_geoms ( i )% geometry , disp_result ) if (. not . disp_result % has_gradient ) then call logger % error ( \"Failed to compute gradient for backward displacement \" // to_char ( i )) error stop \"Finite difference Hessian: gradient calculation failed\" end if backward_gradients ( i , :, :) = disp_result % gradient call disp_result % destroy () end do if ( this % verbose ) then call logger % info ( \"  Forward and backward gradient calculations complete \" ) end if ! Compute Hessian from finite differences if ( this % verbose ) then call logger % info ( \"  Assembling Hessian matrix...\" ) end if call finite_diff_hessian_from_gradients ( fragment , forward_gradients , backward_gradients , & displacement , result % hessian ) ! Also compute energy and gradient at reference geometry for completeness call this % calc_gradient ( fragment , disp_result ) result % energy = disp_result % energy result % has_energy = disp_result % has_energy if ( disp_result % has_gradient ) then allocate ( result % gradient ( 3 , n_atoms )) result % gradient = disp_result % gradient result % has_gradient = . true . end if call disp_result % destroy () result % has_hessian = . true . if ( this % verbose ) then call logger % info ( \"  Hessian calculation complete\" ) end if ! Cleanup deallocate ( forward_gradients , backward_gradients ) do i = 1 , n_displacements call forward_geoms ( i )% destroy () call backward_geoms ( i )% destroy () end do deallocate ( forward_geoms , backward_geoms ) end subroutine xtb_calc_hessian","tags":"","url":"proc/xtb_calc_hessian.html"},{"title":"geometry_destroy – metalquicha","text":"private  subroutine geometry_destroy(this) Clean up allocated memory in geometry_type Type Bound geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this Called by proc~~geometry_destroy~~CalledByGraph proc~geometry_destroy geometry_type%geometry_destroy proc~config_destroy mqc_config_t%config_destroy proc~config_destroy->proc~geometry_destroy proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~geometry_destroy proc~molecule_destroy molecule_t%molecule_destroy proc~molecule_destroy->proc~geometry_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine geometry_destroy ( this ) !! Clean up allocated memory in geometry_type class ( geometry_type ), intent ( inout ) :: this if ( allocated ( this % elements )) deallocate ( this % elements ) if ( allocated ( this % coords )) deallocate ( this % coords ) if ( allocated ( this % comment )) deallocate ( this % comment ) this % natoms = 0 end subroutine geometry_destroy","tags":"","url":"proc/geometry_destroy.html"},{"title":"gmbe_pie_coordinator – metalquicha","text":"public  subroutine gmbe_pie_coordinator(world_comm, node_comm, pie_atom_sets, pie_coefficients, n_pie_terms, node_leader_ranks, num_nodes, sys_geom, method, calc_type, bonds) Uses mqc_physical_fragment mqc_calc_types pic_logger proc~~gmbe_pie_coordinator~~UsesGraph proc~gmbe_pie_coordinator gmbe_pie_coordinator module~mqc_calc_types mqc_calc_types proc~gmbe_pie_coordinator->module~mqc_calc_types module~mqc_physical_fragment mqc_physical_fragment proc~gmbe_pie_coordinator->module~mqc_physical_fragment pic_logger pic_logger proc~gmbe_pie_coordinator->pic_logger pic_types pic_types module~mqc_calc_types->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. MPI coordinator for PIE-based GMBE calculations\nDistributes PIE terms across MPI ranks and accumulates results Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer, intent(in) :: n_pie_terms integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~gmbe_pie_coordinator~~CallsGraph proc~gmbe_pie_coordinator gmbe_pie_coordinator configuration configuration proc~gmbe_pie_coordinator->configuration error error proc~gmbe_pie_coordinator->error get_elapsed_time get_elapsed_time proc~gmbe_pie_coordinator->get_elapsed_time info info proc~gmbe_pie_coordinator->info iprobe iprobe proc~gmbe_pie_coordinator->iprobe irecv irecv proc~gmbe_pie_coordinator->irecv isend isend proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~result_irecv result_irecv proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker start start proc~gmbe_pie_coordinator->start to_char to_char proc~gmbe_pie_coordinator->to_char verbose verbose proc~gmbe_pie_coordinator->verbose proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~print_gmbe_pie_json->error proc~print_gmbe_pie_json->info proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_pie_json->proc~get_output_json_filename proc~result_irecv->irecv recv recv proc~result_irecv->recv proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gmbe_pie_coordinator~~CalledByGraph proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(timer_type), private :: coord_timer integer, private :: current_term_idx integer, private :: dummy_msg integer, private :: finished_nodes logical, private :: handling_local_workers logical, private :: has_pending integer, private :: hess_dim integer, private :: local_dummy integer, private :: local_finished_workers type(MPI_Status), private :: local_status type(request_t), private :: req integer, private :: request_source type( calculation_result_t ), private, allocatable :: results (:) integer, private :: results_received type(MPI_Status), private :: status integer, private :: term_idx real(kind=dp), private :: total_energy real(kind=dp), private, allocatable :: total_gradient (:,:) real(kind=dp), private, allocatable :: total_hessian (:,:) integer, private :: worker_source integer, private :: worker_term_map (node_comm%size()) Source Code subroutine gmbe_pie_coordinator ( world_comm , node_comm , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method , calc_type , bonds ) !! MPI coordinator for PIE-based GMBE calculations !! Distributes PIE terms across MPI ranks and accumulates results use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian type ( comm_t ), intent ( in ) :: world_comm , node_comm integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer , intent ( in ) :: n_pie_terms integer , intent ( in ) :: node_leader_ranks (:), num_nodes type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method , calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( timer_type ) :: coord_timer integer :: current_term_idx , results_received , finished_nodes integer :: request_source , dummy_msg , term_idx type ( MPI_Status ) :: status , local_status logical :: handling_local_workers , has_pending integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer :: worker_term_map ( node_comm % size ()) integer :: worker_source real ( dp ) :: total_energy real ( dp ), allocatable :: total_gradient (:, :) real ( dp ), allocatable :: total_hessian (:, :) integer :: hess_dim ! MPI request handles type ( request_t ) :: req current_term_idx = n_pie_terms finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( node_comm % size () > 1 ) results_received = 0 worker_term_map = 0 allocate ( results ( n_pie_terms )) call logger % verbose ( \"GMBE PIE coordinator starting with \" // to_char ( n_pie_terms ) // & \" PIE terms for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers if ( handling_local_workers ) then do call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE if ( worker_term_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no term was assigned!\" ) error stop \"Invalid worker_term_map state\" end if call result_irecv ( results ( worker_term_map ( worker_source )), node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) worker_term_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1 , n_pie_terms / 10 )) == 0 . or . results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit call irecv ( world_comm , term_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( term_idx ), world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) results_received = results_received + 1 if ( mod ( results_received , max ( 1 , n_pie_terms / 10 )) == 0 . or . results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_term_idx >= 1 ) then call send_pie_term_to_node ( world_comm , current_term_idx , pie_atom_sets , request_source ) current_term_idx = current_term_idx - 1 else call isend ( world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < node_comm % size () - 1 ) then call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then if ( worker_term_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_term_idx >= 1 ) then call send_pie_term_to_worker ( node_comm , current_term_idx , pie_atom_sets , local_status % MPI_SOURCE ) worker_term_map ( local_status % MPI_SOURCE ) = current_term_idx current_term_idx = current_term_idx - 1 else call isend ( node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= node_comm % size () - 1 & . and . results_received >= n_pie_terms ) then handling_local_workers = . false . finished_nodes = finished_nodes + 1 end if end do call logger % verbose ( \"GMBE PIE coordinator finished all terms\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all PIE terms \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Accumulate results with PIE coefficients call logger % info ( \" \" ) call logger % info ( \"Computing GMBE PIE energy...\" ) call coord_timer % start () total_energy = 0.0_dp do term_idx = 1 , n_pie_terms total_energy = total_energy + real ( pie_coefficients ( term_idx ), dp ) * results ( term_idx )% energy % total () end do ! Handle gradients if computed if ( calc_type == CALC_TYPE_GRADIENT ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp do term_idx = 1 , n_pie_terms if ( results ( term_idx )% has_gradient ) then ! Map fragment gradient to system coordinates block real ( dp ), allocatable :: term_gradient (:, :) type ( physical_fragment_t ) :: phys_frag integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , bonds ) call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) call phys_frag % destroy () deallocate ( atom_list ) end if ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system block use pic_logger , only : info_level integer :: iatom , current_log_level call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end block deallocate ( total_gradient ) end if ! Handle Hessians if computed if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp ! Also allocate gradient for Hessian calculations if (. not . allocated ( total_gradient )) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if do term_idx = 1 , n_pie_terms if ( results ( term_idx )% has_hessian . or . results ( term_idx )% has_gradient ) then block real ( dp ), allocatable :: term_gradient (:, :), term_hessian (:, :) type ( physical_fragment_t ) :: phys_frag integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , bonds ) ! Redistribute gradient if present if ( results ( term_idx )% has_gradient ) then allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end if ! Redistribute Hessian if present if ( results ( term_idx )% has_hessian ) then allocate ( term_hessian ( hess_dim , hess_dim )) term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( term_idx )% hessian , term_hessian ) total_hessian = total_hessian + real ( pie_coefficients ( term_idx ), dp ) * term_hessian deallocate ( term_hessian ) end if call phys_frag % destroy () deallocate ( atom_list ) end if end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print Hessian information call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) end if call coord_timer % stop () call logger % info ( \"Time to compute GMBE PIE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) call logger % info ( \" \" ) ! Write JSON output (reuse existing function) block real ( dp ), allocatable :: pie_energies (:) allocate ( pie_energies ( n_pie_terms )) do term_idx = 1 , n_pie_terms pie_energies ( term_idx ) = results ( term_idx )% energy % total () end do call print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) deallocate ( pie_energies ) end block deallocate ( results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) end subroutine gmbe_pie_coordinator","tags":"","url":"proc/gmbe_pie_coordinator.html"},{"title":"serial_gmbe_pie_processor – metalquicha","text":"public  subroutine serial_gmbe_pie_processor(pie_atom_sets, pie_coefficients, n_pie_terms, sys_geom, method, calc_type, bonds) Uses mqc_physical_fragment mqc_calc_types pic_logger proc~~serial_gmbe_pie_processor~~UsesGraph proc~serial_gmbe_pie_processor serial_gmbe_pie_processor module~mqc_calc_types mqc_calc_types proc~serial_gmbe_pie_processor->module~mqc_calc_types module~mqc_physical_fragment mqc_physical_fragment proc~serial_gmbe_pie_processor->module~mqc_physical_fragment pic_logger pic_logger proc~serial_gmbe_pie_processor->pic_logger pic_types pic_types module~mqc_calc_types->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Serial GMBE processor using PIE coefficients\nEvaluates each unique atom set once and sums with PIE coefficients\nSupports energy-only, energy+gradient, and energy+gradient+Hessian calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer, intent(in) :: n_pie_terms type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~serial_gmbe_pie_processor~~CallsGraph proc~serial_gmbe_pie_processor serial_gmbe_pie_processor configuration configuration proc~serial_gmbe_pie_processor->configuration info info proc~serial_gmbe_pie_processor->info proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~calc_type_to_string calc_type_to_string proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~do_fragment_work do_fragment_work proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~energy_total energy_t%energy_total proc~serial_gmbe_pie_processor->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~redistribute_cap_gradients redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian to_char to_char proc~serial_gmbe_pie_processor->to_char verbose verbose proc~serial_gmbe_pie_processor->verbose proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~do_fragment_work->configuration proc~do_fragment_work->proc~calc_type_to_string error error proc~do_fragment_work->error proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~print_gmbe_pie_json->info proc~print_gmbe_pie_json->error proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_gmbe_pie_json->proc~get_output_json_filename proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->info proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->error proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~result_reset->proc~energy_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~serial_gmbe_pie_processor~~CalledByGraph proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: atom_list (:) integer, private :: coeff integer, private :: current_log_level integer, private :: hess_dim integer, private :: i integer, private :: iatom integer, private :: max_atoms integer, private :: n_atoms type( physical_fragment_t ), private :: phys_frag real(kind=dp), private, allocatable :: pie_energies (:) Store individual energies for JSON output type( calculation_result_t ), private, allocatable :: results (:) real(kind=dp), private :: term_energy real(kind=dp), private, allocatable :: term_gradient (:,:) Temporary gradient for each term real(kind=dp), private, allocatable :: term_hessian (:,:) Temporary Hessian for each term real(kind=dp), private :: total_energy real(kind=dp), private, allocatable :: total_gradient (:,:) Total gradient (3, total_atoms) real(kind=dp), private, allocatable :: total_hessian (:,:) Total Hessian (3 total_atoms, 3 total_atoms) Source Code subroutine serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , sys_geom , method , calc_type , bonds ) !! Serial GMBE processor using PIE coefficients !! Evaluates each unique atom set once and sums with PIE coefficients !! Supports energy-only, energy+gradient, and energy+gradient+Hessian calculations use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN , CALC_TYPE_ENERGY , calc_type_to_string use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian use pic_logger , only : info_level integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer , intent ( in ) :: n_pie_terms type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method , calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: phys_frag type ( calculation_result_t ), allocatable :: results (:) integer :: i , n_atoms , max_atoms , iatom , current_log_level , hess_dim integer , allocatable :: atom_list (:) real ( dp ) :: total_energy , term_energy real ( dp ), allocatable :: pie_energies (:) !! Store individual energies for JSON output real ( dp ), allocatable :: total_gradient (:, :) !! Total gradient (3, total_atoms) real ( dp ), allocatable :: term_gradient (:, :) !! Temporary gradient for each term real ( dp ), allocatable :: total_hessian (:, :) !! Total Hessian (3*total_atoms, 3*total_atoms) real ( dp ), allocatable :: term_hessian (:, :) !! Temporary Hessian for each term integer :: coeff call logger % info ( \"Processing \" // to_char ( n_pie_terms ) // \" unique PIE terms...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) total_energy = 0.0_dp max_atoms = size ( pie_atom_sets , 1 ) allocate ( pie_energies ( n_pie_terms )) allocate ( results ( n_pie_terms )) ! Allocate gradient and Hessian arrays if needed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) allocate ( term_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp end if do i = 1 , n_pie_terms coeff = pie_coefficients ( i ) ! Skip terms with zero coefficient (shouldn't happen, but safety check) if ( coeff == 0 ) then pie_energies ( i ) = 0.0_dp ! Mark as skipped cycle end if ! Extract atom list for this term n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , i ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms == 0 ) then pie_energies ( i ) = 0.0_dp ! Mark as skipped cycle end if allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , i ) ! Build fragment from atom list call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , bonds ) ! Compute energy (and gradient if requested) call do_fragment_work ( i , results ( i ), method , phys_frag , calc_type ) term_energy = results ( i )% energy % total () ! Store energy for JSON output pie_energies ( i ) = term_energy ! Accumulate with PIE coefficient total_energy = total_energy + real ( coeff , dp ) * term_energy ! Accumulate gradient if present if (( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) . and . results ( i )% has_gradient ) then ! Map fragment gradient to system coordinates with proper cap handling term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( i )% gradient , term_gradient ) ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( coeff , dp ) * term_gradient end if ! Accumulate Hessian if present if ( calc_type == CALC_TYPE_HESSIAN . and . results ( i )% has_hessian ) then ! Map fragment Hessian to system coordinates with proper cap handling term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( i )% hessian , term_hessian ) ! Accumulate with PIE coefficient total_hessian = total_hessian + real ( coeff , dp ) * term_hessian end if call logger % verbose ( \"PIE term \" // to_char ( i ) // \"/\" // to_char ( n_pie_terms ) // & \": \" // to_char ( n_atoms ) // \" atoms, coeff=\" // to_char ( coeff ) // & \", E=\" // to_char ( term_energy )) deallocate ( atom_list ) call phys_frag % destroy () end do call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) ! Print gradient info if computed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end if ! Print Hessian info if computed if ( calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) end if call logger % info ( \" \" ) ! Write JSON output call print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) deallocate ( pie_energies , results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( term_gradient )) deallocate ( term_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) if ( allocated ( term_hessian )) deallocate ( term_hessian ) end subroutine serial_gmbe_pie_processor","tags":"","url":"proc/serial_gmbe_pie_processor.html"},{"title":"send_pie_term_to_node – metalquicha","text":"private  subroutine send_pie_term_to_node(world_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to remote node coordinator Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer, intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank Calls proc~~send_pie_term_to_node~~CallsGraph proc~send_pie_term_to_node send_pie_term_to_node isend isend proc~send_pie_term_to_node->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_pie_term_to_node~~CalledByGraph proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: atom_list (:) integer(kind=int32), private :: fragment_type integer, private :: max_atoms integer, private :: n_atoms type(request_t), private :: req (4) Source Code subroutine send_pie_term_to_node ( world_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to remote node coordinator type ( comm_t ), intent ( in ) :: world_comm integer , intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( world_comm , term_idx , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , n_atoms , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , atom_list , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_node","tags":"","url":"proc/send_pie_term_to_node.html"},{"title":"send_pie_term_to_worker – metalquicha","text":"private  subroutine send_pie_term_to_worker(node_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to local worker Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer, intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank Calls proc~~send_pie_term_to_worker~~CallsGraph proc~send_pie_term_to_worker send_pie_term_to_worker isend isend proc~send_pie_term_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_pie_term_to_worker~~CalledByGraph proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: atom_list (:) integer(kind=int32), private :: fragment_type integer, private :: max_atoms integer, private :: n_atoms type(request_t), private :: req (4) Source Code subroutine send_pie_term_to_worker ( node_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to local worker type ( comm_t ), intent ( in ) :: node_comm integer , intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( node_comm , term_idx , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , n_atoms , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , atom_list , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_worker","tags":"","url":"proc/send_pie_term_to_worker.html"},{"title":"get_logger_level – metalquicha","text":"public  function get_logger_level(level_string) result(level_int) Uses pic_logger proc~~get_logger_level~~UsesGraph proc~get_logger_level get_logger_level pic_logger pic_logger proc~get_logger_level->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Convert string log level to integer value\nThis function uses the pic_logger constants Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: level_string Return Value integer Called by proc~~get_logger_level~~CalledByGraph proc~get_logger_level get_logger_level program~main main program~main->proc~get_logger_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_logger_level ( level_string ) result ( level_int ) !! Convert string log level to integer value !! This function uses the pic_logger constants use pic_logger , only : debug_level , verbose_level , info_level , performance_level , & warning_level , error_level , knowledge_level character ( len =* ), intent ( in ) :: level_string integer :: level_int select case ( trim ( adjustl ( level_string ))) case ( 'debug' , 'Debug' , 'DEBUG' ) level_int = debug_level case ( 'verbose' , 'Verbose' , 'VERBOSE' ) level_int = verbose_level case ( 'info' , 'Info' , 'INFO' ) level_int = info_level case ( 'performance' , 'Performance' , 'PERFORMANCE' ) level_int = performance_level case ( 'warning' , 'Warning' , 'WARNING' ) level_int = warning_level case ( 'error' , 'Error' , 'ERROR' ) level_int = error_level case ( 'knowledge' , 'Knowledge' , 'KNOWLEDGE' ) level_int = knowledge_level case default ! Default to info level if unknown level_int = info_level end select end function get_logger_level","tags":"","url":"proc/get_logger_level.html"},{"title":"check_fragment_overlap – metalquicha","text":"public  subroutine check_fragment_overlap(fragments, nfrag, error) Uses mqc_config_parser pic_io proc~~check_fragment_overlap~~UsesGraph proc~check_fragment_overlap check_fragment_overlap module~mqc_config_parser mqc_config_parser proc~check_fragment_overlap->module~mqc_config_parser pic_io pic_io proc~check_fragment_overlap->pic_io module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Check if any atoms appear in multiple fragments\nThis is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes Arguments Type Intent Optional Attributes Name type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: nfrag type( error_t ), intent(out) :: error Calls proc~~check_fragment_overlap~~CallsGraph proc~check_fragment_overlap check_fragment_overlap proc~error_set error_t%error_set proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~check_fragment_overlap~~CalledByGraph proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~check_fragment_overlap proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_i integer, private :: atom_j integer, private :: i integer, private :: j integer, private :: k integer, private :: l Source Code subroutine check_fragment_overlap ( fragments , nfrag , error ) !! Check if any atoms appear in multiple fragments !! This is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes use mqc_config_parser , only : input_fragment_t use pic_io , only : to_char type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: nfrag type ( error_t ), intent ( out ) :: error integer :: i , j , k , l integer :: atom_i , atom_j ! Compare each pair of fragments do i = 1 , nfrag - 1 do j = i + 1 , nfrag ! Compare atoms in fragment i with atoms in fragment j do k = 1 , size ( fragments ( i )% indices ) atom_i = fragments ( i )% indices ( k ) do l = 1 , size ( fragments ( j )% indices ) atom_j = fragments ( j )% indices ( l ) if ( atom_i == atom_j ) then ! Found overlapping atom call error % set ( ERROR_VALIDATION , \"Overlapping fragments detected: fragments \" // to_char ( i ) // \" and \" // & to_char ( j ) // \" both contain atom \" // to_char ( atom_i ) // & \". Set allow_overlapping_fragments = true to allow this.\" ) return end if end do end do end do end do end subroutine check_fragment_overlap","tags":"","url":"proc/check_fragment_overlap.html"},{"title":"config_to_driver – metalquicha","text":"public  subroutine config_to_driver(mqc_config, driver_config, molecule_index) Convert mqc_config_t to minimal driver_config_t\nExtracts only the fields needed by the driver\nIf molecule_index is provided, uses that molecule’s fragment count Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( driver_config_t ), intent(out) :: driver_config integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) Called by proc~~config_to_driver~~CalledByGraph proc~config_to_driver config_to_driver proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_driver program~main main program~main->proc~config_to_driver program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: nfrag_to_use Source Code subroutine config_to_driver ( mqc_config , driver_config , molecule_index ) !! Convert mqc_config_t to minimal driver_config_t !! Extracts only the fields needed by the driver !! If molecule_index is provided, uses that molecule's fragment count type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ), intent ( out ) :: driver_config integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: nfrag_to_use ! Copy method and calc_type (already integers) driver_config % method = mqc_config % method driver_config % calc_type = mqc_config % calc_type ! Determine fragment count if ( present ( molecule_index )) then ! Multi-molecule mode: use specific molecule's fragment count if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then nfrag_to_use = 0 else nfrag_to_use = mqc_config % molecules ( molecule_index )% nfrag end if else ! Single molecule mode (backward compatible) nfrag_to_use = mqc_config % nfrag end if ! Set fragmentation level ! For unfragmented calculations (nfrag=0), nlevel must be 0 if ( nfrag_to_use == 0 ) then driver_config % nlevel = 0 else driver_config % nlevel = mqc_config % frag_level end if ! Set GMBE overlapping fragments flag driver_config % allow_overlapping_fragments = mqc_config % allow_overlapping_fragments ! Set GMBE maximum intersection level driver_config % max_intersection_level = mqc_config % max_intersection_level end subroutine config_to_driver","tags":"","url":"proc/config_to_driver.html"},{"title":"config_to_system_geometry – metalquicha","text":"public  subroutine config_to_system_geometry(mqc_config, sys_geom, error, molecule_index) Convert mqc_config_t geometry to system_geometry_t\nFor unfragmented calculations (nfrag=0), treats entire system as single unit\nFor fragmented calculations, currently assumes monomer-based fragmentation\nIf molecule_index is provided, uses that specific molecule from multi-molecule mode Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) Calls proc~~config_to_system_geometry~~CallsGraph proc~config_to_system_geometry config_to_system_geometry proc~error_has_error error_t%error_has_error proc~config_to_system_geometry->proc~error_has_error proc~error_set error_t%error_set proc~config_to_system_geometry->proc~error_set proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~molecule_to_system_geometry->proc~error_set proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~config_to_system_geometry~~CalledByGraph proc~config_to_system_geometry config_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i logical, private :: use_angstrom Source Code subroutine config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index ) !! Convert mqc_config_t geometry to system_geometry_t !! For unfragmented calculations (nfrag=0), treats entire system as single unit !! For fragmented calculations, currently assumes monomer-based fragmentation !! If molecule_index is provided, uses that specific molecule from multi-molecule mode type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: i logical :: use_angstrom ! Determine units use_angstrom = . true . if ( allocated ( mqc_config % units )) then if ( trim ( mqc_config % units ) == 'bohr' ) then use_angstrom = . false . end if end if ! Handle multi-molecule vs single molecule mode if ( present ( molecule_index )) then ! Multi-molecule mode: extract specific molecule if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then call error % set ( ERROR_VALIDATION , \"Invalid molecule_index in multi-molecule mode\" ) return end if call molecule_to_system_geometry ( mqc_config % molecules ( molecule_index ), & sys_geom , use_angstrom , mqc_config % allow_overlapping_fragments , error ) else ! Single molecule mode (backward compatible) ! Check if geometry is loaded if ( mqc_config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in mqc_config\" ) return end if if ( mqc_config % nfrag == 0 ) then ! Unfragmented calculation: entire system is one \"monomer\" call geometry_to_system_unfragmented ( mqc_config % geometry , sys_geom , use_angstrom ) sys_geom % charge = mqc_config % charge sys_geom % multiplicity = mqc_config % multiplicity else ! Fragmented calculation with explicit fragments call geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) if ( error % has_error ()) return end if end if end subroutine config_to_system_geometry","tags":"","url":"proc/config_to_system_geometry.html"},{"title":"geometry_to_system_fragmented – metalquicha","text":"private  subroutine geometry_to_system_fragmented(mqc_config, sys_geom, use_angstrom, error) Convert geometry to system_geometry_t for fragmented calculation\nSupports both identical and variable-sized fragments Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom type( error_t ), intent(out) :: error Calls proc~~geometry_to_system_fragmented~~CallsGraph proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~element_symbol_to_number element_symbol_to_number proc~initialize_fragmented_system->proc~element_symbol_to_number proc~error_has_error error_t%error_has_error proc~initialize_fragmented_system->proc~error_has_error proc~to_bohr to_bohr proc~initialize_fragmented_system->proc~to_bohr proc~error_set error_t%error_set proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~geometry_to_system_fragmented~~CalledByGraph proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) !! Convert geometry to system_geometry_t for fragmented calculation !! Supports both identical and variable-sized fragments type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error call initialize_fragmented_system ( mqc_config % nfrag , mqc_config % geometry , mqc_config % fragments , & mqc_config % charge , mqc_config % multiplicity , & mqc_config % allow_overlapping_fragments , use_angstrom , & sys_geom , error ) end subroutine geometry_to_system_fragmented","tags":"","url":"proc/geometry_to_system_fragmented.html"},{"title":"geometry_to_system_unfragmented – metalquicha","text":"private  subroutine geometry_to_system_unfragmented(geom, sys_geom, use_angstrom) Uses mqc_geometry proc~~geometry_to_system_unfragmented~~UsesGraph proc~geometry_to_system_unfragmented geometry_to_system_unfragmented module~mqc_geometry mqc_geometry proc~geometry_to_system_unfragmented->module~mqc_geometry pic_types pic_types module~mqc_geometry->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Convert geometry to system_geometry_t for unfragmented calculation\nTreats entire system as a single monomer Arguments Type Intent Optional Attributes Name type( geometry_type ), intent(in) :: geom type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom Calls proc~~geometry_to_system_unfragmented~~CallsGraph proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~geometry_to_system_unfragmented~~CalledByGraph proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine geometry_to_system_unfragmented ( geom , sys_geom , use_angstrom ) !! Convert geometry to system_geometry_t for unfragmented calculation !! Treats entire system as a single monomer use mqc_geometry , only : geometry_type type ( geometry_type ), intent ( in ) :: geom type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom integer :: i ! For unfragmented: n_monomers=1, atoms_per_monomer=natoms sys_geom % n_monomers = 1 sys_geom % atoms_per_monomer = geom % natoms sys_geom % total_atoms = geom % natoms allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine geometry_to_system_unfragmented","tags":"","url":"proc/geometry_to_system_unfragmented.html"},{"title":"initialize_fragmented_system – metalquicha","text":"private  subroutine initialize_fragmented_system(nfrag, geom, fragments, charge, multiplicity, allow_overlapping, use_angstrom, sys_geom, error) Uses mqc_config_parser mqc_geometry proc~~initialize_fragmented_system~~UsesGraph proc~initialize_fragmented_system initialize_fragmented_system module~mqc_config_parser mqc_config_parser proc~initialize_fragmented_system->module~mqc_config_parser module~mqc_geometry mqc_geometry proc~initialize_fragmented_system->module~mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_geometry->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Shared helper to initialize system_geometry_t for fragmented calculations\nHandles fragment allocation, size checking, and overlap validation Arguments Type Intent Optional Attributes Name integer, intent(in) :: nfrag type( geometry_type ), intent(in) :: geom type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: charge integer, intent(in) :: multiplicity logical, intent(in) :: allow_overlapping logical, intent(in) :: use_angstrom type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error Calls proc~~initialize_fragmented_system~~CallsGraph proc~initialize_fragmented_system initialize_fragmented_system proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~element_symbol_to_number element_symbol_to_number proc~initialize_fragmented_system->proc~element_symbol_to_number proc~error_has_error error_t%error_has_error proc~initialize_fragmented_system->proc~error_has_error proc~to_bohr to_bohr proc~initialize_fragmented_system->proc~to_bohr proc~error_set error_t%error_set proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initialize_fragmented_system~~CalledByGraph proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: all_same_size integer, private :: atoms_in_first_frag integer, private :: i integer, private :: j integer, private :: max_frag_size Source Code subroutine initialize_fragmented_system ( nfrag , geom , fragments , charge , multiplicity , & allow_overlapping , use_angstrom , sys_geom , error ) !! Shared helper to initialize system_geometry_t for fragmented calculations !! Handles fragment allocation, size checking, and overlap validation use mqc_geometry , only : geometry_type use mqc_config_parser , only : input_fragment_t integer , intent ( in ) :: nfrag type ( geometry_type ), intent ( in ) :: geom type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: charge , multiplicity logical , intent ( in ) :: allow_overlapping logical , intent ( in ) :: use_angstrom type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer :: i , j , atoms_in_first_frag , max_frag_size logical :: all_same_size ! Set up basic system geometry sys_geom % n_monomers = nfrag sys_geom % total_atoms = geom % natoms sys_geom % charge = charge sys_geom % multiplicity = multiplicity ! Allocate fragment info arrays allocate ( sys_geom % fragment_sizes ( nfrag )) allocate ( sys_geom % fragment_charges ( nfrag )) allocate ( sys_geom % fragment_multiplicities ( nfrag )) ! Get fragment sizes max_frag_size = 0 atoms_in_first_frag = size ( fragments ( 1 )% indices ) all_same_size = . true . do i = 1 , nfrag sys_geom % fragment_sizes ( i ) = size ( fragments ( i )% indices ) sys_geom % fragment_charges ( i ) = fragments ( i )% charge sys_geom % fragment_multiplicities ( i ) = fragments ( i )% multiplicity max_frag_size = max ( max_frag_size , sys_geom % fragment_sizes ( i )) if ( sys_geom % fragment_sizes ( i ) /= atoms_in_first_frag ) then all_same_size = . false . end if end do ! Allocate fragment_atoms array allocate ( sys_geom % fragment_atoms ( max_frag_size , nfrag )) sys_geom % fragment_atoms = - 1 ! Initialize with invalid index ! Store fragment atom indices (0-indexed from input file) do i = 1 , nfrag do j = 1 , sys_geom % fragment_sizes ( i ) sys_geom % fragment_atoms ( j , i ) = fragments ( i )% indices ( j ) end do end do ! Check for overlapping fragments if not allowed if (. not . allow_overlapping ) then call check_fragment_overlap ( fragments , nfrag , error ) if ( error % has_error ()) return end if ! Set atoms_per_monomer: use common size if identical, else 0 if ( all_same_size ) then sys_geom % atoms_per_monomer = atoms_in_first_frag else sys_geom % atoms_per_monomer = 0 ! Signal variable-sized fragments end if allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine initialize_fragmented_system","tags":"","url":"proc/initialize_fragmented_system.html"},{"title":"molecule_to_system_geometry – metalquicha","text":"private  subroutine molecule_to_system_geometry(mol, sys_geom, use_angstrom, allow_overlapping, error) Uses mqc_config_parser proc~~molecule_to_system_geometry~~UsesGraph proc~molecule_to_system_geometry molecule_to_system_geometry module~mqc_config_parser mqc_config_parser proc~molecule_to_system_geometry->module~mqc_config_parser module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Convert a molecule_t to system_geometry_t\nHandles both unfragmented (nfrag=0) and fragmented molecules Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: mol type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom logical, intent(in) :: allow_overlapping type( error_t ), intent(out) :: error Calls proc~~molecule_to_system_geometry~~CallsGraph proc~molecule_to_system_geometry molecule_to_system_geometry proc~error_set error_t%error_set proc~molecule_to_system_geometry->proc~error_set proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~initialize_fragmented_system initialize_fragmented_system proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~initialize_fragmented_system->proc~element_symbol_to_number proc~error_has_error error_t%error_has_error proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap->proc~error_set to_char to_char proc~check_fragment_overlap->to_char to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~molecule_to_system_geometry~~CalledByGraph proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine molecule_to_system_geometry ( mol , sys_geom , use_angstrom , allow_overlapping , error ) !! Convert a molecule_t to system_geometry_t !! Handles both unfragmented (nfrag=0) and fragmented molecules use mqc_config_parser , only : molecule_t type ( molecule_t ), intent ( in ) :: mol type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error logical , intent ( in ) :: allow_overlapping ! Check if geometry is loaded if ( mol % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in molecule\" ) return end if if ( mol % nfrag == 0 ) then ! Unfragmented molecule call geometry_to_system_unfragmented ( mol % geometry , sys_geom , use_angstrom ) sys_geom % charge = mol % charge sys_geom % multiplicity = mol % multiplicity else ! Fragmented molecule call initialize_fragmented_system ( mol % nfrag , mol % geometry , mol % fragments , & mol % charge , mol % multiplicity , & allow_overlapping , use_angstrom , & sys_geom , error ) end if end subroutine molecule_to_system_geometry","tags":"","url":"proc/molecule_to_system_geometry.html"},{"title":"ends_with – metalquicha","text":"public  function ends_with(str, suffix) Check if string ends with suffix Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix Return Value logical Called by proc~~ends_with~~CalledByGraph proc~ends_with ends_with program~main main program~main->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: str_len integer, private :: suffix_len Source Code logical function ends_with ( str , suffix ) !! Check if string ends with suffix character ( len =* ), intent ( in ) :: str , suffix integer :: str_len , suffix_len str_len = len_trim ( str ) suffix_len = len_trim ( suffix ) if ( suffix_len > str_len ) then ends_with = . false . return end if ends_with = ( str ( str_len - suffix_len + 1 : str_len ) == suffix ) end function ends_with","tags":"","url":"proc/ends_with.html"},{"title":"get_basename – metalquicha","text":"public  function get_basename() result(basename) Get the base name without “output_” prefix and “.json” suffix\nExample: “output_w1.json” -> “w1” Arguments None Return Value character(len=256) Called by proc~~get_basename~~CalledByGraph proc~get_basename get_basename proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~print_detailed_breakdown_json->proc~get_basename proc~print_gmbe_json print_gmbe_json proc~print_gmbe_json->proc~get_basename proc~print_gmbe_pie_json print_gmbe_pie_json proc~print_gmbe_pie_json->proc~get_basename proc~print_unfragmented_json print_unfragmented_json proc~print_unfragmented_json->proc~get_basename proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~print_detailed_breakdown_json proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~print_unfragmented_json proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~print_unfragmented_json proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~global_coordinator proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: end_pos integer, private :: start_pos Source Code function get_basename () result ( basename ) !! Get the base name without \"output_\" prefix and \".json\" suffix !! Example: \"output_w1.json\" -> \"w1\" character ( len = 256 ) :: basename integer :: start_pos , end_pos ! Remove \"output_\" prefix (7 characters) start_pos = 8 ! Find \".json\" suffix end_pos = index ( output_json_filename , '.json' , back = . true .) - 1 if ( end_pos > start_pos ) then basename = output_json_filename ( start_pos : end_pos ) else basename = \"unknown\" end if end function get_basename","tags":"","url":"proc/get_basename.html"},{"title":"get_molecule_name – metalquicha","text":"public  function get_molecule_name(filename) result(name) Extract molecule name from filename\nExample: “output_multi_structure_molecule_1.json” -> “molecule_1” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value character(len=256) Called by proc~~get_molecule_name~~CalledByGraph proc~get_molecule_name get_molecule_name proc~read_json_content read_json_content proc~read_json_content->proc~get_molecule_name proc~merge_multi_molecule_json merge_multi_molecule_json proc~merge_multi_molecule_json->proc~read_json_content proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: end_pos integer, private :: start_pos Source Code function get_molecule_name ( filename ) result ( name ) !! Extract molecule name from filename !! Example: \"output_multi_structure_molecule_1.json\" -> \"molecule_1\" character ( len =* ), intent ( in ) :: filename character ( len = 256 ) :: name integer :: start_pos , end_pos ! Find \"_molecule_\" or similar pattern start_pos = index ( filename , '_molecule_' ) if ( start_pos == 0 ) start_pos = index ( filename , '_mol_' ) if ( start_pos > 0 ) then start_pos = start_pos + 1 ! Skip leading underscore end_pos = index ( filename , '.json' ) - 1 if ( end_pos > start_pos ) then name = filename ( start_pos : end_pos ) else name = \"unknown\" end if else name = \"unknown\" end if end function get_molecule_name","tags":"","url":"proc/get_molecule_name.html"},{"title":"get_output_json_filename – metalquicha","text":"public  function get_output_json_filename() result(filename) Get the current JSON output filename Arguments None Return Value character(len=256) Called by proc~~get_output_json_filename~~CalledByGraph proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_gmbe_json print_gmbe_json proc~print_gmbe_json->proc~get_output_json_filename proc~print_gmbe_pie_json print_gmbe_pie_json proc~print_gmbe_pie_json->proc~get_output_json_filename proc~print_unfragmented_json print_unfragmented_json proc~print_unfragmented_json->proc~get_output_json_filename proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~get_output_json_filename proc~run_calculation run_calculation proc~run_multi_molecule_calculations->proc~run_calculation proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->proc~print_detailed_breakdown_json proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~print_unfragmented_json proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~print_unfragmented_json program~main main program~main->proc~run_multi_molecule_calculations program~main->proc~run_calculation proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~global_coordinator proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_output_json_filename () result ( filename ) !! Get the current JSON output filename character ( len = 256 ) :: filename filename = trim ( output_json_filename ) end function get_output_json_filename","tags":"","url":"proc/get_output_json_filename.html"},{"title":"set_molecule_suffix – metalquicha","text":"public  subroutine set_molecule_suffix(suffix) Append a suffix to the output filename (e.g., for multi-molecule mode)\nExample: suffix=”_mol1” -> “output_multi_structure_mol1.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: suffix Called by proc~~set_molecule_suffix~~CalledByGraph proc~set_molecule_suffix set_molecule_suffix proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~set_molecule_suffix program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine set_molecule_suffix ( suffix ) !! Append a suffix to the output filename (e.g., for multi-molecule mode) !! Example: suffix=\"_mol1\" -> \"output_multi_structure_mol1.json\" character ( len =* ), intent ( in ) :: suffix if ( len_trim ( current_basename ) > 0 ) then output_json_filename = \"output_\" // trim ( current_basename ) // trim ( suffix ) // \".json\" end if end subroutine set_molecule_suffix","tags":"","url":"proc/set_molecule_suffix.html"},{"title":"set_output_json_filename – metalquicha","text":"public  subroutine set_output_json_filename(input_filename) Set the JSON output filename based on input filename\nExample: “water.mqc” -> “output_water.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_filename Called by proc~~set_output_json_filename~~CalledByGraph proc~set_output_json_filename set_output_json_filename program~main main program~main->proc~set_output_json_filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename integer, private :: dot_pos integer, private :: slash_pos Source Code subroutine set_output_json_filename ( input_filename ) !! Set the JSON output filename based on input filename !! Example: \"water.mqc\" -> \"output_water.json\" character ( len =* ), intent ( in ) :: input_filename integer :: dot_pos , slash_pos character ( len = 256 ) :: basename ! Find last slash (if any) to extract basename slash_pos = index ( input_filename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = input_filename ( slash_pos + 1 :) else basename = input_filename end if ! Find last dot to remove extension dot_pos = index ( basename , '.' , back = . true .) if ( dot_pos > 0 ) then basename = basename ( 1 : dot_pos - 1 ) end if ! Store basename for later use current_basename = trim ( basename ) ! Construct output filename: output_<basename>.json output_json_filename = \"output_\" // trim ( basename ) // \".json\" end subroutine set_output_json_filename","tags":"","url":"proc/set_output_json_filename.html"},{"title":"distributed_unfragmented_hessian – metalquicha","text":"public  subroutine distributed_unfragmented_hessian(world_comm, sys_geom, method) Uses mqc_finite_differences mqc_method_xtb proc~~distributed_unfragmented_hessian~~UsesGraph proc~distributed_unfragmented_hessian distributed_unfragmented_hessian module~mqc_finite_differences mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_finite_differences module~mqc_method_xtb mqc_method_xtb proc~distributed_unfragmented_hessian->module~mqc_method_xtb module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_xtb->module~mqc_result_types pic_timer pic_timer module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute Hessian for unfragmented system using MPI distribution Uses a dynamic work queue approach: workers request displacement indices\nfrom rank 0, compute gradients, and send results back. This provides\nbetter load balancing than static work distribution. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method Calls proc~~distributed_unfragmented_hessian~~CallsGraph proc~distributed_unfragmented_hessian distributed_unfragmented_hessian barrier barrier proc~distributed_unfragmented_hessian->barrier proc~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->proc~hessian_worker configuration configuration proc~hessian_coordinator->configuration get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time info info proc~hessian_coordinator->info iprobe iprobe proc~hessian_coordinator->iprobe irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~energy_total energy_t%energy_total proc~hessian_coordinator->proc~energy_total proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_coordinator->proc~fragment_compute_nelec proc~method_type_to_string method_type_to_string proc~hessian_coordinator->proc~method_type_to_string proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator->proc~print_unfragmented_json proc~result_destroy calculation_result_t%result_destroy proc~hessian_coordinator->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_coordinator->proc~xtb_calc_gradient recv recv proc~hessian_coordinator->recv start start proc~hessian_coordinator->start to_char to_char proc~hessian_coordinator->to_char abort_comm abort_comm proc~hessian_worker->abort_comm error error proc~hessian_worker->error proc~hessian_worker->irecv proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~hessian_worker->proc~fragment_compute_nelec proc~hessian_worker->proc~method_type_to_string proc~hessian_worker->proc~result_destroy proc~hessian_worker->proc~xtb_calc_gradient send send proc~hessian_worker->send proc~hessian_worker->to_char proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~print_unfragmented_json->error proc~print_unfragmented_json->info proc~print_unfragmented_json->proc~energy_total proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~xtb_calc_gradient->proc~energy_total new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~distributed_unfragmented_hessian~~CalledByGraph proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: my_rank integer, private :: n_ranks Source Code subroutine distributed_unfragmented_hessian ( world_comm , sys_geom , method ) !! Compute Hessian for unfragmented system using MPI distribution !! !! Uses a dynamic work queue approach: workers request displacement indices !! from rank 0, compute gradients, and send results back. This provides !! better load balancing than static work distribution. use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT , & copy_and_displace_geometry #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method integer :: my_rank , n_ranks my_rank = world_comm % rank () n_ranks = world_comm % size () if ( my_rank == 0 ) then ! Rank 0 is the coordinator call hessian_coordinator ( world_comm , sys_geom , method ) else ! Other ranks are workers call hessian_worker ( world_comm , sys_geom , method ) end if ! Synchronize all ranks before returning call world_comm % barrier () end subroutine distributed_unfragmented_hessian","tags":"","url":"proc/distributed_unfragmented_hessian.html"},{"title":"do_fragment_work – metalquicha","text":"public  subroutine do_fragment_work(fragment_idx, result, method, phys_frag, calc_type) Uses pic_logger proc~~do_fragment_work~~UsesGraph proc~do_fragment_work do_fragment_work pic_logger pic_logger proc~do_fragment_work->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Process a single fragment for quantum chemistry calculation Performs energy and gradient calculation on a molecular fragment using\nspecified quantum chemistry method (GFN-xTB variants).\nVerbosity is controlled by the global logger level. Arguments Type Intent Optional Attributes Name integer, intent(in) :: fragment_idx Fragment index for identification type( calculation_result_t ), intent(out) :: result Computation results integer(kind=int32), intent(in) :: method QC method type( physical_fragment_t ), intent(in), optional :: phys_frag Fragment geometry integer(kind=int32), intent(in), optional :: calc_type Calculation type Calls proc~~do_fragment_work~~CallsGraph proc~do_fragment_work do_fragment_work configuration configuration proc~do_fragment_work->configuration error error proc~do_fragment_work->error proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset info info proc~print_fragment_xyz->info proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom to_char to_char proc~print_fragment_xyz->to_char new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_energy->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~xtb_calc_hessian->info proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~xtb_calc_hessian->to_char proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~result_reset->proc~energy_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~do_fragment_work~~CalledByGraph proc~do_fragment_work do_fragment_work proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: calc_type_local Local copy of calc_type with default integer, private :: current_log_level Current logger verbosity level logical, private :: is_verbose Whether verbose output is enabled type( xtb_method_t ), private :: xtb_calc XTB calculator instance Source Code subroutine do_fragment_work ( fragment_idx , result , method , phys_frag , calc_type ) !! Process a single fragment for quantum chemistry calculation !! !! Performs energy and gradient calculation on a molecular fragment using !! specified quantum chemistry method (GFN-xTB variants). !! Verbosity is controlled by the global logger level. use pic_logger , only : verbose_level integer , intent ( in ) :: fragment_idx !! Fragment index for identification type ( calculation_result_t ), intent ( out ) :: result !! Computation results integer ( int32 ), intent ( in ) :: method !! QC method type ( physical_fragment_t ), intent ( in ), optional :: phys_frag !! Fragment geometry integer ( int32 ), intent ( in ), optional :: calc_type !! Calculation type integer :: current_log_level !! Current logger verbosity level logical :: is_verbose !! Whether verbose output is enabled integer ( int32 ) :: calc_type_local !! Local copy of calc_type with default #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc !! XTB calculator instance #endif ! Set default calc_type if not provided if ( present ( calc_type )) then calc_type_local = calc_type else calc_type_local = CALC_TYPE_ENERGY ! Default to energy-only calculation end if ! Query logger to determine verbosity call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) ! Print fragment geometry if provided and verbose mode is enabled if ( present ( phys_frag )) then if ( is_verbose ) then call print_fragment_xyz ( fragment_idx , phys_frag ) end if #ifndef MQC_WITHOUT_TBLITE ! Setup XTB method xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = is_verbose ! Run the calculation using the method API select case ( calc_type_local ) case ( CALC_TYPE_ENERGY ) call xtb_calc % calc_energy ( phys_frag , result ) case ( CALC_TYPE_GRADIENT ) call xtb_calc % calc_gradient ( phys_frag , result ) case ( CALC_TYPE_HESSIAN ) call xtb_calc % calc_hessian ( phys_frag , result ) case default call logger % error ( \"Unknown calc_type: \" // calc_type_to_string ( calc_type_local )) error stop \"Invalid calc_type in do_fragment_work\" end select #else call logger % error ( \"XTB method requested but tblite support not compiled in\" ) call logger % error ( \"Please rebuild with -DMQC_ENABLE_TBLITE=ON\" ) error stop \"tblite support not available\" #endif else ! For empty fragments, set energy to zero call result % energy % reset () result % has_energy = . true . end if end subroutine do_fragment_work","tags":"","url":"proc/do_fragment_work.html"},{"title":"global_coordinator – metalquicha","text":"public  subroutine global_coordinator(world_comm, node_comm, total_fragments, polymers, max_level, node_leader_ranks, num_nodes, sys_geom, calc_type, bonds) Global coordinator for distributing fragments to node coordinators\nwill act as a node coordinator for a single node calculation\nUses int64 for total_fragments to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in), optional :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~global_coordinator~~CallsGraph proc~global_coordinator global_coordinator debug debug proc~global_coordinator->debug error error proc~global_coordinator->error get_elapsed_time get_elapsed_time proc~global_coordinator->get_elapsed_time info info proc~global_coordinator->info iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe_energy compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~result_irecv result_irecv proc~global_coordinator->proc~result_irecv proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker start start proc~global_coordinator->start to_char to_char proc~global_coordinator->to_char verbose verbose proc~global_coordinator->verbose proc~compute_mbe_energy->debug proc~compute_mbe_energy->get_elapsed_time proc~compute_mbe_energy->info proc~compute_mbe_energy->start proc~compute_mbe_energy->to_char configuration configuration proc~compute_mbe_energy->configuration proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~energy_total energy_t%energy_total proc~compute_mbe_energy->proc~energy_total proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient->debug proc~compute_mbe_energy_gradient->error proc~compute_mbe_energy_gradient->get_elapsed_time proc~compute_mbe_energy_gradient->info proc~compute_mbe_energy_gradient->start proc~compute_mbe_energy_gradient->to_char proc~compute_mbe_energy_gradient->configuration proc~compute_mbe_energy_gradient->proc~compute_mbe proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~energy_total proc~compute_mbe_energy_gradient->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient->proc~fragment_lookup_init proc~compute_mbe_energy_gradient->proc~fragment_lookup_insert proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient_hessian->error proc~compute_mbe_energy_gradient_hessian->info proc~compute_mbe_energy_gradient_hessian->to_char proc~compute_mbe_energy_gradient_hessian->configuration proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~energy_total proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_init proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_insert proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~print_detailed_breakdown_json proc~result_irecv->irecv recv recv proc~result_irecv->recv proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort proc~map_fragment_to_system_gradient->debug proc~map_fragment_to_system_gradient->configuration proc~build_fragment_from_indices build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~fragment_destroy physical_fragment_t%fragment_destroy proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->verbose header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->info proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->warning proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_lookup_find->fnv_1a_hash proc~fragment_lookup_find->sort proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~global_coordinator~~CalledByGraph proc~global_coordinator global_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: calc_type_local type(timer_type), private :: coord_timer integer(kind=int64), private :: current_fragment integer, private :: dummy_msg integer, private :: finished_nodes integer, private :: fragment_idx logical, private :: handling_local_workers logical, private :: has_pending integer, private :: local_dummy integer, private :: local_finished_workers type(MPI_Status), private :: local_status type(request_t), private :: req integer, private :: request_source type( calculation_result_t ), private, allocatable :: results (:) integer(kind=int64), private :: results_received type(MPI_Status), private :: status integer(kind=int64), private :: worker_fragment_map (node_comm%size()) integer, private :: worker_source Source Code subroutine global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , calc_type , bonds ) !! Global coordinator for distributing fragments to node coordinators !! will act as a node coordinator for a single node calculation !! Uses int64 for total_fragments to handle large fragment counts that overflow int32. type ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level , num_nodes integer , intent ( in ) :: polymers (:, :), node_leader_ranks (:) type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ), optional :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( timer_type ) :: coord_timer integer ( int64 ) :: current_fragment , results_received integer :: finished_nodes integer :: request_source , dummy_msg , fragment_idx type ( MPI_Status ) :: status , local_status logical :: handling_local_workers logical :: has_pending integer ( int32 ) :: calc_type_local ! For local workers integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer ( int64 ) :: worker_fragment_map ( node_comm % size ()) integer :: worker_source ! MPI request handles for non-blocking operations type ( request_t ) :: req ! Set default calc_type if not provided if ( present ( calc_type )) then calc_type_local = calc_type else calc_type_local = CALC_TYPE_ENERGY end if current_fragment = total_fragments finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( node_comm % size () > 1 ) results_received = 0_int64 ! Allocate storage for results allocate ( results ( total_fragments )) worker_fragment_map = 0 call logger % verbose ( \"Global coordinator starting with \" // to_char ( total_fragments ) // & \" fragments for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers ! This MUST be checked before sending new work to avoid race conditions if ( handling_local_workers ) then ! Keep checking for results until there are none pending do call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state\" end if ! Receive result and store it using the fragment index for this worker call result_irecv ( results ( worker_fragment_map ( worker_source )), node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clear the mapping since we've received the result worker_fragment_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit ! Receive fragment index and result from node coordinator ! TODO: serialize the data for better performance call irecv ( world_comm , fragment_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( fragment_idx ), world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_fragment >= 1 ) then call send_fragment_to_node ( world_comm , current_fragment , polymers , request_source ) current_fragment = current_fragment - 1 else call isend ( world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < node_comm % size () - 1 ) then call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_fragment >= 1 ) then call send_fragment_to_worker ( node_comm , current_fragment , polymers , & local_status % MPI_SOURCE ) ! Track which fragment was sent to this worker worker_fragment_map ( local_status % MPI_SOURCE ) = current_fragment current_fragment = current_fragment - 1 else call isend ( node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if ! If worker still has pending results, skip the work request ! It will be processed on the next iteration after results are received end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= node_comm % size () - 1 & . and . results_received >= total_fragments ) then handling_local_workers = . false . if ( num_nodes == 1 ) then finished_nodes = finished_nodes + 1 call logger % debug ( \"Manually incremented finished_nodes for self\" ) else finished_nodes = finished_nodes + 1 call logger % verbose ( \"Global coordinator finished local workers\" ) end if end if end do call logger % verbose ( \"Global coordinator finished all fragments\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) block real ( dp ) :: mbe_total_energy real ( dp ), allocatable :: mbe_total_gradient (:, :) real ( dp ), allocatable :: mbe_total_hessian (:, :) ! Compute the many-body expansion call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Use combined function if computing gradients or Hessians (more efficient) if ( calc_type_local == CALC_TYPE_HESSIAN ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for Hessian calculation in global_coordinator\" ) error stop \"Missing sys_geom for Hessian calculation\" end if allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) allocate ( mbe_total_hessian ( 3 * sys_geom % total_atoms , 3 * sys_geom % total_atoms )) call compute_mbe_energy_gradient_hessian ( polymers , total_fragments , max_level , results , sys_geom , & mbe_total_energy , mbe_total_gradient , mbe_total_hessian , bonds ) deallocate ( mbe_total_gradient , mbe_total_hessian ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for gradient calculation in global_coordinator\" ) error stop \"Missing sys_geom for gradient calculation\" end if allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) call compute_mbe_energy_gradient ( polymers , total_fragments , max_level , results , sys_geom , & mbe_total_energy , mbe_total_gradient , bonds ) deallocate ( mbe_total_gradient ) else call compute_mbe_energy ( polymers , total_fragments , max_level , results , mbe_total_energy ) end if call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end block ! Cleanup deallocate ( results ) end subroutine global_coordinator","tags":"","url":"proc/global_coordinator.html"},{"title":"node_coordinator – metalquicha","text":"public  subroutine node_coordinator(world_comm, node_comm, calc_type) Node coordinator for distributing fragments to local workers\nHandles work requests and result collection from local workers Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm integer(kind=int32), intent(in), optional :: calc_type Calls proc~~node_coordinator~~CallsGraph proc~node_coordinator node_coordinator error error proc~node_coordinator->error iprobe iprobe proc~node_coordinator->iprobe irecv irecv proc~node_coordinator->irecv isend isend proc~node_coordinator->isend proc~result_irecv result_irecv proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv to_char to_char proc~node_coordinator->to_char proc~result_irecv->irecv proc~result_irecv->recv proc~result_isend->isend send send proc~result_isend->send Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~node_coordinator~~CalledByGraph proc~node_coordinator node_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: dummy_msg integer(kind=int32), private :: finished_workers integer(kind=int32), private :: fragment_idx integer(kind=int32), private, allocatable :: fragment_indices (:) integer(kind=int32), private :: fragment_size integer(kind=int32), private :: fragment_type type(MPI_Status), private :: global_status logical, private :: has_result integer(kind=int32), private :: local_dummy logical, private :: local_message_pending logical, private :: more_fragments type(request_t), private :: req type(MPI_Status), private :: status integer(kind=int32), private :: worker_fragment_map (node_comm%size()) type( calculation_result_t ), private :: worker_result integer(kind=int32), private :: worker_source Source Code subroutine node_coordinator ( world_comm , node_comm , calc_type ) !! Node coordinator for distributing fragments to local workers !! Handles work requests and result collection from local workers class ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int32 ), intent ( in ), optional :: calc_type integer ( int32 ) :: fragment_idx , fragment_size , fragment_type , dummy_msg integer ( int32 ) :: finished_workers integer ( int32 ), allocatable :: fragment_indices (:) type ( MPI_Status ) :: status , global_status logical :: local_message_pending , more_fragments , has_result integer ( int32 ) :: local_dummy ! For tracking worker-fragment mapping and collecting results integer ( int32 ) :: worker_fragment_map ( node_comm % size ()) integer ( int32 ) :: worker_source type ( calculation_result_t ) :: worker_result ! MPI request handles for non-blocking operations type ( request_t ) :: req finished_workers = 0 more_fragments = . true . dummy_msg = 0 worker_fragment_map = 0 do while ( finished_workers < node_comm % size () - 1 ) ! PRIORITY 1: Check for incoming results from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_result , status ) if ( has_result ) then worker_source = status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Node coordinator received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state in node coordinator\" end if ! Receive result from worker call result_irecv ( worker_result , node_comm , worker_source , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Forward results to global coordinator with fragment index call isend ( world_comm , worker_fragment_map ( worker_source ), 0 , TAG_NODE_SCALAR_RESULT , req ) ! fragment_idx call wait ( req ) call result_isend ( worker_result , world_comm , 0 , TAG_NODE_SCALAR_RESULT , req ) ! result call wait ( req ) ! Clear the mapping worker_fragment_map ( worker_source ) = 0 end if ! PRIORITY 2: Check for work requests from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , local_message_pending , status ) if ( local_message_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( more_fragments ) then call isend ( world_comm , dummy_msg , 0 , TAG_NODE_REQUEST , req ) call wait ( req ) call irecv ( world_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , global_status ) if ( global_status % MPI_TAG == TAG_NODE_FRAGMENT ) then ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( world_comm , fragment_type , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) call irecv ( world_comm , fragment_size , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( world_comm , fragment_indices , 0 , TAG_NODE_FRAGMENT , global_status ) ! Forward to worker call isend ( node_comm , fragment_idx , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_type , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_size , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_indices , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Track which fragment was sent to this worker worker_fragment_map ( status % MPI_SOURCE ) = fragment_idx deallocate ( fragment_indices ) else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 more_fragments = . false . end if else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end if end do end subroutine node_coordinator","tags":"","url":"proc/node_coordinator.html"},{"title":"node_worker – metalquicha","text":"public  subroutine node_worker(world_comm, node_comm, sys_geom, method, calc_type, bonds) Node worker for processing fragments assigned by node coordinator Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in), optional :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~node_worker~~CallsGraph proc~node_worker node_worker error error proc~node_worker->error irecv irecv proc~node_worker->irecv isend isend proc~node_worker->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~node_worker->proc~build_fragment_from_atom_list proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~do_fragment_work do_fragment_work proc~node_worker->proc~do_fragment_work proc~fragment_destroy physical_fragment_t%fragment_destroy proc~node_worker->proc~fragment_destroy proc~result_isend result_isend proc~node_worker->proc~result_isend recv recv proc~node_worker->recv to_char to_char proc~node_worker->to_char proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~do_fragment_work->error configuration configuration proc~do_fragment_work->configuration proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~result_isend->isend send send proc~result_isend->send proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->to_char info info proc~print_fragment_xyz->info proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_energy->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~xtb_calc_hessian->info proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~result_reset->proc~energy_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~node_worker~~CalledByGraph proc~node_worker node_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: dummy_msg integer(kind=int32), private :: fragment_idx integer(kind=int32), private, allocatable :: fragment_indices (:) integer(kind=int32), private :: fragment_size integer(kind=int32), private :: fragment_type 0 = monomer (indices), 1 = intersection (atom list) type( physical_fragment_t ), private :: phys_frag type(request_t), private :: req type( calculation_result_t ), private :: result type(MPI_Status), private :: status Source Code subroutine node_worker ( world_comm , node_comm , sys_geom , method , calc_type , bonds ) !! Node worker for processing fragments assigned by node coordinator class ( comm_t ), intent ( in ) :: world_comm , node_comm type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ), optional :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int32 ) :: fragment_idx , fragment_size , dummy_msg integer ( int32 ) :: fragment_type !! 0 = monomer (indices), 1 = intersection (atom list) integer ( int32 ), allocatable :: fragment_indices (:) type ( calculation_result_t ) :: result type ( MPI_Status ) :: status type ( physical_fragment_t ) :: phys_frag ! MPI request handles for non-blocking operations type ( request_t ) :: req dummy_msg = 0 do call isend ( node_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( node_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) select case ( status % MPI_TAG ) case ( TAG_WORKER_FRAGMENT ) ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( node_comm , fragment_type , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call irecv ( node_comm , fragment_size , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( node_comm , fragment_indices , 0 , TAG_WORKER_FRAGMENT , status ) ! Build physical fragment based on type if ( present ( sys_geom )) then if ( fragment_type == 0 ) then ! Monomer: fragment_indices are monomer indices call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , bonds ) else ! Intersection: fragment_indices are atom indices call build_fragment_from_atom_list ( sys_geom , fragment_indices , fragment_size , phys_frag , bonds ) end if ! Process the chemistry fragment with physical geometry call do_fragment_work ( fragment_idx , result , method , phys_frag , calc_type ) call phys_frag % destroy () else ! Process without physical geometry (old behavior) call do_fragment_work ( fragment_idx , result , method , calc_type = calc_type ) end if ! Send result back to coordinator call result_isend ( result , node_comm , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clean up result call result % destroy () deallocate ( fragment_indices ) case ( TAG_WORKER_FINISH ) exit case default ! Unexpected MPI tag - this should not happen in normal operation call logger % error ( \"Worker received unexpected MPI tag: \" // to_char ( status % MPI_TAG )) call logger % error ( \"Expected TAG_WORKER_FRAGMENT or TAG_WORKER_FINISH\" ) error stop \"MPI protocol error in node_worker\" end select end do end subroutine node_worker","tags":"","url":"proc/node_worker.html"},{"title":"serial_fragment_processor – metalquicha","text":"public  subroutine serial_fragment_processor(total_fragments, polymers, max_level, sys_geom, method, calc_type, bonds) Process all fragments serially in single-rank mode\nThis is used when running with only 1 MPI rank Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in), optional :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~serial_fragment_processor~~CallsGraph proc~serial_fragment_processor serial_fragment_processor configuration configuration proc~serial_fragment_processor->configuration get_elapsed_time get_elapsed_time proc~serial_fragment_processor->get_elapsed_time info info proc~serial_fragment_processor->info omp_get_max_threads omp_get_max_threads proc~serial_fragment_processor->omp_get_max_threads omp_set_num_threads omp_set_num_threads proc~serial_fragment_processor->omp_set_num_threads proc~build_fragment_from_indices build_fragment_from_indices proc~serial_fragment_processor->proc~build_fragment_from_indices proc~calc_type_to_string calc_type_to_string proc~serial_fragment_processor->proc~calc_type_to_string proc~compute_mbe_energy compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~do_fragment_work do_fragment_work proc~serial_fragment_processor->proc~do_fragment_work proc~energy_total energy_t%energy_total proc~serial_fragment_processor->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~serial_fragment_processor->proc~fragment_destroy start start proc~serial_fragment_processor->start to_char to_char proc~serial_fragment_processor->to_char verbose verbose proc~serial_fragment_processor->verbose proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~check_duplicate_atoms check_duplicate_atoms proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~compute_mbe_energy->configuration proc~compute_mbe_energy->get_elapsed_time proc~compute_mbe_energy->info proc~compute_mbe_energy->proc~energy_total proc~compute_mbe_energy->start proc~compute_mbe_energy->to_char debug debug proc~compute_mbe_energy->debug proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient->configuration proc~compute_mbe_energy_gradient->get_elapsed_time proc~compute_mbe_energy_gradient->info proc~compute_mbe_energy_gradient->proc~energy_total proc~compute_mbe_energy_gradient->start proc~compute_mbe_energy_gradient->to_char proc~compute_mbe_energy_gradient->debug error error proc~compute_mbe_energy_gradient->error proc~compute_mbe_energy_gradient->proc~compute_mbe proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient->proc~fragment_lookup_init proc~compute_mbe_energy_gradient->proc~fragment_lookup_insert proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient_hessian->configuration proc~compute_mbe_energy_gradient_hessian->info proc~compute_mbe_energy_gradient_hessian->proc~energy_total proc~compute_mbe_energy_gradient_hessian->to_char proc~compute_mbe_energy_gradient_hessian->error proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_init proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_insert proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~print_detailed_breakdown_json proc~do_fragment_work->configuration proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->error proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~check_duplicate_atoms->to_char proc~check_duplicate_atoms->error proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~compute_mbe_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_gradient->proc~fragment_lookup_find proc~compute_mbe_gradient->proc~get_next_combination proc~compute_mbe_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_hessian->proc~fragment_lookup_find proc~compute_mbe_hessian->proc~get_next_combination proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort proc~map_fragment_to_system_gradient->configuration proc~map_fragment_to_system_gradient->proc~build_fragment_from_indices proc~map_fragment_to_system_gradient->proc~fragment_destroy proc~map_fragment_to_system_gradient->debug proc~redistribute_cap_gradients redistribute_cap_gradients proc~map_fragment_to_system_gradient->proc~redistribute_cap_gradients proc~map_fragment_to_system_hessian->proc~build_fragment_from_indices proc~map_fragment_to_system_hessian->proc~fragment_destroy proc~redistribute_cap_hessian redistribute_cap_hessian proc~map_fragment_to_system_hessian->proc~redistribute_cap_hessian proc~print_detailed_breakdown->verbose header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->info proc~print_detailed_breakdown_json->error proc~get_basename get_basename proc~print_detailed_breakdown_json->proc~get_basename proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~get_output_json_filename get_output_json_filename proc~print_detailed_breakdown_json->proc~get_output_json_filename proc~print_detailed_breakdown_json->warning proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->info proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->error proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~result_destroy calculation_result_t%result_destroy proc~xtb_calc_hessian->proc~result_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~fragment_lookup_find->fnv_1a_hash proc~fragment_lookup_find->sort proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~result_reset->proc~energy_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~serial_fragment_processor~~CalledByGraph proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: calc_type_local type(timer_type), private :: coord_timer integer, private :: current_log_level integer(kind=int64), private :: frag_idx integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size integer, private :: iatom real(kind=dp), private :: mbe_total_energy real(kind=dp), private, allocatable :: mbe_total_gradient (:,:) real(kind=dp), private, allocatable :: mbe_total_hessian (:,:) type( physical_fragment_t ), private :: phys_frag type( calculation_result_t ), private, allocatable :: results (:) Source Code subroutine serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method , calc_type , bonds ) !! Process all fragments serially in single-rank mode !! This is used when running with only 1 MPI rank integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: polymers (:, :), max_level type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ), optional :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int64 ) :: frag_idx integer :: fragment_size , current_log_level , iatom integer , allocatable :: fragment_indices (:) type ( calculation_result_t ), allocatable :: results (:) real ( dp ) :: mbe_total_energy real ( dp ), allocatable :: mbe_total_gradient (:, :) real ( dp ), allocatable :: mbe_total_hessian (:, :) type ( physical_fragment_t ) :: phys_frag type ( timer_type ) :: coord_timer integer ( int32 ) :: calc_type_local ! Set default calc_type if not provided if ( present ( calc_type )) then calc_type_local = calc_type else calc_type_local = CALC_TYPE_ENERGY end if call logger % info ( \"Processing \" // to_char ( total_fragments ) // \" fragments serially...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type_local )) allocate ( results ( total_fragments )) call omp_set_num_threads ( 1 ) call coord_timer % start () do frag_idx = 1_int64 , total_fragments fragment_size = count ( polymers ( frag_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( frag_idx , 1 : fragment_size ) call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , bonds ) call do_fragment_work ( int ( frag_idx ), results ( frag_idx ), method , phys_frag , calc_type = calc_type_local ) ! Debug output for gradients if ( calc_type_local == CALC_TYPE_GRADIENT . and . results ( frag_idx )% has_gradient ) then call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level ) then block character ( len = 512 ) :: debug_line integer :: iatom_local write ( debug_line , '(a,i0,a,*(i0,1x))' ) \"Fragment \" , frag_idx , \" monomers: \" , fragment_indices call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Energy: \" , results ( frag_idx )% energy % total () call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( results ( frag_idx )% gradient ** 2 )) call logger % verbose ( trim ( debug_line )) if ( size ( results ( frag_idx )% gradient , 2 ) <= 20 ) then call logger % verbose ( \"  Fragment gradient:\" ) do iatom_local = 1 , size ( results ( frag_idx )% gradient , 2 ) write ( debug_line , '(a,i3,a,3f20.12)' ) \"    Atom \" , iatom_local , \": \" , & results ( frag_idx )% gradient ( 1 , iatom_local ), & results ( frag_idx )% gradient ( 2 , iatom_local ), & results ( frag_idx )% gradient ( 3 , iatom_local ) call logger % verbose ( trim ( debug_line )) end do end if end block end if end if call phys_frag % destroy () deallocate ( fragment_indices ) if ( mod ( frag_idx , max ( 1_int64 , total_fragments / 10 )) == 0 . or . frag_idx == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( frag_idx ) // \"/\" // to_char ( total_fragments ) // & \" fragments [\" // to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call omp_set_num_threads ( omp_get_max_threads ()) call logger % info ( \"All fragments processed\" ) call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Use combined function if computing gradients or Hessians (more efficient) if ( calc_type_local == CALC_TYPE_HESSIAN ) then allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) allocate ( mbe_total_hessian ( 3 * sys_geom % total_atoms , 3 * sys_geom % total_atoms )) call compute_mbe_energy_gradient_hessian ( polymers , total_fragments , max_level , results , sys_geom , & mbe_total_energy , mbe_total_gradient , mbe_total_hessian , bonds ) deallocate ( mbe_total_gradient , mbe_total_hessian ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) call compute_mbe_energy_gradient ( polymers , total_fragments , max_level , results , sys_geom , & mbe_total_energy , mbe_total_gradient , bonds ) deallocate ( mbe_total_gradient ) else call compute_mbe_energy ( polymers , total_fragments , max_level , results , mbe_total_energy ) end if call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) deallocate ( results ) end subroutine serial_fragment_processor","tags":"","url":"proc/serial_fragment_processor.html"},{"title":"unfragmented_calculation – metalquicha","text":"public  subroutine unfragmented_calculation(sys_geom, method, calc_type, bonds) Run unfragmented calculation on the entire system (nlevel=0)\nThis is a simple single-process calculation without MPI distribution Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in), optional :: calc_type type( bond_t ), intent(in), optional :: bonds (:) Calls proc~~unfragmented_calculation~~CallsGraph proc~unfragmented_calculation unfragmented_calculation configuration configuration proc~unfragmented_calculation->configuration error error proc~unfragmented_calculation->error info info proc~unfragmented_calculation->info proc~check_duplicate_atoms check_duplicate_atoms proc~unfragmented_calculation->proc~check_duplicate_atoms proc~do_fragment_work do_fragment_work proc~unfragmented_calculation->proc~do_fragment_work proc~energy_total energy_t%energy_total proc~unfragmented_calculation->proc~energy_total proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy to_char to_char proc~unfragmented_calculation->to_char proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~do_fragment_work->configuration proc~do_fragment_work->error proc~calc_type_to_string calc_type_to_string proc~do_fragment_work->proc~calc_type_to_string proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~print_unfragmented_json->error proc~print_unfragmented_json->info proc~print_unfragmented_json->proc~energy_total proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~result_reset->proc~energy_reset proc~xtb_calc_energy->proc~energy_total new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~xtb_calc_gradient->proc~energy_total proc~xtb_calc_gradient->new proc~xtb_calc_gradient->new_gfn1_calculator proc~xtb_calc_gradient->new_gfn2_calculator proc~xtb_calc_gradient->new_wavefunction proc~xtb_calc_gradient->xtb_singlepoint proc~xtb_calc_hessian->error proc~xtb_calc_hessian->info proc~xtb_calc_hessian->proc~result_destroy proc~xtb_calc_hessian->to_char proc~xtb_calc_hessian->proc~xtb_calc_gradient proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~xtb_calc_hessian->proc~finite_diff_hessian_from_gradients proc~generate_perturbed_geometries generate_perturbed_geometries proc~xtb_calc_hessian->proc~generate_perturbed_geometries proc~copy_and_displace_geometry copy_and_displace_geometry proc~generate_perturbed_geometries->proc~copy_and_displace_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unfragmented_calculation~~CalledByGraph proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( physical_fragment_t ), private :: full_system integer, private :: i type( calculation_result_t ), private :: result integer, private :: total_atoms Source Code subroutine unfragmented_calculation ( sys_geom , method , calc_type , bonds ) !! Run unfragmented calculation on the entire system (nlevel=0) !! This is a simple single-process calculation without MPI distribution type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ), optional :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ) :: result integer :: total_atoms type ( physical_fragment_t ) :: full_system integer :: i if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for unfragmented calculation\" ) error stop \"Missing geometry in unfragmented_calculation\" end if total_atoms = sys_geom % total_atoms call logger % info ( \"============================================\" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( total_atoms )) call logger % info ( \"============================================\" ) ! Build the full system as a single fragment ! For overlapping fragments, we use the full system directly (not concatenating fragments) full_system % n_atoms = total_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( total_atoms )) allocate ( full_system % coordinates ( 3 , total_atoms )) ! Copy all atoms from system geometry full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates ! Set charge and multiplicity from system full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Validate geometry (check for spatially overlapping atoms) call check_duplicate_atoms ( full_system ) ! Process the full system call do_fragment_work ( 0_int32 , result , method , phys_frag = full_system , calc_type = calc_type ) call logger % info ( \"============================================\" ) call logger % info ( \"Unfragmented calculation completed\" ) block character ( len = 256 ) :: result_line integer :: current_log_level , iatom , i , j real ( dp ) :: hess_norm write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) ! Print full gradient if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Gradient (Hartree/Bohr):\" ) do iatom = 1 , total_atoms write ( result_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & result % gradient ( 1 , iatom ), result % gradient ( 2 , iatom ), result % gradient ( 3 , iatom ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if if ( result % has_hessian ) then ! Compute Frobenius norm of Hessian hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) ! Print full Hessian if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * total_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * total_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if end block call logger % info ( \"============================================\" ) call print_unfragmented_json ( result ) call result % destroy () end subroutine unfragmented_calculation","tags":"","url":"proc/unfragmented_calculation.html"},{"title":"hessian_coordinator – metalquicha","text":"private  subroutine hessian_coordinator(world_comm, sys_geom, method) Uses mqc_finite_differences mqc_method_xtb proc~~hessian_coordinator~~UsesGraph proc~hessian_coordinator hessian_coordinator module~mqc_finite_differences mqc_finite_differences proc~hessian_coordinator->module~mqc_finite_differences module~mqc_method_xtb mqc_method_xtb proc~hessian_coordinator->module~mqc_method_xtb module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_xtb->module~mqc_result_types pic_timer pic_timer module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Coordinator for distributed Hessian calculation\nDistributes displacement work and collects gradient results Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method Calls proc~~hessian_coordinator~~CallsGraph proc~hessian_coordinator hessian_coordinator configuration configuration proc~hessian_coordinator->configuration get_elapsed_time get_elapsed_time proc~hessian_coordinator->get_elapsed_time info info proc~hessian_coordinator->info iprobe iprobe proc~hessian_coordinator->iprobe irecv irecv proc~hessian_coordinator->irecv isend isend proc~hessian_coordinator->isend proc~energy_total energy_t%energy_total proc~hessian_coordinator->proc~energy_total proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_coordinator->proc~fragment_compute_nelec proc~method_type_to_string method_type_to_string proc~hessian_coordinator->proc~method_type_to_string proc~print_unfragmented_json print_unfragmented_json proc~hessian_coordinator->proc~print_unfragmented_json proc~result_destroy calculation_result_t%result_destroy proc~hessian_coordinator->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_coordinator->proc~xtb_calc_gradient recv recv proc~hessian_coordinator->recv start start proc~hessian_coordinator->start to_char to_char proc~hessian_coordinator->to_char proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~print_unfragmented_json->info proc~print_unfragmented_json->proc~energy_total error error proc~print_unfragmented_json->error proc~get_basename get_basename proc~print_unfragmented_json->proc~get_basename proc~get_output_json_filename get_output_json_filename proc~print_unfragmented_json->proc~get_output_json_filename proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~xtb_calc_gradient->proc~energy_total new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hessian_coordinator~~CalledByGraph proc~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: backward_gradients (:,:,:) type(timer_type), private :: coord_timer integer, private :: current_disp integer, private :: current_log_level integer, private :: disp_idx real(kind=dp), private :: displacement integer, private :: dummy_msg integer, private :: finished_workers real(kind=dp), private, allocatable :: forward_gradients (:,:,:) type( physical_fragment_t ), private :: full_system real(kind=dp), private, allocatable :: grad_buffer (:,:) integer, private :: gradient_type logical, private :: has_pending real(kind=dp), private :: hess_norm real(kind=dp), private, allocatable :: hessian (:,:) integer, private :: i logical, private :: is_verbose integer, private :: j integer, private :: n_atoms integer, private :: n_displacements integer, private :: n_ranks type(request_t), private :: req type( calculation_result_t ), private :: result character(len=256), private :: result_line type(MPI_Status), private :: status integer, private :: worker_rank type( xtb_method_t ), private :: xtb_calc Source Code subroutine hessian_coordinator ( world_comm , sys_geom , method ) !! Coordinator for distributed Hessian calculation !! Distributes displacement work and collects gradient results use mqc_finite_differences , only : finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method type ( physical_fragment_t ) :: full_system type ( timer_type ) :: coord_timer real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: hessian (:, :) real ( dp ), allocatable :: grad_buffer (:, :) type ( calculation_result_t ) :: result real ( dp ) :: displacement integer :: n_atoms , n_displacements , n_ranks integer :: current_disp , finished_workers , dummy_msg , worker_rank integer :: disp_idx , gradient_type ! gradient_type: 1=forward, 2=backward type ( MPI_Status ) :: status logical :: has_pending type ( request_t ) :: req integer :: current_log_level logical :: is_verbose character ( len = 256 ) :: result_line real ( dp ) :: hess_norm integer :: i , j #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc #endif n_ranks = world_comm % size () n_atoms = sys_geom % total_atoms n_displacements = 3 * n_atoms displacement = DEFAULT_DISPLACEMENT call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) call logger % info ( \"============================================\" ) call logger % info ( \"Distributed unfragmented Hessian calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) call logger % info ( \"  MPI ranks: \" // to_char ( n_ranks )) call logger % info ( \"  Work distribution: Dynamic queue\" ) call logger % info ( \"============================================\" ) ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge call full_system % compute_nelec () ! Allocate storage for all gradients allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) allocate ( grad_buffer ( 3 , n_atoms )) current_disp = 1 finished_workers = 0 ! Process work requests and collect results call coord_timer % start () do while ( finished_workers < n_ranks - 1 ) ! Check for incoming gradient results call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE ! Receive: displacement index, gradient type (1=forward, 2=backward), gradient data call irecv ( world_comm , disp_idx , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call irecv ( world_comm , gradient_type , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call recv ( world_comm , grad_buffer , worker_rank , TAG_WORKER_SCALAR_RESULT , status ) ! Store gradient in appropriate array if ( gradient_type == 1 ) then forward_gradients ( disp_idx , :, :) = grad_buffer else backward_gradients ( disp_idx , :, :) = grad_buffer end if ! Log progress every 10% or at completion (count both forward and backward) if ( gradient_type == 2 ) then ! Only log after backward gradient to count complete displacements if ( mod ( disp_idx , max ( 1 , n_displacements / 10 )) == 0 . or . disp_idx == n_displacements ) then call logger % info ( \"  Completed \" // to_char ( disp_idx ) // \"/\" // to_char ( n_displacements ) // & \" displacement pairs in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end if end if end if ! Check for work requests from workers call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE call irecv ( world_comm , dummy_msg , worker_rank , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_disp <= n_displacements ) then ! Send next displacement index to worker call isend ( world_comm , current_disp , worker_rank , TAG_WORKER_FRAGMENT , req ) call wait ( req ) current_disp = current_disp + 1 else ! No more work - tell worker to finish call isend ( world_comm , - 1 , worker_rank , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end do deallocate ( grad_buffer ) call coord_timer % stop () call logger % info ( \"All gradient calculations completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Assemble Hessian from finite differences call logger % info ( \"  Assembling Hessian matrix...\" ) call coord_timer % start () call finite_diff_hessian_from_gradients ( full_system , forward_gradients , backward_gradients , & displacement , hessian ) call coord_timer % stop () call logger % info ( \"Hessian assembly completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Compute energy and gradient at reference geometry call logger % info ( \"  Computing reference energy and gradient...\" ) #ifndef MQC_WITHOUT_TBLITE xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = is_verbose call xtb_calc % calc_gradient ( full_system , result ) #endif ! Store Hessian in result if ( allocated ( result % hessian )) deallocate ( result % hessian ) allocate ( result % hessian ( size ( hessian , 1 ), size ( hessian , 2 ))) result % hessian = hessian result % has_hessian = . true . ! Print results call logger % info ( \"============================================\" ) call logger % info ( \"Distributed Hessian calculation completed\" ) write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) end if if ( result % has_hessian ) then hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) if ( is_verbose . and . n_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * n_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * n_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if call logger % info ( \"============================================\" ) ! Output JSON call print_unfragmented_json ( result ) ! Cleanup call result % destroy () deallocate ( forward_gradients , backward_gradients ) if ( allocated ( hessian )) deallocate ( hessian ) end subroutine hessian_coordinator","tags":"","url":"proc/hessian_coordinator.html"},{"title":"hessian_worker – metalquicha","text":"private  subroutine hessian_worker(world_comm, sys_geom, method) Uses mqc_finite_differences mqc_method_xtb proc~~hessian_worker~~UsesGraph proc~hessian_worker hessian_worker module~mqc_finite_differences mqc_finite_differences proc~hessian_worker->module~mqc_finite_differences module~mqc_method_xtb mqc_method_xtb proc~hessian_worker->module~mqc_method_xtb module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_xtb->module~mqc_result_types pic_timer pic_timer module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Worker for distributed Hessian calculation\nRequests displacement indices, computes gradients, and sends results back Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method Calls proc~~hessian_worker~~CallsGraph proc~hessian_worker hessian_worker abort_comm abort_comm proc~hessian_worker->abort_comm error error proc~hessian_worker->error irecv irecv proc~hessian_worker->irecv isend isend proc~hessian_worker->isend proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~hessian_worker->proc~fragment_compute_nelec proc~method_type_to_string method_type_to_string proc~hessian_worker->proc~method_type_to_string proc~result_destroy calculation_result_t%result_destroy proc~hessian_worker->proc~result_destroy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~hessian_worker->proc~xtb_calc_gradient send send proc~hessian_worker->send to_char to_char proc~hessian_worker->to_char proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_gradient->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_gradient->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_gradient->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_gradient->new_wavefunction proc~energy_total energy_t%energy_total proc~xtb_calc_gradient->proc~energy_total xtb_singlepoint xtb_singlepoint proc~xtb_calc_gradient->xtb_singlepoint proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~energy_reset energy_t%energy_reset proc~result_reset->proc~energy_reset proc~mp2_reset mp2_energy_t%mp2_reset proc~energy_reset->proc~mp2_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hessian_worker~~CalledByGraph proc~hessian_worker hessian_worker proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_worker proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_idx integer, private :: coord integer, private :: disp_idx type( physical_fragment_t ), private :: displaced_geom real(kind=dp), private :: displacement integer, private :: dummy_msg type( physical_fragment_t ), private :: full_system type( calculation_result_t ), private :: grad_result integer, private :: gradient_type integer, private :: n_atoms type(request_t), private :: req type(MPI_Status), private :: status type( xtb_method_t ), private :: xtb_calc Source Code subroutine hessian_worker ( world_comm , sys_geom , method ) !! Worker for distributed Hessian calculation !! Requests displacement indices, computes gradients, and sends results back use mqc_finite_differences , only : DEFAULT_DISPLACEMENT , copy_and_displace_geometry #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method type ( physical_fragment_t ) :: full_system , displaced_geom type ( calculation_result_t ) :: grad_result real ( dp ) :: displacement integer :: n_atoms , disp_idx , atom_idx , coord , gradient_type , dummy_msg type ( MPI_Status ) :: status type ( request_t ) :: req #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc #endif n_atoms = sys_geom % total_atoms displacement = DEFAULT_DISPLACEMENT ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () #ifndef MQC_WITHOUT_TBLITE ! Setup XTB method xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = . false . dummy_msg = 0 do ! Request work from coordinator call isend ( world_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( world_comm , disp_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) if ( status % MPI_TAG == TAG_WORKER_FINISH ) exit ! Compute displacement index to atom and coordinate atom_idx = ( disp_idx - 1 ) / 3 + 1 coord = mod ( disp_idx - 1 , 3 ) + 1 ! Compute FORWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , displacement , displaced_geom ) call xtb_calc % calc_gradient ( displaced_geom , grad_result ) if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (1=forward), gradient data gradient_type = 1 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call grad_result % destroy () call displaced_geom % destroy () ! Compute BACKWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , - displacement , displaced_geom ) call xtb_calc % calc_gradient ( displaced_geom , grad_result ) if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (2=backward), gradient data gradient_type = 2 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call grad_result % destroy () call displaced_geom % destroy () end do #else call logger % error ( \"XTB method requested but tblite support not compiled in\" ) call abort_comm ( world_comm , 1 ) #endif end subroutine hessian_worker","tags":"","url":"proc/hessian_worker.html"},{"title":"send_fragment_to_node – metalquicha","text":"private  subroutine send_fragment_to_node(world_comm, fragment_idx, polymers, dest_rank) Send fragment data to remote node coordinator\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank Calls proc~~send_fragment_to_node~~CallsGraph proc~send_fragment_to_node send_fragment_to_node isend isend proc~send_fragment_to_node->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_fragment_to_node~~CalledByGraph proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator global_coordinator proc~global_coordinator->proc~send_fragment_to_node proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: fragment_idx_int32 integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size integer(kind=int32), private :: fragment_type type(request_t), private :: req (4) Source Code subroutine send_fragment_to_node ( world_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to remote node coordinator !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int32 ) :: fragment_idx_int32 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int32 = int ( fragment_idx , kind = int32 ) call isend ( world_comm , fragment_idx_int32 , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , fragment_size , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , fragment_indices , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_node","tags":"","url":"proc/send_fragment_to_node.html"},{"title":"send_fragment_to_worker – metalquicha","text":"private  subroutine send_fragment_to_worker(node_comm, fragment_idx, polymers, dest_rank) Send fragment data to local worker\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank Calls proc~~send_fragment_to_worker~~CallsGraph proc~send_fragment_to_worker send_fragment_to_worker isend isend proc~send_fragment_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_fragment_to_worker~~CalledByGraph proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator global_coordinator proc~global_coordinator->proc~send_fragment_to_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: fragment_idx_int32 integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size integer(kind=int32), private :: fragment_type type(request_t), private :: req (4) Source Code subroutine send_fragment_to_worker ( node_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to local worker !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int32 ) :: fragment_idx_int32 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int32 = int ( fragment_idx , kind = int32 ) call isend ( node_comm , fragment_idx_int32 , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , fragment_size , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , fragment_indices , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_worker","tags":"","url":"proc/send_fragment_to_worker.html"},{"title":"ang_mom_char_to_int – metalquicha","text":"public pure function ang_mom_char_to_int(ang_mom_char) result(ang_mom) Convert angular momentum character to integer Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6\nSpecial case: L=-1 (combined S+P shell, requires splitting) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ang_mom_char Angular momentum symbol Return Value integer Corresponding integer value Called by proc~~ang_mom_char_to_int~~CalledByGraph proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~ang_mom_char_to_int proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function ang_mom_char_to_int ( ang_mom_char ) result ( ang_mom ) !! Convert angular momentum character to integer !! !! Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6 !! Special case: L=-1 (combined S+P shell, requires splitting) character ( len = 1 ), intent ( in ) :: ang_mom_char !! Angular momentum symbol integer :: ang_mom !! Corresponding integer value select case ( ang_mom_char ) case ( 'S' ) ang_mom = 0 case ( 'P' ) ang_mom = 1 case ( 'D' ) ang_mom = 2 case ( 'F' ) ang_mom = 3 case ( 'G' ) ang_mom = 4 case ( 'H' ) ang_mom = 5 case ( 'I' ) ang_mom = 6 case ( 'L' ) ang_mom = - 1 ! Special case: L shells are split into S+P case default ang_mom = - 1 end select end function ang_mom_char_to_int","tags":"","url":"proc/ang_mom_char_to_int.html"},{"title":"ang_mom_int_to_char – metalquicha","text":"public pure function ang_mom_int_to_char(ang_mom) result(ang_mom_char) Convert angular momentum integer to character Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I\nReturns ‘?’ for invalid input values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ang_mom Angular momentum quantum number Return Value character(len=1) Corresponding symbol character Source Code pure function ang_mom_int_to_char ( ang_mom ) result ( ang_mom_char ) !! Convert angular momentum integer to character !! !! Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I !! Returns '?' for invalid input values. integer , intent ( in ) :: ang_mom !! Angular momentum quantum number character ( len = 1 ) :: ang_mom_char !! Corresponding symbol character select case ( ang_mom ) case ( 0 ) ang_mom_char = 'S' case ( 1 ) ang_mom_char = 'P' case ( 2 ) ang_mom_char = 'D' case ( 3 ) ang_mom_char = 'F' case ( 4 ) ang_mom_char = 'G' case ( 5 ) ang_mom_char = 'H' case ( 6 ) ang_mom_char = 'I' case default ang_mom_char = '?' end select end function ang_mom_int_to_char","tags":"","url":"proc/ang_mom_int_to_char.html"},{"title":"classify_line – metalquicha","text":"public pure function classify_line(line) result(line_type) Classify a line from a gamess formatted basis set file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer Calls proc~~classify_line~~CallsGraph proc~classify_line classify_line proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~classify_line~~CalledByGraph proc~classify_line classify_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: line_trim Source Code pure function classify_line ( line ) result ( line_type ) !! Classify a line from a gamess formatted basis set file character ( len =* ), intent ( in ) :: line integer :: line_type character ( len = :), allocatable :: line_trim line_trim = trim ( adjustl ( line )) if ( is_blank_or_control ( line_trim )) then line_type = LINE_UNKNOWN else if ( is_function_line ( line_trim )) then line_type = LINE_FUNCTION else if ( is_shell_header ( line_trim )) then line_type = LINE_SHELL else line_type = LINE_ATOM end if end function classify_line","tags":"","url":"proc/classify_line.html"},{"title":"is_blank_or_control – metalquicha","text":"private pure function is_blank_or_control(line) result(res) Check if a line is blank or a control line (starts with ‘$’) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_blank_or_control~~CalledByGraph proc~is_blank_or_control is_blank_or_control proc~classify_line classify_line proc~classify_line->proc~is_blank_or_control proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: trimmed_len Source Code pure function is_blank_or_control ( line ) result ( res ) !! Check if a line is blank or a control line (starts with '$') character ( len =* ), intent ( in ) :: line logical :: res integer :: trimmed_len trimmed_len = len_trim ( line ) if ( trimmed_len == 0 ) then res = . true . else res = ( line ( 1 : 1 ) == '$' ) end if end function is_blank_or_control","tags":"","url":"proc/is_blank_or_control.html"},{"title":"is_function_line – metalquicha","text":"private pure function is_function_line(line) result(res) Check if a line is a function coefficient line (starts with a number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_function_line~~CalledByGraph proc~is_function_line is_function_line proc~classify_line classify_line proc~classify_line->proc~is_function_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: first_char Source Code pure function is_function_line ( line ) result ( res ) !! Check if a line is a function coefficient line (starts with a number) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char if ( len_trim ( line ) == 0 ) then res = . false . return end if first_char = line ( 1 : 1 ) res = ( first_char >= '0' . and . first_char <= '9' ) end function is_function_line","tags":"","url":"proc/is_function_line.html"},{"title":"is_shell_header – metalquicha","text":"private pure function is_shell_header(line) result(res) Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_shell_header~~CalledByGraph proc~is_shell_header is_shell_header proc~classify_line classify_line proc~classify_line->proc~is_shell_header proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: dummy character(len=1), private :: first_char integer, private :: ios Source Code pure function is_shell_header ( line ) result ( res ) !! Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char integer :: ios , dummy res = . false . if ( len_trim ( line ) == 0 ) return first_char = line ( 1 : 1 ) if (. not . any ( first_char == [ 'S' , 'P' , 'D' , 'F' , 'G' , 'H' , 'I' , 'L' ])) return read ( line ( 2 :), * , iostat = ios ) dummy res = ( ios == 0 ) end function is_shell_header","tags":"","url":"proc/is_shell_header.html"},{"title":"build_molecular_basis – metalquicha","text":"public  subroutine build_molecular_basis(basis_string, element_names, mol_basis, error) Build molecular basis from geometry and basis file\nOnly parses unique elements, then copies basis data to atoms Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_names (:) Element for each atom in geometry order type( molecular_basis_type ), intent(out) :: mol_basis type( error_t ), intent(out) :: error Calls proc~~build_molecular_basis~~CallsGraph proc~build_molecular_basis build_molecular_basis proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~build_molecular_basis->proc~atomic_basis_destroy proc~basis_set_allocate_elements molecular_basis_type%basis_set_allocate_elements proc~build_molecular_basis->proc~basis_set_allocate_elements proc~copy_atomic_basis copy_atomic_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~error_get_message error_t%error_get_message proc~build_molecular_basis->proc~error_get_message proc~error_has_error error_t%error_has_error proc~build_molecular_basis->proc~error_has_error proc~error_set error_t%error_set proc~build_molecular_basis->proc~error_set proc~find_unique_strings find_unique_strings proc~build_molecular_basis->proc~find_unique_strings proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~strings_equal strings_equal proc~build_molecular_basis->proc~strings_equal proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis->proc~allocate_basis_shells proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis->proc~cgto_allocate_arrays proc~find_unique_strings->proc~strings_equal proc~parse_element_basis->proc~error_has_error proc~parse_element_basis->proc~error_set proc~parse_element_basis->proc~allocate_basis_shells proc~count_shells_for_element count_shells_for_element proc~parse_element_basis->proc~count_shells_for_element proc~fill_element_basis fill_element_basis proc~parse_element_basis->proc~fill_element_basis proc~count_shells_for_element->proc~error_set proc~count_shells_for_element->proc~strings_equal proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~fill_element_basis->proc~error_set proc~fill_element_basis->proc~strings_equal proc~fill_element_basis->proc~cgto_allocate_arrays proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~fill_element_basis->proc~classify_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom integer, private :: iunique integer, private :: match_idx integer, private :: natoms integer, private :: nunique type( atomic_basis_type ), private, allocatable :: unique_bases (:) character(len=:), private, allocatable :: unique_elements (:) Source Code subroutine build_molecular_basis ( basis_string , element_names , mol_basis , error ) !! Build molecular basis from geometry and basis file !! Only parses unique elements, then copies basis data to atoms character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_names (:) !! Element for each atom in geometry order type ( molecular_basis_type ), intent ( out ) :: mol_basis type ( error_t ), intent ( out ) :: error integer :: iatom , natoms , iunique , nunique character ( len = :), allocatable :: unique_elements (:) type ( atomic_basis_type ), allocatable :: unique_bases (:) integer :: match_idx match_idx = 0 natoms = size ( element_names ) ! Find unique elements call find_unique_strings ( element_names , unique_elements , nunique ) print * , \"Found \" , nunique , \" unique elements out of \" , natoms , \" atoms\" ! Allocate for unique bases allocate ( unique_bases ( nunique )) ! Parse basis for each unique element do iunique = 1 , nunique print * , \"Parsing basis for: \" , trim ( unique_elements ( iunique )) call parse_element_basis ( basis_string , unique_elements ( iunique ), & unique_bases ( iunique ), error ) if ( error % has_error ()) then ! Prepend context to error message call error % set ( ERROR_PARSE , \"Failed to parse basis for element \" // & trim ( unique_elements ( iunique )) // \": \" // error % get_message ()) return end if end do ! Allocate molecular basis and assign to each atom call mol_basis % allocate_elements ( natoms ) do iatom = 1 , natoms ! Find which unique element this atom corresponds to do iunique = 1 , nunique if ( strings_equal ( element_names ( iatom ), unique_elements ( iunique ))) then match_idx = iunique exit end if end do ! Copy the basis data call copy_atomic_basis ( unique_bases ( match_idx ), mol_basis % elements ( iatom )) end do ! Clean up do iunique = 1 , nunique call unique_bases ( iunique )% destroy () end do end subroutine build_molecular_basis","tags":"","url":"proc/build_molecular_basis.html"},{"title":"parse_element_basis – metalquicha","text":"public pure subroutine parse_element_basis(basis_string, element_name, atom_basis, error) Parse basis set for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(out) :: atom_basis type( error_t ), intent(out) :: error Calls proc~~parse_element_basis~~CallsGraph proc~parse_element_basis parse_element_basis proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~parse_element_basis->proc~allocate_basis_shells proc~count_shells_for_element count_shells_for_element proc~parse_element_basis->proc~count_shells_for_element proc~error_has_error error_t%error_has_error proc~parse_element_basis->proc~error_has_error proc~error_set error_t%error_set proc~parse_element_basis->proc~error_set proc~fill_element_basis fill_element_basis proc~parse_element_basis->proc~fill_element_basis proc~count_shells_for_element->proc~error_set proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~strings_equal strings_equal proc~count_shells_for_element->proc~strings_equal proc~fill_element_basis->proc~error_set proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~fill_element_basis->proc~cgto_allocate_arrays proc~fill_element_basis->proc~classify_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~fill_element_basis->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_element_basis~~CalledByGraph proc~parse_element_basis parse_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: nshells Source Code pure subroutine parse_element_basis ( basis_string , element_name , atom_basis , error ) !! Parse basis set for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( out ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: nshells ! Pass 1: Find the element and count its shells call count_shells_for_element ( basis_string , element_name , nshells , error ) if ( error % has_error ()) return if ( nshells == 0 ) then call error % set ( ERROR_PARSE , \"Element \" // trim ( element_name ) // \" not found in basis file\" ) return end if ! ! Allocate shells atom_basis % element = trim ( element_name ) call atom_basis % allocate_shells ( nshells ) ! ! Pass 2: Parse and fill shell data call fill_element_basis ( basis_string , element_name , atom_basis , error ) end subroutine parse_element_basis","tags":"","url":"proc/parse_element_basis.html"},{"title":"copy_atomic_basis – metalquicha","text":"private pure subroutine copy_atomic_basis(source, dest) Deep copy of atomic basis data from source to dest Arguments Type Intent Optional Attributes Name type( atomic_basis_type ), intent(in) :: source type( atomic_basis_type ), intent(out) :: dest Calls proc~~copy_atomic_basis~~CallsGraph proc~copy_atomic_basis copy_atomic_basis proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis->proc~allocate_basis_shells proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis->proc~cgto_allocate_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_atomic_basis~~CalledByGraph proc~copy_atomic_basis copy_atomic_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ishell Source Code pure subroutine copy_atomic_basis ( source , dest ) !! Deep copy of atomic basis data from source to dest type ( atomic_basis_type ), intent ( in ) :: source type ( atomic_basis_type ), intent ( out ) :: dest integer :: ishell dest % element = source % element call dest % allocate_shells ( source % nshells ) do ishell = 1 , source % nshells dest % shells ( ishell )% ang_mom = source % shells ( ishell )% ang_mom call dest % shells ( ishell )% allocate_arrays ( source % shells ( ishell )% nfunc ) dest % shells ( ishell )% exponents = source % shells ( ishell )% exponents dest % shells ( ishell )% coefficients = source % shells ( ishell )% coefficients end do end subroutine copy_atomic_basis","tags":"","url":"proc/copy_atomic_basis.html"},{"title":"count_shells_for_element – metalquicha","text":"private pure subroutine count_shells_for_element(basis_string, element_name, nshells, error) Count the number of shells for a specific element in a GAMESS formatted basis string, Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name integer, intent(out) :: nshells type( error_t ), intent(out) :: error Calls proc~~count_shells_for_element~~CallsGraph proc~count_shells_for_element count_shells_for_element proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~error_set error_t%error_set proc~count_shells_for_element->proc~error_set proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~strings_equal strings_equal proc~count_shells_for_element->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~count_shells_for_element~~CalledByGraph proc~count_shells_for_element count_shells_for_element proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: ang_mom logical, private :: found_element logical, private :: in_target_element character(len=256), private :: line integer, private :: line_end integer, private :: line_start integer, private :: line_type Source Code pure subroutine count_shells_for_element ( basis_string , element_name , nshells , error ) !! Count the number of shells for a specific element in a GAMESS formatted basis string, character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name integer , intent ( out ) :: nshells type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_target_element , found_element character ( len = 1 ) :: ang_mom nshells = 0 in_target_element = . false . found_element = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) case ( LINE_ATOM ) ! Check if this is our target element if ( strings_equal ( line , element_name )) then in_target_element = . true . found_element = . true . else ! Different element - stop counting if we were in target if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Extract angular momentum line = adjustl ( line ) ang_mom = line ( 1 : 1 ) ! L shells become 2 shells (S + P) if ( ang_mom == 'L' ) then nshells = nshells + 2 else nshells = nshells + 1 end if end if case ( LINE_UNKNOWN ) ! Skip blank lines and comments continue case default ! Skip any other line types (e.g., LINE_FUNCTION) continue end select line_start = line_end end do ! Check if we found the element at all if (. not . found_element ) then call error % set ( ERROR_PARSE , \"Element not found in basis string: \" // trim ( element_name )) end if end subroutine count_shells_for_element","tags":"","url":"proc/count_shells_for_element.html"},{"title":"fill_element_basis – metalquicha","text":"private pure subroutine fill_element_basis(basis_string, element_name, atom_basis, error) Fill in the shell data for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(inout) :: atom_basis type( error_t ), intent(out) :: error Calls proc~~fill_element_basis~~CallsGraph proc~fill_element_basis fill_element_basis proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~fill_element_basis->proc~cgto_allocate_arrays proc~classify_line classify_line proc~fill_element_basis->proc~classify_line proc~error_set error_t%error_set proc~fill_element_basis->proc~error_set proc~get_next_line get_next_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~strings_equal strings_equal proc~fill_element_basis->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_element_basis~~CalledByGraph proc~fill_element_basis fill_element_basis proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: ang_mom real(kind=dp), private :: coeff_p real(kind=dp), private :: coeff_s real(kind=dp), private :: exponent integer, private :: func_num logical, private :: has_p integer, private :: ifunc logical, private :: in_data_block logical, private :: in_target_element integer, private :: ishell integer, private :: l_shell_p_idx integer, private :: l_shell_s_idx character(len=256), private :: line integer, private :: line_end integer, private :: line_start integer, private :: line_type integer, private :: nfunc logical, private :: reading_l_shell integer, private :: stat Source Code pure subroutine fill_element_basis ( basis_string , element_name , atom_basis , error ) !! Fill in the shell data for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( inout ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_data_block , in_target_element character ( len = 1 ) :: ang_mom integer :: nfunc , func_num , ishell , ifunc real ( dp ) :: exponent , coeff_s , coeff_p logical :: has_p ! L shell handling: we split into two shells, need to track both logical :: reading_l_shell integer :: l_shell_s_idx , l_shell_p_idx integer :: stat in_data_block = . false . in_target_element = . false . ishell = 0 reading_l_shell = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) ! case (LINE_UNKNOWN) !   if (index(line, '$DATA') > 0) then !     in_data_block = .true. !   else if (index(line, '$END') > 0) then !     exit !   end if case ( LINE_ATOM ) if ( strings_equal ( line , element_name )) then in_target_element = . true . else if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Parse shell header call parse_shell_header ( line , ang_mom , nfunc , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse shell header: \" // trim ( line )) return end if if ( ang_mom == 'L' ) then ! L shell: create two shells (S and P) reading_l_shell = . true . ishell = ishell + 1 l_shell_s_idx = ishell atom_basis % shells ( ishell )% ang_mom = 0 ! S call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ishell = ishell + 1 l_shell_p_idx = ishell atom_basis % shells ( ishell )% ang_mom = 1 ! P call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 ! Reset function counter else ! Regular shell reading_l_shell = . false . ishell = ishell + 1 ! Set angular momentum (S=0, P=1, D=2, F=3, G=4, H=5, I=6) atom_basis % shells ( ishell )% ang_mom = ang_mom_char_to_int ( ang_mom ) call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 end if end if case ( LINE_FUNCTION ) if ( in_target_element ) then call parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse function line: \" // trim ( line )) return end if ifunc = ifunc + 1 if ( reading_l_shell ) then if (. not . has_p ) then call error % set ( ERROR_PARSE , \"L shell requires both S and P coefficients\" ) return end if ! Store in both S and P shells atom_basis % shells ( l_shell_s_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_s_idx )% coefficients ( ifunc ) = coeff_s atom_basis % shells ( l_shell_p_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_p_idx )% coefficients ( ifunc ) = coeff_p else ! Store in current shell atom_basis % shells ( ishell )% exponents ( ifunc ) = exponent atom_basis % shells ( ishell )% coefficients ( ifunc ) = coeff_s end if end if case default ! Skip unknown line types (e.g., LINE_UNKNOWN, blank lines, comments) continue end select line_start = line_end end do end subroutine fill_element_basis","tags":"","url":"proc/fill_element_basis.html"},{"title":"find_unique_strings – metalquicha","text":"private pure subroutine find_unique_strings(input_array, unique_array, nunique) Find unique strings in an array\nReturns array of unique strings and count Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_array (:) character(len=:), intent(out), allocatable :: unique_array (:) integer, intent(out) :: nunique Calls proc~~find_unique_strings~~CallsGraph proc~find_unique_strings find_unique_strings proc~strings_equal strings_equal proc~find_unique_strings->proc~strings_equal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_unique_strings~~CalledByGraph proc~find_unique_strings find_unique_strings proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~find_unique_strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i logical, private :: is_unique integer, private :: j integer, private :: n character(len=len), private, allocatable :: temp_unique (:) Source Code pure subroutine find_unique_strings ( input_array , unique_array , nunique ) !! Find unique strings in an array !! Returns array of unique strings and count character ( len =* ), intent ( in ) :: input_array (:) character ( len = :), allocatable , intent ( out ) :: unique_array (:) integer , intent ( out ) :: nunique integer :: i , j , n logical :: is_unique character ( len = len ( input_array )), allocatable :: temp_unique (:) n = size ( input_array ) allocate ( temp_unique ( n )) ! Max possible size nunique = 0 do i = 1 , n is_unique = . true . ! Check if we've already seen this string do j = 1 , nunique if ( strings_equal ( input_array ( i ), temp_unique ( j ))) then is_unique = . false . exit end if end do if ( is_unique ) then nunique = nunique + 1 temp_unique ( nunique ) = input_array ( i ) end if end do ! Allocate output array with exact size and copy allocate ( character ( len = len ( input_array )) :: unique_array ( nunique )) unique_array = temp_unique ( 1 : nunique ) end subroutine find_unique_strings","tags":"","url":"proc/find_unique_strings.html"},{"title":"get_next_line – metalquicha","text":"private pure subroutine get_next_line(string, line_start, line, line_end) Extract the next line from a string starting at line_start Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: line_start character(len=*), intent(out) :: line integer, intent(out) :: line_end Called by proc~~get_next_line~~CalledByGraph proc~get_next_line get_next_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~get_next_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~get_next_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: newline_pos Source Code pure subroutine get_next_line ( string , line_start , line , line_end ) !! Extract the next line from a string starting at line_start character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: line_start character ( len =* ), intent ( out ) :: line integer , intent ( out ) :: line_end integer :: newline_pos if ( line_start > len ( string )) then line = '' line_end = 0 return end if newline_pos = index ( string ( line_start :), new_line ( 'a' )) if ( newline_pos == 0 ) then ! Last line (no newline at end) line = string ( line_start :) line_end = len ( string ) + 1 else line = string ( line_start : line_start + newline_pos - 2 ) line_end = line_start + newline_pos end if end subroutine get_next_line","tags":"","url":"proc/get_next_line.html"},{"title":"parse_function_line – metalquicha","text":"private pure subroutine parse_function_line(line, func_num, exponent, coeff_s, coeff_p, has_p, stat) Parse function line (e.g., “1 1.0 2.0” or “1 1.0 2.0 3.0” for L shells) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(out) :: func_num real(kind=dp), intent(out) :: exponent real(kind=dp), intent(out) :: coeff_s real(kind=dp), intent(out), optional :: coeff_p logical, intent(out) :: has_p integer, intent(out) :: stat Called by proc~~parse_function_line~~CalledByGraph proc~parse_function_line parse_function_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~parse_function_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: temp_p Source Code pure subroutine parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) !! Parse function line (e.g., \"1 1.0 2.0\" or \"1 1.0 2.0 3.0\" for L shells) character ( len =* ), intent ( in ) :: line integer , intent ( out ) :: func_num real ( dp ), intent ( out ) :: exponent real ( dp ), intent ( out ) :: coeff_s real ( dp ), intent ( out ), optional :: coeff_p logical , intent ( out ) :: has_p integer , intent ( out ) :: stat real ( dp ) :: temp_p has_p = . false . ! Try to read 4 values (func_num, exponent, coeff_s, coeff_p) read ( line , * , iostat = stat ) func_num , exponent , coeff_s , temp_p if ( stat == 0 ) then ! Successfully read 4 values - this is an L shell has_p = . true . if ( present ( coeff_p )) coeff_p = temp_p else ! Try reading just 3 values (func_num, exponent, coeff_s) read ( line , * , iostat = stat ) func_num , exponent , coeff_s end if end subroutine parse_function_line","tags":"","url":"proc/parse_function_line.html"},{"title":"parse_shell_header – metalquicha","text":"private pure subroutine parse_shell_header(line, ang_mom, nfunc, stat) Parse shell header line (e.g., “S 2” or “L 3”) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(out) :: ang_mom integer, intent(out) :: nfunc integer, intent(out) :: stat Called by proc~~parse_shell_header~~CalledByGraph proc~parse_shell_header parse_shell_header proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~parse_shell_header proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: line_trim Source Code pure subroutine parse_shell_header ( line , ang_mom , nfunc , stat ) !! Parse shell header line (e.g., \"S 2\" or \"L 3\") character ( len =* ), intent ( in ) :: line character ( len = 1 ), intent ( out ) :: ang_mom integer , intent ( out ) :: nfunc integer , intent ( out ) :: stat character ( len = 256 ) :: line_trim line_trim = adjustl ( line ) ang_mom = line_trim ( 1 : 1 ) ! Read the number of functions read ( line_trim ( 2 :), * , iostat = stat ) nfunc end subroutine parse_shell_header","tags":"","url":"proc/parse_shell_header.html"},{"title":"method_type_from_string – metalquicha","text":"public pure function method_type_from_string(method_str) result(method_type) Convert method type string to integer constant Performs case-insensitive comparison and returns appropriate constant.\nReturns METHOD_TYPE_UNKNOWN for unrecognized strings. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Input string (e.g., “gfn1”, “gfn2”, “hf”) Return Value integer(kind=int32) Output integer constant Called by proc~~method_type_from_string~~CalledByGraph proc~method_type_from_string method_type_from_string proc~parse_method_string parse_method_string proc~parse_method_string->proc~method_type_from_string proc~parse_model_section parse_model_section proc~parse_model_section->proc~parse_method_string proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~parse_model_section program~main main program~main->proc~read_mqc_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=len_trim), private :: lower_str Source Code pure function method_type_from_string ( method_str ) result ( method_type ) !! Convert method type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns METHOD_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: method_str !! Input string (e.g., \"gfn1\", \"gfn2\", \"hf\") integer ( int32 ) :: method_type !! Output integer constant character ( len = len_trim ( method_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) case ( 'gfn1' ) method_type = METHOD_TYPE_GFN1 case ( 'gfn2' ) method_type = METHOD_TYPE_GFN2 case ( 'hf' ) method_type = METHOD_TYPE_HF case default method_type = METHOD_TYPE_UNKNOWN end select end function method_type_from_string","tags":"","url":"proc/method_type_from_string.html"},{"title":"method_type_to_string – metalquicha","text":"public pure function method_type_to_string(method_type) result(method_str) Convert method type integer constant to string Provides human-readable string representation of method type. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: method_type Input integer constant Return Value character(len=:), allocatable Output string representation Called by proc~~method_type_to_string~~CalledByGraph proc~method_type_to_string method_type_to_string proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~method_type_to_string proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->proc~method_type_to_string proc~hessian_worker hessian_worker proc~hessian_worker->proc~method_type_to_string proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_worker proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function method_type_to_string ( method_type ) result ( method_str ) !! Convert method type integer constant to string !! !! Provides human-readable string representation of method type. integer ( int32 ), intent ( in ) :: method_type !! Input integer constant character ( len = :), allocatable :: method_str !! Output string representation select case ( method_type ) case ( METHOD_TYPE_GFN1 ) method_str = \"gfn1\" case ( METHOD_TYPE_GFN2 ) method_str = \"gfn2\" case ( METHOD_TYPE_HF ) method_str = \"hf\" case default method_str = \"unknown\" end select end function method_type_to_string","tags":"","url":"proc/method_type_to_string.html"},{"title":"error_get_code – metalquicha","text":"private pure function error_get_code(this) result(code) Get the error code Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value integer Source Code pure function error_get_code ( this ) result ( code ) !! Get the error code class ( error_t ), intent ( in ) :: this integer :: code code = this % code end function error_get_code","tags":"","url":"proc/error_get_code.html"},{"title":"error_get_message – metalquicha","text":"private pure function error_get_message(this) result(message) Get the error message Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable Called by proc~~error_get_message~~CalledByGraph proc~error_get_message error_t%error_get_message proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~error_get_message proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~error_get_message program~main main program~main->proc~error_get_message program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function error_get_message ( this ) result ( message ) !! Get the error message class ( error_t ), intent ( in ) :: this character ( len = :), allocatable :: message if ( allocated ( this % message )) then message = this % message else message = \"\" end if end function error_get_message","tags":"","url":"proc/error_get_message.html"},{"title":"error_has_error – metalquicha","text":"private pure function error_has_error(this) result(has_err) Check if an error is set Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value logical Called by proc~~error_has_error~~CalledByGraph proc~error_has_error error_t%error_has_error proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~error_has_error proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~error_has_error proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->proc~error_has_error proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~error_has_error proc~parse_element_basis->proc~error_has_error proc~parse_fragment parse_fragment proc~parse_fragment->proc~error_has_error proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~parse_fragment proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~error_has_error proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_single_molecule->proc~error_has_error proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~error_has_error proc~read_mqc_file->proc~parse_molecules_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~error_has_error proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~error_has_error program~main->proc~config_to_system_geometry program~main->proc~read_mqc_file program~main->proc~run_multi_molecule_calculations proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_molecule_fragments->proc~parse_fragments_generic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function error_has_error ( this ) result ( has_err ) !! Check if an error is set class ( error_t ), intent ( in ) :: this logical :: has_err has_err = ( this % code /= SUCCESS ) end function error_has_error","tags":"","url":"proc/error_has_error.html"},{"title":"error_clear – metalquicha","text":"private pure subroutine error_clear(this) Clear the error state Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this Source Code pure subroutine error_clear ( this ) !! Clear the error state class ( error_t ), intent ( inout ) :: this this % code = SUCCESS if ( allocated ( this % message )) deallocate ( this % message ) end subroutine error_clear","tags":"","url":"proc/error_clear.html"},{"title":"error_set – metalquicha","text":"private pure subroutine error_set(this, code, message) Set an error with code and message Type Bound error_t Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this integer, intent(in) :: code character(len=*), intent(in) :: message Called by proc~~error_set~~CalledByGraph proc~error_set error_t%error_set proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~error_set proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->proc~error_set proc~config_to_system_geometry config_to_system_geometry proc~config_to_system_geometry->proc~error_set proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~error_set proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~error_set proc~find_basis_file find_basis_file proc~find_basis_file->proc~error_set proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~error_set proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~molecule_to_system_geometry->proc~error_set proc~initialize_fragmented_system initialize_fragmented_system proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~parse_command_line parse_command_line proc~parse_command_line->proc~error_set proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_generic->proc~error_set proc~skip_to_end skip_to_end proc~parse_connectivity_generic->proc~skip_to_end proc~parse_driver_section parse_driver_section proc~parse_driver_section->proc~error_set proc~parse_element_basis->proc~error_set proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~parse_fragment parse_fragment proc~parse_fragment->proc~error_set proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_fragmentation_section parse_fragmentation_section proc~parse_fragmentation_section->proc~error_set proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~parse_fragment proc~parse_fragments_generic->proc~skip_to_end proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_generic->proc~error_set proc~parse_indices_line->proc~error_set proc~parse_model_section parse_model_section proc~parse_model_section->proc~error_set proc~parse_molecules_section parse_molecules_section proc~parse_molecules_section->proc~error_set proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~skip_to_end proc~parse_scf_section parse_scf_section proc~parse_scf_section->proc~error_set proc~parse_schema_section parse_schema_section proc~parse_schema_section->proc~error_set proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic parse_structure_generic proc~parse_structure_generic->proc~error_set proc~parse_system_section parse_system_section proc~parse_system_section->proc~error_set proc~read_mqc_file read_mqc_file proc~read_mqc_file->proc~error_set proc~read_mqc_file->proc~parse_driver_section proc~read_mqc_file->proc~parse_fragmentation_section proc~read_mqc_file->proc~parse_model_section proc~read_mqc_file->proc~parse_molecules_section proc~read_mqc_file->proc~parse_scf_section proc~read_mqc_file->proc~parse_schema_section proc~read_mqc_file->proc~parse_system_section proc~read_mqc_file->proc~skip_to_end proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_geometry_section parse_geometry_section proc~read_mqc_file->proc~parse_geometry_section proc~parse_structure_section parse_structure_section proc~read_mqc_file->proc~parse_structure_section proc~read_xyz_file->proc~error_set proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~read_xyz_string->proc~error_set proc~skip_to_end->proc~error_set proc~initialize_fragmented_system->proc~check_fragment_overlap proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~config_to_system_geometry program~main main program~main->proc~config_to_system_geometry program~main->proc~read_mqc_file program~main->proc~run_multi_molecule_calculations proc~geometry_to_system_fragmented->proc~initialize_fragmented_system Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine error_set ( this , code , message ) !! Set an error with code and message class ( error_t ), intent ( inout ) :: this integer , intent ( in ) :: code character ( len =* ), intent ( in ) :: message this % code = code this % message = trim ( message ) end subroutine error_set","tags":"","url":"proc/error_set.html"},{"title":"find_fragment_intersection – metalquicha","text":"public  function find_fragment_intersection(frag1_atoms, n1, frag2_atoms, n2, intersection, n_intersect) result(has_intersection) Find shared atoms between two fragments (for GMBE with overlapping fragments) This function identifies atoms that appear in both fragments, which is essential\nfor computing intersection-corrected energies in GMBE. Algorithm: O(n1 * n2) brute-force comparison\n- Loop through all atoms in fragment 1\n- For each atom, check if it appears in fragment 2\n- Collect all shared atoms Returns:\n  .true. if fragments share at least one atom, .false. otherwise Output:\n  intersection - allocatable array containing shared atom indices\n  n_intersect - number of shared atoms Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag1_atoms (:) Atom indices in fragment 1 (0-indexed) integer, intent(in) :: n1 Number of atoms in fragment 1 integer, intent(in) :: frag2_atoms (:) Atom indices in fragment 2 (0-indexed) integer, intent(in) :: n2 Number of atoms in fragment 2 integer, intent(out), allocatable :: intersection (:) Shared atom indices integer, intent(out) :: n_intersect Number of shared atoms Return Value logical Called by proc~~find_fragment_intersection~~CalledByGraph proc~find_fragment_intersection find_fragment_intersection proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->proc~find_fragment_intersection proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: temp_count integer, private, allocatable :: temp_intersection (:) Source Code function find_fragment_intersection ( frag1_atoms , n1 , frag2_atoms , n2 , & intersection , n_intersect ) result ( has_intersection ) !! Find shared atoms between two fragments (for GMBE with overlapping fragments) !! !! This function identifies atoms that appear in both fragments, which is essential !! for computing intersection-corrected energies in GMBE. !! !! Algorithm: O(n1 * n2) brute-force comparison !! - Loop through all atoms in fragment 1 !! - For each atom, check if it appears in fragment 2 !! - Collect all shared atoms !! !! Returns: !!   .true. if fragments share at least one atom, .false. otherwise !! !! Output: !!   intersection - allocatable array containing shared atom indices !!   n_intersect - number of shared atoms integer , intent ( in ) :: frag1_atoms (:) !! Atom indices in fragment 1 (0-indexed) integer , intent ( in ) :: n1 !! Number of atoms in fragment 1 integer , intent ( in ) :: frag2_atoms (:) !! Atom indices in fragment 2 (0-indexed) integer , intent ( in ) :: n2 !! Number of atoms in fragment 2 integer , allocatable , intent ( out ) :: intersection (:) !! Shared atom indices integer , intent ( out ) :: n_intersect !! Number of shared atoms logical :: has_intersection integer :: i , j integer , allocatable :: temp_intersection (:) integer :: temp_count ! Allocate temporary array (max possible size is min(n1, n2)) allocate ( temp_intersection ( min ( n1 , n2 ))) temp_count = 0 ! Find all shared atoms do i = 1 , n1 do j = 1 , n2 if ( frag1_atoms ( i ) == frag2_atoms ( j )) then ! Found a shared atom temp_count = temp_count + 1 temp_intersection ( temp_count ) = frag1_atoms ( i ) exit ! Move to next atom in frag1 end if end do end do ! Set output n_intersect = temp_count has_intersection = ( temp_count > 0 ) ! Allocate and copy result if intersection exists if ( has_intersection ) then allocate ( intersection ( n_intersect )) intersection = temp_intersection ( 1 : n_intersect ) end if deallocate ( temp_intersection ) end function find_fragment_intersection","tags":"","url":"proc/find_fragment_intersection.html"},{"title":"atom_sets_equal – metalquicha","text":"private  function atom_sets_equal(set1, set2, n_atoms) result(equal) Check if two atom sets are equal (assuming sorted) Arguments Type Intent Optional Attributes Name integer, intent(in) :: set1 (:) integer, intent(in) :: set2 (:) integer, intent(in) :: n_atoms Return Value logical Called by proc~~atom_sets_equal~~CalledByGraph proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~atom_sets_equal proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code function atom_sets_equal ( set1 , set2 , n_atoms ) result ( equal ) !! Check if two atom sets are equal (assuming sorted) integer , intent ( in ) :: set1 (:), set2 (:) integer , intent ( in ) :: n_atoms logical :: equal integer :: i equal = . true . do i = 1 , n_atoms if ( set1 ( i ) /= set2 ( i )) then equal = . false . return end if end do end function atom_sets_equal","tags":"","url":"proc/atom_sets_equal.html"},{"title":"next_combination – metalquicha","text":"private  function next_combination(combination, k, n) result(has_next) Generate next combination in lexicographic order\nReturns .true. if there’s a next combination, .false. if we’ve exhausted all Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k integer, intent(in) :: n Return Value logical Called by proc~~next_combination~2~~CalledByGraph proc~next_combination~2 next_combination proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->proc~next_combination~2 proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_k_way_intersections_from_lists->proc~next_combination~2 proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code function next_combination ( combination , k , n ) result ( has_next ) !! Generate next combination in lexicographic order !! Returns .true. if there's a next combination, .false. if we've exhausted all integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k , n logical :: has_next integer :: i has_next = . true . ! Find the rightmost element that can be incremented i = k do while ( i >= 1 ) if ( combination ( i ) < n - k + i ) then combination ( i ) = combination ( i ) + 1 ! Reset all elements to the right do while ( i < k ) i = i + 1 combination ( i ) = combination ( i - 1 ) + 1 end do return end if i = i - 1 end do ! No more combinations has_next = . false . end function next_combination","tags":"","url":"proc/next_combination~2.html"},{"title":"compute_polymer_atoms – metalquicha","text":"public  subroutine compute_polymer_atoms(sys_geom, polymer, polymer_size, atom_list, n_atoms) Uses mqc_physical_fragment proc~~compute_polymer_atoms~~UsesGraph proc~compute_polymer_atoms compute_polymer_atoms module~mqc_physical_fragment mqc_physical_fragment proc~compute_polymer_atoms->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute the atom list for a polymer (union of atoms from base fragments)\npolymer(:) contains base fragment indices (1-based) Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymer (:) Base fragment indices in this polymer integer, intent(in) :: polymer_size Number of base fragments in polymer integer, intent(out), allocatable :: atom_list (:) Unique atoms in this polymer integer, intent(out) :: n_atoms Number of unique atoms Called by proc~~compute_polymer_atoms~~CalledByGraph proc~compute_polymer_atoms compute_polymer_atoms proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~compute_polymer_atoms proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: already_present integer, private :: frag_idx integer, private :: frag_size integer, private :: i integer, private :: j integer, private, allocatable :: temp_atoms (:) integer, private :: temp_count Source Code subroutine compute_polymer_atoms ( sys_geom , polymer , polymer_size , atom_list , n_atoms ) !! Compute the atom list for a polymer (union of atoms from base fragments) !! polymer(:) contains base fragment indices (1-based) use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymer (:) !! Base fragment indices in this polymer integer , intent ( in ) :: polymer_size !! Number of base fragments in polymer integer , allocatable , intent ( out ) :: atom_list (:) !! Unique atoms in this polymer integer , intent ( out ) :: n_atoms !! Number of unique atoms integer , allocatable :: temp_atoms (:) integer :: i , j , frag_idx , frag_size , temp_count logical :: already_present ! Allocate temporary array (worst case: all atoms from all fragments) allocate ( temp_atoms ( sys_geom % total_atoms )) temp_count = 0 ! Loop through each base fragment in the polymer do i = 1 , polymer_size frag_idx = polymer ( i ) if ( frag_idx == 0 ) exit ! Padding zeros frag_size = sys_geom % fragment_sizes ( frag_idx ) ! Add each atom from this fragment (avoid duplicates) do j = 1 , frag_size already_present = . false . ! Check if this atom is already in our list block integer :: k , current_atom current_atom = sys_geom % fragment_atoms ( j , frag_idx ) do k = 1 , temp_count if ( temp_atoms ( k ) == current_atom ) then already_present = . true . exit end if end do end block ! Add if not already present if (. not . already_present ) then temp_count = temp_count + 1 temp_atoms ( temp_count ) = sys_geom % fragment_atoms ( j , frag_idx ) end if end do end do ! Copy to output array n_atoms = temp_count allocate ( atom_list ( n_atoms )) atom_list = temp_atoms ( 1 : n_atoms ) deallocate ( temp_atoms ) end subroutine compute_polymer_atoms","tags":"","url":"proc/compute_polymer_atoms.html"},{"title":"generate_intersections – metalquicha","text":"public  subroutine generate_intersections(sys_geom, monomers, polymers, n_monomers, max_intersection_level, intersections, intersection_sets, intersection_levels, n_intersections) Uses mqc_physical_fragment proc~~generate_intersections~~UsesGraph proc~generate_intersections generate_intersections module~mqc_physical_fragment mqc_physical_fragment proc~generate_intersections->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) For a system with overlapping fragments, this computes k-way intersections\nfollowing the inclusion-exclusion principle for GMBE.\nThe max_intersection_level parameter controls the maximum depth to avoid combinatorial explosion. Algorithm:\n- For each k from 2 to min(max_intersection_level, n_monomers):\n  - Generate all C(n_monomers, k) combinations\n  - For each combination, compute intersection of all k fragments\n  - Store non-empty intersections with their level k Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) Monomer indices integer, intent(inout) :: polymers (:,:) Output: monomers stored here integer, intent(in) :: n_monomers Number of monomers integer, intent(in) :: max_intersection_level Maximum k-way intersection depth integer, intent(out), allocatable :: intersections (:,:) Intersection atom lists integer, intent(out), allocatable :: intersection_sets (:,:) Which k-tuple created each intersection integer, intent(out), allocatable :: intersection_levels (:) Level (k) of each intersection integer, intent(out) :: n_intersections Number of intersections found Calls proc~~generate_intersections~~CallsGraph proc~generate_intersections generate_intersections info info proc~generate_intersections->info proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_intersections->proc~generate_k_way_intersections_for_level to_char to_char proc~generate_intersections->to_char proc~find_fragment_intersection find_fragment_intersection proc~generate_k_way_intersections_for_level->proc~find_fragment_intersection proc~next_combination_init~2 next_combination_init proc~generate_k_way_intersections_for_level->proc~next_combination_init~2 proc~next_combination~2 next_combination proc~generate_k_way_intersections_for_level->proc~next_combination~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: combination (:) integer, private, allocatable :: current_intersection (:) integer, private :: current_n_intersect logical, private :: has_intersection integer, private :: i integer, private :: idx integer, private :: intersection_count integer, private :: k integer, private :: max_atoms integer, private :: max_intersections integer, private :: max_k_level integer, private, allocatable :: temp_intersection (:) integer, private, allocatable :: temp_intersections (:,:) integer, private, allocatable :: temp_levels (:) integer, private :: temp_n_intersect integer, private, allocatable :: temp_sets (:,:) Source Code subroutine generate_intersections ( sys_geom , monomers , polymers , n_monomers , max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) !! !! For a system with overlapping fragments, this computes k-way intersections !! following the inclusion-exclusion principle for GMBE. !! The max_intersection_level parameter controls the maximum depth to avoid combinatorial explosion. !! !! Algorithm: !! - For each k from 2 to min(max_intersection_level, n_monomers): !!   - Generate all C(n_monomers, k) combinations !!   - For each combination, compute intersection of all k fragments !!   - Store non-empty intersections with their level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:) !! Monomer indices integer , intent ( inout ) :: polymers (:, :) !! Output: monomers stored here integer , intent ( in ) :: n_monomers !! Number of monomers integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth integer , allocatable , intent ( out ) :: intersections (:, :) !! Intersection atom lists integer , allocatable , intent ( out ) :: intersection_sets (:, :) !! Which k-tuple created each intersection integer , allocatable , intent ( out ) :: intersection_levels (:) !! Level (k) of each intersection integer , intent ( out ) :: n_intersections !! Number of intersections found ! Temporaries for storing intersections integer , allocatable :: temp_intersections (:, :) integer , allocatable :: temp_sets (:, :) integer , allocatable :: temp_levels (:) integer , allocatable :: temp_intersection (:) integer , allocatable :: current_intersection (:) integer :: temp_n_intersect , current_n_intersect logical :: has_intersection integer :: k , intersection_count , max_atoms , max_intersections , max_k_level integer :: i , idx integer , allocatable :: combination (:) ! Store monomers in polymers array polymers ( 1 : n_monomers , 1 ) = monomers ( 1 : n_monomers ) if ( n_monomers < 2 ) then n_intersections = 0 return end if ! Count maximum possible intersections: sum of C(n,k) for k=2 to n ! For small n, this is 2&#94;n - n - 1 max_intersections = 2 ** n_monomers - n_monomers - 1 ! Find maximum atoms in any fragment for allocation max_atoms = maxval ( sys_geom % fragment_sizes ( 1 : n_monomers )) ! Allocate temporary arrays allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_monomers , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 ! Determine actual maximum intersection level to use max_k_level = min ( max_intersection_level , n_monomers ) if ( max_k_level < n_monomers ) then call logger % info ( \"Generating k-way intersections up to k=\" // to_char ( max_k_level ) // & \" (limited by max_intersection_level)\" ) else call logger % info ( \"Generating all k-way intersections for GMBE (inclusion-exclusion principle)\" ) end if ! Loop over intersection levels k from 2 to max_k_level do k = 2 , max_k_level ! Generate all C(n_monomers, k) combinations allocate ( combination ( k )) call generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_monomers , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_monomers , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , max_k_level idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else call logger % info ( \"No intersections found (fragments are non-overlapping)\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections","tags":"","url":"proc/generate_intersections.html"},{"title":"generate_polymer_intersections – metalquicha","text":"public  subroutine generate_polymer_intersections(sys_geom, polymers, n_polymers, max_level, intersections, intersection_sets, intersection_levels, n_intersections) Uses mqc_physical_fragment pic_logger pic_io proc~~generate_polymer_intersections~~UsesGraph proc~generate_polymer_intersections generate_polymer_intersections module~mqc_physical_fragment mqc_physical_fragment proc~generate_polymer_intersections->module~mqc_physical_fragment pic_io pic_io proc~generate_polymer_intersections->pic_io pic_logger pic_logger proc~generate_polymer_intersections->pic_logger module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate all k-way intersections for polymers at any level (GMBE-N)\nThis works with dynamically generated polymers, not just base fragments Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymers (:,:) Polymer definitions (n_polymers, max_level) integer, intent(in) :: n_polymers integer, intent(in) :: max_level integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections Calls proc~~generate_polymer_intersections~~CallsGraph proc~generate_polymer_intersections generate_polymer_intersections atom_list atom_list proc~generate_polymer_intersections->atom_list info info proc~generate_polymer_intersections->info proc~compute_polymer_atoms compute_polymer_atoms proc~generate_polymer_intersections->proc~compute_polymer_atoms proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists to_char to_char proc~generate_polymer_intersections->to_char proc~generate_intersections_from_atom_lists->info proc~generate_intersections_from_atom_lists->to_char proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~next_combination_init~2 next_combination_init proc~generate_k_way_intersections_from_lists->proc~next_combination_init~2 proc~next_combination~2 next_combination proc~generate_k_way_intersections_from_lists->proc~next_combination~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: max_atoms_per_polymer integer, private :: max_intersection_level integer, private, allocatable :: polymer_atoms (:,:) Atom lists for each polymer integer, private, allocatable :: polymer_n_atoms (:) Number of atoms in each polymer integer, private :: polymer_size Source Code subroutine generate_polymer_intersections ( sys_geom , polymers , n_polymers , max_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for polymers at any level (GMBE-N) !! This works with dynamically generated polymers, not just base fragments use mqc_physical_fragment , only : system_geometry_t use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymers (:, :) !! Polymer definitions (n_polymers, max_level) integer , intent ( in ) :: n_polymers , max_level integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer , allocatable :: polymer_atoms (:, :) !! Atom lists for each polymer integer , allocatable :: polymer_n_atoms (:) !! Number of atoms in each polymer integer :: max_atoms_per_polymer integer :: i , polymer_size , max_intersection_level call logger % info ( \"Computing atom compositions for \" // to_char ( n_polymers ) // \" polymers...\" ) ! First, compute atom list for each polymer ! Find max atoms needed max_atoms_per_polymer = 0 do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) ! Worst case: all atoms from all fragments in this polymer max_atoms_per_polymer = max ( max_atoms_per_polymer , polymer_size * maxval ( sys_geom % fragment_sizes )) end do allocate ( polymer_atoms ( max_atoms_per_polymer , n_polymers )) allocate ( polymer_n_atoms ( n_polymers )) polymer_atoms = 0 ! Compute atoms for each polymer do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , polymers ( i , 1 : polymer_size ), polymer_size , atom_list , n_atoms ) polymer_n_atoms ( i ) = n_atoms polymer_atoms ( 1 : n_atoms , i ) = atom_list deallocate ( atom_list ) end block end do call logger % info ( \"Finding intersections between polymers...\" ) ! For GMBE(N), limit intersections to level N+1 to prevent combinatorial explosion ! GMBE(2): dimers → 3-way intersections max ! GMBE(3): trimers → 4-way intersections max max_intersection_level = max_level + 1 call logger % info ( \"Limiting intersections to level \" // to_char ( max_intersection_level ) // & \" (polymer level \" // to_char ( max_level ) // \" + 1)\" ) ! Now generate intersections between these polymer atom sets call generate_intersections_from_atom_lists ( polymer_atoms , polymer_n_atoms , n_polymers , & max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) deallocate ( polymer_atoms , polymer_n_atoms ) end subroutine generate_polymer_intersections","tags":"","url":"proc/generate_polymer_intersections.html"},{"title":"gmbe_enumerate_pie_terms – metalquicha","text":"public  subroutine gmbe_enumerate_pie_terms(sys_geom, primaries, n_primaries, polymer_level, max_k_level, pie_atom_sets, pie_coefficients, n_pie_terms) Uses mqc_physical_fragment proc~~gmbe_enumerate_pie_terms~~UsesGraph proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms module~mqc_physical_fragment mqc_physical_fragment proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Enumerate all unique intersections via DFS and accumulate PIE coefficients\nThis implements the GMBE(N) algorithm with inclusion-exclusion principle Algorithm:\n1. For each primary i, start DFS with clique=[i]\n2. Recursively grow cliques by adding overlapping primaries\n3. For each clique of size k, compute intersection and add PIE coefficient:\n   coefficient = (+1) if k odd, (-1) if k even\n4. Accumulate coefficients for each unique atom set Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: primaries (:,:) Primary polymers (n_primaries, polymer_level) integer, intent(in) :: n_primaries Number of primary polymers integer, intent(in) :: polymer_level Level of primaries (1=monomers, 2=dimers, etc.) integer, intent(in) :: max_k_level Maximum clique size (intersection depth limit) integer, intent(out), allocatable :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_terms) integer, intent(out), allocatable :: pie_coefficients (:) PIE coefficient for each term integer, intent(out) :: n_pie_terms Number of unique PIE terms Calls proc~~gmbe_enumerate_pie_terms~~CallsGraph proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list info info proc~gmbe_enumerate_pie_terms->info proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate to_char to_char proc~gmbe_enumerate_pie_terms->to_char proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~dfs_pie_accumulate->to_char error error proc~dfs_pie_accumulate->error new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gmbe_enumerate_pie_terms~~CalledByGraph proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_PIE_TERMS = 100000 integer, private, allocatable :: candidates (:) Candidate primaries to add integer, private, allocatable :: clique (:) Current clique being built integer, private, allocatable :: current_atoms (:) Current intersection atoms integer, private :: i integer, private :: j integer, private :: max_atoms integer, private :: n_candidates integer, private, allocatable :: primary_atoms (:,:) Precomputed atom lists for each primary integer, private, allocatable :: primary_n_atoms (:) Atom counts for each primary integer, private, allocatable :: temp_atom_sets (:,:) integer, private, allocatable :: temp_coefficients (:) Source Code subroutine gmbe_enumerate_pie_terms ( sys_geom , primaries , n_primaries , polymer_level , max_k_level , & pie_atom_sets , pie_coefficients , n_pie_terms ) !! Enumerate all unique intersections via DFS and accumulate PIE coefficients !! This implements the GMBE(N) algorithm with inclusion-exclusion principle !! !! Algorithm: !! 1. For each primary i, start DFS with clique=[i] !! 2. Recursively grow cliques by adding overlapping primaries !! 3. For each clique of size k, compute intersection and add PIE coefficient: !!    coefficient = (+1) if k odd, (-1) if k even !! 4. Accumulate coefficients for each unique atom set use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: primaries (:, :) !! Primary polymers (n_primaries, polymer_level) integer , intent ( in ) :: n_primaries !! Number of primary polymers integer , intent ( in ) :: polymer_level !! Level of primaries (1=monomers, 2=dimers, etc.) integer , intent ( in ) :: max_k_level !! Maximum clique size (intersection depth limit) integer , allocatable , intent ( out ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_terms) integer , allocatable , intent ( out ) :: pie_coefficients (:) !! PIE coefficient for each term integer , intent ( out ) :: n_pie_terms !! Number of unique PIE terms ! Temporary storage for PIE terms (allocate generously) integer , parameter :: MAX_PIE_TERMS = 100000 ! Adjust if needed integer , allocatable :: temp_atom_sets (:, :) integer , allocatable :: temp_coefficients (:) integer , allocatable :: primary_atoms (:, :) !! Precomputed atom lists for each primary integer , allocatable :: primary_n_atoms (:) !! Atom counts for each primary integer , allocatable :: clique (:) !! Current clique being built integer , allocatable :: current_atoms (:) !! Current intersection atoms integer , allocatable :: candidates (:) !! Candidate primaries to add integer :: i , j , max_atoms , n_candidates call logger % info ( \"Enumerating GMBE PIE terms via DFS...\" ) ! Find maximum atoms in any fragment max_atoms = sys_geom % total_atoms ! Allocate temporary storage allocate ( temp_atom_sets ( max_atoms , MAX_PIE_TERMS )) allocate ( temp_coefficients ( MAX_PIE_TERMS )) temp_atom_sets = - 1 temp_coefficients = 0 n_pie_terms = 0 ! Precompute atom lists for all primaries allocate ( primary_atoms ( max_atoms , n_primaries )) allocate ( primary_n_atoms ( n_primaries )) primary_atoms = - 1 do i = 1 , n_primaries block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , primaries ( i , :), polymer_level , atom_list , n_atoms ) primary_n_atoms ( i ) = n_atoms primary_atoms ( 1 : n_atoms , i ) = atom_list ( 1 : n_atoms ) deallocate ( atom_list ) end block end do ! Allocate work arrays allocate ( clique ( max_k_level )) allocate ( current_atoms ( max_atoms )) allocate ( candidates ( n_primaries )) ! Start DFS from each primary do i = 1 , n_primaries ! Initial clique: just primary i clique ( 1 ) = i current_atoms ( 1 : primary_n_atoms ( i )) = primary_atoms ( 1 : primary_n_atoms ( i ), i ) ! Candidates: all primaries after i (to avoid duplicates) n_candidates = n_primaries - i if ( n_candidates > 0 ) then candidates ( 1 : n_candidates ) = [( i + j , j = 1 , n_candidates )] end if ! DFS from this primary call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , 1 , current_atoms ( 1 : primary_n_atoms ( i )), primary_n_atoms ( i ), & candidates , n_candidates , max_k_level , & temp_atom_sets , temp_coefficients , n_pie_terms , MAX_PIE_TERMS ) end do ! Copy to output arrays if ( n_pie_terms > 0 ) then allocate ( pie_atom_sets ( max_atoms , n_pie_terms )) allocate ( pie_coefficients ( n_pie_terms )) pie_atom_sets = temp_atom_sets (:, 1 : n_pie_terms ) pie_coefficients = temp_coefficients ( 1 : n_pie_terms ) end if call logger % info ( \"Generated \" // to_char ( n_pie_terms ) // \" unique PIE terms\" ) ! Cleanup deallocate ( temp_atom_sets , temp_coefficients , primary_atoms , primary_n_atoms ) deallocate ( clique , current_atoms , candidates ) end subroutine gmbe_enumerate_pie_terms","tags":"","url":"proc/gmbe_enumerate_pie_terms.html"},{"title":"dfs_pie_accumulate – metalquicha","text":"private recursive subroutine dfs_pie_accumulate(primary_atoms, primary_n_atoms, n_primaries, max_atoms, clique, clique_size, current_atoms, n_current_atoms, candidates, n_candidates, max_k_level, atom_sets, coefficients, n_terms, max_terms) DFS helper: accumulate PIE coefficients for intersections Arguments Type Intent Optional Attributes Name integer, intent(in) :: primary_atoms (:,:) Precomputed atom lists integer, intent(in) :: primary_n_atoms (:) Atom counts integer, intent(in) :: n_primaries integer, intent(in) :: max_atoms integer, intent(in) :: clique (:) Current clique integer, intent(in) :: clique_size Size of current clique integer, intent(in) :: current_atoms (:) Atoms in current intersection integer, intent(in) :: n_current_atoms Number of atoms in intersection integer, intent(in) :: candidates (:) Candidate primaries integer, intent(in) :: n_candidates integer, intent(in) :: max_k_level integer, intent(inout) :: atom_sets (:,:) integer, intent(inout) :: coefficients (:) integer, intent(inout) :: n_terms integer, intent(in) :: max_terms Calls proc~~dfs_pie_accumulate~~CallsGraph proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~dfs_pie_accumulate error error proc~dfs_pie_accumulate->error new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect to_char to_char proc~dfs_pie_accumulate->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dfs_pie_accumulate~~CalledByGraph proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: candidate_idx logical, private :: found integer, private :: i integer, private :: n_new_atoms integer, private :: n_new_candidates integer, private, allocatable :: new_atoms (:) integer, private, allocatable :: new_candidates (:) integer, private :: sign integer, private :: term_idx Source Code recursive subroutine dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , clique_size , current_atoms , n_current_atoms , & candidates , n_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms ) !! DFS helper: accumulate PIE coefficients for intersections integer , intent ( in ) :: primary_atoms (:, :) !! Precomputed atom lists integer , intent ( in ) :: primary_n_atoms (:) !! Atom counts integer , intent ( in ) :: n_primaries , max_atoms integer , intent ( in ) :: clique (:) !! Current clique integer , intent ( in ) :: clique_size !! Size of current clique integer , intent ( in ) :: current_atoms (:) !! Atoms in current intersection integer , intent ( in ) :: n_current_atoms !! Number of atoms in intersection integer , intent ( in ) :: candidates (:) !! Candidate primaries integer , intent ( in ) :: n_candidates integer , intent ( in ) :: max_k_level integer , intent ( inout ) :: atom_sets (:, :) integer , intent ( inout ) :: coefficients (:) integer , intent ( inout ) :: n_terms integer , intent ( in ) :: max_terms integer :: sign , term_idx , i , candidate_idx integer , allocatable :: new_atoms (:), new_candidates (:) integer :: n_new_atoms , n_new_candidates logical :: found ! Skip empty intersections if ( n_current_atoms == 0 ) return ! Compute PIE sign: (+1) for odd clique size, (-1) for even sign = merge ( 1 , - 1 , mod ( clique_size , 2 ) == 1 ) ! Find or create entry for this atom set found = . false . do i = 1 , n_terms if ( atom_sets_equal ( atom_sets (:, i ), current_atoms , n_current_atoms )) then coefficients ( i ) = coefficients ( i ) + sign found = . true . exit end if end do if (. not . found ) then ! New atom set if ( n_terms >= max_terms ) then call logger % error ( \"Exceeded maximum PIE terms (\" // to_char ( max_terms ) // \")\" ) return end if n_terms = n_terms + 1 atom_sets ( 1 : n_current_atoms , n_terms ) = current_atoms ( 1 : n_current_atoms ) atom_sets ( n_current_atoms + 1 :, n_terms ) = - 1 coefficients ( n_terms ) = sign end if ! Stop if we've reached maximum clique size if ( clique_size >= max_k_level ) return if ( n_candidates == 0 ) return ! Try adding each candidate to the clique allocate ( new_atoms ( max_atoms )) allocate ( new_candidates ( n_primaries )) do i = 1 , n_candidates candidate_idx = candidates ( i ) ! Compute intersection with this candidate call intersect_atom_lists ( current_atoms , n_current_atoms , & primary_atoms (:, candidate_idx ), primary_n_atoms ( candidate_idx ), & new_atoms , n_new_atoms ) ! Skip if no intersection if ( n_new_atoms == 0 ) cycle ! New candidates: must come after this one and overlap with new_atoms n_new_candidates = 0 do term_idx = i + 1 , n_candidates block integer :: test_candidate , test_n_intersect integer , allocatable :: test_intersect (:) test_candidate = candidates ( term_idx ) allocate ( test_intersect ( max_atoms )) call intersect_atom_lists ( new_atoms , n_new_atoms , & primary_atoms (:, test_candidate ), primary_n_atoms ( test_candidate ), & test_intersect , test_n_intersect ) if ( test_n_intersect > 0 ) then n_new_candidates = n_new_candidates + 1 new_candidates ( n_new_candidates ) = test_candidate end if deallocate ( test_intersect ) end block end do ! Recurse block integer :: new_clique ( clique_size + 1 ) new_clique ( 1 : clique_size ) = clique ( 1 : clique_size ) new_clique ( clique_size + 1 ) = candidate_idx call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & new_clique , clique_size + 1 , new_atoms , n_new_atoms , & new_candidates , n_new_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms ) end block end do deallocate ( new_atoms , new_candidates ) end subroutine dfs_pie_accumulate","tags":"","url":"proc/dfs_pie_accumulate.html"},{"title":"generate_intersections_from_atom_lists – metalquicha","text":"private  subroutine generate_intersections_from_atom_lists(atom_lists, n_atoms_list, n_sets, max_k_level, intersections, intersection_sets, intersection_levels, n_intersections) Uses pic_logger pic_io proc~~generate_intersections_from_atom_lists~~UsesGraph proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists pic_io pic_io proc~generate_intersections_from_atom_lists->pic_io pic_logger pic_logger proc~generate_intersections_from_atom_lists->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Generate k-way intersections from arbitrary atom lists (not tied to sys_geom)\nmax_k_level limits the maximum intersection order to prevent combinatorial explosion Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) (max_atoms, n_sets) integer, intent(in) :: n_atoms_list (:) Number of atoms in each set integer, intent(in) :: n_sets Number of sets (polymers) integer, intent(in) :: max_k_level Maximum intersection level to compute integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections Calls proc~~generate_intersections_from_atom_lists~~CallsGraph proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists info info proc~generate_intersections_from_atom_lists->info proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists to_char to_char proc~generate_intersections_from_atom_lists->to_char proc~next_combination_init~2 next_combination_init proc~generate_k_way_intersections_from_lists->proc~next_combination_init~2 proc~next_combination~2 next_combination proc~generate_k_way_intersections_from_lists->proc~next_combination~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_intersections_from_atom_lists~~CalledByGraph proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: actual_max_k integer, private, allocatable :: combination (:) integer, private :: idx integer, private :: intersection_count integer, private :: k integer, private :: max_atoms integer, private :: max_intersections integer, private, allocatable :: temp_intersections (:,:) integer, private, allocatable :: temp_levels (:) integer, private, allocatable :: temp_sets (:,:) Source Code subroutine generate_intersections_from_atom_lists ( atom_lists , n_atoms_list , n_sets , max_k_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate k-way intersections from arbitrary atom lists (not tied to sys_geom) !! max_k_level limits the maximum intersection order to prevent combinatorial explosion use pic_logger , only : logger => global_logger use pic_io , only : to_char integer , intent ( in ) :: atom_lists (:, :) !! (max_atoms, n_sets) integer , intent ( in ) :: n_atoms_list (:) !! Number of atoms in each set integer , intent ( in ) :: n_sets !! Number of sets (polymers) integer , intent ( in ) :: max_k_level !! Maximum intersection level to compute integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer :: max_intersections , max_atoms integer , allocatable :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer :: intersection_count , k , idx , actual_max_k integer , allocatable :: combination (:) if ( n_sets < 2 ) then n_intersections = 0 return end if ! Limit k-way intersections to min(max_k_level, n_sets) actual_max_k = min ( max_k_level , n_sets ) max_intersections = 2 ** n_sets - n_sets - 1 max_atoms = maxval ( n_atoms_list ) allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_sets , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 call logger % info ( \"Generating k-way intersections (k=2 to \" // to_char ( actual_max_k ) // \")\" ) ! Loop over intersection levels k from 2 to actual_max_k do k = 2 , actual_max_k allocate ( combination ( k )) call generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_sets , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_sets , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , actual_max_k idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else allocate ( intersections ( 1 , 0 )) allocate ( intersection_sets ( 1 , 0 )) allocate ( intersection_levels ( 0 )) call logger % info ( \"No intersections found\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections_from_atom_lists","tags":"","url":"proc/generate_intersections_from_atom_lists.html"},{"title":"generate_k_way_intersections_for_level – metalquicha","text":"private recursive subroutine generate_k_way_intersections_for_level(sys_geom, monomers, n_monomers, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Uses mqc_physical_fragment proc~~generate_k_way_intersections_for_level~~UsesGraph proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level module~mqc_physical_fragment mqc_physical_fragment proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Helper to generate all k-way intersections at a specific level k Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count Calls proc~~generate_k_way_intersections_for_level~~CallsGraph proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~find_fragment_intersection find_fragment_intersection proc~generate_k_way_intersections_for_level->proc~find_fragment_intersection proc~next_combination_init~2 next_combination_init proc~generate_k_way_intersections_for_level->proc~next_combination_init~2 proc~next_combination~2 next_combination proc~generate_k_way_intersections_for_level->proc~next_combination~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_k_way_intersections_for_level~~CalledByGraph proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: current_intersection (:) integer, private :: current_n_intersect integer, private :: frag_size logical, private :: has_intersection integer, private :: i integer, private :: j integer, private :: mono_idx integer, private, allocatable :: temp_intersection (:) integer, private :: temp_n_intersect Source Code recursive subroutine generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Helper to generate all k-way intersections at a specific level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:), n_monomers , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , mono_idx , frag_size logical :: has_intersection ! Generate combinations using an iterative approach call next_combination_init ( combination , k ) do ! Compute intersection of all fragments in this combination has_intersection = . false . ! Start with the first fragment in the combination mono_idx = monomers ( combination ( 1 )) frag_size = sys_geom % fragment_sizes ( mono_idx ) allocate ( current_intersection ( frag_size )) current_intersection = sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ) current_n_intersect = frag_size ! Intersect with each subsequent fragment do i = 2 , k mono_idx = monomers ( combination ( i )) frag_size = sys_geom % fragment_sizes ( mono_idx ) has_intersection = find_fragment_intersection ( & current_intersection , current_n_intersect , & sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ), frag_size , & temp_intersection , temp_n_intersect ) if (. not . has_intersection ) then ! Intersection is empty, break early deallocate ( current_intersection ) if ( allocated ( temp_intersection )) deallocate ( temp_intersection ) exit end if ! Replace current_intersection with the new intersection deallocate ( current_intersection ) allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection current_n_intersect = temp_n_intersect deallocate ( temp_intersection ) end do ! If we have a non-empty intersection, store it if ( has_intersection . and . allocated ( current_intersection )) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection temp_sets ( 1 : k , intersection_count ) = monomers ( combination ) temp_levels ( intersection_count ) = k deallocate ( current_intersection ) end if ! Get next combination if (. not . next_combination ( combination , k , n_monomers )) exit end do end subroutine generate_k_way_intersections_for_level","tags":"","url":"proc/generate_k_way_intersections_for_level.html"},{"title":"generate_k_way_intersections_from_lists – metalquicha","text":"private  subroutine generate_k_way_intersections_from_lists(atom_lists, n_atoms_list, n_sets, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Generate all k-way intersections from atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) integer, intent(in) :: n_atoms_list (:) integer, intent(in) :: n_sets integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count Calls proc~~generate_k_way_intersections_from_lists~~CallsGraph proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~next_combination_init~2 next_combination_init proc~generate_k_way_intersections_from_lists->proc~next_combination_init~2 proc~next_combination~2 next_combination proc~generate_k_way_intersections_from_lists->proc~next_combination~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_k_way_intersections_from_lists~~CalledByGraph proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: current_intersection (:) integer, private :: current_n_intersect logical, private :: has_intersection integer, private :: i integer, private :: j integer, private :: set_idx integer, private, allocatable :: temp_intersection (:) integer, private :: temp_n_intersect Source Code subroutine generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Generate all k-way intersections from atom lists integer , intent ( in ) :: atom_lists (:, :), n_atoms_list (:), n_sets , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , set_idx logical :: has_intersection call next_combination_init ( combination , k ) do ! Compute intersection of all sets in this combination has_intersection = . false . ! Start with the first set in the combination set_idx = combination ( 1 ) allocate ( current_intersection ( n_atoms_list ( set_idx ))) current_intersection = atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) current_n_intersect = n_atoms_list ( set_idx ) ! Intersect with each subsequent set do i = 2 , k set_idx = combination ( i ) allocate ( temp_intersection ( current_n_intersect )) ! Find intersection temp_n_intersect = 0 do j = 1 , current_n_intersect if ( any ( atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) == current_intersection ( j ))) then temp_n_intersect = temp_n_intersect + 1 temp_intersection ( temp_n_intersect ) = current_intersection ( j ) end if end do ! Update current intersection deallocate ( current_intersection ) if ( temp_n_intersect > 0 ) then allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection ( 1 : temp_n_intersect ) current_n_intersect = temp_n_intersect has_intersection = . true . else has_intersection = . false . end if deallocate ( temp_intersection ) if (. not . has_intersection ) exit end do ! Store if we found an intersection if ( has_intersection . and . current_n_intersect > 0 ) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection ( 1 : current_n_intersect ) temp_sets ( 1 : k , intersection_count ) = combination ( 1 : k ) temp_levels ( intersection_count ) = k end if if ( allocated ( current_intersection )) deallocate ( current_intersection ) ! Get next combination if (. not . next_combination ( combination , k , n_sets )) exit end do end subroutine generate_k_way_intersections_from_lists","tags":"","url":"proc/generate_k_way_intersections_from_lists.html"},{"title":"intersect_atom_lists – metalquicha","text":"private  subroutine intersect_atom_lists(atoms1, n1, atoms2, n2, intersection, n_intersect) Compute intersection of two atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms1 (:) integer, intent(in) :: n1 integer, intent(in) :: atoms2 (:) integer, intent(in) :: n2 integer, intent(out) :: intersection (:) integer, intent(out) :: n_intersect Called by proc~~intersect_atom_lists~~CalledByGraph proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate dfs_pie_accumulate proc~dfs_pie_accumulate->proc~intersect_atom_lists proc~dfs_pie_accumulate->proc~dfs_pie_accumulate proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j Source Code subroutine intersect_atom_lists ( atoms1 , n1 , atoms2 , n2 , intersection , n_intersect ) !! Compute intersection of two atom lists integer , intent ( in ) :: atoms1 (:), n1 , atoms2 (:), n2 integer , intent ( out ) :: intersection (:) integer , intent ( out ) :: n_intersect integer :: i , j n_intersect = 0 do i = 1 , n1 if ( atoms1 ( i ) < 0 ) cycle do j = 1 , n2 if ( atoms2 ( j ) < 0 ) cycle if ( atoms1 ( i ) == atoms2 ( j )) then n_intersect = n_intersect + 1 intersection ( n_intersect ) = atoms1 ( i ) exit end if end do end do end subroutine intersect_atom_lists","tags":"","url":"proc/intersect_atom_lists.html"},{"title":"next_combination_init – metalquicha","text":"private  subroutine next_combination_init(combination, k) Initialize combination to [1, 2, …, k] Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k Called by proc~~next_combination_init~2~~CalledByGraph proc~next_combination_init~2 next_combination_init proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->proc~next_combination_init~2 proc~generate_k_way_intersections_from_lists generate_k_way_intersections_from_lists proc~generate_k_way_intersections_from_lists->proc~next_combination_init~2 proc~generate_intersections generate_intersections proc~generate_intersections->proc~generate_k_way_intersections_for_level proc~generate_intersections_from_atom_lists generate_intersections_from_atom_lists proc~generate_intersections_from_atom_lists->proc~generate_k_way_intersections_from_lists proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->proc~generate_intersections_from_atom_lists Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine next_combination_init ( combination , k ) !! Initialize combination to [1, 2, ..., k] integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k integer :: i do i = 1 , k combination ( i ) = i end do end subroutine next_combination_init","tags":"","url":"proc/next_combination_init~2.html"},{"title":"merge_multi_molecule_json – metalquicha","text":"public  subroutine merge_multi_molecule_json(individual_files, nmol) Uses mqc_io_helpers proc~~merge_multi_molecule_json~~UsesGraph proc~merge_multi_molecule_json merge_multi_molecule_json module~mqc_io_helpers mqc_io_helpers proc~merge_multi_molecule_json->module~mqc_io_helpers Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Merge individual molecule JSON files into a single combined file Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: individual_files (:) integer, intent(in) :: nmol Calls proc~~merge_multi_molecule_json~~CallsGraph proc~merge_multi_molecule_json merge_multi_molecule_json error error proc~merge_multi_molecule_json->error info info proc~merge_multi_molecule_json->info proc~read_json_content read_json_content proc~merge_multi_molecule_json->proc~read_json_content to_char to_char proc~merge_multi_molecule_json->to_char proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~merge_multi_molecule_json~~CalledByGraph proc~merge_multi_molecule_json merge_multi_molecule_json proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: basename integer, private :: dot_pos logical, private :: file_exists integer, private :: imol integer, private :: io_stat character(len=10000), private :: line character(len=256), private :: output_file integer, private :: slash_pos integer, private :: unit_in integer, private :: unit_out Source Code subroutine merge_multi_molecule_json ( individual_files , nmol ) !! Merge individual molecule JSON files into a single combined file use mqc_io_helpers , only : get_molecule_name character ( len = 256 ), intent ( in ) :: individual_files (:) integer , intent ( in ) :: nmol integer :: imol , unit_in , unit_out , io_stat , slash_pos , dot_pos character ( len = 10000 ) :: line character ( len = 256 ) :: output_file , basename logical :: file_exists ! Determine combined output filename from first individual file ! Example: \"output_multi_structure_molecule_1.json\" -> \"output_multi_structure.json\" basename = individual_files ( 1 ) slash_pos = index ( basename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = basename ( slash_pos + 1 :) end if ! Remove \"_molecule_1\" or similar suffix dot_pos = index ( basename , '_molecule_' ) if ( dot_pos > 0 ) then output_file = basename ( 1 : dot_pos - 1 ) // \".json\" else output_file = \"output_combined.json\" end if ! Open combined output file open ( newunit = unit_out , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Merging \" // to_char ( nmol ) // \" molecule JSON files into \" // trim ( output_file )) ! Write opening brace and top-level key (basename without \"output_\" and \".json\") dot_pos = index ( output_file , '.json' ) if ( dot_pos > 0 ) then basename = output_file ( 8 : dot_pos - 1 ) ! Skip \"output_\" else basename = \"combined\" end if write ( unit_out , '(a)' ) \"{\" write ( unit_out , '(a)' ) '  \"' // trim ( basename ) // '\": {' ! Process each individual JSON file do imol = 1 , nmol inquire ( file = trim ( individual_files ( imol )), exist = file_exists ) if (. not . file_exists ) cycle open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) cycle ! Read all lines from the individual JSON file call read_json_content ( unit_in , imol , unit_out , individual_files ( imol )) close ( unit_in ) ! Delete individual file open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'readwrite' ) close ( unit_in , status = 'delete' ) end do ! Close last molecule write ( unit_out , '(a)' ) '    }' ! Close top-level key and file write ( unit_out , '(a)' ) '  }' write ( unit_out , '(a)' ) '}' close ( unit_out ) call logger % info ( \"Combined JSON written to \" // trim ( output_file )) end subroutine merge_multi_molecule_json","tags":"","url":"proc/merge_multi_molecule_json.html"},{"title":"read_json_content – metalquicha","text":"private  subroutine read_json_content(unit_in, mol_index, unit_out, filename) Uses mqc_io_helpers proc~~read_json_content~~UsesGraph proc~read_json_content read_json_content module~mqc_io_helpers mqc_io_helpers proc~read_json_content->module~mqc_io_helpers Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Read and write JSON content from an individual molecule file\nProperly handles nested structures from fragmented calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit_in integer, intent(in) :: mol_index integer, intent(in) :: unit_out character(len=*), intent(in) :: filename Calls proc~~read_json_content~~CallsGraph proc~read_json_content read_json_content error error proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_json_content~~CalledByGraph proc~read_json_content read_json_content proc~merge_multi_molecule_json merge_multi_molecule_json proc~merge_multi_molecule_json->proc~read_json_content proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json program~main main program~main->proc~run_multi_molecule_calculations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=10000), private, allocatable :: all_lines (:) integer, private :: i integer, private :: io_stat character(len=10000), private :: line integer, private :: nlines Source Code subroutine read_json_content ( unit_in , mol_index , unit_out , filename ) !! Read and write JSON content from an individual molecule file !! Properly handles nested structures from fragmented calculations use mqc_io_helpers , only : get_molecule_name integer , intent ( in ) :: unit_in , mol_index , unit_out character ( len =* ), intent ( in ) :: filename character ( len = 10000 ), allocatable :: all_lines (:) character ( len = 10000 ) :: line integer :: io_stat , nlines , i ! Read all lines into memory allocate ( all_lines ( 1000 )) ! Reasonable size for most JSON files nlines = 0 do read ( unit_in , '(a)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit nlines = nlines + 1 if ( nlines > size ( all_lines )) then ! Reallocate if needed call logger % error ( \"JSON file too large: \" // trim ( filename )) return end if all_lines ( nlines ) = line end do ! Lines structure: ! 1: \"{\" ! 2: '  \"molecule_name\": {' ! 3..(n-2): content ! n-1: \"  }\" ! n: \"}\" if ( nlines < 3 ) then call logger % error ( \"Invalid JSON structure: \" // trim ( filename )) return end if ! Write molecule key (extracted from filename) if ( mol_index > 1 ) write ( unit_out , '(a)' ) '    },' write ( unit_out , '(a)' ) '    \"' // trim ( get_molecule_name ( filename )) // '\" : {' ! Write all content lines (from line 3 to line n-2) do i = 3 , nlines - 2 write ( unit_out , '(a)' ) '  ' // trim ( all_lines ( i )) ! Add 2 spaces for proper indentation end do deallocate ( all_lines ) end subroutine read_json_content","tags":"","url":"proc/read_json_content.html"},{"title":"mqc_method_hf – metalquicha","text":"Implements the Hartree-Fock quantum chemistry method\nProvides energy and gradient calculations using a basic SCF procedure. Uses mqc_result_types mqc_physical_fragment pic_types mqc_method_base module~~mqc_method_hf~~UsesGraph module~mqc_method_hf mqc_method_hf module~mqc_method_base mqc_method_base module~mqc_method_hf->module~mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_hf->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_hf->module~mqc_result_types pic_types pic_types module~mqc_method_hf->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( qc_method_t ) :: hf_method_t Hartree-Fock method implementation Components Type Visibility Attributes Name Initial type( hf_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => hf_calc_energy procedure, public :: calc_gradient => hf_calc_gradient procedure, public :: calc_hessian => null_hessian Placeholder for Hessian calculation type, public :: hf_options_t Hartree-Fock calculation options Components Type Visibility Attributes Name Initial real(kind=dp), public :: conv_tol = 1.0e-8_dp Energy convergence threshold integer, public :: max_iter = 100 Maximum SCF iterations logical, public :: spherical = .false. Use spherical (true) or Cartesian (false) basis logical, public :: verbose = .true. Print SCF iterations Subroutines private  subroutine hf_calc_energy (this, fragment, result) Calculate electronic energy using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine hf_calc_gradient (this, fragment, result) Calculate energy gradient using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine null_hessian (this, fragment, result) Placeholder for Hessian calculation Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result","tags":"","url":"module/mqc_method_hf.html"},{"title":"mqc_combinatorics – metalquicha","text":"Provides pure combinatorial functions for generating molecular fragments\nincluding binomial coefficients, combinations, and fragment counting\nBinomial coefficient calculation\nCalculate total number of fragments\nGenerate sequential monomer indices\nGenerate all fragments up to max level\nGenerate all combinations of size r\nGenerate next combination in sequence\nInitialize combination to [1,2,…,k]\nGenerate next combination (alternate interface)\nDebug utility to print combinations Uses pic_types module~~mqc_combinatorics~~UsesGraph module~mqc_combinatorics mqc_combinatorics pic_types pic_types module~mqc_combinatorics->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_combinatorics~~UsedByGraph module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils mqc_frag_utils module~mqc_frag_utils->module~mqc_combinatorics module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe program~main main program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public pure function binomial (n, r) result(c) Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) Read more… Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n Total number of items integer(kind=default_int), intent(in) :: r Number of items to choose Return Value integer(kind=int64) Binomial coefficient result public pure function get_nfrags (n_monomers, max_level) result(n_expected_fragments) Calculate total number of fragments for given system size and max level Read more… Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n_monomers Number of monomers in system integer(kind=default_int), intent(in) :: max_level Maximum fragment size Return Value integer(kind=int64) Total fragment count public  function next_combination (combination, k, n) result(has_next) Generate next combination in lexicographic order\nReturns .true. if there’s a next combination, .false. if we’ve exhausted all Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k integer, intent(in) :: n Return Value logical Subroutines public recursive subroutine combine (arr, n, r, out_array, count) Generate all combinations of size r from array arr of size n\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count public pure subroutine create_monomer_list (monomers) Generate a list of monomer indices from 1 to N Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(inout), allocatable :: monomers (:) public recursive subroutine generate_fragment_list (monomers, max_level, polymers, count) Generate all possible fragments (combinations of monomers) up to max_level\nUses int64 for count to handle large numbers of fragments that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: monomers (:) integer(kind=default_int), intent(in) :: max_level integer(kind=default_int), intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: count public pure subroutine get_next_combination (indices, k, n, has_next) Generate next combination (updates indices in place)\nhas_next = .true. if there’s a next combination Arguments Type Intent Optional Attributes Name integer, intent(inout) :: indices (:) integer, intent(in) :: k integer, intent(in) :: n logical, intent(out) :: has_next public  subroutine next_combination_init (combination, k) Initialize combination to [1, 2, …, k] Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k public  subroutine print_combos (out_array, count, max_len) Print combinations stored in out_array\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: out_array (:,:) integer(kind=int64), intent(in) :: count integer(kind=default_int), intent(in) :: max_len private recursive subroutine combine_util (arr, n, r, index, data, i, out_array, count) Utility for generating combinations recursively\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(in) :: index integer(kind=default_int), intent(inout) :: data (:) integer(kind=default_int), intent(in) :: i integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count","tags":"","url":"module/mqc_combinatorics.html"},{"title":"mqc_result_types – metalquicha","text":"Defines data structures for storing and managing results from\nquantum chemistry calculations including energies, gradients, and properties.\nMP2 energy components type\nCoupled cluster energy components type\nEnergy components type\nMain result container type\nSend result over MPI\nReceive result over MPI Uses pic_types pic_mpi_lib module~~mqc_result_types~~UsesGraph module~mqc_result_types mqc_result_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib pic_types pic_types module~mqc_result_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_result_types~~UsedByGraph module~mqc_result_types mqc_result_types module~mqc_driver mqc_driver module~mqc_driver->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io->module~mqc_result_types module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_result_types module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->module~mqc_method_base proc~compute_gmbe_energy compute_gmbe_energy proc~compute_gmbe_energy->module~mqc_result_types proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->module~mqc_result_types proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->module~mqc_result_types proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->module~mqc_result_types proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->module~mqc_result_types proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->module~mqc_result_types proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_result_types proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_result_types module~mqc_mbe->module~mqc_mbe_io proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_xtb program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: SCS_OS_SCALE = 1.2_dp SCS opposite-spin scaling factor real(kind=dp), private, parameter :: SCS_SS_SCALE = 1.0_dp/3.0_dp SCS same-spin scaling factor Derived Types type, public :: calculation_result_t Container for quantum chemistry calculation results Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dipole (:) Dipole moment vector (3) (Debye) type( energy_t ), public :: energy Energy components (Hartree) real(kind=dp), public, allocatable :: gradient (:,:) Energy gradient (3, natoms) (Hartree/Bohr) logical, public :: has_dipole = .false. Dipole moment has been computed logical, public :: has_energy = .false. Energy has been computed logical, public :: has_gradient = .false. Gradient has been computed logical, public :: has_hessian = .false. Hessian has been computed logical, public :: has_sigma = .false. Stress tensor has been computed real(kind=dp), public, allocatable :: hessian (:,:) Energy hessian (future implementation) real(kind=dp), public, allocatable :: sigma (:,:) Stress tensor (3,3) (Hartree/Bohr&#94;3) Type-Bound Procedures procedure, public :: destroy => result_destroy Clean up allocated memory procedure, public :: reset => result_reset Reset all values and flags type, public :: cc_energy_t Container for coupled cluster energy components Components Type Visibility Attributes Name Initial real(kind=dp), public :: doubles = 0.0_dp Doubles contribution (Hartree) real(kind=dp), public :: singles = 0.0_dp Singles contribution (Hartree) real(kind=dp), public :: triples = 0.0_dp Triples contribution (Hartree) Type-Bound Procedures procedure, public :: check_stability => cc_check_stability Check for positive energies (instability) procedure, public :: reset => cc_reset Reset all components to zero procedure, public :: total => cc_total Compute total CC correlation type, public :: energy_t Container for quantum chemistry energy components Read more… Components Type Visibility Attributes Name Initial type( cc_energy_t ), public :: cc Coupled cluster correlation components type( mp2_energy_t ), public :: mp2 MP2 correlation components real(kind=dp), public :: scf = 0.0_dp SCF/HF reference energy (Hartree) Type-Bound Procedures procedure, public :: reset => energy_reset Reset all components to zero procedure, public :: total => energy_total Compute total energy from components type, public :: mp2_energy_t Container for MP2 energy components (SS/OS) Components Type Visibility Attributes Name Initial real(kind=dp), public :: os = 0.0_dp Opposite-spin correlation energy (Hartree) real(kind=dp), public :: ss = 0.0_dp Same-spin correlation energy (Hartree) Type-Bound Procedures procedure, public :: check_stability => mp2_check_stability Check for positive energies (instability) procedure, public :: reset => mp2_reset Reset both components to zero procedure, public :: scs => mp2_scs Compute SCS-MP2 correlation procedure, public :: total => mp2_total Compute total MP2 correlation Functions private pure function cc_total (this) result(total) Compute total CC correlation energy Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this Return Value real(kind=dp) private pure function energy_total (this) result(total) Compute total energy from all components Arguments Type Intent Optional Attributes Name class( energy_t ), intent(in) :: this Return Value real(kind=dp) private pure function mp2_scs (this) result(scs_energy) Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy\nSCS-MP2 uses: E_SCS = (1/3) E_SS + 1.2 E_OS Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) private pure function mp2_total (this) result(total) Compute total MP2 correlation energy Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this Return Value real(kind=dp) Subroutines public  subroutine result_irecv (result, comm, source, tag, req) Receive calculation result over MPI (non-blocking)\nReceives SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(request_t), intent(out) :: req public  subroutine result_isend (result, comm, dest, tag, req) Send calculation result over MPI (non-blocking)\nSends SCF energy (non-blocking) and other components (blocking) Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag type(request_t), intent(out) :: req public  subroutine result_recv (result, comm, source, tag, status) Receive calculation result over MPI (blocking)\nReceives energy components and conditionally receives gradient based on flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(inout) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: source integer, intent(in) :: tag type(MPI_Status), intent(out) :: status public  subroutine result_send (result, comm, dest, tag) Send calculation result over MPI (blocking)\nSends energy components and conditionally sends gradient based on has_gradient flag Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result type(comm_t), intent(in) :: comm integer, intent(in) :: dest integer, intent(in) :: tag private  subroutine cc_check_stability (this) Check for positive CC correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(in) :: this private  subroutine cc_reset (this) Reset all CC components to zero Arguments Type Intent Optional Attributes Name class( cc_energy_t ), intent(inout) :: this private  subroutine energy_reset (this) Reset all energy components to zero Arguments Type Intent Optional Attributes Name class( energy_t ), intent(inout) :: this private  subroutine mp2_check_stability (this) Check for positive MP2 correlation energies (instability warning)\nCorrelation energies should be negative; positive values indicate instability Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(in) :: this private  subroutine mp2_reset (this) Reset both MP2 components to zero Arguments Type Intent Optional Attributes Name class( mp2_energy_t ), intent(inout) :: this private  subroutine result_destroy (this) Clean up allocated memory in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this private  subroutine result_reset (this) Reset all values and flags in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this","tags":"","url":"module/mqc_result_types.html"},{"title":"mqc_mbe_io – metalquicha","text":"Uses pic_logger mqc_io_helpers mqc_physical_fragment mqc_elements pic_io pic_types mqc_result_types module~~mqc_mbe_io~~UsesGraph module~mqc_mbe_io mqc_mbe_io module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_mbe_io->module~mqc_result_types pic_io pic_io module~mqc_mbe_io->pic_io pic_logger pic_logger module~mqc_mbe_io->pic_logger pic_types pic_types module~mqc_mbe_io->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mbe_io~~UsedByGraph module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_driver mqc_driver module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function get_frag_level_name (frag_level) result(level_name) Map body level (n-mer) to descriptive name\nSupports up to decamers (10-mers), then falls back to “N-mers” format Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag_level Return Value character(len=32) Subroutines public  subroutine print_detailed_breakdown (polymers, fragment_count, max_level, energies, delta_energies) Print detailed energy breakdown for each fragment\nShows full energy and deltaE correction for all monomers, dimers, trimers, etc.\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) public  subroutine print_detailed_breakdown_json (polymers, fragment_count, max_level, energies, delta_energies, sum_by_level, total_energy, total_gradient, total_hessian) Write detailed energy breakdown to results.json file\nOutputs structured JSON with all fragment energies and deltaE corrections\nOptionally includes total gradient and Hessian if provided\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) real(kind=dp), intent(in) :: sum_by_level (:) real(kind=dp), intent(in) :: total_energy real(kind=dp), intent(in), optional :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(in), optional :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) public  subroutine print_fragment_xyz (fragment_idx, phys_frag) Print fragment geometry in XYZ format Arguments Type Intent Optional Attributes Name integer, intent(in) :: fragment_idx type( physical_fragment_t ), intent(in) :: phys_frag public  subroutine print_gmbe_json (n_monomers, monomer_indices, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, total_energy) Write GMBE calculation results to output JSON file\nOutputs structured JSON with monomers, intersections, and total energy\nIntersection parameters are optional and should be omitted when n_intersections=0 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_monomers integer, intent(in) :: monomer_indices (:) type( calculation_result_t ), intent(in) :: monomer_results (:) integer, intent(in) :: n_intersections type( calculation_result_t ), intent(in), optional :: intersection_results (:) integer, intent(in), optional :: intersection_sets (:,:) (n_monomers, n_intersections) integer, intent(in), optional :: intersection_levels (:) real(kind=dp), intent(in) :: total_energy public  subroutine print_gmbe_pie_json (pie_atom_sets, pie_coefficients, pie_energies, n_pie_terms, total_energy, total_gradient, total_hessian) Write GMBE PIE calculation results to output JSON file\nOutputs structured JSON with PIE terms (atom sets with coefficients and energies)\nOptionally includes total gradient and Hessian norms Arguments Type Intent Optional Attributes Name integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term real(kind=dp), intent(in) :: pie_energies (:) Raw energy for each term integer, intent(in) :: n_pie_terms real(kind=dp), intent(in) :: total_energy real(kind=dp), intent(in), optional :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(in), optional :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) public  subroutine print_unfragmented_json (result) Write unfragmented calculation results to output JSON file\nOutputs structured JSON with energy and optionally gradient Arguments Type Intent Optional Attributes Name type( calculation_result_t ), intent(in) :: result","tags":"","url":"module/mqc_mbe_io.html"},{"title":"mqc_elements – metalquicha","text":"Provides atomic numbers, element symbols, and atomic masses for the complete\nperiodic table (elements 1-118) with conversion functions between representations.\nConvert element symbol to atomic number\nConvert atomic number to element symbol\nGet atomic mass by atomic number Uses pic_ascii pic_types module~~mqc_elements~~UsesGraph module~mqc_elements mqc_elements pic_ascii pic_ascii module~mqc_elements->pic_ascii pic_types pic_types module~mqc_elements->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_elements~~UsedByGraph module~mqc_elements mqc_elements module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_elements module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_io->module~mqc_elements module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_physical_fragment->module~mqc_elements module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_adapter module~mqc_driver->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->module~mqc_physical_fragment proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_config_adapter program~main->module~mqc_physical_fragment program~main->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: element_masses (n_elements) = [1.008_dp, 4.0026_dp, 6.94_dp, 9.0122_dp, 10.81_dp, 12.011_dp, 14.007_dp, 15.999_dp, 18.998_dp, 20.180_dp, 22.990_dp, 24.305_dp, 26.982_dp, 28.085_dp, 30.974_dp, 32.06_dp, 35.45_dp, 39.948_dp, 39.098_dp, 40.078_dp, 44.956_dp, 47.867_dp, 50.942_dp, 51.996_dp, 54.938_dp, 55.845_dp, 58.933_dp, 58.693_dp, 63.546_dp, 65.38_dp, 69.723_dp, 72.630_dp, 74.922_dp, 78.971_dp, 79.904_dp, 83.798_dp, 85.468_dp, 87.62_dp, 88.906_dp, 91.224_dp, 92.906_dp, 95.95_dp, 98.0_dp, 101.07_dp, 102.91_dp, 106.42_dp, 107.87_dp, 112.41_dp, 114.82_dp, 118.71_dp, 121.76_dp, 127.60_dp, 126.90_dp, 131.29_dp, 132.91_dp, 137.33_dp, 138.91_dp, 140.12_dp, 140.91_dp, 144.24_dp, 145.0_dp, 150.36_dp, 151.96_dp, 157.25_dp, 158.93_dp, 162.50_dp, 164.93_dp, 167.26_dp, 168.93_dp, 173.05_dp, 174.97_dp, 178.49_dp, 180.95_dp, 183.84_dp, 186.21_dp, 190.23_dp, 192.22_dp, 195.08_dp, 196.97_dp, 200.59_dp, 204.38_dp, 207.2_dp, 208.98_dp, 209.0_dp, 210.0_dp, 222.0_dp, 223.0_dp, 226.0_dp, 227.0_dp, 232.04_dp, 231.04_dp, 238.03_dp, 237.0_dp, 244.0_dp, 243.0_dp, 247.0_dp, 247.0_dp, 251.0_dp, 252.0_dp, 257.0_dp, 258.0_dp, 259.0_dp, 262.0_dp, 267.0_dp, 268.0_dp, 271.0_dp, 272.0_dp, 270.0_dp, 276.0_dp, 281.0_dp, 280.0_dp, 285.0_dp, 284.0_dp, 289.0_dp, 288.0_dp, 293.0_dp, 294.0_dp, 294.0_dp] Standard atomic masses in atomic mass units (amu)\nBased on IUPAC standard atomic weights, ordered by atomic number character(len=2), private, parameter :: element_symbols (n_elements) = [character(len=2)::'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og'] Element symbols for the complete periodic table (H through Og)\nOrdered by atomic number from 1 to 118 integer, private, parameter :: n_elements = 118 Functions public pure function element_mass (atomic_number) result(mass) Return atomic mass in atomic mass units (amu) for a given atomic number\nUses standard atomic weights from IUPAC Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value real(kind=dp) public pure function element_number_to_symbol (atomic_number) result(symbol) Convert atomic number to element symbol\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value character(len=2) public pure function element_symbol_to_number (symbol) result(atomic_number) Convert element symbol to atomic number\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Return Value integer","tags":"","url":"module/mqc_elements.html"},{"title":"mqc_method_base – metalquicha","text":"Defines the common interface that all quantum chemistry methods must implement,\nproviding a unified API for energy and gradient calculations.\nAbstract base type for all QC methods Uses mqc_physical_fragment pic_types mqc_result_types module~~mqc_method_base~~UsesGraph module~mqc_method_base mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_base->module~mqc_result_types pic_types pic_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_base~~UsedByGraph module~mqc_method_base mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_method_base module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_xtb module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface private  subroutine calc_energy_interface(this, fragment, result) Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results abstract interface private  subroutine calc_gradient_interface(this, fragment, result) Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result abstract interface private  subroutine calc_hessian_interface(this, fragment, result) Interface for energy, gradient, and Hessian calculations Computes electronic energy, nuclear gradients, and Hessian matrix for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Derived Types type, public, abstract :: qc_method_t Abstract base type for all quantum chemistry methods Read more… Type-Bound Procedures procedure( calc_energy_interface ), public, deferred :: calc_energy Energy calculation interface procedure( calc_gradient_interface ), public, deferred :: calc_gradient Gradient calculation interface procedure( calc_hessian_interface ), public, deferred :: calc_hessian Hessian calculation interface","tags":"","url":"module/mqc_method_base.html"},{"title":"mqc_config_parser – metalquicha","text":"Parses section-based input files with %section…end blocks\nThis is the new format generated by mqc_prep.py\n========================================================================\nGeneric parsing helpers to eliminate redundancy\n======================================================================== Uses mqc_error mqc_geometry mqc_calc_types mqc_method_types pic_types module~~mqc_config_parser~~UsesGraph module~mqc_config_parser mqc_config_parser module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types pic_types pic_types module~mqc_config_parser->pic_types module~mqc_calc_types->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_config_parser~~UsedByGraph module~mqc_config_parser mqc_config_parser module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_config_adapter module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_physical_fragment module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_physical_fragment->module~mqc_config_parser proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->module~mqc_config_parser proc~compute_gmbe_energy_gradient->module~mqc_physical_fragment proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->module~mqc_config_parser proc~compute_gmbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->module~mqc_config_parser proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->module~mqc_config_parser proc~compute_mbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_parser program~main->module~mqc_config_adapter program~main->module~mqc_driver program~main->module~mqc_physical_fragment module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_LINE_LEN = 1024 Derived Types type, public :: bond_t Bond definition with atom indices, order, and broken status Components Type Visibility Attributes Name Initial integer, public :: atom_i = 0 integer, public :: atom_j = 0 logical, public :: is_broken = .false. integer, public :: order = 1 type, public :: input_fragment_t Input fragment definition with charge, multiplicity, and atom indices\nThis is the parsed representation from the input file, not the computational fragment Components Type Visibility Attributes Name Initial integer, public :: charge = 0 integer, public, allocatable :: indices (:) Atom indices in this fragment integer, public :: multiplicity = 1 Type-Bound Procedures procedure, public :: destroy => input_fragment_destroy type, public :: molecule_t Single molecule definition with structure, geometry, fragments, and connectivity Components Type Visibility Attributes Name Initial type( bond_t ), public, allocatable :: bonds (:) integer, public :: charge = 0 type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry integer, public :: multiplicity = 1 character(len=:), public, allocatable :: name Optional molecule name integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 Type-Bound Procedures procedure, public :: destroy => molecule_destroy type, public :: mqc_config_t Complete configuration from .mqc file Components Type Visibility Attributes Name Initial logical, public :: allow_overlapping_fragments = .false. character(len=:), public, allocatable :: aux_basis character(len=:), public, allocatable :: basis type( bond_t ), public, allocatable :: bonds (:) integer(kind=int32), public :: calc_type = CALC_TYPE_ENERGY integer, public :: charge = 0 character(len=:), public, allocatable :: cutoff_method real(kind=dp), public :: dimer_cutoff = 0.0_dp character(len=:), public, allocatable :: distance_metric character(len=:), public, allocatable :: embedding integer, public :: frag_level = 1 character(len=:), public, allocatable :: frag_method MBE, etc. type( input_fragment_t ), public, allocatable :: fragments (:) type( geometry_type ), public :: geometry integer, public :: index_base = 0 0-based or 1-based indexing character(len=:), public, allocatable :: log_level integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method = METHOD_TYPE_GFN2 type( molecule_t ), public, allocatable :: molecules (:) Array of molecules (if nmol > 0) integer, public :: multiplicity = 1 integer, public :: nbonds = 0 integer, public :: nbroken = 0 integer, public :: nfrag = 0 integer, public :: nmol = 0 Number of molecules (0 = single molecule mode for backward compatibility) integer, public :: scf_maxiter = 300 real(kind=dp), public :: scf_tolerance = 1.0e-6_dp character(len=:), public, allocatable :: schema_name character(len=:), public, allocatable :: schema_version real(kind=dp), public :: trimer_cutoff = 0.0_dp character(len=:), public, allocatable :: units angstrom or bohr Type-Bound Procedures procedure, public :: destroy => config_destroy Functions private  function parse_method_string (method_str) result(method_type) Parse method string from input file (e.g., “XTB-GFN1” -> gfn1) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Return Value integer(kind=int32) private pure function strip_comment (line) result(stripped) Remove comments (! or #) from a line and trim result Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value character(len=:), allocatable Subroutines public  subroutine read_mqc_file (filename, config, error) Read and parse a .mqc format input file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename type( mqc_config_t ), intent(out) :: config type( error_t ), intent(out) :: error private  subroutine config_destroy (this) Clean up allocated memory in mqc_config_t Arguments Type Intent Optional Attributes Name class( mqc_config_t ), intent(inout) :: this private  subroutine input_fragment_destroy (this) Clean up allocated memory in input_fragment_t Arguments Type Intent Optional Attributes Name class( input_fragment_t ), intent(inout) :: this private  subroutine molecule_destroy (this) Clean up allocated memory in molecule_t Arguments Type Intent Optional Attributes Name class( molecule_t ), intent(inout) :: this private  subroutine parse_connectivity_generic (unit, nbonds, nbroken, bonds, error) Generic parser for %connectivity section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nbonds integer, intent(inout) :: nbroken type( bond_t ), intent(inout), allocatable :: bonds (:) type( error_t ), intent(out) :: error private  subroutine parse_connectivity_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_driver_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_fragment (unit, fragment, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error private  subroutine parse_fragmentation_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_fragments_generic (unit, nfrag, fragments, error) Generic parser for %fragments section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: nfrag type( input_fragment_t ), intent(inout), allocatable :: fragments (:) type( error_t ), intent(out) :: error private  subroutine parse_fragments_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_geometry_generic (unit, geom, error) Generic parser for %geometry section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( geometry_type ), intent(inout) :: geom type( error_t ), intent(out) :: error private  subroutine parse_geometry_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_indices_line (line, fragment, error) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( input_fragment_t ), intent(inout) :: fragment type( error_t ), intent(out) :: error private  subroutine parse_model_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_molecule_connectivity (unit, mol, error) Parse %connectivity section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecule_fragments (unit, mol, error) Parse %fragments section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecule_geometry (unit, mol, error) Parse %geometry section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecule_structure (unit, mol, error) Parse %structure section for a molecule Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_molecules_section (unit, config, error) Parse %molecules section containing multiple %molecule blocks Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_scf_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_schema_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_single_molecule (unit, mol, error) Parse a single %molecule block with its sections Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( molecule_t ), intent(inout) :: mol type( error_t ), intent(out) :: error private  subroutine parse_structure_generic (unit, charge, multiplicity, error) Generic parser for %structure section (works for both config and molecule) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit integer, intent(inout) :: charge integer, intent(inout) :: multiplicity type( error_t ), intent(out) :: error private  subroutine parse_structure_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine parse_system_section (unit, config, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( mqc_config_t ), intent(inout) :: config type( error_t ), intent(out) :: error private  subroutine skip_to_end (unit, error) Skip lines until ‘end’ marker is found Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit type( error_t ), intent(out) :: error","tags":"","url":"module/mqc_config_parser.html"},{"title":"mqc_physical_fragment – metalquicha","text":"Physical molecular fragment representation and geometry handling Provides data structures and utilities for managing molecular fragments\nwith atomic coordinates, electronic properties, and geometric operations.\nSingle molecular fragment type\nComplete system geometry type\nSystem geometry initialization\nExtract fragment from system\nBuild fragment from explicit atom indices (for intersections)\nValidate fragment has no overlapping atoms Redistribute hydrogen cap gradients to original atoms\nRedistribute hydrogen cap Hessian to original atoms\nUnit conversion utilities\nGeometric centroid calculation\nMass-weighted center calculation\nPoint-to-point distance\nInter-fragment distance\nClosest approach distance Uses mqc_error mqc_geometry mqc_xyz_reader mqc_config_parser mqc_cgto mqc_elements pic_types module~~mqc_physical_fragment~~UsesGraph module~mqc_physical_fragment mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_physical_fragment~~UsedByGraph module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->module~mqc_physical_fragment proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: bohr_radius = 0.52917721092_dp Bohr radius in Ångström Derived Types type, public :: physical_fragment_t Physical molecular fragment with atomic coordinates and properties Read more… Components Type Visibility Attributes Name Initial type( molecular_basis_type ), public, allocatable :: basis Gaussian basis functions integer, public, allocatable :: cap_replaces_atom (:) Original atom index that each cap replaces (size: n_caps) integer, public :: charge = 0 Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) Cartesian coordinates (3, n_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers (Z values) integer, public, allocatable :: local_to_global (:) Map fragment atom index to system atom index (size: n_atoms - n_caps) integer, public :: multiplicity = 1 Spin multiplicity (2S+1) integer, public :: n_atoms Number of atoms in this fragment integer, public :: n_caps = 0 Number of hydrogen caps added (always at end of atom list) integer, public :: nelec = 0 Total number of electrons Type-Bound Procedures procedure, public :: compute_nelec => fragment_compute_nelec Calculate electron count procedure, public :: destroy => fragment_destroy Memory cleanup procedure, public :: set_basis => fragment_set_basis Assign basis set type, public :: system_geometry_t Complete molecular system geometry for fragment-based calculations Read more… Components Type Visibility Attributes Name Initial integer, public :: atoms_per_monomer Atoms in each monomer (0 if variable-sized) integer, public :: charge Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) All coordinates (3, total_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers for all atoms integer, public, allocatable :: fragment_atoms (:,:) Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer, public, allocatable :: fragment_charges (:) Charge for each fragment (n_monomers) integer, public, allocatable :: fragment_multiplicities (:) Multiplicity for each fragment (n_monomers) integer, public, allocatable :: fragment_sizes (:) Number of atoms in each fragment (n_monomers) integer, public :: multiplicity Spin multiplicity (2S+1) integer, public :: n_monomers Number of monomer units in system integer, public :: total_atoms Total number of atoms Type-Bound Procedures procedure, public :: destroy => system_destroy Memory cleanup Functions public pure function distance_between_fragments (frag1, frag2, use_com) result(distance) Calculate distance between two fragments\nIf use_com is .true., uses center of mass; otherwise uses centroid\nDistance is in the same units as the fragment coordinates (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: frag1 type( physical_fragment_t ), intent(in) :: frag2 logical, intent(in) :: use_com Return Value real(kind=dp) public pure function distance_between_points (point1, point2) result(distance) Calculate Euclidean distance between two 3D points\nPoints should be in the same units (typically Bohr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: point1 (3) real(kind=dp), intent(in) :: point2 (3) Return Value real(kind=dp) public pure function fragment_center_of_mass (fragment) result(com) Calculate the center of mass of a fragment\nWeights each atomic position by its atomic mass\nReturns coordinates in the same units as the fragment (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment Return Value real(kind=dp), (3) public pure function fragment_centroid (fragment) result(centroid) Calculate the geometric centroid (center of geometry) of a fragment\nThis is the simple average of all atomic coordinates\nReturns coordinates in the same units as the fragment (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment Return Value real(kind=dp), (3) public pure function minimal_distance_between_fragments (frag1, frag2) result(min_distance) Calculate the minimal distance between any two atoms in two fragments\nThis iterates over all atom pairs and finds the closest pair\nDistance is in the same units as the fragment coordinates (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: frag1 type( physical_fragment_t ), intent(in) :: frag2 Return Value real(kind=dp) public pure elemental function to_angstrom (bohr_value) result(angstrom_value) Convert coordinate from Bohr to Angstrom Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: bohr_value Return Value real(kind=dp) public pure elemental function to_bohr (angstrom_value) result(bohr_value) Convert coordinate from Angstrom to Bohr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: angstrom_value Return Value real(kind=dp) Subroutines public  subroutine build_fragment_from_atom_list (sys_geom, atom_indices, n_atoms, fragment, bonds) Build a fragment from explicit atom list (for GMBE intersection fragments) Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: atom_indices (:) 0-indexed atom indices integer, intent(in) :: n_atoms Number of atoms in list type( physical_fragment_t ), intent(out) :: fragment type( bond_t ), intent(in), optional :: bonds (:) Connectivity for capping public  subroutine build_fragment_from_indices (sys_geom, monomer_indices, fragment, bonds) Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) type( physical_fragment_t ), intent(out) :: fragment type( bond_t ), intent(in), optional :: bonds (:) Connectivity information for capping public  subroutine check_duplicate_atoms (fragment) Validate that fragment has no spatially overlapping atoms\nChecks if any two atoms are too close together (< 0.01 Bohr)\nThis catches bugs in geometry construction or fragment building Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment public  subroutine initialize_system_geometry (full_geom_file, monomer_file, sys_geom, error) Read full geometry and monomer template, initialize system_geometry_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full_geom_file character(len=*), intent(in) :: monomer_file type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error public  subroutine redistribute_cap_gradients (fragment, fragment_gradient, system_gradient) Redistribute hydrogen cap gradients to original atoms Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_gradient (:,:) (3, n_atoms_fragment) real(kind=dp), intent(inout) :: system_gradient (:,:) (3, n_atoms_system) public  subroutine redistribute_cap_hessian (fragment, fragment_hessian, system_hessian) Redistribute hydrogen cap Hessian to original atoms Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment real(kind=dp), intent(in) :: fragment_hessian (:,:) (3 n_atoms_fragment, 3 n_atoms_fragment) real(kind=dp), intent(inout) :: system_hessian (:,:) (3 n_atoms_system, 3 n_atoms_system) private  subroutine add_hydrogen_caps (atoms_in_fragment, bonds, sys_geom, fragment, base_atom_count) Add hydrogen caps to fragment for broken bonds\nCaps are placed at the position of the atom outside the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in) :: bonds (:) type( system_geometry_t ), intent(in) :: sys_geom type( physical_fragment_t ), intent(inout) :: fragment integer, intent(in) :: base_atom_count Number of non-cap atoms private  subroutine count_hydrogen_caps (atoms_in_fragment, bonds, n_caps) Count how many hydrogen caps are needed for a fragment\nA cap is needed when exactly one atom of a broken bond is in the fragment Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms_in_fragment (:) 0-indexed atom indices in fragment type( bond_t ), intent(in), optional :: bonds (:) integer, intent(out) :: n_caps private  subroutine fragment_compute_nelec (this) Compute number of electrons from atomic numbers and charge Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this private  subroutine fragment_destroy (this) Clean up allocated memory in physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this private  subroutine fragment_set_basis (this, basis) Set the basis set for this fragment Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis private  subroutine system_destroy (this) Clean up allocated memory in system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this","tags":"","url":"module/mqc_physical_fragment.html"},{"title":"mqc_xyz_reader – metalquicha","text":"Provides functions to parse standard XYZ format files containing\natomic coordinates and element symbols for molecular structures.\nRead XYZ file from disk\nParse XYZ data from string\nSplit text into lines (for testing) Uses mqc_error pic_types mqc_geometry module~~mqc_xyz_reader~~UsesGraph module~mqc_xyz_reader mqc_xyz_reader module~mqc_error mqc_error module~mqc_xyz_reader->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_xyz_reader->module~mqc_geometry pic_types pic_types module~mqc_xyz_reader->pic_types module~mqc_geometry->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_xyz_reader~~UsedByGraph module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->module~mqc_physical_fragment proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 Maximum element symbol length Functions private pure function int_to_string (i) result(str) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Subroutines public  subroutine read_xyz_file (filename, geom, error) Read molecular geometry from XYZ format file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Path to XYZ file type( geometry_type ), intent(out) :: geom Parsed molecular geometry type( error_t ), intent(out) :: error Error handling public pure subroutine read_xyz_string (xyz_string, geom, error) Parse molecular geometry from XYZ format string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xyz_string type( geometry_type ), intent(out) :: geom type( error_t ), intent(out) :: error public pure subroutine split_lines (text, lines, nlines) Split input text into lines based on CR, LF, or CRLF line endings\nTrailing newlines do not create empty lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text character(len=:), intent(out), allocatable :: lines (:) integer, intent(out) :: nlines","tags":"","url":"module/mqc_xyz_reader.html"},{"title":"mqc_cgto – metalquicha","text":"Defines data structures for cartesian contracted Gaussian type orbitals (CGTOs) Uses pic_types module~~mqc_cgto~~UsesGraph module~mqc_cgto mqc_cgto pic_types pic_types module~mqc_cgto->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_cgto~~UsedByGraph module~mqc_cgto mqc_cgto module~mqc_basis_reader mqc_basis_reader module~mqc_basis_reader->module~mqc_cgto module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->module~mqc_physical_fragment proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: atomic_basis_type Atomic basis set data structure Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: element element symbol integer, public :: nshells number of shells in type type( cgto_type ), public, allocatable :: shells (:) array of contracted shells Type-Bound Procedures procedure, public :: allocate_shells => allocate_basis_shells procedure, public :: destroy => atomic_basis_destroy procedure, public :: num_basis_functions => atomic_basis_num_basis_functions type, public :: cgto_type Contracted Gaussian type orbital (CGTO) data structure Components Type Visibility Attributes Name Initial integer, public :: ang_mom Angular momentum quantum number (0=s, 1=p, 2=d, etc.) real(kind=dp), public, allocatable :: coefficients (:) Contraction coefficients real(kind=dp), public, allocatable :: exponents (:) Exponents (alpha values) integer, public :: nfunc Number of primitive Gaussians in the contraction Type-Bound Procedures procedure, public :: allocate_arrays => cgto_allocate_arrays procedure, public :: destroy => cgto_destroy procedure, public :: num_basis_functions => cgto_num_basis_functions type, public :: molecular_basis_type Molecular basis set data structure (assembled basis) Components Type Visibility Attributes Name Initial type( atomic_basis_type ), public, allocatable :: elements (:) array of atomic basis types integer, public :: nelements total number of atoms/elements in a molecule Type-Bound Procedures procedure, public :: allocate_elements => basis_set_allocate_elements procedure, public :: destroy => basis_set_destroy procedure, public :: num_basis_functions => molecular_basis_num_basis_functions Functions private pure function atomic_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for an atom Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer private pure function cgto_num_basis_functions (self) result(nbf) Get number of basis functions in a shell (Cartesian) Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer private pure function molecular_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for the molecule Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Subroutines private pure subroutine allocate_basis_shells (self, nshells) Allocate array of shells in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells private pure subroutine atomic_basis_destroy (self) Clean up allocated memory in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self private pure subroutine basis_set_allocate_elements (self, nelements) Allocate array of atomic basis elements in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements private pure subroutine basis_set_destroy (self) Clean up allocated memory in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self private pure subroutine cgto_allocate_arrays (self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc private pure subroutine cgto_destroy (self) Clean up allocated memory in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self","tags":"","url":"module/mqc_cgto.html"},{"title":"mqc_basis_utils – metalquicha","text":"Provides utilities for normalizing basis set names and locating basis set files Normalization rules:\n  * -> s   (e.g., 6-31G* -> 6-31Gs)\n  + -> p   (e.g., 6-31+G -> 6-31pG)\n  (d,p) -> dp (remove parentheses and commas) Uses mqc_error module~~mqc_basis_utils~~UsesGraph module~mqc_basis_utils mqc_basis_utils module~mqc_error mqc_error module~mqc_basis_utils->module~mqc_error Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_basis_utils~~UsedByGraph module~mqc_basis_utils mqc_basis_utils module~mqc_cli_parser mqc_cli_parser module~mqc_cli_parser->module~mqc_basis_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public pure function normalize_basis_name (basis_name) result(normalized) Normalize basis set name to filename-safe format Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name Return Value character(len=:), allocatable Subroutines public  subroutine find_basis_file (basis_name, filename, error) Find basis set file using normalized name Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name character(len=:), intent(out), allocatable :: filename type( error_t ), intent(out) :: error","tags":"","url":"module/mqc_basis_utils.html"},{"title":"mqc_logo – metalquicha","text":"Provides the project branding sunflower logo and version information\ndisplayed at program startup.\nDisplay ASCII sunflower logo and project info Used by module~~mqc_logo~~UsedByGraph module~mqc_logo mqc_logo program~main main program~main->module~mqc_logo Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine print_logo () Print the PIC Chemistry ASCII sunflower logo Arguments None","tags":"","url":"module/mqc_logo.html"},{"title":"mqc_mbe – metalquicha","text":"Implements hierarchical many-body expansion for fragment-based quantum chemistry\ncalculations with MPI parallelization and energy/gradient computation.\nGMBE energy with intersection correction\nGMBE energy and gradient with intersection correction\nGMBE energy, gradient, and Hessian with intersection correction Uses mqc_mbe_io pic_logger mqc_mpi_tags mqc_physical_fragment pic_timer pic_mpi_lib mqc_frag_utils pic_io pic_types module~~mqc_mbe~~UsesGraph module~mqc_mbe mqc_mbe module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe->module~mqc_physical_fragment pic_io pic_io module~mqc_mbe->pic_io pic_logger pic_logger module~mqc_mbe->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe->pic_mpi_lib pic_timer pic_timer module~mqc_mbe->pic_timer pic_types pic_types module~mqc_mbe->pic_types module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_result_types mqc_result_types module~mqc_mbe_io->module~mqc_result_types module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_geometry->pic_types module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mbe~~UsedByGraph module~mqc_mbe mqc_mbe module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function compute_mbe (fragment_idx, fragment, lookup, energies, delta_energies, n) result(delta_E) Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas)\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all subset deltaE values\nAll subsets must have been computed already (guaranteed by processing fragments in order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Index of this fragment (already known) integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup Pre-built hash table for lookups real(kind=dp), intent(in) :: energies (:) Pre-computed delta values real(kind=dp), intent(in) :: delta_energies (:) Pre-computed delta values integer, intent(in) :: n Return Value real(kind=dp) Subroutines public  subroutine compute_gmbe_energy (monomers, n_monomers, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, total_energy) Compute GMBE (Generalized Many-Body Expansion) energy with full inclusion-exclusion Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: monomers (:) Monomer indices (1-based) integer, intent(in) :: n_monomers Number of monomers type( calculation_result_t ), intent(in) :: monomer_results (:) Monomer energies integer, intent(in) :: n_intersections Number of intersection fragments type( calculation_result_t ), intent(in), optional :: intersection_results (:) Intersection energies integer, intent(in), optional :: intersection_sets (:,:) k-tuples that created each intersection (n_monomers, n_intersections) integer, intent(in), optional :: intersection_levels (:) Level k of each intersection real(kind=dp), intent(out) :: total_energy Total GMBE energy public  subroutine compute_gmbe_energy_gradient (monomers, n_monomers, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, sys_geom, total_energy, total_gradient, bonds) Compute GMBE (Generalized Many-Body Expansion) energy and gradient with full inclusion-exclusion Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: monomers (:) Monomer indices (1-based) integer, intent(in) :: n_monomers Number of monomers type( calculation_result_t ), intent(in) :: monomer_results (:) Monomer energies and gradients integer, intent(in) :: n_intersections Number of intersection fragments type( calculation_result_t ), intent(in), optional :: intersection_results (:) Intersection energies and gradients integer, intent(in), optional :: intersection_sets (:,:) k-tuples that created each intersection (n_monomers, n_intersections) integer, intent(in), optional :: intersection_levels (:) Level k of each intersection type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: total_energy Total GMBE energy real(kind=dp), intent(out) :: total_gradient (:,:) Total GMBE gradient (3, total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps public  subroutine compute_gmbe_energy_gradient_hessian (monomers, n_monomers, monomer_results, n_intersections, intersection_results, intersection_sets, intersection_levels, sys_geom, total_energy, total_gradient, total_hessian, bonds) Compute GMBE energy, gradient, and Hessian with full inclusion-exclusion\nTODO: Full implementation with intersection Hessians pending Arguments Type Intent Optional Attributes Name integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers type( calculation_result_t ), intent(in) :: monomer_results (:) integer, intent(in) :: n_intersections type( calculation_result_t ), intent(in), optional :: intersection_results (:) integer, intent(in), optional :: intersection_sets (:,:) integer, intent(in), optional :: intersection_levels (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: total_energy real(kind=dp), intent(out) :: total_gradient (:,:) real(kind=dp), intent(out) :: total_hessian (:,:) type( bond_t ), intent(in), optional :: bonds (:) public  subroutine compute_mbe_energy (polymers, fragment_count, max_level, results, total_energy) Compute the many-body expansion (MBE) energy\nTotal = sum(E(i)) + sum(deltaE(ij)) + sum(deltaE(ijk)) + …\nGeneral n-body correction:\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all lower-order terms\nUses int64 for fragment_count to handle large fragment counts that overflow int32.\nDetailed breakdown is printed only if logger level is verbose or higher. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(out) :: total_energy public  subroutine compute_mbe_energy_gradient (polymers, fragment_count, max_level, results, sys_geom, total_energy, total_gradient, bonds) Compute both MBE energy and gradient in a single pass\nThis is more efficient than calling compute_mbe_energy and compute_mbe_gradient separately\nas it only builds the lookup table once and processes all fragments in one loop Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( calculation_result_t ), intent(in) :: results (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: total_energy real(kind=dp), intent(out) :: total_gradient (:,:) (3, total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps public  subroutine compute_mbe_energy_gradient_hessian (polymers, fragment_count, max_level, results, sys_geom, total_energy, total_gradient, total_hessian, bonds) Compute MBE energy, gradient, and Hessian in a single pass\nMost efficient for simultaneous energy+gradient+Hessian calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level type( calculation_result_t ), intent(in) :: results (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(out) :: total_energy real(kind=dp), intent(out) :: total_gradient (:,:) (3, total_atoms) real(kind=dp), intent(out) :: total_hessian (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:) private  subroutine compute_mbe_gradient (fragment_idx, fragment, lookup, results, delta_gradients, n, sys_geom, bonds) Bottom-up computation of n-body gradient correction\nExactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs)\nAll gradients are in system coordinates, so subtraction is simple Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_gradients (:,:,:) (3, total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps private  subroutine compute_mbe_hessian (fragment_idx, fragment, lookup, results, delta_hessians, n, sys_geom, bonds) Bottom-up computation of n-body Hessian correction\nMirrors MBE gradient logic but for second derivatives Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup type( calculation_result_t ), intent(in) :: results (:) real(kind=dp), intent(inout) :: delta_hessians (:,:,:) (3 total_atoms, 3 total_atoms, fragment_count) integer, intent(in) :: n type( system_geometry_t ), intent(in) :: sys_geom type( bond_t ), intent(in), optional :: bonds (:) private  subroutine map_fragment_to_system_gradient (frag_grad, monomers, sys_geom, sys_grad, bonds) Map fragment gradient to system gradient coordinates with hydrogen cap redistribution Read more… Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_grad (:,:) (3, natoms_frag) integer, intent(in) :: monomers (:) Monomer indices in fragment type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_grad (:,:) (3, total_atoms) type( bond_t ), intent(in), optional :: bonds (:) Bond information for caps private  subroutine map_fragment_to_system_hessian (frag_hess, monomers, sys_geom, sys_hess, bonds) Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: frag_hess (:,:) (3 natoms_frag, 3 natoms_frag) integer, intent(in) :: monomers (:) type( system_geometry_t ), intent(in) :: sys_geom real(kind=dp), intent(inout) :: sys_hess (:,:) (3 total_atoms, 3 total_atoms) type( bond_t ), intent(in), optional :: bonds (:)","tags":"","url":"module/mqc_mbe.html"},{"title":"mqc_basis_file_reader – metalquicha","text":"Module for reading and parsing GAMESS formatted basis set files Uses pic_types module~~mqc_basis_file_reader~~UsesGraph module~mqc_basis_file_reader mqc_basis_file_reader pic_types pic_types module~mqc_basis_file_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_basis_file_reader~~UsedByGraph module~mqc_basis_file_reader mqc_basis_file_reader module~mqc_basis_reader mqc_basis_reader module~mqc_basis_reader->module~mqc_basis_file_reader Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: basis_file_t Container for basis set file contents Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: data_section character(len=:), public, allocatable :: full_content Functions public  function extract_element (basis_file, element) result(element_content) Extract the basis set data for a specific element from the basis file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(in) :: basis_file character(len=*), intent(in) :: element Return Value character(len=:), allocatable public pure function strings_equal (str1, str2) result(equal) Compare two strings after trimming and adjusting (removing leading/trailing whitespace)\nCompare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical private pure function is_letter (c) result(is_alpha) Check if character is a letter (A-Z or a-z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical private pure function is_uppercase_letter (c) result(is_upper) Check if character is an uppercase letter (A-Z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical private pure function uppercase (str) result(upper) Convert a string to uppercase, should use pic_ascii! Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:), allocatable Subroutines public  subroutine open_basis_file (basis_file, filename) Open and read a GAMESS formatted basis set file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(out) :: basis_file character(len=*), intent(in) :: filename","tags":"","url":"module/mqc_basis_file_reader.html"},{"title":"mqc_fragment_lookup – metalquicha","text":"Provides O(1) hash table for mapping monomer combinations to fragment indices\nHash-based lookup table type Uses pic_hash_32bit pic_sorting pic_types module~~mqc_fragment_lookup~~UsesGraph module~mqc_fragment_lookup mqc_fragment_lookup pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting pic_types pic_types module~mqc_fragment_lookup->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_fragment_lookup~~UsedByGraph module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils mqc_frag_utils module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe program~main main program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: fragment_lookup_t Hash-based lookup table for O(1) fragment index retrieval Components Type Visibility Attributes Name Initial logical, public :: initialized = .false. integer(kind=int64), public :: n_entries = 0 type( hash_entry_t ), public, allocatable :: table (:) integer, public :: table_size = 0 Type-Bound Procedures procedure, public :: destroy => fragment_lookup_destroy procedure, public :: find => fragment_lookup_find procedure, public :: init => fragment_lookup_init procedure, public :: insert => fragment_lookup_insert type, private :: hash_entry_t Single entry in hash table (private helper type) Components Type Visibility Attributes Name Initial integer, public, allocatable :: key (:) Sorted monomer indices type( hash_entry_t ), public, pointer :: next => null() Chain for collisions integer(kind=int64), public :: value Fragment index Functions private pure function arrays_equal_internal (a, b, n) result(equal) Check if two arrays are equal Arguments Type Intent Optional Attributes Name integer, intent(in) :: a (:) integer, intent(in) :: b (:) integer, intent(in) :: n Return Value logical private  function fragment_lookup_find (this, monomers, n) result(idx) Find fragment index for given monomer combination Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) private pure function next_prime_internal (n) result(p) Find next prime number >= n (simple implementation) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer Subroutines private  subroutine fragment_lookup_destroy (this) Clean up hash table and all chains Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this private  subroutine fragment_lookup_init (this, estimated_entries) Initialize hash table with estimated size Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries private  subroutine fragment_lookup_insert (this, monomers, n, fragment_idx) Insert a monomer combination -> fragment index mapping Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx","tags":"","url":"module/mqc_fragment_lookup.html"},{"title":"mqc_cli_parser – metalquicha","text":"Handles parsing of command line options including geometry files,\nbasis set specifications, and help/usage display.\nParsed command line arguments container\nMain argument parsing routine\nDisplay program usage information\nStandardize basis set names\nLocate basis set files Uses mqc_basis_utils mqc_error module~~mqc_cli_parser~~UsesGraph module~mqc_cli_parser mqc_cli_parser module~mqc_basis_utils mqc_basis_utils module~mqc_cli_parser->module~mqc_basis_utils module~mqc_error mqc_error module~mqc_cli_parser->module~mqc_error module~mqc_basis_utils->module~mqc_error Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: cli_args_type Container for parsed command line arguments Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: basis_name Basis set name (e.g., “6-31G”) character(len=:), public, allocatable :: xyz_file Input XYZ geometry file path Type-Bound Procedures procedure, public :: destroy => cli_args_destroy Memory cleanup Subroutines public  subroutine parse_command_line (args, error) Parse command line arguments for geometry file and basis set Read more… Arguments Type Intent Optional Attributes Name type( cli_args_type ), intent(out) :: args Parsed argument container type( error_t ), intent(out) :: error Error object public  subroutine print_usage () Print usage information Arguments None private  subroutine cli_args_destroy (this) Clean up CLI args Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this","tags":"","url":"module/mqc_cli_parser.html"},{"title":"mqc_finite_differences – metalquicha","text":"Provides utilities for generating perturbed geometries and computing\nnumerical derivatives via finite differences (gradients, Hessians, etc.)\nGenerate forward/backward displacements\nContainer for displaced geometry\nCompute Hessian from gradient differences\nCopy and displace geometry Uses mqc_physical_fragment pic_types module~~mqc_finite_differences~~UsesGraph module~mqc_finite_differences mqc_finite_differences module~mqc_physical_fragment mqc_physical_fragment module~mqc_finite_differences->module~mqc_physical_fragment pic_types pic_types module~mqc_finite_differences->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_finite_differences~~UsedByGraph module~mqc_finite_differences mqc_finite_differences proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: DEFAULT_DISPLACEMENT = 0.01_dp ~0.05 Angstrom Derived Types type, public :: displaced_geometry_t Container for a single displaced geometry Components Type Visibility Attributes Name Initial integer, public :: atom_index Which atom was displaced (1-based) integer, public :: coordinate Which coordinate was displaced (1=x, 2=y, 3=z) integer, public :: direction +1 for forward, -1 for backward real(kind=dp), public :: displacement Displacement magnitude in Bohr type( physical_fragment_t ), public :: geometry The displaced geometry Type-Bound Procedures procedure, public :: destroy => displaced_geometry_destroy Subroutines public  subroutine copy_and_displace_geometry (reference_geom, atom_idx, coord_idx, displacement, displaced_geom) Create a copy of reference geometry with one coordinate displaced Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom integer, intent(in) :: atom_idx integer, intent(in) :: coord_idx real(kind=dp), intent(in) :: displacement type( physical_fragment_t ), intent(out) :: displaced_geom public  subroutine finite_diff_hessian_from_gradients (reference_geom, forward_gradients, backward_gradients, displacement, hessian) Compute Hessian matrix from finite differences of gradients Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: forward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: backward_gradients (:,:,:) (n_displacements, 3, n_atoms) real(kind=dp), intent(in) :: displacement real(kind=dp), intent(out), allocatable :: hessian (:,:) (3 n_atoms, 3 n_atoms) public  subroutine generate_perturbed_geometries (reference_geom, displacement, forward_geoms, backward_geoms) Generate all forward and backward displaced geometries for finite difference calculations Read more… Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: reference_geom real(kind=dp), intent(in) :: displacement type( displaced_geometry_t ), intent(out), allocatable :: forward_geoms (:) type( displaced_geometry_t ), intent(out), allocatable :: backward_geoms (:) private  subroutine displaced_geometry_destroy (this) Clean up memory for displaced geometry Arguments Type Intent Optional Attributes Name class( displaced_geometry_t ), intent(inout) :: this","tags":"","url":"module/mqc_finite_differences.html"},{"title":"mqc_libcint_interface – metalquicha","text":"Provides Fortran interface to the Libcint library for integral calculations","tags":"","url":"module/mqc_libcint_interface.html"},{"title":"mqc_calc_types – metalquicha","text":"Defines integer constants for calculation types to avoid string comparisons\nthroughout the codebase. Provides conversion utilities between string\nrepresentations and integer constants. Uses pic_types module~~mqc_calc_types~~UsesGraph module~mqc_calc_types mqc_calc_types pic_types pic_types module~mqc_calc_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_calc_types~~UsedByGraph module~mqc_calc_types mqc_calc_types module~mqc_config_parser mqc_config_parser module~mqc_config_parser->module~mqc_calc_types module~mqc_driver mqc_driver module~mqc_driver->module~mqc_calc_types module~mqc_driver->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_config_adapter mqc_config_adapter module~mqc_driver->module~mqc_config_adapter module~mqc_physical_fragment mqc_physical_fragment module~mqc_driver->module~mqc_physical_fragment module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_calc_types proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_calc_types proc~serial_gmbe_pie_processor->module~mqc_physical_fragment module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_physical_fragment->module~mqc_config_parser proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->module~mqc_config_parser proc~compute_gmbe_energy_gradient->module~mqc_physical_fragment proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->module~mqc_config_parser proc~compute_gmbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->module~mqc_config_parser proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->module~mqc_config_parser proc~compute_mbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_parser program~main->module~mqc_driver program~main->module~mqc_config_adapter program~main->module~mqc_physical_fragment module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: CALC_TYPE_ENERGY = 1 integer(kind=int32), public, parameter :: CALC_TYPE_GRADIENT = 2 integer(kind=int32), public, parameter :: CALC_TYPE_HESSIAN = 3 integer(kind=int32), public, parameter :: CALC_TYPE_UNKNOWN = 0 Functions public pure function calc_type_from_string (calc_type_str) result(calc_type) Convert calculation type string to integer constant Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: calc_type_str Input string (e.g., “energy”, “gradient”) Return Value integer(kind=int32) Output integer constant public pure function calc_type_to_string (calc_type) result(calc_type_str) Convert calculation type integer constant to string Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: calc_type Input integer constant Return Value character(len=:), allocatable Output string representation","tags":"","url":"module/mqc_calc_types.html"},{"title":"mqc_driver – metalquicha","text":"Handles both fragmented (many-body expansion) and unfragmented calculations\nwith MPI parallelization and node-based work distribution.\nMain entry point for all calculations\nMulti-molecule calculation dispatcher Uses mqc_mbe mqc_mbe_fragment_distribution_scheme mqc_error mqc_json pic_logger mqc_io_helpers mqc_config_parser mqc_physical_fragment pic_mpi_lib mqc_gmbe_fragment_distribution_scheme mqc_calc_types mqc_method_types omp_lib mqc_frag_utils mqc_config_adapter pic_io pic_types mqc_result_types module~~mqc_driver~~UsesGraph module~mqc_driver mqc_driver module~mqc_calc_types mqc_calc_types module~mqc_driver->module~mqc_calc_types module~mqc_config_adapter mqc_config_adapter module~mqc_driver->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_driver->module~mqc_config_parser module~mqc_error mqc_error module~mqc_driver->module~mqc_error module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_io_helpers mqc_io_helpers module~mqc_driver->module~mqc_io_helpers module~mqc_json mqc_json module~mqc_driver->module~mqc_json module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_method_types mqc_method_types module~mqc_driver->module~mqc_method_types module~mqc_physical_fragment mqc_physical_fragment module~mqc_driver->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_driver->module~mqc_result_types omp_lib omp_lib module~mqc_driver->omp_lib pic_io pic_io module~mqc_driver->pic_io pic_logger pic_logger module~mqc_driver->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_driver->pic_mpi_lib pic_types pic_types module~mqc_driver->pic_types module~mqc_calc_types->pic_types module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_error module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_adapter->pic_types module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->pic_io module~mqc_gmbe_fragment_distribution_scheme->pic_logger module~mqc_gmbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_gmbe_fragment_distribution_scheme->pic_types module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags pic_timer pic_timer module~mqc_gmbe_fragment_distribution_scheme->pic_timer module~mqc_json->pic_io module~mqc_json->pic_logger module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->pic_timer module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme->omp_lib module~mqc_mbe_fragment_distribution_scheme->pic_io module~mqc_mbe_fragment_distribution_scheme->pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_timer module~mqc_method_types->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_cgto->pic_types module~mqc_combinatorics->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_geometry->pic_types module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_mbe_io->module~mqc_io_helpers module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_types module~mqc_method_xtb->pic_timer mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_driver~~UsedByGraph module~mqc_driver mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine run_calculation (world_comm, node_comm, config, sys_geom, bonds) Main calculation dispatcher - routes to fragmented or unfragmented calculation Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator type( driver_config_t ), intent(in) :: config Driver configuration type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information public  subroutine run_multi_molecule_calculations (world_comm, node_comm, mqc_config) Run calculations for multiple molecules with MPI parallelization\nEach molecule is independent, so assign one molecule per rank Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm type( mqc_config_t ), intent(in) :: mqc_config private  subroutine run_fragmented_calculation (world_comm, node_comm, method, calc_type, sys_geom, max_level, allow_overlapping_fragments, max_intersection_level, bonds) Handle fragmented calculation (nlevel > 0) Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator integer(kind=int32), intent(in) :: method Quantum chemistry method integer(kind=int32), intent(in) :: calc_type Calculation type type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info integer, intent(in) :: max_level Maximum fragment level for MBE logical, intent(in) :: allow_overlapping_fragments Use GMBE for overlapping fragments integer, intent(in) :: max_intersection_level Maximum k-way intersection depth for GMBE type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information private  subroutine run_unfragmented_calculation (world_comm, sys_geom, method, calc_type, bonds) Handle unfragmented calculation (nlevel=0) Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type( system_geometry_t ), intent(in) :: sys_geom Complete system geometry integer(kind=int32), intent(in) :: method Quantum chemistry method integer(kind=int32), intent(in) :: calc_type Calculation type type( bond_t ), intent(in), optional :: bonds (:) Bond connectivity information","tags":"","url":"module/mqc_driver.html"},{"title":"mqc_method_xtb – metalquicha","text":"Provides GFN1-xTB and GFN2-xTB methods via the tblite library,\nimplementing the abstract method interface for energy and gradient calculations.\nXTB method implementation type Uses tblite_xtb_calculator mqc_method_base tblite_context_type tblite_xtb_gfn2 tblite_xtb_singlepoint mctc_io mqc_physical_fragment tblite_wavefunction mctc_env tblite_xtb_gfn1 pic_timer pic_types mqc_result_types module~~mqc_method_xtb~~UsesGraph module~mqc_method_xtb mqc_method_xtb mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_xtb->module~mqc_result_types pic_timer pic_timer module~mqc_method_xtb->pic_timer pic_types pic_types module~mqc_method_xtb->pic_types tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_config_parser mqc_config_parser module~mqc_physical_fragment->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_error mqc_error module~mqc_physical_fragment->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types pic_mpi_lib pic_mpi_lib module~mqc_result_types->pic_mpi_lib module~mqc_cgto->pic_types module~mqc_config_parser->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->module~mqc_geometry module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_calc_types->pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_xtb~~UsedByGraph module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_method_xtb module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( qc_method_t ) :: xtb_method_t Extended Tight-Binding (xTB) method implementation Read more… Components Type Visibility Attributes Name Initial real(kind=wp), public :: accuracy = 0.01_wp Numerical accuracy parameter real(kind=wp), public :: kt = 300.0_wp*3.166808578545117e-06_wp Electronic temperature (300 K) character(len=:), public, allocatable :: variant XTB variant: “gfn1” or “gfn2” logical, public :: verbose = .false. Print calculation details Type-Bound Procedures procedure, public :: calc_energy => xtb_calc_energy Energy-only calculation procedure, public :: calc_gradient => xtb_calc_gradient Energy + gradient calculation procedure, public :: calc_hessian => xtb_calc_hessian Placeholder for Hessian calculation Subroutines private  subroutine xtb_calc_energy (this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine xtb_calc_gradient (this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine xtb_calc_hessian (this, fragment, result) Calculate Hessian using finite differences of gradients Read more… Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result","tags":"","url":"module/mqc_method_xtb.html"},{"title":"mqc_mpi_tags – metalquicha","text":"Module defining MPI communication tags for clarity and maintainability Uses pic_types module~~mqc_mpi_tags~~UsesGraph module~mqc_mpi_tags mqc_mpi_tags pic_types pic_types module~mqc_mpi_tags->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mpi_tags~~UsedByGraph module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_driver mqc_driver module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: TAG_NODE_FINISH = 302 Global coordinator signals node coordinator to finish integer(kind=default_int), public, parameter :: TAG_NODE_FRAGMENT = 301 Global coordinator sends fragment data to node coordinator integer(kind=default_int), public, parameter :: TAG_NODE_MATRIX_RESULT = 304 Node coordinator sends matrix results to global coordinator integer(kind=default_int), public, parameter :: TAG_NODE_REQUEST = 300 Node coordinator requests work from global coordinator integer(kind=default_int), public, parameter :: TAG_NODE_SCALAR_RESULT = 303 Node coordinator sends results (fragment_idx + scalar) to global coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_FINISH = 202 Coordinator signals worker to finish integer(kind=default_int), public, parameter :: TAG_WORKER_FRAGMENT = 201 Coordinator sends fragment data to worker integer(kind=default_int), public, parameter :: TAG_WORKER_MATRIX_RESULT = 204 Worker sends matrix results back to coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_REQUEST = 200 Worker requests work from node coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_SCALAR_RESULT = 203 Worker sends scalar results back to coordinator","tags":"","url":"module/mqc_mpi_tags.html"},{"title":"mqc_geometry – metalquicha","text":"Defines the geometry data structure for molecular systems Uses pic_types module~~mqc_geometry~~UsesGraph module~mqc_geometry mqc_geometry pic_types pic_types module~mqc_geometry->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_geometry~~UsedByGraph module~mqc_geometry mqc_geometry module~mqc_config_parser mqc_config_parser module~mqc_config_parser->module~mqc_geometry module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_geometry module~mqc_physical_fragment->module~mqc_config_parser module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_xyz_reader->module~mqc_geometry proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~geometry_to_system_unfragmented->module~mqc_geometry proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_geometry proc~initialize_fragmented_system->module~mqc_config_parser module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->module~mqc_config_adapter module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->module~mqc_config_parser proc~compute_gmbe_energy_gradient->module~mqc_physical_fragment proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->module~mqc_config_parser proc~compute_gmbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->module~mqc_config_parser proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->module~mqc_config_parser proc~compute_mbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment program~main main program~main->module~mqc_config_parser program~main->module~mqc_physical_fragment program~main->module~mqc_config_adapter program~main->module~mqc_driver proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 Derived Types type, public :: geometry_type Molecular geometry data structure Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: comment real(kind=dp), public, allocatable :: coords (:,:) character(len=:), public, allocatable :: elements (:) integer, public :: natoms Type-Bound Procedures procedure, public :: destroy => geometry_destroy Subroutines private  subroutine geometry_destroy (this) Clean up allocated memory in geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this","tags":"","url":"module/mqc_geometry.html"},{"title":"mqc_gmbe_fragment_distribution_scheme – metalquicha","text":"Implements fragment distribution schemes for GMBE calculations with overlapping fragments\nHandles both serial and MPI-parallelized distribution of monomers and intersection fragments\nPIE-based serial processor\nPIE-based MPI coordinator Uses mqc_mbe_fragment_distribution_scheme mqc_mbe_io pic_logger mqc_mpi_tags mqc_physical_fragment pic_timer mqc_calc_types pic_mpi_lib mqc_config_parser pic_io pic_types mqc_result_types module~~mqc_gmbe_fragment_distribution_scheme~~UsesGraph module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_calc_types mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_config_parser mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types pic_io pic_io module~mqc_gmbe_fragment_distribution_scheme->pic_io pic_logger pic_logger module~mqc_gmbe_fragment_distribution_scheme->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_gmbe_fragment_distribution_scheme->pic_mpi_lib pic_timer pic_timer module~mqc_gmbe_fragment_distribution_scheme->pic_timer pic_types pic_types module~mqc_gmbe_fragment_distribution_scheme->pic_types module~mqc_calc_types->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->pic_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme->pic_io module~mqc_mbe_fragment_distribution_scheme->pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_timer module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_method_types->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_gmbe_fragment_distribution_scheme~~UsedByGraph module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine gmbe_pie_coordinator (world_comm, node_comm, pie_atom_sets, pie_coefficients, n_pie_terms, node_leader_ranks, num_nodes, sys_geom, method, calc_type, bonds) MPI coordinator for PIE-based GMBE calculations\nDistributes PIE terms across MPI ranks and accumulates results Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer, intent(in) :: n_pie_terms integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) public  subroutine serial_gmbe_pie_processor (pie_atom_sets, pie_coefficients, n_pie_terms, sys_geom, method, calc_type, bonds) Serial GMBE processor using PIE coefficients\nEvaluates each unique atom set once and sums with PIE coefficients\nSupports energy-only, energy+gradient, and energy+gradient+Hessian calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_pie_terms) integer, intent(in) :: pie_coefficients (:) PIE coefficient for each term integer, intent(in) :: n_pie_terms type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in) :: calc_type type( bond_t ), intent(in), optional :: bonds (:) private  subroutine send_pie_term_to_node (world_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to remote node coordinator Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer, intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank private  subroutine send_pie_term_to_worker (node_comm, term_idx, pie_atom_sets, dest_rank) Send PIE term (atom list) to local worker Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer, intent(in) :: term_idx integer, intent(in) :: pie_atom_sets (:,:) integer, intent(in) :: dest_rank","tags":"","url":"module/mqc_gmbe_fragment_distribution_scheme.html"},{"title":"mqc_config_adapter – metalquicha","text":"Provides conversion utilities from mqc_config_t to driver-compatible structures\nMinimal config for driver\nConvert log level string to integer\nCheck for overlapping fragments (for testing) Minimal configuration for driver (internal use only) Uses mqc_error mqc_physical_fragment mqc_config_parser pic_types mqc_elements module~~mqc_config_adapter~~UsesGraph module~mqc_config_adapter mqc_config_adapter module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements module~mqc_error mqc_error module~mqc_config_adapter->module~mqc_error module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_config_parser->module~mqc_error module~mqc_config_parser->pic_types module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_geometry->pic_types module~mqc_method_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_config_adapter~~UsedByGraph module~mqc_config_adapter mqc_config_adapter module~mqc_driver mqc_driver module~mqc_driver->module~mqc_config_adapter proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_adapter program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: driver_config_t Components Type Visibility Attributes Name Initial logical, public :: allow_overlapping_fragments Enable GMBE for overlapping fragments integer(kind=int32), public :: calc_type Calculation type constant integer, public :: max_intersection_level = 999 Maximum k-way intersection depth for GMBE (default: no limit) integer(kind=int32), public :: method QC method constant integer, public :: nlevel = 0 Fragmentation level (0 = unfragmented) Functions public  function get_logger_level (level_string) result(level_int) Convert string log level to integer value\nThis function uses the pic_logger constants Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: level_string Return Value integer Subroutines public  subroutine check_fragment_overlap (fragments, nfrag, error) Check if any atoms appear in multiple fragments\nThis is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes Arguments Type Intent Optional Attributes Name type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: nfrag type( error_t ), intent(out) :: error public  subroutine config_to_driver (mqc_config, driver_config, molecule_index) Convert mqc_config_t to minimal driver_config_t\nExtracts only the fields needed by the driver\nIf molecule_index is provided, uses that molecule’s fragment count Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( driver_config_t ), intent(out) :: driver_config integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) public  subroutine config_to_system_geometry (mqc_config, sys_geom, error, molecule_index) Convert mqc_config_t geometry to system_geometry_t\nFor unfragmented calculations (nfrag=0), treats entire system as single unit\nFor fragmented calculations, currently assumes monomer-based fragmentation\nIf molecule_index is provided, uses that specific molecule from multi-molecule mode Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error integer, intent(in), optional :: molecule_index Which molecule to use (for multi-molecule mode) private  subroutine geometry_to_system_fragmented (mqc_config, sys_geom, use_angstrom, error) Convert geometry to system_geometry_t for fragmented calculation\nSupports both identical and variable-sized fragments Arguments Type Intent Optional Attributes Name type( mqc_config_t ), intent(in) :: mqc_config type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom type( error_t ), intent(out) :: error private  subroutine geometry_to_system_unfragmented (geom, sys_geom, use_angstrom) Convert geometry to system_geometry_t for unfragmented calculation\nTreats entire system as a single monomer Arguments Type Intent Optional Attributes Name type( geometry_type ), intent(in) :: geom type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom private  subroutine initialize_fragmented_system (nfrag, geom, fragments, charge, multiplicity, allow_overlapping, use_angstrom, sys_geom, error) Shared helper to initialize system_geometry_t for fragmented calculations\nHandles fragment allocation, size checking, and overlap validation Arguments Type Intent Optional Attributes Name integer, intent(in) :: nfrag type( geometry_type ), intent(in) :: geom type( input_fragment_t ), intent(in) :: fragments (:) integer, intent(in) :: charge integer, intent(in) :: multiplicity logical, intent(in) :: allow_overlapping logical, intent(in) :: use_angstrom type( system_geometry_t ), intent(out) :: sys_geom type( error_t ), intent(out) :: error private  subroutine molecule_to_system_geometry (mol, sys_geom, use_angstrom, allow_overlapping, error) Convert a molecule_t to system_geometry_t\nHandles both unfragmented (nfrag=0) and fragmented molecules Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: mol type( system_geometry_t ), intent(out) :: sys_geom logical, intent(in) :: use_angstrom logical, intent(in) :: allow_overlapping type( error_t ), intent(out) :: error","tags":"","url":"module/mqc_config_adapter.html"},{"title":"mqc_io_helpers – metalquicha","text":"Used by module~~mqc_io_helpers~~UsedByGraph module~mqc_io_helpers mqc_io_helpers module~mqc_driver mqc_driver module~mqc_driver->module~mqc_io_helpers module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_io->module~mqc_io_helpers proc~merge_multi_molecule_json merge_multi_molecule_json proc~merge_multi_molecule_json->module~mqc_io_helpers proc~read_json_content read_json_content proc~read_json_content->module~mqc_io_helpers proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_io_helpers program~main main program~main->module~mqc_io_helpers program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private, save :: current_basename = \"\" character(len=256), private, save :: output_json_filename = \"results.json\" Functions public  function ends_with (str, suffix) Check if string ends with suffix Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in) :: suffix Return Value logical public  function get_basename () result(basename) Get the base name without “output_” prefix and “.json” suffix\nExample: “output_w1.json” -> “w1” Arguments None Return Value character(len=256) public  function get_molecule_name (filename) result(name) Extract molecule name from filename\nExample: “output_multi_structure_molecule_1.json” -> “molecule_1” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Return Value character(len=256) public  function get_output_json_filename () result(filename) Get the current JSON output filename Arguments None Return Value character(len=256) Subroutines public  subroutine set_molecule_suffix (suffix) Append a suffix to the output filename (e.g., for multi-molecule mode)\nExample: suffix=”_mol1” -> “output_multi_structure_mol1.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: suffix public  subroutine set_output_json_filename (input_filename) Set the JSON output filename based on input filename\nExample: “water.mqc” -> “output_water.json” Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_filename","tags":"","url":"module/mqc_io_helpers.html"},{"title":"mqc_mbe_fragment_distribution_scheme – metalquicha","text":"Implements hierarchical many-body expansion for fragment-based quantum chemistry\ncalculations with MPI parallelization and energy/gradient computation. Uses omp_lib mqc_mbe mqc_method_xtb pic_blas_interfaces mqc_mbe_io pic_logger mqc_mpi_tags mqc_physical_fragment pic_timer mqc_calc_types mqc_method_types pic_mpi_lib mqc_config_parser pic_io pic_types mqc_result_types module~~mqc_mbe_fragment_distribution_scheme~~UsesGraph module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_calc_types mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_config_parser mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_types mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_calc_types->pic_types module~mqc_config_parser->module~mqc_calc_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_error mqc_error module~mqc_config_parser->module~mqc_error module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_io_helpers mqc_io_helpers module~mqc_mbe_io->module~mqc_io_helpers module~mqc_method_types->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_timer module~mqc_method_xtb->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mbe_fragment_distribution_scheme~~UsedByGraph module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine distributed_unfragmented_hessian (world_comm, sys_geom, method) Compute Hessian for unfragmented system using MPI distribution Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method public  subroutine do_fragment_work (fragment_idx, result, method, phys_frag, calc_type) Process a single fragment for quantum chemistry calculation Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: fragment_idx Fragment index for identification type( calculation_result_t ), intent(out) :: result Computation results integer(kind=int32), intent(in) :: method QC method type( physical_fragment_t ), intent(in), optional :: phys_frag Fragment geometry integer(kind=int32), intent(in), optional :: calc_type Calculation type public  subroutine global_coordinator (world_comm, node_comm, total_fragments, polymers, max_level, node_leader_ranks, num_nodes, sys_geom, calc_type, bonds) Global coordinator for distributing fragments to node coordinators\nwill act as a node coordinator for a single node calculation\nUses int64 for total_fragments to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in), optional :: calc_type type( bond_t ), intent(in), optional :: bonds (:) public  subroutine node_coordinator (world_comm, node_comm, calc_type) Node coordinator for distributing fragments to local workers\nHandles work requests and result collection from local workers Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm integer(kind=int32), intent(in), optional :: calc_type public  subroutine node_worker (world_comm, node_comm, sys_geom, method, calc_type, bonds) Node worker for processing fragments assigned by node coordinator Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in), optional :: calc_type type( bond_t ), intent(in), optional :: bonds (:) public  subroutine serial_fragment_processor (total_fragments, polymers, max_level, sys_geom, method, calc_type, bonds) Process all fragments serially in single-rank mode\nThis is used when running with only 1 MPI rank Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in), optional :: calc_type type( bond_t ), intent(in), optional :: bonds (:) public  subroutine unfragmented_calculation (sys_geom, method, calc_type, bonds) Run unfragmented calculation on the entire system (nlevel=0)\nThis is a simple single-process calculation without MPI distribution Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom integer(kind=int32), intent(in) :: method integer(kind=int32), intent(in), optional :: calc_type type( bond_t ), intent(in), optional :: bonds (:) private  subroutine hessian_coordinator (world_comm, sys_geom, method) Coordinator for distributed Hessian calculation\nDistributes displacement work and collects gradient results Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method private  subroutine hessian_worker (world_comm, sys_geom, method) Worker for distributed Hessian calculation\nRequests displacement indices, computes gradients, and sends results back Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type( system_geometry_t ), intent(in) :: sys_geom integer(kind=int32), intent(in) :: method private  subroutine send_fragment_to_node (world_comm, fragment_idx, polymers, dest_rank) Send fragment data to remote node coordinator\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank private  subroutine send_fragment_to_worker (node_comm, fragment_idx, polymers, dest_rank) Send fragment data to local worker\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank","tags":"","url":"module/mqc_mbe_fragment_distribution_scheme.html"},{"title":"mqc_basis_reader – metalquicha","text":"Gaussian basis set parser and molecular basis construction Provides utilities for parsing Gaussian-type orbital basis sets\nfrom text files and building molecular basis sets for quantum calculations.\nDetermine basis file line type\nParse basis for single element\nBuild complete molecular basis\nConvert angular momentum character to integer\nConvert angular momentum integer to character Uses mqc_basis_file_reader pic_types mqc_error mqc_cgto module~~mqc_basis_reader~~UsesGraph module~mqc_basis_reader mqc_basis_reader module~mqc_basis_file_reader mqc_basis_file_reader module~mqc_basis_reader->module~mqc_basis_file_reader module~mqc_cgto mqc_cgto module~mqc_basis_reader->module~mqc_cgto module~mqc_error mqc_error module~mqc_basis_reader->module~mqc_error pic_types pic_types module~mqc_basis_reader->pic_types module~mqc_basis_file_reader->pic_types module~mqc_cgto->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: LINE_ATOM = 1 Element specification line integer, public, parameter :: LINE_FUNCTION = 3 Basis function coefficient line integer, public, parameter :: LINE_SHELL = 2 Shell definition line integer, public, parameter :: LINE_UNKNOWN = 0 Unrecognized line type Functions public pure function ang_mom_char_to_int (ang_mom_char) result(ang_mom) Convert angular momentum character to integer Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ang_mom_char Angular momentum symbol Return Value integer Corresponding integer value public pure function ang_mom_int_to_char (ang_mom) result(ang_mom_char) Convert angular momentum integer to character Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ang_mom Angular momentum quantum number Return Value character(len=1) Corresponding symbol character public pure function classify_line (line) result(line_type) Classify a line from a gamess formatted basis set file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer private pure function is_blank_or_control (line) result(res) Check if a line is blank or a control line (starts with ‘$’) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical private pure function is_function_line (line) result(res) Check if a line is a function coefficient line (starts with a number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical private pure function is_shell_header (line) result(res) Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Subroutines public  subroutine build_molecular_basis (basis_string, element_names, mol_basis, error) Build molecular basis from geometry and basis file\nOnly parses unique elements, then copies basis data to atoms Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_names (:) Element for each atom in geometry order type( molecular_basis_type ), intent(out) :: mol_basis type( error_t ), intent(out) :: error public pure subroutine parse_element_basis (basis_string, element_name, atom_basis, error) Parse basis set for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(out) :: atom_basis type( error_t ), intent(out) :: error private pure subroutine copy_atomic_basis (source, dest) Deep copy of atomic basis data from source to dest Arguments Type Intent Optional Attributes Name type( atomic_basis_type ), intent(in) :: source type( atomic_basis_type ), intent(out) :: dest private pure subroutine count_shells_for_element (basis_string, element_name, nshells, error) Count the number of shells for a specific element in a GAMESS formatted basis string, Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name integer, intent(out) :: nshells type( error_t ), intent(out) :: error private pure subroutine fill_element_basis (basis_string, element_name, atom_basis, error) Fill in the shell data for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(inout) :: atom_basis type( error_t ), intent(out) :: error private pure subroutine find_unique_strings (input_array, unique_array, nunique) Find unique strings in an array\nReturns array of unique strings and count Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_array (:) character(len=:), intent(out), allocatable :: unique_array (:) integer, intent(out) :: nunique private pure subroutine get_next_line (string, line_start, line, line_end) Extract the next line from a string starting at line_start Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: line_start character(len=*), intent(out) :: line integer, intent(out) :: line_end private pure subroutine parse_function_line (line, func_num, exponent, coeff_s, coeff_p, has_p, stat) Parse function line (e.g., “1 1.0 2.0” or “1 1.0 2.0 3.0” for L shells) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(out) :: func_num real(kind=dp), intent(out) :: exponent real(kind=dp), intent(out) :: coeff_s real(kind=dp), intent(out), optional :: coeff_p logical, intent(out) :: has_p integer, intent(out) :: stat private pure subroutine parse_shell_header (line, ang_mom, nfunc, stat) Parse shell header line (e.g., “S 2” or “L 3”) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(out) :: ang_mom integer, intent(out) :: nfunc integer, intent(out) :: stat","tags":"","url":"module/mqc_basis_reader.html"},{"title":"mqc_frag_utils – metalquicha","text":"Provides combinatorial functions and algorithms for generating molecular\nfragments, managing fragment lists, and performing many-body expansion calculations. This module re-exports functionality from specialized modules:\n- mqc_combinatorics: Pure combinatorial mathematics\n- mqc_fragment_lookup: Hash-based fragment index lookup\n- mqc_gmbe_utils: GMBE intersection and PIE enumeration Uses mqc_gmbe_utils mqc_fragment_lookup mqc_combinatorics module~~mqc_frag_utils~~UsesGraph module~mqc_frag_utils mqc_frag_utils module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils pic_types pic_types module~mqc_combinatorics->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_fragment_lookup->pic_types pic_io pic_io module~mqc_gmbe_utils->pic_io pic_logger pic_logger module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_frag_utils~~UsedByGraph module~mqc_frag_utils mqc_frag_utils module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe program~main main program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module/mqc_frag_utils.html"},{"title":"mqc_method_types – metalquicha","text":"Defines integer constants for quantum chemistry methods to avoid string comparisons\nthroughout the codebase. Provides conversion utilities between string\nrepresentations and integer constants. Uses pic_types module~~mqc_method_types~~UsesGraph module~mqc_method_types mqc_method_types pic_types pic_types module~mqc_method_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_types~~UsedByGraph module~mqc_method_types mqc_method_types module~mqc_config_parser mqc_config_parser module~mqc_config_parser->module~mqc_method_types module~mqc_driver mqc_driver module~mqc_driver->module~mqc_method_types module~mqc_driver->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_config_adapter mqc_config_adapter module~mqc_driver->module~mqc_config_adapter module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_physical_fragment mqc_physical_fragment module~mqc_driver->module~mqc_physical_fragment module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_physical_fragment->module~mqc_config_parser proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->module~mqc_config_parser proc~compute_gmbe_energy_gradient->module~mqc_physical_fragment proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->module~mqc_config_parser proc~compute_gmbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->module~mqc_config_parser proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->module~mqc_config_parser proc~compute_mbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_config_parser proc~run_multi_molecule_calculations->module~mqc_config_adapter program~main main program~main->module~mqc_config_parser program~main->module~mqc_driver program~main->module~mqc_config_adapter program~main->module~mqc_physical_fragment module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: METHOD_TYPE_GFN1 = 1 integer(kind=int32), public, parameter :: METHOD_TYPE_GFN2 = 2 integer(kind=int32), public, parameter :: METHOD_TYPE_HF = 3 integer(kind=int32), public, parameter :: METHOD_TYPE_UNKNOWN = 0 Functions public pure function method_type_from_string (method_str) result(method_type) Convert method type string to integer constant Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: method_str Input string (e.g., “gfn1”, “gfn2”, “hf”) Return Value integer(kind=int32) Output integer constant public pure function method_type_to_string (method_type) result(method_str) Convert method type integer constant to string Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: method_type Input integer constant Return Value character(len=:), allocatable Output string representation","tags":"","url":"module/mqc_method_types.html"},{"title":"mqc_error – metalquicha","text":"Error codes Used by module~~mqc_error~~UsedByGraph module~mqc_error mqc_error module~mqc_basis_reader mqc_basis_reader module~mqc_basis_reader->module~mqc_error module~mqc_basis_utils mqc_basis_utils module~mqc_basis_utils->module~mqc_error module~mqc_cli_parser mqc_cli_parser module~mqc_cli_parser->module~mqc_error module~mqc_cli_parser->module~mqc_basis_utils module~mqc_config_adapter mqc_config_adapter module~mqc_config_adapter->module~mqc_error module~mqc_config_parser mqc_config_parser module~mqc_config_adapter->module~mqc_config_parser module~mqc_physical_fragment mqc_physical_fragment module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_config_parser->module~mqc_error module~mqc_driver mqc_driver module~mqc_driver->module~mqc_error module~mqc_driver->module~mqc_config_adapter module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_physical_fragment->module~mqc_error module~mqc_physical_fragment->module~mqc_config_parser module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_xyz_reader->module~mqc_error proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_error proc~run_multi_molecule_calculations->module~mqc_config_adapter proc~run_multi_molecule_calculations->module~mqc_config_parser program~main main program~main->module~mqc_error program~main->module~mqc_config_adapter program~main->module~mqc_config_parser program~main->module~mqc_driver program~main->module~mqc_physical_fragment module~mqc_finite_differences mqc_finite_differences module~mqc_finite_differences->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base proc~check_fragment_overlap check_fragment_overlap proc~check_fragment_overlap->module~mqc_config_parser proc~compute_gmbe_energy_gradient compute_gmbe_energy_gradient proc~compute_gmbe_energy_gradient->module~mqc_config_parser proc~compute_gmbe_energy_gradient->module~mqc_physical_fragment proc~compute_gmbe_energy_gradient_hessian compute_gmbe_energy_gradient_hessian proc~compute_gmbe_energy_gradient_hessian->module~mqc_config_parser proc~compute_gmbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~compute_mbe_energy_gradient->module~mqc_config_parser proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~compute_mbe_energy_gradient_hessian->module~mqc_config_parser proc~compute_mbe_energy_gradient_hessian->module~mqc_physical_fragment proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_gradient->module~mqc_config_parser proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_hessian->module~mqc_config_parser proc~compute_polymer_atoms compute_polymer_atoms proc~compute_polymer_atoms->module~mqc_physical_fragment proc~generate_intersections generate_intersections proc~generate_intersections->module~mqc_physical_fragment proc~generate_k_way_intersections_for_level generate_k_way_intersections_for_level proc~generate_k_way_intersections_for_level->module~mqc_physical_fragment proc~generate_polymer_intersections generate_polymer_intersections proc~generate_polymer_intersections->module~mqc_physical_fragment proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~gmbe_enumerate_pie_terms->module~mqc_physical_fragment proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~gmbe_pie_coordinator->module~mqc_physical_fragment proc~initialize_fragmented_system initialize_fragmented_system proc~initialize_fragmented_system->module~mqc_config_parser proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~map_fragment_to_system_gradient->module~mqc_config_parser proc~map_fragment_to_system_gradient->module~mqc_physical_fragment proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~map_fragment_to_system_hessian->module~mqc_config_parser proc~map_fragment_to_system_hessian->module~mqc_physical_fragment proc~molecule_to_system_geometry molecule_to_system_geometry proc~molecule_to_system_geometry->module~mqc_config_parser proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~serial_gmbe_pie_processor->module~mqc_physical_fragment proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~distributed_unfragmented_hessian->module~mqc_finite_differences proc~distributed_unfragmented_hessian->module~mqc_method_xtb proc~hessian_coordinator hessian_coordinator proc~hessian_coordinator->module~mqc_finite_differences proc~hessian_coordinator->module~mqc_method_xtb proc~hessian_worker hessian_worker proc~hessian_worker->module~mqc_finite_differences proc~hessian_worker->module~mqc_method_xtb proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~xtb_calc_hessian->module~mqc_finite_differences Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: ERROR_GENERIC = 1 integer, public, parameter :: ERROR_IO = 2 integer, public, parameter :: ERROR_PARSE = 3 integer, public, parameter :: ERROR_VALIDATION = 4 Unified error type integer, public, parameter :: SUCCESS = 0 Derived Types type, public :: error_t Components Type Visibility Attributes Name Initial integer, public :: code = SUCCESS Error code (0 = no error) character(len=:), public, allocatable :: message Error message Type-Bound Procedures procedure, public :: clear => error_clear procedure, public :: get_code => error_get_code procedure, public :: get_message => error_get_message procedure, public :: has_error => error_has_error procedure, public :: set => error_set Functions private pure function error_get_code (this) result(code) Get the error code Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value integer private pure function error_get_message (this) result(message) Get the error message Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value character(len=:), allocatable private pure function error_has_error (this) result(has_err) Check if an error is set Arguments Type Intent Optional Attributes Name class( error_t ), intent(in) :: this Return Value logical Subroutines private pure subroutine error_clear (this) Clear the error state Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this private pure subroutine error_set (this, code, message) Set an error with code and message Arguments Type Intent Optional Attributes Name class( error_t ), intent(inout) :: this integer, intent(in) :: code character(len=*), intent(in) :: message","tags":"","url":"module/mqc_error.html"},{"title":"mqc_gmbe_utils – metalquicha","text":"Provides functions for computing fragment intersections, generating k-way\nintersections, and enumerating PIE (Principle of Inclusion-Exclusion) terms\nfor GMBE calculations with overlapping molecular fragments.\nFind shared atoms between two fragments\nGenerate all k-way intersections for GMBE\nCompute atom list for polymer (union of fragments)\nGenerate intersections for polymers\nDFS-based PIE coefficient enumeration Uses pic_logger pic_types pic_io module~~mqc_gmbe_utils~~UsesGraph module~mqc_gmbe_utils mqc_gmbe_utils pic_io pic_io module~mqc_gmbe_utils->pic_io pic_logger pic_logger module~mqc_gmbe_utils->pic_logger pic_types pic_types module~mqc_gmbe_utils->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_gmbe_utils~~UsedByGraph module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils mqc_frag_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe program~main main program~main->module~mqc_driver module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function find_fragment_intersection (frag1_atoms, n1, frag2_atoms, n2, intersection, n_intersect) result(has_intersection) Find shared atoms between two fragments (for GMBE with overlapping fragments) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag1_atoms (:) Atom indices in fragment 1 (0-indexed) integer, intent(in) :: n1 Number of atoms in fragment 1 integer, intent(in) :: frag2_atoms (:) Atom indices in fragment 2 (0-indexed) integer, intent(in) :: n2 Number of atoms in fragment 2 integer, intent(out), allocatable :: intersection (:) Shared atom indices integer, intent(out) :: n_intersect Number of shared atoms Return Value logical private  function atom_sets_equal (set1, set2, n_atoms) result(equal) Check if two atom sets are equal (assuming sorted) Arguments Type Intent Optional Attributes Name integer, intent(in) :: set1 (:) integer, intent(in) :: set2 (:) integer, intent(in) :: n_atoms Return Value logical private  function next_combination (combination, k, n) result(has_next) Generate next combination in lexicographic order\nReturns .true. if there’s a next combination, .false. if we’ve exhausted all Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k integer, intent(in) :: n Return Value logical Subroutines public  subroutine compute_polymer_atoms (sys_geom, polymer, polymer_size, atom_list, n_atoms) Compute the atom list for a polymer (union of atoms from base fragments)\npolymer(:) contains base fragment indices (1-based) Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymer (:) Base fragment indices in this polymer integer, intent(in) :: polymer_size Number of base fragments in polymer integer, intent(out), allocatable :: atom_list (:) Unique atoms in this polymer integer, intent(out) :: n_atoms Number of unique atoms public  subroutine generate_intersections (sys_geom, monomers, polymers, n_monomers, max_intersection_level, intersections, intersection_sets, intersection_levels, n_intersections) Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) Monomer indices integer, intent(inout) :: polymers (:,:) Output: monomers stored here integer, intent(in) :: n_monomers Number of monomers integer, intent(in) :: max_intersection_level Maximum k-way intersection depth integer, intent(out), allocatable :: intersections (:,:) Intersection atom lists integer, intent(out), allocatable :: intersection_sets (:,:) Which k-tuple created each intersection integer, intent(out), allocatable :: intersection_levels (:) Level (k) of each intersection integer, intent(out) :: n_intersections Number of intersections found public  subroutine generate_polymer_intersections (sys_geom, polymers, n_polymers, max_level, intersections, intersection_sets, intersection_levels, n_intersections) Generate all k-way intersections for polymers at any level (GMBE-N)\nThis works with dynamically generated polymers, not just base fragments Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: polymers (:,:) Polymer definitions (n_polymers, max_level) integer, intent(in) :: n_polymers integer, intent(in) :: max_level integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections public  subroutine gmbe_enumerate_pie_terms (sys_geom, primaries, n_primaries, polymer_level, max_k_level, pie_atom_sets, pie_coefficients, n_pie_terms) Enumerate all unique intersections via DFS and accumulate PIE coefficients\nThis implements the GMBE(N) algorithm with inclusion-exclusion principle Read more… Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: primaries (:,:) Primary polymers (n_primaries, polymer_level) integer, intent(in) :: n_primaries Number of primary polymers integer, intent(in) :: polymer_level Level of primaries (1=monomers, 2=dimers, etc.) integer, intent(in) :: max_k_level Maximum clique size (intersection depth limit) integer, intent(out), allocatable :: pie_atom_sets (:,:) Unique atom sets (max_atoms, n_terms) integer, intent(out), allocatable :: pie_coefficients (:) PIE coefficient for each term integer, intent(out) :: n_pie_terms Number of unique PIE terms private recursive subroutine dfs_pie_accumulate (primary_atoms, primary_n_atoms, n_primaries, max_atoms, clique, clique_size, current_atoms, n_current_atoms, candidates, n_candidates, max_k_level, atom_sets, coefficients, n_terms, max_terms) DFS helper: accumulate PIE coefficients for intersections Arguments Type Intent Optional Attributes Name integer, intent(in) :: primary_atoms (:,:) Precomputed atom lists integer, intent(in) :: primary_n_atoms (:) Atom counts integer, intent(in) :: n_primaries integer, intent(in) :: max_atoms integer, intent(in) :: clique (:) Current clique integer, intent(in) :: clique_size Size of current clique integer, intent(in) :: current_atoms (:) Atoms in current intersection integer, intent(in) :: n_current_atoms Number of atoms in intersection integer, intent(in) :: candidates (:) Candidate primaries integer, intent(in) :: n_candidates integer, intent(in) :: max_k_level integer, intent(inout) :: atom_sets (:,:) integer, intent(inout) :: coefficients (:) integer, intent(inout) :: n_terms integer, intent(in) :: max_terms private  subroutine generate_intersections_from_atom_lists (atom_lists, n_atoms_list, n_sets, max_k_level, intersections, intersection_sets, intersection_levels, n_intersections) Generate k-way intersections from arbitrary atom lists (not tied to sys_geom)\nmax_k_level limits the maximum intersection order to prevent combinatorial explosion Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) (max_atoms, n_sets) integer, intent(in) :: n_atoms_list (:) Number of atoms in each set integer, intent(in) :: n_sets Number of sets (polymers) integer, intent(in) :: max_k_level Maximum intersection level to compute integer, intent(out), allocatable :: intersections (:,:) integer, intent(out), allocatable :: intersection_sets (:,:) integer, intent(out), allocatable :: intersection_levels (:) integer, intent(out) :: n_intersections private recursive subroutine generate_k_way_intersections_for_level (sys_geom, monomers, n_monomers, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Helper to generate all k-way intersections at a specific level k Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomers (:) integer, intent(in) :: n_monomers integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count private  subroutine generate_k_way_intersections_from_lists (atom_lists, n_atoms_list, n_sets, k, combination, max_atoms, temp_intersections, temp_sets, temp_levels, intersection_count) Generate all k-way intersections from atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atom_lists (:,:) integer, intent(in) :: n_atoms_list (:) integer, intent(in) :: n_sets integer, intent(in) :: k integer, intent(inout) :: combination (:) integer, intent(in) :: max_atoms integer, intent(inout) :: temp_intersections (:,:) integer, intent(inout) :: temp_sets (:,:) integer, intent(inout) :: temp_levels (:) integer, intent(inout) :: intersection_count private  subroutine intersect_atom_lists (atoms1, n1, atoms2, n2, intersection, n_intersect) Compute intersection of two atom lists Arguments Type Intent Optional Attributes Name integer, intent(in) :: atoms1 (:) integer, intent(in) :: n1 integer, intent(in) :: atoms2 (:) integer, intent(in) :: n2 integer, intent(out) :: intersection (:) integer, intent(out) :: n_intersect private  subroutine next_combination_init (combination, k) Initialize combination to [1, 2, …, k] Arguments Type Intent Optional Attributes Name integer, intent(inout) :: combination (:) integer, intent(in) :: k","tags":"","url":"module/mqc_gmbe_utils.html"},{"title":"mqc_json – metalquicha","text":"Uses pic_logger pic_io module~~mqc_json~~UsesGraph module~mqc_json mqc_json pic_io pic_io module~mqc_json->pic_io pic_logger pic_logger module~mqc_json->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_json~~UsedByGraph module~mqc_json mqc_json module~mqc_driver mqc_driver module~mqc_driver->module~mqc_json proc~run_multi_molecule_calculations run_multi_molecule_calculations proc~run_multi_molecule_calculations->module~mqc_json program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine merge_multi_molecule_json (individual_files, nmol) Merge individual molecule JSON files into a single combined file Arguments Type Intent Optional Attributes Name character(len=256), intent(in) :: individual_files (:) integer, intent(in) :: nmol private  subroutine read_json_content (unit_in, mol_index, unit_out, filename) Read and write JSON content from an individual molecule file\nProperly handles nested structures from fragmented calculations Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit_in integer, intent(in) :: mol_index integer, intent(in) :: unit_out character(len=*), intent(in) :: filename","tags":"","url":"module/mqc_json.html"},{"title":"main – metalquicha","text":"Uses mqc_driver mqc_error pic_logger mqc_io_helpers mqc_physical_fragment pic_timer pic_mpi_lib mqc_config_adapter mqc_config_parser pic_io mqc_logo program~~main~~UsesGraph program~main main module~mqc_config_adapter mqc_config_adapter program~main->module~mqc_config_adapter module~mqc_config_parser mqc_config_parser program~main->module~mqc_config_parser module~mqc_driver mqc_driver program~main->module~mqc_driver module~mqc_error mqc_error program~main->module~mqc_error module~mqc_io_helpers mqc_io_helpers program~main->module~mqc_io_helpers module~mqc_logo mqc_logo program~main->module~mqc_logo module~mqc_physical_fragment mqc_physical_fragment program~main->module~mqc_physical_fragment pic_io pic_io program~main->pic_io pic_logger pic_logger program~main->pic_logger pic_mpi_lib pic_mpi_lib program~main->pic_mpi_lib pic_timer pic_timer program~main->pic_timer module~mqc_config_adapter->module~mqc_config_parser module~mqc_config_adapter->module~mqc_error module~mqc_config_adapter->module~mqc_physical_fragment module~mqc_elements mqc_elements module~mqc_config_adapter->module~mqc_elements pic_types pic_types module~mqc_config_adapter->pic_types module~mqc_config_parser->module~mqc_error module~mqc_calc_types mqc_calc_types module~mqc_config_parser->module~mqc_calc_types module~mqc_geometry mqc_geometry module~mqc_config_parser->module~mqc_geometry module~mqc_method_types mqc_method_types module~mqc_config_parser->module~mqc_method_types module~mqc_config_parser->pic_types module~mqc_driver->module~mqc_config_adapter module~mqc_driver->module~mqc_config_parser module~mqc_driver->module~mqc_error module~mqc_driver->module~mqc_io_helpers module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->pic_io module~mqc_driver->pic_logger module~mqc_driver->pic_mpi_lib module~mqc_driver->module~mqc_calc_types module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_gmbe_fragment_distribution_scheme mqc_gmbe_fragment_distribution_scheme module~mqc_driver->module~mqc_gmbe_fragment_distribution_scheme module~mqc_json mqc_json module~mqc_driver->module~mqc_json module~mqc_mbe mqc_mbe module~mqc_driver->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_method_types module~mqc_result_types mqc_result_types module~mqc_driver->module~mqc_result_types omp_lib omp_lib module~mqc_driver->omp_lib module~mqc_driver->pic_types module~mqc_physical_fragment->module~mqc_config_parser module~mqc_physical_fragment->module~mqc_error module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_calc_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_combinatorics mqc_combinatorics module~mqc_frag_utils->module~mqc_combinatorics module~mqc_fragment_lookup mqc_fragment_lookup module~mqc_frag_utils->module~mqc_fragment_lookup module~mqc_gmbe_utils mqc_gmbe_utils module~mqc_frag_utils->module~mqc_gmbe_utils module~mqc_geometry->pic_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_gmbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_gmbe_fragment_distribution_scheme->pic_io module~mqc_gmbe_fragment_distribution_scheme->pic_logger module~mqc_gmbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_gmbe_fragment_distribution_scheme->pic_timer module~mqc_gmbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_fragment_distribution_scheme module~mqc_gmbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_gmbe_fragment_distribution_scheme->pic_types module~mqc_mbe_io mqc_mbe_io module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mpi_tags mqc_mpi_tags module~mqc_gmbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_json->pic_io module~mqc_json->pic_logger module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_config_parser module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->pic_io module~mqc_mbe_fragment_distribution_scheme->pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_timer module~mqc_mbe_fragment_distribution_scheme->module~mqc_calc_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_mbe_fragment_distribution_scheme->omp_lib module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces module~mqc_method_types->pic_types module~mqc_result_types->pic_mpi_lib module~mqc_result_types->pic_types module~mqc_xyz_reader->module~mqc_error module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_combinatorics->pic_types module~mqc_fragment_lookup->pic_types pic_hash_32bit pic_hash_32bit module~mqc_fragment_lookup->pic_hash_32bit pic_sorting pic_sorting module~mqc_fragment_lookup->pic_sorting module~mqc_gmbe_utils->pic_io module~mqc_gmbe_utils->pic_logger module~mqc_gmbe_utils->pic_types module~mqc_mbe_io->module~mqc_io_helpers module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->module~mqc_elements module~mqc_mbe_io->module~mqc_result_types module~mqc_mbe_io->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->pic_timer module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Orchestrates MPI initialization, input parsing, geometry loading,\nand dispatches to appropriate calculation routines (fragmented or unfragmented). Calls program~~main~~CallsGraph program~main main abort_comm abort_comm program~main->abort_comm comm_world comm_world program~main->comm_world configure configure program~main->configure error error program~main->error finalize finalize program~main->finalize get_elapsed_time get_elapsed_time program~main->get_elapsed_time info info program~main->info pic_mpi_finalize pic_mpi_finalize program~main->pic_mpi_finalize pic_mpi_init pic_mpi_init program~main->pic_mpi_init proc~config_to_driver config_to_driver program~main->proc~config_to_driver proc~config_to_system_geometry config_to_system_geometry program~main->proc~config_to_system_geometry proc~ends_with ends_with program~main->proc~ends_with proc~error_get_message error_t%error_get_message program~main->proc~error_get_message proc~error_has_error error_t%error_has_error program~main->proc~error_has_error proc~get_logger_level get_logger_level program~main->proc~get_logger_level proc~print_logo print_logo program~main->proc~print_logo proc~read_mqc_file read_mqc_file program~main->proc~read_mqc_file proc~run_calculation run_calculation program~main->proc~run_calculation proc~run_multi_molecule_calculations run_multi_molecule_calculations program~main->proc~run_multi_molecule_calculations proc~set_output_json_filename set_output_json_filename program~main->proc~set_output_json_filename proc~system_destroy system_geometry_t%system_destroy program~main->proc~system_destroy split split program~main->split start start program~main->start to_char to_char program~main->to_char proc~config_to_system_geometry->proc~error_has_error proc~error_set error_t%error_set proc~config_to_system_geometry->proc~error_set proc~geometry_to_system_fragmented geometry_to_system_fragmented proc~config_to_system_geometry->proc~geometry_to_system_fragmented proc~geometry_to_system_unfragmented geometry_to_system_unfragmented proc~config_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry molecule_to_system_geometry proc~config_to_system_geometry->proc~molecule_to_system_geometry proc~read_mqc_file->proc~error_has_error proc~read_mqc_file->proc~error_set proc~parse_connectivity_section parse_connectivity_section proc~read_mqc_file->proc~parse_connectivity_section proc~parse_driver_section parse_driver_section proc~read_mqc_file->proc~parse_driver_section proc~parse_fragmentation_section parse_fragmentation_section proc~read_mqc_file->proc~parse_fragmentation_section proc~parse_fragments_section parse_fragments_section proc~read_mqc_file->proc~parse_fragments_section proc~parse_geometry_section parse_geometry_section proc~read_mqc_file->proc~parse_geometry_section proc~parse_model_section parse_model_section proc~read_mqc_file->proc~parse_model_section proc~parse_molecules_section parse_molecules_section proc~read_mqc_file->proc~parse_molecules_section proc~parse_scf_section parse_scf_section proc~read_mqc_file->proc~parse_scf_section proc~parse_schema_section parse_schema_section proc~read_mqc_file->proc~parse_schema_section proc~parse_structure_section parse_structure_section proc~read_mqc_file->proc~parse_structure_section proc~parse_system_section parse_system_section proc~read_mqc_file->proc~parse_system_section proc~skip_to_end skip_to_end proc~read_mqc_file->proc~skip_to_end proc~run_calculation->info proc~run_calculation->to_char omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation warning warning proc~run_calculation->warning proc~run_multi_molecule_calculations->abort_comm proc~run_multi_molecule_calculations->error proc~run_multi_molecule_calculations->info proc~run_multi_molecule_calculations->proc~config_to_driver proc~run_multi_molecule_calculations->proc~config_to_system_geometry proc~run_multi_molecule_calculations->proc~error_get_message proc~run_multi_molecule_calculations->proc~error_has_error proc~run_multi_molecule_calculations->proc~run_calculation proc~run_multi_molecule_calculations->proc~system_destroy proc~run_multi_molecule_calculations->to_char barrier barrier proc~run_multi_molecule_calculations->barrier proc~get_output_json_filename get_output_json_filename proc~run_multi_molecule_calculations->proc~get_output_json_filename proc~merge_multi_molecule_json merge_multi_molecule_json proc~run_multi_molecule_calculations->proc~merge_multi_molecule_json proc~set_molecule_suffix set_molecule_suffix proc~run_multi_molecule_calculations->proc~set_molecule_suffix verbose verbose proc~run_multi_molecule_calculations->verbose proc~initialize_fragmented_system initialize_fragmented_system proc~geometry_to_system_fragmented->proc~initialize_fragmented_system proc~element_symbol_to_number element_symbol_to_number proc~geometry_to_system_unfragmented->proc~element_symbol_to_number proc~to_bohr to_bohr proc~geometry_to_system_unfragmented->proc~to_bohr proc~merge_multi_molecule_json->error proc~merge_multi_molecule_json->info proc~merge_multi_molecule_json->to_char proc~read_json_content read_json_content proc~merge_multi_molecule_json->proc~read_json_content proc~molecule_to_system_geometry->proc~error_set proc~molecule_to_system_geometry->proc~geometry_to_system_unfragmented proc~molecule_to_system_geometry->proc~initialize_fragmented_system proc~parse_connectivity_generic parse_connectivity_generic proc~parse_connectivity_section->proc~parse_connectivity_generic proc~parse_driver_section->proc~error_set proc~calc_type_from_string calc_type_from_string proc~parse_driver_section->proc~calc_type_from_string proc~strip_comment strip_comment proc~parse_driver_section->proc~strip_comment proc~parse_fragmentation_section->proc~error_set proc~parse_fragmentation_section->proc~strip_comment proc~parse_fragments_generic parse_fragments_generic proc~parse_fragments_section->proc~parse_fragments_generic proc~parse_geometry_generic parse_geometry_generic proc~parse_geometry_section->proc~parse_geometry_generic proc~parse_model_section->proc~error_set proc~parse_method_string parse_method_string proc~parse_model_section->proc~parse_method_string proc~parse_model_section->proc~strip_comment proc~parse_molecules_section->proc~error_has_error proc~parse_molecules_section->proc~error_set proc~parse_molecules_section->proc~skip_to_end proc~parse_single_molecule parse_single_molecule proc~parse_molecules_section->proc~parse_single_molecule proc~parse_molecules_section->proc~strip_comment proc~parse_scf_section->proc~error_set proc~parse_scf_section->proc~strip_comment proc~parse_schema_section->proc~error_set proc~parse_schema_section->proc~strip_comment proc~parse_structure_generic parse_structure_generic proc~parse_structure_section->proc~parse_structure_generic proc~parse_system_section->proc~error_set proc~parse_system_section->proc~strip_comment proc~run_fragmented_calculation->info proc~run_fragmented_calculation->to_char proc~run_fragmented_calculation->omp_set_num_threads proc~run_fragmented_calculation->verbose allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~binomial binomial proc~run_fragmented_calculation->proc~binomial proc~combine combine proc~run_fragmented_calculation->proc~combine proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~gmbe_enumerate_pie_terms gmbe_enumerate_pie_terms proc~run_fragmented_calculation->proc~gmbe_enumerate_pie_terms proc~gmbe_pie_coordinator gmbe_pie_coordinator proc~run_fragmented_calculation->proc~gmbe_pie_coordinator proc~node_coordinator node_coordinator proc~run_fragmented_calculation->proc~node_coordinator proc~node_worker node_worker proc~run_fragmented_calculation->proc~node_worker proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->proc~serial_fragment_processor proc~serial_gmbe_pie_processor serial_gmbe_pie_processor proc~run_fragmented_calculation->proc~serial_gmbe_pie_processor proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char proc~run_unfragmented_calculation->verbose proc~calc_type_to_string calc_type_to_string proc~run_unfragmented_calculation->proc~calc_type_to_string proc~distributed_unfragmented_hessian distributed_unfragmented_hessian proc~run_unfragmented_calculation->proc~distributed_unfragmented_hessian proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~skip_to_end->proc~error_set proc~skip_to_end->proc~strip_comment proc~combine_util combine_util proc~combine->proc~combine_util proc~distributed_unfragmented_hessian->barrier proc~hessian_coordinator hessian_coordinator proc~distributed_unfragmented_hessian->proc~hessian_coordinator proc~hessian_worker hessian_worker proc~distributed_unfragmented_hessian->proc~hessian_worker to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~generate_fragment_list->proc~combine proc~get_nfrags->proc~binomial proc~global_coordinator->error proc~global_coordinator->get_elapsed_time proc~global_coordinator->info proc~global_coordinator->start proc~global_coordinator->to_char proc~global_coordinator->verbose debug debug proc~global_coordinator->debug iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend mbe_total_gradient mbe_total_gradient proc~global_coordinator->mbe_total_gradient mbe_total_hessian mbe_total_hessian proc~global_coordinator->mbe_total_hessian proc~compute_mbe_energy compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy proc~compute_mbe_energy_gradient compute_mbe_energy_gradient proc~global_coordinator->proc~compute_mbe_energy_gradient proc~compute_mbe_energy_gradient_hessian compute_mbe_energy_gradient_hessian proc~global_coordinator->proc~compute_mbe_energy_gradient_hessian proc~result_irecv result_irecv proc~global_coordinator->proc~result_irecv proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~gmbe_enumerate_pie_terms->info proc~gmbe_enumerate_pie_terms->to_char atom_list atom_list proc~gmbe_enumerate_pie_terms->atom_list proc~compute_polymer_atoms compute_polymer_atoms proc~gmbe_enumerate_pie_terms->proc~compute_polymer_atoms proc~dfs_pie_accumulate dfs_pie_accumulate proc~gmbe_enumerate_pie_terms->proc~dfs_pie_accumulate proc~gmbe_pie_coordinator->error proc~gmbe_pie_coordinator->get_elapsed_time proc~gmbe_pie_coordinator->info proc~gmbe_pie_coordinator->start proc~gmbe_pie_coordinator->to_char proc~gmbe_pie_coordinator->verbose configuration configuration proc~gmbe_pie_coordinator->configuration proc~gmbe_pie_coordinator->iprobe proc~gmbe_pie_coordinator->irecv proc~gmbe_pie_coordinator->isend proc~build_fragment_from_atom_list build_fragment_from_atom_list proc~gmbe_pie_coordinator->proc~build_fragment_from_atom_list proc~energy_total energy_t%energy_total proc~gmbe_pie_coordinator->proc~energy_total proc~fragment_destroy physical_fragment_t%fragment_destroy proc~gmbe_pie_coordinator->proc~fragment_destroy proc~print_gmbe_pie_json print_gmbe_pie_json proc~gmbe_pie_coordinator->proc~print_gmbe_pie_json proc~redistribute_cap_gradients redistribute_cap_gradients proc~gmbe_pie_coordinator->proc~redistribute_cap_gradients proc~redistribute_cap_hessian redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~redistribute_cap_hessian proc~gmbe_pie_coordinator->proc~result_irecv proc~send_pie_term_to_node send_pie_term_to_node proc~gmbe_pie_coordinator->proc~send_pie_term_to_node proc~send_pie_term_to_worker send_pie_term_to_worker proc~gmbe_pie_coordinator->proc~send_pie_term_to_worker proc~initialize_fragmented_system->proc~error_has_error proc~initialize_fragmented_system->proc~element_symbol_to_number proc~initialize_fragmented_system->proc~to_bohr proc~check_fragment_overlap check_fragment_overlap proc~initialize_fragmented_system->proc~check_fragment_overlap proc~node_coordinator->error proc~node_coordinator->to_char proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend proc~node_coordinator->proc~result_irecv proc~result_isend result_isend proc~node_coordinator->proc~result_isend recv recv proc~node_coordinator->recv proc~node_worker->error proc~node_worker->to_char proc~node_worker->irecv proc~node_worker->isend proc~node_worker->proc~build_fragment_from_atom_list proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~do_fragment_work do_fragment_work proc~node_worker->proc~do_fragment_work proc~node_worker->proc~fragment_destroy proc~node_worker->proc~result_isend proc~node_worker->recv proc~parse_connectivity_generic->proc~error_set proc~parse_connectivity_generic->proc~skip_to_end proc~parse_connectivity_generic->proc~strip_comment proc~parse_fragments_generic->proc~error_has_error proc~parse_fragments_generic->proc~error_set proc~parse_fragments_generic->proc~skip_to_end proc~parse_fragments_generic->proc~strip_comment proc~parse_fragment parse_fragment proc~parse_fragments_generic->proc~parse_fragment proc~parse_geometry_generic->proc~error_set proc~parse_geometry_generic->proc~strip_comment proc~method_type_from_string method_type_from_string proc~parse_method_string->proc~method_type_from_string proc~parse_single_molecule->proc~error_has_error proc~parse_single_molecule->proc~error_set proc~parse_single_molecule->proc~skip_to_end proc~parse_single_molecule->proc~strip_comment proc~parse_molecule_connectivity parse_molecule_connectivity proc~parse_single_molecule->proc~parse_molecule_connectivity proc~parse_molecule_fragments parse_molecule_fragments proc~parse_single_molecule->proc~parse_molecule_fragments proc~parse_molecule_geometry parse_molecule_geometry proc~parse_single_molecule->proc~parse_molecule_geometry proc~parse_molecule_structure parse_molecule_structure proc~parse_single_molecule->proc~parse_molecule_structure proc~parse_structure_generic->proc~error_set proc~parse_structure_generic->proc~strip_comment proc~read_json_content->error proc~get_molecule_name get_molecule_name proc~read_json_content->proc~get_molecule_name proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->info proc~serial_fragment_processor->start proc~serial_fragment_processor->to_char proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->verbose proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~calc_type_to_string proc~serial_fragment_processor->configuration proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy_gradient proc~serial_fragment_processor->proc~compute_mbe_energy_gradient_hessian proc~serial_fragment_processor->proc~do_fragment_work proc~serial_fragment_processor->proc~energy_total proc~serial_fragment_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->info proc~serial_gmbe_pie_processor->to_char proc~serial_gmbe_pie_processor->verbose proc~serial_gmbe_pie_processor->proc~calc_type_to_string proc~serial_gmbe_pie_processor->configuration proc~serial_gmbe_pie_processor->proc~build_fragment_from_atom_list proc~serial_gmbe_pie_processor->proc~do_fragment_work proc~serial_gmbe_pie_processor->proc~energy_total proc~serial_gmbe_pie_processor->proc~fragment_destroy proc~serial_gmbe_pie_processor->proc~print_gmbe_pie_json proc~serial_gmbe_pie_processor->proc~redistribute_cap_gradients proc~serial_gmbe_pie_processor->proc~redistribute_cap_hessian proc~unfragmented_calculation->error proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char proc~unfragmented_calculation->configuration proc~check_duplicate_atoms check_duplicate_atoms proc~unfragmented_calculation->proc~check_duplicate_atoms proc~unfragmented_calculation->proc~do_fragment_work proc~unfragmented_calculation->proc~energy_total proc~fragment_compute_nelec physical_fragment_t%fragment_compute_nelec proc~unfragmented_calculation->proc~fragment_compute_nelec proc~print_unfragmented_json print_unfragmented_json proc~unfragmented_calculation->proc~print_unfragmented_json proc~result_destroy calculation_result_t%result_destroy proc~unfragmented_calculation->proc~result_destroy proc~build_fragment_from_atom_list->proc~check_duplicate_atoms proc~build_fragment_from_atom_list->proc~fragment_compute_nelec proc~add_hydrogen_caps add_hydrogen_caps proc~build_fragment_from_atom_list->proc~add_hydrogen_caps proc~count_hydrogen_caps count_hydrogen_caps proc~build_fragment_from_atom_list->proc~count_hydrogen_caps proc~build_fragment_from_indices->proc~check_duplicate_atoms proc~build_fragment_from_indices->proc~fragment_compute_nelec proc~build_fragment_from_indices->proc~add_hydrogen_caps proc~build_fragment_from_indices->proc~count_hydrogen_caps proc~check_duplicate_atoms->error proc~check_duplicate_atoms->to_char proc~element_number_to_symbol element_number_to_symbol proc~check_duplicate_atoms->proc~element_number_to_symbol proc~check_fragment_overlap->to_char proc~check_fragment_overlap->proc~error_set proc~combine_util->proc~combine_util proc~compute_mbe_energy->get_elapsed_time proc~compute_mbe_energy->info proc~compute_mbe_energy->start proc~compute_mbe_energy->to_char proc~compute_mbe_energy->configuration proc~compute_mbe_energy->debug proc~compute_mbe_energy->proc~energy_total proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient->error proc~compute_mbe_energy_gradient->get_elapsed_time proc~compute_mbe_energy_gradient->info proc~compute_mbe_energy_gradient->start proc~compute_mbe_energy_gradient->to_char proc~compute_mbe_energy_gradient->configuration proc~compute_mbe_energy_gradient->debug proc~compute_mbe_energy_gradient->proc~energy_total proc~compute_mbe_energy_gradient->proc~compute_mbe proc~compute_mbe_gradient compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~compute_mbe_gradient proc~compute_mbe_energy_gradient->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient->proc~fragment_lookup_init proc~compute_mbe_energy_gradient->proc~fragment_lookup_insert proc~map_fragment_to_system_gradient map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~map_fragment_to_system_gradient proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown proc~compute_mbe_energy_gradient->proc~print_detailed_breakdown_json proc~compute_mbe_energy_gradient_hessian->error proc~compute_mbe_energy_gradient_hessian->info proc~compute_mbe_energy_gradient_hessian->to_char proc~compute_mbe_energy_gradient_hessian->configuration proc~compute_mbe_energy_gradient_hessian->proc~energy_total proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_gradient proc~compute_mbe_hessian compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~compute_mbe_hessian proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_destroy proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_init proc~compute_mbe_energy_gradient_hessian->proc~fragment_lookup_insert proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_gradient proc~map_fragment_to_system_hessian map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~map_fragment_to_system_hessian proc~compute_mbe_energy_gradient_hessian->proc~print_detailed_breakdown_json proc~dfs_pie_accumulate->error proc~dfs_pie_accumulate->to_char proc~dfs_pie_accumulate->proc~dfs_pie_accumulate new_clique new_clique proc~dfs_pie_accumulate->new_clique proc~atom_sets_equal atom_sets_equal proc~dfs_pie_accumulate->proc~atom_sets_equal proc~intersect_atom_lists intersect_atom_lists proc~dfs_pie_accumulate->proc~intersect_atom_lists test_intersect test_intersect proc~dfs_pie_accumulate->test_intersect proc~do_fragment_work->error proc~do_fragment_work->proc~calc_type_to_string proc~do_fragment_work->configuration proc~energy_reset energy_t%energy_reset proc~do_fragment_work->proc~energy_reset proc~method_type_to_string method_type_to_string proc~do_fragment_work->proc~method_type_to_string proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~do_fragment_work->proc~xtb_calc_gradient proc~xtb_calc_hessian xtb_method_t%xtb_calc_hessian proc~do_fragment_work->proc~xtb_calc_hessian proc~mp2_total mp2_energy_t%mp2_total proc~energy_total->proc~mp2_total proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~hessian_coordinator->get_elapsed_time proc~hessian_coordinator->info proc~hessian_coordinator->start proc~hessian_coordinator->to_char proc~hessian_coordinator->configuration proc~hessian_coordinator->iprobe proc~hessian_coordinator->irecv proc~hessian_coordinator->isend proc~hessian_coordinator->proc~energy_total proc~hessian_coordinator->proc~fragment_compute_nelec proc~hessian_coordinator->proc~print_unfragmented_json proc~hessian_coordinator->proc~result_destroy proc~hessian_coordinator->recv proc~finite_diff_hessian_from_gradients finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~finite_diff_hessian_from_gradients proc~hessian_coordinator->proc~method_type_to_string proc~hessian_coordinator->proc~xtb_calc_gradient proc~hessian_worker->abort_comm proc~hessian_worker->error proc~hessian_worker->to_char proc~hessian_worker->irecv proc~hessian_worker->isend proc~hessian_worker->proc~fragment_compute_nelec proc~hessian_worker->proc~result_destroy proc~copy_and_displace_geometry copy_and_displace_geometry proc~hessian_worker->proc~copy_and_displace_geometry proc~hessian_worker->proc~method_type_to_string proc~hessian_worker->proc~xtb_calc_gradient send send proc~hessian_worker->send proc~parse_fragment->proc~error_has_error proc~parse_fragment->proc~error_set proc~parse_fragment->proc~strip_comment proc~parse_indices_line parse_indices_line proc~parse_fragment->proc~parse_indices_line proc~parse_molecule_connectivity->proc~parse_connectivity_generic proc~parse_molecule_fragments->proc~parse_fragments_generic proc~parse_molecule_geometry->proc~parse_geometry_generic proc~parse_molecule_structure->proc~parse_structure_generic proc~print_gmbe_pie_json->error proc~print_gmbe_pie_json->info proc~print_gmbe_pie_json->proc~get_output_json_filename proc~get_basename get_basename proc~print_gmbe_pie_json->proc~get_basename proc~print_unfragmented_json->error proc~print_unfragmented_json->info proc~print_unfragmented_json->proc~get_output_json_filename proc~print_unfragmented_json->proc~energy_total proc~print_unfragmented_json->proc~get_basename proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset proc~result_irecv->irecv proc~result_irecv->recv proc~result_isend->isend proc~result_isend->send proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~send_pie_term_to_node->isend proc~send_pie_term_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( driver_config_t ) :: config Driver configuration character(len=:), allocatable :: errmsg Error messages for file I/O type( error_t ) :: error Error handling character(len=256) :: input_file Input file name type( mqc_config_t ) :: mqc_config Parsed .mqc file type(timer_type) :: my_timer Execution timing type(comm_t) :: node_comm Node-local MPI communicator integer :: stat Status code for file I/O type( system_geometry_t ) :: sys_geom Loaded molecular system type(comm_t) :: world_comm Global MPI communicator Source Code program main !! Orchestrates MPI initialization, input parsing, geometry loading, !! and dispatches to appropriate calculation routines (fragmented or unfragmented). use pic_logger , only : logger => global_logger , info_level use pic_io , only : to_char use pic_mpi_lib , only : pic_mpi_init , comm_world , comm_t , abort_comm , pic_mpi_finalize use mqc_driver , only : run_calculation , run_multi_molecule_calculations use mqc_physical_fragment , only : system_geometry_t use mqc_config_parser , only : mqc_config_t , read_mqc_file use mqc_config_adapter , only : driver_config_t , config_to_driver , config_to_system_geometry , get_logger_level use mqc_io_helpers , only : set_output_json_filename , ends_with use mqc_logo , only : print_logo use pic_timer , only : timer_type use mqc_error , only : error_t implicit none type ( timer_type ) :: my_timer !! Execution timing type ( comm_t ) :: world_comm !! Global MPI communicator type ( comm_t ) :: node_comm !! Node-local MPI communicator type ( driver_config_t ) :: config !! Driver configuration type ( mqc_config_t ) :: mqc_config !! Parsed .mqc file type ( system_geometry_t ) :: sys_geom !! Loaded molecular system type ( error_t ) :: error !! Error handling integer :: stat !! Status code for file I/O character ( len = :), allocatable :: errmsg !! Error messages for file I/O character ( len = 256 ) :: input_file !! Input file name ! Initialize MPI ! pic-mpi will call mpi_init_thread when needed call pic_mpi_init () ! Create communicators world_comm = comm_world () node_comm = world_comm % split () if ( world_comm % rank () == 0 ) then call print_logo () call my_timer % start () end if ! Parse command line arguments if ( command_argument_count () == 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"No input file specified. Usage: mqc input_file.mqc\" ) end if call abort_comm ( world_comm , 1 ) else if ( command_argument_count () == 1 ) then call get_command_argument ( 1 , input_file , status = stat ) if ( stat /= 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error reading command line argument\" ) end if call abort_comm ( world_comm , 1 ) end if input_file = trim ( input_file ) call set_output_json_filename ( input_file ) ! Validate file extension if (. not . ends_with ( input_file , '.mqc' )) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Invalid input file extension. Expected .mqc\" ) end if call abort_comm ( world_comm , 1 ) end if else if ( world_comm % rank () == 0 ) then call logger % error ( \"Too many arguments. Usage: metalquicha [input_file.mqc]\" ) end if call abort_comm ( world_comm , 1 ) end if ! Parse .mqc input file if ( world_comm % rank () == 0 ) then call logger % info ( \"Reading input file: \" // trim ( input_file )) end if call read_mqc_file ( input_file , mqc_config , error ) if ( error % has_error ()) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error reading .mqc file: \" // error % get_message ()) end if call abort_comm ( world_comm , 1 ) end if ! Configure logger if ( allocated ( mqc_config % log_level )) then call logger % configure ( get_logger_level ( mqc_config % log_level )) if ( world_comm % rank () == 0 ) then call logger % info ( \"Logger verbosity set to: \" // trim ( mqc_config % log_level )) end if end if ! Handle single vs multiple molecules if ( mqc_config % nmol == 0 ) then ! Single molecule mode (backward compatible) call config_to_driver ( mqc_config , config ) call config_to_system_geometry ( mqc_config , sys_geom , error ) if ( error % has_error ()) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error converting geometry: \" // error % get_message ()) end if call abort_comm ( world_comm , 1 ) end if call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % bonds ) call sys_geom % destroy () else ! Multi-molecule mode: loop over all molecules call run_multi_molecule_calculations ( world_comm , node_comm , mqc_config ) end if if ( world_comm % rank () == 0 ) then call my_timer % stop () call logger % info ( \"Total processing time: \" // to_char ( my_timer % get_elapsed_time ()) // \" s\" ) end if call mqc_config % destroy () call world_comm % finalize () call node_comm % finalize () call pic_mpi_finalize () end program main","tags":"","url":"program/main.html"},{"title":"mqc_method_hf.f90 – metalquicha","text":"Hartree-Fock method implementation for metalquicha This file depends on sourcefile~~mqc_method_hf.f90~~EfferentGraph sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Hartree-Fock method implementation for metalquicha module mqc_method_hf !! Implements the Hartree-Fock quantum chemistry method !! Provides energy and gradient calculations using a basic SCF procedure. use pic_types , only : dp use mqc_method_base , only : qc_method_t use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: hf_method_t , hf_options_t type :: hf_options_t !! Hartree-Fock calculation options integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: conv_tol = 1.0e-8_dp !! Energy convergence threshold logical :: spherical = . false . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . true . !! Print SCF iterations end type hf_options_t type , extends ( qc_method_t ) :: hf_method_t !! Hartree-Fock method implementation type ( hf_options_t ) :: options contains procedure :: calc_energy => hf_calc_energy procedure :: calc_gradient => hf_calc_gradient procedure :: calc_hessian => null_hessian !! Placeholder for Hessian calculation end type hf_method_t contains subroutine hf_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement actual HF calculation ! 1. Convert fragment%basis to libcint format ! 2. Build one-electron integrals (S, T, V) ! 3. Run SCF iterations ! 4. Calculate final energy print * , \"HF: Calculating energy for fragment with\" , fragment % n_atoms , \"atoms\" print * , \"HF: nelec =\" , fragment % nelec print * , \"HF: charge =\" , fragment % charge print * , \"HF: multiplicity =\" , fragment % multiplicity ! Dummy result result % energy % scf = - 1.0_dp ! Placeholder result % has_energy = . true . print * , \"HF: Dummy energy =\" , result % energy % total () end subroutine hf_calc_energy subroutine hf_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement gradient calculation ! 1. Calculate energy (call calc_energy) ! 2. Calculate gradient using integral derivatives print * , \"HF: Calculating gradient for fragment with\" , fragment % n_atoms , \"atoms\" ! First get energy call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . print * , \"HF: Dummy gradient allocated\" end subroutine hf_calc_gradient subroutine null_hessian ( this , fragment , result ) !! Placeholder for Hessian calculation class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result print * , \"HF: Hessian calculation not implemented yet.\" result % has_hessian = . false . end subroutine null_hessian end module mqc_method_hf","tags":"","url":"sourcefile/mqc_method_hf.f90.html"},{"title":"mqc_combinatorics.f90 – metalquicha","text":"Combinatorial mathematics utilities for fragment generation Files dependent on this one sourcefile~~mqc_combinatorics.f90~~AfferentGraph sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Combinatorial mathematics utilities for fragment generation module mqc_combinatorics !! Provides pure combinatorial functions for generating molecular fragments !! including binomial coefficients, combinations, and fragment counting use pic_types , only : default_int , int32 , int64 implicit none private public :: binomial !! Binomial coefficient calculation public :: get_nfrags !! Calculate total number of fragments public :: create_monomer_list !! Generate sequential monomer indices public :: generate_fragment_list !! Generate all fragments up to max level public :: combine !! Generate all combinations of size r public :: get_next_combination !! Generate next combination in sequence public :: next_combination_init !! Initialize combination to [1,2,...,k] public :: next_combination !! Generate next combination (alternate interface) public :: print_combos !! Debug utility to print combinations contains pure function get_nfrags ( n_monomers , max_level ) result ( n_expected_fragments ) !! Calculate total number of fragments for given system size and max level !! !! Computes the sum of binomial coefficients C(n,k) for k=1 to max_level, !! representing all possible fragments from monomers to max_level-mers. !! Uses int64 to handle large fragment counts that overflow int32. integer ( default_int ), intent ( in ) :: n_monomers !! Number of monomers in system integer ( default_int ), intent ( in ) :: max_level !! Maximum fragment size integer ( int64 ) :: n_expected_fragments !! Total fragment count integer ( default_int ) :: i !! Loop counter n_expected_fragments = 0_int64 do i = 1 , max_level n_expected_fragments = n_expected_fragments + binomial ( n_monomers , i ) end do end function get_nfrags pure function binomial ( n , r ) result ( c ) !! Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) !! !! Calculates \"n choose r\" using iterative algorithm to avoid !! factorial overflow for large numbers. !! Uses int64 to handle large combinatorial values that overflow int32. integer ( default_int ), intent ( in ) :: n !! Total number of items integer ( default_int ), intent ( in ) :: r !! Number of items to choose integer ( int64 ) :: c !! Binomial coefficient result integer ( default_int ) :: i !! Loop counter if ( r == 0 . or . r == n ) then c = 1_int64 else if ( r > n ) then c = 0_int64 else c = 1_int64 do i = 1 , r c = c * int ( n - i + 1 , int64 ) / int ( i , int64 ) end do end if end function binomial pure subroutine create_monomer_list ( monomers ) !! Generate a list of monomer indices from 1 to N integer ( default_int ), allocatable , intent ( inout ) :: monomers (:) integer ( default_int ) :: i , length length = size ( monomers , 1 ) do i = 1 , length monomers ( i ) = i end do end subroutine create_monomer_list recursive subroutine generate_fragment_list ( monomers , max_level , polymers , count ) !! Generate all possible fragments (combinations of monomers) up to max_level !! Uses int64 for count to handle large numbers of fragments that overflow int32. integer ( default_int ), intent ( in ) :: monomers (:), max_level integer ( default_int ), intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: r , n n = size ( monomers , 1 ) do r = 2 , max_level call combine ( monomers , n , r , polymers , count ) end do end subroutine generate_fragment_list recursive subroutine combine ( arr , n , r , out_array , count ) !! Generate all combinations of size r from array arr of size n !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:) integer ( default_int ), intent ( in ) :: n , r integer ( default_int ), intent ( inout ) :: out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: data ( r ) call combine_util ( arr , n , r , 1 , data , 1 , out_array , count ) end subroutine combine recursive subroutine combine_util ( arr , n , r , index , data , i , out_array , count ) !! Utility for generating combinations recursively !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:), n , r , index , i integer ( default_int ), intent ( inout ) :: data (:), out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: j if ( index > r ) then count = count + 1_int64 out_array ( count , 1 : r ) = data ( 1 : r ) return end if do j = i , n data ( index ) = arr ( j ) call combine_util ( arr , n , r , index + 1 , data , j + 1 , out_array , count ) end do end subroutine combine_util subroutine print_combos ( out_array , count , max_len ) !! Print combinations stored in out_array !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: out_array (:, :), max_len integer ( int64 ), intent ( in ) :: count integer ( int64 ) :: i integer ( default_int ) :: j do i = 1_int64 , count do j = 1 , max_len if ( out_array ( i , j ) == 0 ) exit write ( * , '(I0)' , advance = 'no' ) out_array ( i , j ) if ( j < max_len . and . out_array ( i , j + 1 ) /= 0 ) then write ( * , '(A)' , advance = 'no' ) \":\" end if end do write ( * , * ) ! newline end do end subroutine print_combos pure subroutine get_next_combination ( indices , k , n , has_next ) !! Generate next combination (updates indices in place) !! has_next = .true. if there's a next combination integer , intent ( inout ) :: indices (:) integer , intent ( in ) :: k , n logical , intent ( out ) :: has_next integer :: i has_next = . true . i = k do while ( i >= 1 ) if ( indices ( i ) < n - k + i ) then indices ( i ) = indices ( i ) + 1 do while ( i < k ) i = i + 1 indices ( i ) = indices ( i - 1 ) + 1 end do return end if i = i - 1 end do has_next = . false . end subroutine get_next_combination subroutine next_combination_init ( combination , k ) !! Initialize combination to [1, 2, ..., k] integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k integer :: i do i = 1 , k combination ( i ) = i end do end subroutine next_combination_init function next_combination ( combination , k , n ) result ( has_next ) !! Generate next combination in lexicographic order !! Returns .true. if there's a next combination, .false. if we've exhausted all integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k , n logical :: has_next integer :: i has_next = . true . ! Find the rightmost element that can be incremented i = k do while ( i >= 1 ) if ( combination ( i ) < n - k + i ) then combination ( i ) = combination ( i ) + 1 ! Reset all elements to the right do while ( i < k ) i = i + 1 combination ( i ) = combination ( i - 1 ) + 1 end do return end if i = i - 1 end do ! No more combinations has_next = . false . end function next_combination end module mqc_combinatorics","tags":"","url":"sourcefile/mqc_combinatorics.f90.html"},{"title":"mqc_result_types.f90 – metalquicha","text":"Quantum chemistry calculation result containers Files dependent on this one sourcefile~~mqc_result_types.f90~~AfferentGraph sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Quantum chemistry calculation result containers module mqc_result_types !! Defines data structures for storing and managing results from !! quantum chemistry calculations including energies, gradients, and properties. use pic_types , only : dp use pic_mpi_lib , only : comm_t , isend , irecv , send , recv , wait , request_t , MPI_Status implicit none private public :: mp2_energy_t !! MP2 energy components type public :: cc_energy_t !! Coupled cluster energy components type public :: energy_t !! Energy components type public :: calculation_result_t !! Main result container type public :: result_send , result_isend !! Send result over MPI public :: result_recv , result_irecv !! Receive result over MPI ! SCS-MP2 scaling parameters real ( dp ), parameter :: SCS_SS_SCALE = 1.0_dp / 3.0_dp !! SCS same-spin scaling factor real ( dp ), parameter :: SCS_OS_SCALE = 1.2_dp !! SCS opposite-spin scaling factor type :: mp2_energy_t !! Container for MP2 energy components (SS/OS) real ( dp ) :: ss = 0.0_dp !! Same-spin correlation energy (Hartree) real ( dp ) :: os = 0.0_dp !! Opposite-spin correlation energy (Hartree) contains procedure :: total => mp2_total !! Compute total MP2 correlation procedure :: scs => mp2_scs !! Compute SCS-MP2 correlation procedure :: reset => mp2_reset !! Reset both components to zero procedure :: check_stability => mp2_check_stability !! Check for positive energies (instability) end type mp2_energy_t type :: cc_energy_t !! Container for coupled cluster energy components real ( dp ) :: singles = 0.0_dp !! Singles contribution (Hartree) real ( dp ) :: doubles = 0.0_dp !! Doubles contribution (Hartree) real ( dp ) :: triples = 0.0_dp !! Triples contribution (Hartree) contains procedure :: total => cc_total !! Compute total CC correlation procedure :: reset => cc_reset !! Reset all components to zero procedure :: check_stability => cc_check_stability !! Check for positive energies (instability) end type cc_energy_t type :: energy_t !! Container for quantum chemistry energy components !! !! Stores energy contributions from different levels of theory. !! Total energy is computed as: scf + mp2%total() + cc%total() real ( dp ) :: scf = 0.0_dp !! SCF/HF reference energy (Hartree) type ( mp2_energy_t ) :: mp2 !! MP2 correlation components type ( cc_energy_t ) :: cc !! Coupled cluster correlation components ! add more as needed, also need to modify the total energy function contains procedure :: total => energy_total !! Compute total energy from components procedure :: reset => energy_reset !! Reset all components to zero end type energy_t type :: calculation_result_t !! Container for quantum chemistry calculation results !! !! Stores computed quantities from QC calculations with flags !! indicating which properties have been computed. type ( energy_t ) :: energy !! Energy components (Hartree) real ( dp ), allocatable :: gradient (:, :) !! Energy gradient (3, natoms) (Hartree/Bohr) real ( dp ), allocatable :: sigma (:, :) !! Stress tensor (3,3) (Hartree/Bohr&#94;3) real ( dp ), allocatable :: hessian (:, :) !! Energy hessian (future implementation) real ( dp ), allocatable :: dipole (:) !! Dipole moment vector (3) (Debye) ! Computation status flags logical :: has_energy = . false . !! Energy has been computed logical :: has_gradient = . false . !! Gradient has been computed logical :: has_sigma = . false . !! Stress tensor has been computed logical :: has_hessian = . false . !! Hessian has been computed logical :: has_dipole = . false . !! Dipole moment has been computed contains procedure :: destroy => result_destroy !! Clean up allocated memory procedure :: reset => result_reset !! Reset all values and flags end type calculation_result_t contains pure function mp2_total ( this ) result ( total ) !! Compute total MP2 correlation energy class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % ss + this % os end function mp2_total pure function mp2_scs ( this ) result ( scs_energy ) !! Compute SCS-MP2 (Spin-Component Scaled MP2) correlation energy !! SCS-MP2 uses: E_SCS = (1/3)*E_SS + 1.2*E_OS class ( mp2_energy_t ), intent ( in ) :: this real ( dp ) :: scs_energy scs_energy = SCS_SS_SCALE * this % ss + SCS_OS_SCALE * this % os end function mp2_scs subroutine mp2_reset ( this ) !! Reset both MP2 components to zero class ( mp2_energy_t ), intent ( inout ) :: this this % ss = 0.0_dp this % os = 0.0_dp end subroutine mp2_reset subroutine mp2_check_stability ( this ) !! Check for positive MP2 correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( mp2_energy_t ), intent ( in ) :: this if ( this % ss > 0.0_dp ) then call logger % warning ( \"MP2 same-spin correlation energy is positive - possible instability!\" ) end if if ( this % os > 0.0_dp ) then call logger % warning ( \"MP2 opposite-spin correlation energy is positive - possible instability!\" ) end if end subroutine mp2_check_stability pure function cc_total ( this ) result ( total ) !! Compute total CC correlation energy class ( cc_energy_t ), intent ( in ) :: this real ( dp ) :: total total = this % singles + this % doubles + this % triples end function cc_total subroutine cc_reset ( this ) !! Reset all CC components to zero class ( cc_energy_t ), intent ( inout ) :: this this % singles = 0.0_dp this % doubles = 0.0_dp this % triples = 0.0_dp end subroutine cc_reset subroutine cc_check_stability ( this ) !! Check for positive CC correlation energies (instability warning) !! Correlation energies should be negative; positive values indicate instability use pic_logger , only : logger => global_logger class ( cc_energy_t ), intent ( in ) :: this if ( this % singles > 0.0_dp ) then call logger % warning ( \"CC singles correlation energy is positive - possible instability!\" ) end if if ( this % doubles > 0.0_dp ) then call logger % warning ( \"CC doubles correlation energy is positive - possible instability!\" ) end if if ( this % triples > 0.0_dp ) then call logger % warning ( \"CC triples correlation energy is positive - possible instability!\" ) end if end subroutine cc_check_stability pure function energy_total ( this ) result ( total ) !! Compute total energy from all components class ( energy_t ), intent ( in ) :: this real ( dp ) :: total ! this line needs to me modified if more components are added total = this % scf + this % mp2 % total () + this % cc % total () end function energy_total subroutine energy_reset ( this ) !! Reset all energy components to zero class ( energy_t ), intent ( inout ) :: this this % scf = 0.0_dp call this % mp2 % reset () call this % cc % reset () end subroutine energy_reset subroutine result_destroy ( this ) !! Clean up allocated memory in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % sigma )) deallocate ( this % sigma ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) call this % reset () end subroutine result_destroy subroutine result_reset ( this ) !! Reset all values and flags in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this call this % energy % reset () this % has_energy = . false . this % has_gradient = . false . this % has_sigma = . false . this % has_hessian = . false . this % has_dipole = . false . end subroutine result_reset subroutine result_send ( result , comm , dest , tag ) !! Send calculation result over MPI (blocking) !! Sends energy components and conditionally sends gradient based on has_gradient flag type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag ! Send energy components call send ( comm , result % energy % scf , dest , tag ) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send gradient flag and data if present call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if end subroutine result_send subroutine result_isend ( result , comm , dest , tag , req ) !! Send calculation result over MPI (non-blocking) !! Sends SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( in ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: dest , tag type ( request_t ), intent ( out ) :: req ! Send SCF energy (non-blocking) call isend ( comm , result % energy % scf , dest , tag , req ) ! Send other energy components (blocking to avoid needing multiple request handles) call send ( comm , result % energy % mp2 % ss , dest , tag ) call send ( comm , result % energy % mp2 % os , dest , tag ) call send ( comm , result % energy % cc % singles , dest , tag ) call send ( comm , result % energy % cc % doubles , dest , tag ) call send ( comm , result % energy % cc % triples , dest , tag ) ! Send gradient flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_gradient , dest , tag ) if ( result % has_gradient ) then call send ( comm , result % gradient , dest , tag ) end if ! Send Hessian flag and data (blocking to avoid needing multiple request handles) call send ( comm , result % has_hessian , dest , tag ) if ( result % has_hessian ) then call send ( comm , result % hessian , dest , tag ) end if end subroutine result_isend subroutine result_recv ( result , comm , source , tag , status ) !! Receive calculation result over MPI (blocking) !! Receives energy components and conditionally receives gradient based on flag type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( MPI_Status ), intent ( out ) :: status ! Receive energy components call recv ( comm , result % energy % scf , source , tag , status ) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive gradient flag and data if present call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data if present call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if end subroutine result_recv subroutine result_irecv ( result , comm , source , tag , req ) !! Receive calculation result over MPI (non-blocking) !! Receives SCF energy (non-blocking) and other components (blocking) type ( calculation_result_t ), intent ( inout ) :: result type ( comm_t ), intent ( in ) :: comm integer , intent ( in ) :: source , tag type ( request_t ), intent ( out ) :: req type ( MPI_Status ) :: status ! Receive SCF energy (non-blocking) call irecv ( comm , result % energy % scf , source , tag , req ) ! Receive other energy components (blocking to avoid needing multiple request handles) call recv ( comm , result % energy % mp2 % ss , source , tag , status ) call recv ( comm , result % energy % mp2 % os , source , tag , status ) call recv ( comm , result % energy % cc % singles , source , tag , status ) call recv ( comm , result % energy % cc % doubles , source , tag , status ) call recv ( comm , result % energy % cc % triples , source , tag , status ) result % has_energy = . true . ! Receive gradient flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_gradient , source , tag , status ) if ( result % has_gradient ) then ! Receive allocatable gradient array (MPI lib handles allocation) call recv ( comm , result % gradient , source , tag , status ) end if ! Receive Hessian flag and data (blocking to avoid needing multiple request handles) call recv ( comm , result % has_hessian , source , tag , status ) if ( result % has_hessian ) then ! Receive allocatable Hessian array (MPI lib handles allocation) call recv ( comm , result % hessian , source , tag , status ) end if end subroutine result_irecv end module mqc_result_types","tags":"","url":"sourcefile/mqc_result_types.f90.html"},{"title":"mqc_mbe_io.f90 – metalquicha","text":"This file depends on sourcefile~~mqc_mbe_io.f90~~EfferentGraph sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe_io.f90~~AfferentGraph sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module mqc_mbe_io use pic_types , only : int32 , int64 , dp use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_physical_fragment , only : physical_fragment_t , to_angstrom use mqc_elements , only : element_number_to_symbol use mqc_result_types , only : calculation_result_t use mqc_io_helpers , only : get_output_json_filename , get_basename implicit none private public :: print_fragment_xyz , print_detailed_breakdown , print_detailed_breakdown_json public :: print_unfragmented_json , print_gmbe_json , print_gmbe_pie_json contains function get_frag_level_name ( frag_level ) result ( level_name ) !! Map body level (n-mer) to descriptive name !! Supports up to decamers (10-mers), then falls back to \"N-mers\" format integer , intent ( in ) :: frag_level character ( len = 32 ) :: level_name select case ( frag_level ) case ( 1 ) level_name = \"monomers\" case ( 2 ) level_name = \"dimers\" case ( 3 ) level_name = \"trimers\" case ( 4 ) level_name = \"tetramers\" case ( 5 ) level_name = \"pentamers\" case ( 6 ) level_name = \"hexamers\" case ( 7 ) level_name = \"heptamers\" case ( 8 ) level_name = \"octamers\" case ( 9 ) level_name = \"nonamers\" case ( 10 ) level_name = \"decamers\" case default ! For levels > 10, use generic format write ( level_name , '(i0,a)' ) frag_level , \"-mers\" end select end function get_frag_level_name subroutine print_fragment_xyz ( fragment_idx , phys_frag ) !! Print fragment geometry in XYZ format integer , intent ( in ) :: fragment_idx type ( physical_fragment_t ), intent ( in ) :: phys_frag integer :: i character ( len = 2 ) :: symbol character ( len = 256 ) :: coord_line call logger % info ( \"=========================================\" ) call logger % info ( \" Fragment \" // to_char ( fragment_idx )) call logger % info ( \" Number of atoms: \" // to_char ( phys_frag % n_atoms )) call logger % info ( \" Coordinates in Angstroms:\" ) call logger % info ( \"-----------------------------------------\" ) do i = 1 , phys_frag % n_atoms symbol = element_number_to_symbol ( phys_frag % element_numbers ( i )) ! Convert from Bohr back to Angstroms for printing write ( coord_line , '(a2,3f15.8)' ) symbol , to_angstrom ( phys_frag % coordinates ( 1 : 3 , i )) call logger % info ( trim ( coord_line )) end do call logger % info ( \"=========================================\" ) end subroutine print_fragment_xyz subroutine print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) !! Print detailed energy breakdown for each fragment !! Shows full energy and deltaE correction for all monomers, dimers, trimers, etc. !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) integer ( int64 ) :: i integer :: fragment_size , j , frag_level character ( len = 512 ) :: fragment_str , energy_line integer ( int64 ) :: count_by_level call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) call logger % verbose ( \"Detailed Energy Breakdown by Fragment\" ) call logger % verbose ( \"============================================\" ) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). Using generic N-mers notation.\" ) end if do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then call logger % verbose ( \" \" ) block character ( len = 256 ) :: header character ( len = 32 ) :: level_name level_name = get_frag_level_name ( frag_level ) write ( header , '(a,a,i0,a)' ) trim ( level_name ), \" (\" , count_by_level , \" fragments):\" ! Capitalize first letter if ( len_trim ( level_name ) > 0 ) then if ( level_name ( 1 : 1 ) >= 'a' . and . level_name ( 1 : 1 ) <= 'z' ) then header ( 1 : 1 ) = achar ( iachar ( header ( 1 : 1 )) - 32 ) end if end if call logger % verbose ( trim ( header )) end block call logger % verbose ( \"--------------------------------------------\" ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then fragment_str = \"[\" do j = 1 , fragment_size if ( j > 1 ) then write ( fragment_str , '(a,a,i0)' ) trim ( fragment_str ), \",\" , polymers ( i , j ) else write ( fragment_str , '(a,i0)' ) trim ( fragment_str ), polymers ( i , j ) end if end do write ( fragment_str , '(a,a)' ) trim ( fragment_str ), \"]\" if ( frag_level == 1 ) then write ( energy_line , '(a,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ) else write ( energy_line , '(a,a,f20.10,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ), & \"   deltaE: \" , delta_energies ( i ) end if call logger % verbose ( trim ( energy_line )) end if end do end if end do call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) end subroutine print_detailed_breakdown subroutine print_detailed_breakdown_json ( polymers , fragment_count , max_level , & energies , delta_energies , sum_by_level , total_energy , & total_gradient , total_hessian ) !! Write detailed energy breakdown to results.json file !! Outputs structured JSON with all fragment energies and deltaE corrections !! Optionally includes total gradient and Hessian if provided !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) real ( dp ), intent ( in ) :: sum_by_level (:), total_energy real ( dp ), intent ( in ), optional :: total_gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( in ), optional :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) integer ( int64 ) :: i integer :: fragment_size , j , frag_level , unit , io_stat , iatom character ( len = 512 ) :: json_line integer ( int64 ) :: count_by_level logical :: first_level , first_fragment character ( len = 32 ) :: level_name integer :: total_atoms character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing JSON output to \" // trim ( output_file )) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). JSON will use generic N-mers notation.\" ) end if write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '    \"levels\": [' first_level = . true . do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then if (. not . first_level ) then write ( unit , '(a)' ) '      },' end if first_level = . false . write ( unit , '(a)' ) '      {' level_name = get_frag_level_name ( frag_level ) write ( json_line , '(a,i0,a)' ) '        \"frag_level\": ' , frag_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,a,a)' ) '        \"name\": \"' , trim ( level_name ), '\",' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '        \"count\": ' , count_by_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '        \"total_energy\": ' , sum_by_level ( frag_level ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '        \"fragments\": [' first_fragment = . true . do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then if (. not . first_fragment ) then write ( unit , '(a)' ) '          },' end if first_fragment = . false . write ( unit , '(a)' ) '          {' json_line = '            \"indices\": [' do j = 1 , fragment_size if ( j > 1 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , polymers ( i , j ) else write ( json_line , '(a,i0)' ) trim ( json_line ), polymers ( i , j ) end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '            \"energy\": ' , energies ( i ) if ( frag_level > 1 ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '            \"delta_energy\": ' , delta_energies ( i ) end if write ( unit , '(a)' ) trim ( json_line ) end if end do if (. not . first_fragment ) then write ( unit , '(a)' ) '          }' end if write ( unit , '(a)' ) '        ]' end if end do if (. not . first_level ) then write ( unit , '(a)' ) '      }' end if ! Close levels array (with comma if we have more fields) if ( present ( total_gradient ) . or . present ( total_hessian )) then write ( unit , '(a)' ) '    ],' else write ( unit , '(a)' ) '    ]' end if ! Add gradient norm if present (inside basename object) if ( present ( total_gradient )) then write ( json_line , '(a,f20.10)' ) '    \"gradient_norm\": ' , sqrt ( sum ( total_gradient ** 2 )) if ( present ( total_hessian )) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian Frobenius norm if present (inside basename object) if ( present ( total_hessian )) then write ( json_line , '(a,f20.10)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( total_hessian ** 2 )) write ( unit , '(a)' ) trim ( json_line ) end if ! Close basename object write ( unit , '(a)' ) '  }' ! Close outer object write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine print_detailed_breakdown_json subroutine print_unfragmented_json ( result ) !! Write unfragmented calculation results to output JSON file !! Outputs structured JSON with energy and optionally gradient type ( calculation_result_t ), intent ( in ) :: result integer :: unit , io_stat , iatom , total_atoms character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) if ( result % has_energy ) then write ( json_line , '(a,f25.15)' ) '    \"total_energy\": ' , result % energy % total () if ( result % has_gradient . or . result % has_hessian ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add gradient norm if present if ( result % has_gradient ) then write ( json_line , '(a,f25.15)' ) '    \"gradient_norm\": ' , sqrt ( sum ( result % gradient ** 2 )) if ( result % has_hessian ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' end if write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian Frobenius norm if present if ( result % has_hessian ) then write ( json_line , '(a,f25.15)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( result % hessian ** 2 )) write ( unit , '(a)' ) trim ( json_line ) end if write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"JSON output written successfully to \" // trim ( output_file )) end subroutine print_unfragmented_json subroutine print_gmbe_json ( n_monomers , monomer_indices , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , total_energy ) !! Write GMBE calculation results to output JSON file !! Outputs structured JSON with monomers, intersections, and total energy !! Intersection parameters are optional and should be omitted when n_intersections=0 integer , intent ( in ) :: n_monomers integer , intent ( in ) :: monomer_indices (:) type ( calculation_result_t ), intent ( in ) :: monomer_results (:) integer , intent ( in ) :: n_intersections type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) integer , intent ( in ), optional :: intersection_sets (:, :) !! (n_monomers, n_intersections) integer , intent ( in ), optional :: intersection_levels (:) real ( dp ), intent ( in ) :: total_energy integer :: i , j , k , max_level , unit , io_stat character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename logical :: first_level , first_intersection integer :: level_count output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing GMBE JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) ! Monomers section write ( unit , '(a)' ) '    \"monomers\": {' write ( json_line , '(a,i0,a)' ) '      \"count\": ' , n_monomers , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"fragments\": [' do i = 1 , n_monomers write ( unit , '(a)' ) '        {' write ( json_line , '(a,i0,a)' ) '          \"index\": ' , monomer_indices ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '          \"energy\": ' , monomer_results ( i )% energy % total () write ( unit , '(a)' ) trim ( json_line ) if ( i < n_monomers ) then write ( unit , '(a)' ) '        },' else write ( unit , '(a)' ) '        }' end if end do write ( unit , '(a)' ) '      ]' ! Add comma after monomers if we have intersections if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then write ( unit , '(a)' ) '    },' else write ( unit , '(a)' ) '    }' end if ! Intersections section if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then max_level = maxval ( intersection_levels ) write ( unit , '(a)' ) '    \"intersections\": {' write ( json_line , '(a,i0,a)' ) '      \"total_count\": ' , n_intersections , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"levels\": [' first_level = . true . do k = 2 , max_level ! Count intersections at this level level_count = 0 do i = 1 , n_intersections if ( intersection_levels ( i ) == k ) level_count = level_count + 1 end do if ( level_count > 0 ) then if (. not . first_level ) then write ( unit , '(a)' ) '        },' end if first_level = . false . write ( unit , '(a)' ) '        {' write ( json_line , '(a,i0,a)' ) '          \"level\": ' , k , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '          \"count\": ' , level_count , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '          \"fragments\": [' first_intersection = . true . do i = 1 , n_intersections if ( intersection_levels ( i ) == k ) then if (. not . first_intersection ) then write ( unit , '(a)' ) '            },' end if first_intersection = . false . write ( unit , '(a)' ) '            {' ! Write indices json_line = '              \"indices\": [' do j = 1 , n_monomers if ( intersection_sets ( j , i ) > 0 ) then if ( j > 1 . and . intersection_sets ( j - 1 , i ) > 0 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , intersection_sets ( j , i ) else write ( json_line , '(a,i0)' ) trim ( json_line ), intersection_sets ( j , i ) end if end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '              \"energy\": ' , intersection_results ( i )% energy % total () write ( unit , '(a)' ) trim ( json_line ) end if end do if (. not . first_intersection ) then write ( unit , '(a)' ) '            }' end if write ( unit , '(a)' ) '          ]' end if end do if (. not . first_level ) then write ( unit , '(a)' ) '        }' end if write ( unit , '(a)' ) '      ]' write ( unit , '(a)' ) '    }' end if write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"GMBE JSON output written successfully to \" // trim ( output_file )) end subroutine print_gmbe_json subroutine print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) !! Write GMBE PIE calculation results to output JSON file !! Outputs structured JSON with PIE terms (atom sets with coefficients and energies) !! Optionally includes total gradient and Hessian norms integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term real ( dp ), intent ( in ) :: pie_energies (:) !! Raw energy for each term integer , intent ( in ) :: n_pie_terms real ( dp ), intent ( in ) :: total_energy real ( dp ), intent ( in ), optional :: total_gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( in ), optional :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) integer :: i , j , max_atoms , n_atoms integer :: unit , io_stat integer :: n_nonzero_terms logical :: first_term character ( len = 512 ) :: json_line character ( len = 256 ) :: output_file , basename output_file = get_output_json_filename () basename = get_basename () open ( newunit = unit , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Writing GMBE PIE JSON output to \" // trim ( output_file )) write ( unit , '(a)' ) \"{\" write ( json_line , '(a,a,a)' ) '  \"' , trim ( basename ), '\": {' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) ! Add gradient if present if ( present ( total_gradient )) then write ( json_line , '(a,f20.10,a)' ) '    \"gradient_norm\": ' , sqrt ( sum ( total_gradient ** 2 )), ',' write ( unit , '(a)' ) trim ( json_line ) end if ! Add Hessian if present if ( present ( total_hessian )) then write ( json_line , '(a,f20.10,a)' ) '    \"hessian_frobenius_norm\": ' , sqrt ( sum ( total_hessian ** 2 )), ',' write ( unit , '(a)' ) trim ( json_line ) end if ! PIE terms section ! First count non-zero coefficient terms n_nonzero_terms = 0 do i = 1 , n_pie_terms if ( pie_coefficients ( i ) /= 0 ) n_nonzero_terms = n_nonzero_terms + 1 end do write ( unit , '(a)' ) '    \"pie_terms\": {' write ( json_line , '(a,i0,a)' ) '      \"count\": ' , n_nonzero_terms , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '      \"terms\": [' max_atoms = size ( pie_atom_sets , 1 ) first_term = . true . do i = 1 , n_pie_terms ! Skip terms with zero coefficient if ( pie_coefficients ( i ) == 0 ) cycle if (. not . first_term ) write ( unit , '(a)' ) '        },' first_term = . false . write ( unit , '(a)' ) '        {' ! Extract atom list size n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , i ) >= 0 ) n_atoms = n_atoms + 1 end do ! Write atom indices json_line = '          \"atom_indices\": [' do j = 1 , n_atoms if ( j > 1 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , pie_atom_sets ( j , i ) else write ( json_line , '(a,i0)' ) trim ( json_line ), pie_atom_sets ( j , i ) end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '          \"coefficient\": ' , pie_coefficients ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '          \"energy\": ' , pie_energies ( i ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '          \"weighted_energy\": ' , & real ( pie_coefficients ( i ), dp ) * pie_energies ( i ) write ( unit , '(a)' ) trim ( json_line ) end do if (. not . first_term ) write ( unit , '(a)' ) '        }' write ( unit , '(a)' ) '      ]' write ( unit , '(a)' ) '    }' write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"GMBE PIE JSON output written successfully to \" // trim ( output_file )) end subroutine print_gmbe_pie_json end module mqc_mbe_io","tags":"","url":"sourcefile/mqc_mbe_io.f90.html"},{"title":"mqc_elements.f90 – metalquicha","text":"Periodic table data and element utilities Files dependent on this one sourcefile~~mqc_elements.f90~~AfferentGraph sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Periodic table data and element utilities module mqc_elements !! Provides atomic numbers, element symbols, and atomic masses for the complete !! periodic table (elements 1-118) with conversion functions between representations. use pic_ascii , only : to_upper , to_lower use pic_types , only : dp implicit none private public :: element_symbol_to_number !! Convert element symbol to atomic number public :: element_number_to_symbol !! Convert atomic number to element symbol public :: element_mass !! Get atomic mass by atomic number ! TODO: refactr to use findloc ! Periodic table data as module-level parameters integer , parameter :: n_elements = 118 character ( len = 2 ), parameter :: element_symbols ( n_elements ) = [ character ( len = 2 ) :: & !! Element symbols for the complete periodic table (H through Og) !! Ordered by atomic number from 1 to 118 ! for some reason this is how the formatted formats this (????) 'H' , 'He' , & 'Li' , 'Be' , 'B' , 'C' , 'N' , 'O' , 'F' , 'Ne' , & 'Na' , 'Mg' , 'Al' , 'Si' , 'P' , 'S' , 'Cl' , 'Ar' , & 'K' , 'Ca' , 'Sc' , 'Ti' , 'V' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , & 'Rb' , 'Sr' , 'Y' , 'Zr' , 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , 'In' , 'Sn' , 'Sb' , 'Te' , 'I' , 'Xe' , & 'Cs' , 'Ba' , 'La' , 'Ce' , 'Pr' , 'Nd' , 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , 'Lu' , & 'Hf' , 'Ta' , 'W' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , & 'Fr' , 'Ra' , 'Ac' , 'Th' , 'Pa' , 'U' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' , 'Es' , 'Fm' , 'Md' , 'No' , 'Lr' , & 'Rf' , 'Db' , 'Sg' , 'Bh' , 'Hs' , 'Mt' , 'Ds' , 'Rg' , 'Cn' , 'Nh' , 'Fl' , 'Mc' , 'Lv' , 'Ts' , 'Og' ] real ( dp ), parameter :: element_masses ( n_elements ) = [ & !! Standard atomic masses in atomic mass units (amu) !! Based on IUPAC standard atomic weights, ordered by atomic number ! for some reason this is how the formatted formats this (????) 1.008_dp , 4.0026_dp , & ! H-He 6.94_dp , 9.0122_dp , 1 0.81_dp , 1 2.011_dp , 1 4.007_dp , 1 5.999_dp , 1 8.998_dp , 2 0.180_dp , & ! Li-Ne 2 2.990_dp , 2 4.305_dp , 2 6.982_dp , 2 8.085_dp , 3 0.974_dp , 3 2.06_dp , 3 5.45_dp , 3 9.948_dp , & ! Na-Ar 3 9.098_dp , 4 0.078_dp , 4 4.956_dp , 4 7.867_dp , 5 0.942_dp , 5 1.996_dp , 5 4.938_dp , 5 5.845_dp , & ! K-Fe 5 8.933_dp , 5 8.693_dp , 6 3.546_dp , 6 5.38_dp , 6 9.723_dp , 7 2.630_dp , 7 4.922_dp , 7 8.971_dp , & ! Co-Se 7 9.904_dp , 8 3.798_dp , & ! Br-Kr 8 5.468_dp , 8 7.62_dp , 8 8.906_dp , 9 1.224_dp , 9 2.906_dp , 9 5.95_dp , 9 8.0_dp , 10 1.07_dp , & ! Rb-Ru 10 2.91_dp , 10 6.42_dp , 10 7.87_dp , 11 2.41_dp , 11 4.82_dp , 11 8.71_dp , 12 1.76_dp , 12 7.60_dp , & ! Rh-Te 12 6.90_dp , 13 1.29_dp , & ! I-Xe 13 2.91_dp , 13 7.33_dp , 13 8.91_dp , 14 0.12_dp , 14 0.91_dp , 14 4.24_dp , 14 5.0_dp , 15 0.36_dp , & ! Cs-Sm 15 1.96_dp , 15 7.25_dp , 15 8.93_dp , 16 2.50_dp , 16 4.93_dp , 16 7.26_dp , 16 8.93_dp , 17 3.05_dp , & ! Eu-Yb 17 4.97_dp , 17 8.49_dp , 18 0.95_dp , 18 3.84_dp , 18 6.21_dp , 19 0.23_dp , 19 2.22_dp , 19 5.08_dp , & ! Lu-Pt 19 6.97_dp , 20 0.59_dp , 20 4.38_dp , 20 7.2_dp , 20 8.98_dp , 20 9.0_dp , 21 0.0_dp , 22 2.0_dp , & ! Au-Rn 22 3.0_dp , 22 6.0_dp , 22 7.0_dp , 23 2.04_dp , 23 1.04_dp , 23 8.03_dp , 23 7.0_dp , 24 4.0_dp , & ! Fr-Pu 24 3.0_dp , 24 7.0_dp , 24 7.0_dp , 25 1.0_dp , 25 2.0_dp , 25 7.0_dp , 25 8.0_dp , 25 9.0_dp , & ! Am-No 26 2.0_dp , 26 7.0_dp , 26 8.0_dp , 27 1.0_dp , 27 2.0_dp , 27 0.0_dp , 27 6.0_dp , 28 1.0_dp , & ! Lr-Ds 28 0.0_dp , 28 5.0_dp , 28 4.0_dp , 28 9.0_dp , 28 8.0_dp , 29 3.0_dp , 29 4.0_dp , 29 4.0_dp ] ! Rg-Og contains pure function element_symbol_to_number ( symbol ) result ( atomic_number ) !! Convert element symbol to atomic number !! Covers the complete periodic table (elements 1-118) character ( len =* ), intent ( in ) :: symbol integer :: atomic_number character ( len = 2 ) :: sym ! Normalize: uppercase first letter, lowercase second sym = adjustl ( symbol ) if ( len_trim ( sym ) >= 1 ) sym ( 1 : 1 ) = to_upper ( sym ( 1 : 1 )) if ( len_trim ( sym ) >= 2 ) sym ( 2 : 2 ) = to_lower ( sym ( 2 : 2 )) ! Search for symbol in table atomic_number = findloc ( element_symbols , sym , dim = 1 ) end function element_symbol_to_number pure function element_number_to_symbol ( atomic_number ) result ( symbol ) !! Convert atomic number to element symbol !! Covers the complete periodic table (elements 1-118) integer , intent ( in ) :: atomic_number character ( len = 2 ) :: symbol select case ( atomic_number ) case ( 1 : 118 ) symbol = element_symbols ( atomic_number ) case default symbol = 'Xx' ! Unknown end select end function element_number_to_symbol pure function element_mass ( atomic_number ) result ( mass ) !! Return atomic mass in atomic mass units (amu) for a given atomic number !! Uses standard atomic weights from IUPAC integer , intent ( in ) :: atomic_number real ( dp ) :: mass select case ( atomic_number ) case ( 1 : 118 ) mass = element_masses ( atomic_number ) case default mass = 0.0_dp ! Unknown element end select end function element_mass end module mqc_elements","tags":"","url":"sourcefile/mqc_elements.f90.html"},{"title":"mqc_method_base.f90 – metalquicha","text":"Abstract base module for quantum chemistry method implementations This file depends on sourcefile~~mqc_method_base.f90~~EfferentGraph sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_base.f90~~AfferentGraph sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Abstract base module for quantum chemistry method implementations module mqc_method_base !! Defines the common interface that all quantum chemistry methods must implement, !! providing a unified API for energy and gradient calculations. use pic_types , only : dp use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: qc_method_t !! Abstract base type for all QC methods type , abstract :: qc_method_t !! Abstract base type for all quantum chemistry methods !! !! Defines the required interface for energy and gradient calculations !! that must be implemented by all concrete method types (XTB, HF, etc.). contains procedure ( calc_energy_interface ), deferred :: calc_energy !! Energy calculation interface procedure ( calc_gradient_interface ), deferred :: calc_gradient !! Gradient calculation interface procedure ( calc_hessian_interface ), deferred :: calc_hessian !! Hessian calculation interface end type qc_method_t abstract interface subroutine calc_energy_interface ( this , fragment , result ) !! Interface for energy-only calculations !! !! Computes the electronic energy for a molecular fragment !! using the specified quantum chemistry method. import :: qc_method_t , calculation_result_t , physical_fragment_t implicit none class ( qc_method_t ), intent ( in ) :: this !! Method instance type ( physical_fragment_t ), intent ( in ) :: fragment !! Molecular fragment type ( calculation_result_t ), intent ( out ) :: result !! Calculation results end subroutine calc_energy_interface subroutine calc_gradient_interface ( this , fragment , result ) !! Interface for energy and gradient calculations !! !! Computes both electronic energy and nuclear gradients for a !! molecular fragment using the specified quantum chemistry method. import :: qc_method_t , calculation_result_t , physical_fragment_t implicit none class ( qc_method_t ), intent ( in ) :: this !! Method instance type ( physical_fragment_t ), intent ( in ) :: fragment !! Molecular fragment type ( calculation_result_t ), intent ( out ) :: result end subroutine calc_gradient_interface subroutine calc_hessian_interface ( this , fragment , result ) !! Interface for energy, gradient, and Hessian calculations !! !! Computes electronic energy, nuclear gradients, and Hessian matrix for a !! molecular fragment using the specified quantum chemistry method. import :: qc_method_t , calculation_result_t , physical_fragment_t implicit none class ( qc_method_t ), intent ( in ) :: this !! Method instance type ( physical_fragment_t ), intent ( in ) :: fragment !! Molecular fragment type ( calculation_result_t ), intent ( out ) :: result end subroutine calc_hessian_interface end interface end module mqc_method_base","tags":"","url":"sourcefile/mqc_method_base.f90.html"},{"title":"mqc_config_parser.f90 – metalquicha","text":"Parser for MQC section-based input files (.mqc format) This file depends on sourcefile~~mqc_config_parser.f90~~EfferentGraph sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_config_parser.f90~~AfferentGraph sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Parser for MQC section-based input files (.mqc format) module mqc_config_parser !! Parses section-based input files with %section...end blocks !! This is the new format generated by mqc_prep.py use pic_types , only : dp , int32 , int64 use mqc_method_types , only : method_type_from_string , METHOD_TYPE_GFN2 , METHOD_TYPE_UNKNOWN use mqc_calc_types , only : calc_type_from_string , CALC_TYPE_ENERGY , CALC_TYPE_UNKNOWN use mqc_geometry , only : geometry_type use mqc_error , only : error_t , ERROR_IO , ERROR_PARSE , ERROR_VALIDATION implicit none private public :: mqc_config_t , read_mqc_file public :: input_fragment_t , bond_t , molecule_t ! Maximum line length for reading integer , parameter :: MAX_LINE_LEN = 1024 type :: input_fragment_t !! Input fragment definition with charge, multiplicity, and atom indices !! This is the parsed representation from the input file, not the computational fragment integer :: charge = 0 integer :: multiplicity = 1 integer , allocatable :: indices (:) !! Atom indices in this fragment contains procedure :: destroy => input_fragment_destroy end type input_fragment_t type :: bond_t !! Bond definition with atom indices, order, and broken status integer :: atom_i = 0 integer :: atom_j = 0 integer :: order = 1 logical :: is_broken = . false . end type bond_t type :: molecule_t !! Single molecule definition with structure, geometry, fragments, and connectivity character ( len = :), allocatable :: name !! Optional molecule name ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) contains procedure :: destroy => molecule_destroy end type molecule_t type :: mqc_config_t !! Complete configuration from .mqc file ! Schema information character ( len = :), allocatable :: schema_name character ( len = :), allocatable :: schema_version integer :: index_base = 0 !! 0-based or 1-based indexing character ( len = :), allocatable :: units !! angstrom or bohr ! Model information integer ( int32 ) :: method = METHOD_TYPE_GFN2 character ( len = :), allocatable :: basis character ( len = :), allocatable :: aux_basis ! Driver information integer ( int32 ) :: calc_type = CALC_TYPE_ENERGY ! Multiple molecules support integer :: nmol = 0 !! Number of molecules (0 = single molecule mode for backward compatibility) type ( molecule_t ), allocatable :: molecules (:) !! Array of molecules (if nmol > 0) ! Single molecule fields (backward compatibility - used if nmol == 0) ! Structure information integer :: charge = 0 integer :: multiplicity = 1 ! Geometry type ( geometry_type ) :: geometry ! Fragments integer :: nfrag = 0 type ( input_fragment_t ), allocatable :: fragments (:) ! Connectivity integer :: nbonds = 0 integer :: nbroken = 0 type ( bond_t ), allocatable :: bonds (:) ! SCF settings integer :: scf_maxiter = 300 real ( dp ) :: scf_tolerance = 1.0e-6_dp ! Fragmentation settings character ( len = :), allocatable :: frag_method !! MBE, etc. integer :: frag_level = 1 logical :: allow_overlapping_fragments = . false . integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) character ( len = :), allocatable :: embedding character ( len = :), allocatable :: cutoff_method character ( len = :), allocatable :: distance_metric real ( dp ) :: dimer_cutoff = 0.0_dp real ( dp ) :: trimer_cutoff = 0.0_dp ! Logger settings (kept for compatibility) character ( len = :), allocatable :: log_level contains procedure :: destroy => config_destroy end type mqc_config_t contains pure function strip_comment ( line ) result ( stripped ) !! Remove comments (! or #) from a line and trim result character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: stripped integer :: comment_pos ! Find first occurrence of ! or # comment_pos = index ( line , '!' ) if ( comment_pos == 0 ) comment_pos = index ( line , '#' ) if ( comment_pos > 0 ) then ! Comment found - take everything before it stripped = trim ( adjustl ( line ( 1 : comment_pos - 1 ))) else ! No comment - use full line stripped = trim ( adjustl ( line )) end if end function strip_comment subroutine read_mqc_file ( filename , config , error ) !! Read and parse a .mqc format input file character ( len =* ), intent ( in ) :: filename type ( mqc_config_t ), intent ( out ) :: config type ( error_t ), intent ( out ) :: error integer :: unit , io_stat character ( len = MAX_LINE_LEN ) :: line logical :: file_exists type ( error_t ) :: parse_error inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"Input file not found: \" // trim ( filename )) return end if open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening input file: \" // trim ( filename )) return end if ! Set defaults config % log_level = \"info\" ! Read file line by line and dispatch to section parsers do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for section start if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%schema' ) call parse_schema_section ( unit , config , parse_error ) case ( '%model' ) call parse_model_section ( unit , config , parse_error ) case ( '%driver' ) call parse_driver_section ( unit , config , parse_error ) case ( '%structure' ) call parse_structure_section ( unit , config , parse_error ) case ( '%geometry' ) call parse_geometry_section ( unit , config , parse_error ) case ( '%fragments' ) call parse_fragments_section ( unit , config , parse_error ) case ( '%connectivity' ) call parse_connectivity_section ( unit , config , parse_error ) case ( '%scf' ) call parse_scf_section ( unit , config , parse_error ) case ( '%fragmentation' ) call parse_fragmentation_section ( unit , config , parse_error ) case ( '%system' ) call parse_system_section ( unit , config , parse_error ) case ( '%molecules' ) call parse_molecules_section ( unit , config , parse_error ) case default ! Skip unknown sections call skip_to_end ( unit , parse_error ) end select if ( parse_error % has_error ()) then error = parse_error close ( unit ) return end if end if end do close ( unit ) ! Validate required fields if (. not . allocated ( config % schema_name )) then call error % set ( ERROR_VALIDATION , \"Missing required section: %schema\" ) return end if ! Validate geometry: required for single-molecule mode, not for multi-molecule mode if ( config % nmol == 0 ) then ! Single molecule mode: require top-level geometry if (. not . allocated ( config % geometry % coords ) . or . config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"Missing required section: %geometry\" ) return end if else ! Multi-molecule mode: each molecule must have geometry (validated during parsing) ! No additional validation needed here end if end subroutine read_mqc_file subroutine parse_schema_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Unexpected end of file in %schema section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'name' ) config % schema_name = trim ( value ) case ( 'version' ) config % schema_version = trim ( value ) case ( 'index_base' ) read ( value , * , iostat = io_stat ) config % index_base case ( 'units' ) config % units = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %schema section: \" // trim ( key )) return end select end do end subroutine parse_schema_section subroutine parse_model_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %model section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'method' ) ! Parse method string (e.g., \"XTB-GFN1\" -> \"gfn1\") config % method = parse_method_string ( trim ( value )) if ( config % method == METHOD_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid method: \" // trim ( value )) return end if case ( 'basis' ) config % basis = trim ( value ) case ( 'aux_basis' ) config % aux_basis = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %model section: \" // trim ( key )) return end select end do end subroutine parse_model_section subroutine parse_driver_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %driver section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'type' ) config % calc_type = calc_type_from_string ( trim ( value )) if ( config % calc_type == CALC_TYPE_UNKNOWN ) then call error % set ( ERROR_PARSE , \"Invalid calc_type: \" // trim ( value )) return end if case default call error % set ( ERROR_PARSE , \"Unknown key in %driver section: \" // trim ( key )) return end select end do end subroutine parse_driver_section subroutine parse_structure_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , config % charge , config % multiplicity , error ) end subroutine parse_structure_section subroutine parse_geometry_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , config % geometry , error ) end subroutine parse_geometry_section subroutine parse_fragments_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , config % nfrag , config % fragments , error ) end subroutine parse_fragments_section subroutine parse_fragment ( unit , fragment , error ) integer , intent ( in ) :: unit type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_indices in_indices = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragment\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_indices ) then in_indices = . false . cycle else exit end if end if if ( trim ( line ) == '%indices' ) then in_indices = . true . cycle end if if ( in_indices ) then ! Read indices call parse_indices_line ( line , fragment , error ) if ( error % has_error ()) return else eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) fragment % charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) fragment % multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in fragment properties: \" // trim ( key )) return end select end if end if end do end subroutine parse_fragment subroutine parse_indices_line ( line , fragment , error ) character ( len =* ), intent ( in ) :: line type ( input_fragment_t ), intent ( inout ) :: fragment type ( error_t ), intent ( out ) :: error integer :: io_stat , pos , count , i , idx character ( len = MAX_LINE_LEN ) :: temp_line integer , allocatable :: temp_indices (:), new_indices (:) temp_line = line ! Count how many integers count = 0 do read ( temp_line , * , iostat = io_stat ) idx if ( io_stat /= 0 ) exit count = count + 1 ! Remove the read integer from temp_line pos = scan ( temp_line , ' ' ) if ( pos == 0 ) exit temp_line = adjustl ( temp_line ( pos :)) end do if ( count == 0 ) return ! Allocate temporary array allocate ( temp_indices ( count )) ! Read the integers read ( line , * , iostat = io_stat ) temp_indices if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading fragment indices\" ) deallocate ( temp_indices ) return end if ! Append to existing indices if ( allocated ( fragment % indices )) then allocate ( new_indices ( size ( fragment % indices ) + count )) new_indices ( 1 : size ( fragment % indices )) = fragment % indices new_indices ( size ( fragment % indices ) + 1 :) = temp_indices call move_alloc ( new_indices , fragment % indices ) else call move_alloc ( temp_indices , fragment % indices ) end if end subroutine parse_indices_line subroutine parse_connectivity_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , config % nbonds , config % nbroken , config % bonds , error ) end subroutine parse_connectivity_section subroutine parse_scf_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %scf section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'maxiter' ) read ( value , * , iostat = io_stat ) config % scf_maxiter case ( 'tolerance' ) read ( value , * , iostat = io_stat ) config % scf_tolerance case default call error % set ( ERROR_PARSE , \"Unknown key in %scf section: \" // trim ( key )) return end select end do end subroutine parse_scf_section subroutine parse_fragmentation_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos logical :: in_cutoffs in_cutoffs = . false . do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragmentation section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) then if ( in_cutoffs ) then in_cutoffs = . false . cycle else exit end if end if if ( trim ( line ) == '%cutoffs' ) then in_cutoffs = . true . cycle end if eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( in_cutoffs ) then select case ( trim ( key )) case ( 'dimer' ) read ( value , * , iostat = io_stat ) config % dimer_cutoff case ( 'trimer' ) read ( value , * , iostat = io_stat ) config % trimer_cutoff case default call error % set ( ERROR_PARSE , \"Unknown key in %fragmentation cutoffs subsection: \" // trim ( key )) return end select else select case ( trim ( key )) case ( 'method' ) config % frag_method = trim ( value ) case ( 'level' ) read ( value , * , iostat = io_stat ) config % frag_level case ( 'allow_overlapping_fragments' ) config % allow_overlapping_fragments = ( trim ( value ) == 'true' ) case ( 'max_intersection_level' ) read ( value , * , iostat = io_stat ) config % max_intersection_level case ( 'embedding' ) config % embedding = trim ( value ) case ( 'cutoff_method' ) config % cutoff_method = trim ( value ) case ( 'distance_metric' ) config % distance_metric = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %fragmentation section: \" // trim ( key )) return end select end if end do end subroutine parse_fragmentation_section subroutine parse_system_section ( unit , config , error ) integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %system section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'log_level' ) config % log_level = trim ( value ) case default call error % set ( ERROR_PARSE , \"Unknown key in %system section: \" // trim ( key )) return end select end do end subroutine parse_system_section subroutine parse_molecules_section ( unit , config , error ) !! Parse %molecules section containing multiple %molecule blocks integer , intent ( in ) :: unit type ( mqc_config_t ), intent ( inout ) :: config type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nmol , imol nmol = 0 ! First pass: read nmol do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecules section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nmol' ) then read ( value , * , iostat = io_stat ) nmol if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nmol value\" ) return end if exit end if end if end do if ( nmol == 0 ) then ! No molecules, just skip to end call skip_to_end ( unit , error ) return end if config % nmol = nmol allocate ( config % molecules ( nmol )) ! Parse individual molecules imol = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%molecule' ) then imol = imol + 1 if ( imol > nmol ) then call error % set ( ERROR_PARSE , \"More molecules than declared nmol\" ) return end if call parse_single_molecule ( unit , config % molecules ( imol ), error ) if ( error % has_error ()) return end if end do if ( imol /= nmol ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nmol , \" molecules, found \" , imol call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_molecules_section subroutine parse_single_molecule ( unit , mol , error ) !! Parse a single %molecule block with its sections integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %molecule\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit ! Check for key=value pairs (like name) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'name' ) then mol % name = trim ( value ) cycle end if end if ! Check for subsections if ( line ( 1 : 1 ) == '%' ) then select case ( trim ( line )) case ( '%structure' ) call parse_molecule_structure ( unit , mol , error ) case ( '%geometry' ) call parse_molecule_geometry ( unit , mol , error ) case ( '%fragments' ) call parse_molecule_fragments ( unit , mol , error ) case ( '%connectivity' ) call parse_molecule_connectivity ( unit , mol , error ) case default ! Skip unknown subsections call skip_to_end ( unit , error ) end select if ( error % has_error ()) return end if end do end subroutine parse_single_molecule subroutine parse_molecule_structure ( unit , mol , error ) !! Parse %structure section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_structure_generic ( unit , mol % charge , mol % multiplicity , error ) end subroutine parse_molecule_structure subroutine parse_molecule_geometry ( unit , mol , error ) !! Parse %geometry section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_geometry_generic ( unit , mol % geometry , error ) end subroutine parse_molecule_geometry subroutine parse_molecule_fragments ( unit , mol , error ) !! Parse %fragments section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_fragments_generic ( unit , mol % nfrag , mol % fragments , error ) end subroutine parse_molecule_fragments subroutine parse_molecule_connectivity ( unit , mol , error ) !! Parse %connectivity section for a molecule integer , intent ( in ) :: unit type ( molecule_t ), intent ( inout ) :: mol type ( error_t ), intent ( out ) :: error call parse_connectivity_generic ( unit , mol % nbonds , mol % nbroken , mol % bonds , error ) end subroutine parse_molecule_connectivity subroutine skip_to_end ( unit , error ) !! Skip lines until 'end' marker is found integer , intent ( in ) :: unit type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line integer :: io_stat do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file while skipping section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) exit end do end subroutine skip_to_end function parse_method_string ( method_str ) result ( method_type ) !! Parse method string from input file (e.g., \"XTB-GFN1\" -> gfn1) character ( len =* ), intent ( in ) :: method_str integer ( int32 ) :: method_type character ( len = :), allocatable :: lower_str , method_part integer :: dash_pos , i ! Convert to lowercase allocate ( character ( len = len_trim ( method_str )) :: lower_str ) lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Handle \"XTB-GFN1\" format -> extract \"gfn1\" if ( index ( lower_str , 'xtb' ) > 0 ) then dash_pos = index ( lower_str , '-' ) if ( dash_pos > 0 ) then method_part = lower_str ( dash_pos + 1 :) else method_part = lower_str end if else method_part = lower_str end if method_type = method_type_from_string ( method_part ) end function parse_method_string subroutine molecule_destroy ( this ) !! Clean up allocated memory in molecule_t class ( molecule_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % name )) deallocate ( this % name ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) end subroutine molecule_destroy subroutine config_destroy ( this ) !! Clean up allocated memory in mqc_config_t class ( mqc_config_t ), intent ( inout ) :: this integer :: i if ( allocated ( this % schema_name )) deallocate ( this % schema_name ) if ( allocated ( this % schema_version )) deallocate ( this % schema_version ) if ( allocated ( this % units )) deallocate ( this % units ) if ( allocated ( this % basis )) deallocate ( this % basis ) if ( allocated ( this % aux_basis )) deallocate ( this % aux_basis ) if ( allocated ( this % log_level )) deallocate ( this % log_level ) if ( allocated ( this % frag_method )) deallocate ( this % frag_method ) if ( allocated ( this % embedding )) deallocate ( this % embedding ) if ( allocated ( this % cutoff_method )) deallocate ( this % cutoff_method ) if ( allocated ( this % distance_metric )) deallocate ( this % distance_metric ) call this % geometry % destroy () if ( allocated ( this % fragments )) then do i = 1 , size ( this % fragments ) call this % fragments ( i )% destroy () end do deallocate ( this % fragments ) end if if ( allocated ( this % bonds )) deallocate ( this % bonds ) ! Clean up molecules array (multi-molecule mode) if ( allocated ( this % molecules )) then do i = 1 , size ( this % molecules ) call this % molecules ( i )% destroy () end do deallocate ( this % molecules ) end if end subroutine config_destroy subroutine input_fragment_destroy ( this ) !! Clean up allocated memory in input_fragment_t class ( input_fragment_t ), intent ( inout ) :: this if ( allocated ( this % indices )) deallocate ( this % indices ) end subroutine input_fragment_destroy !! ======================================================================== !! Generic parsing helpers to eliminate redundancy !! ======================================================================== subroutine parse_structure_generic ( unit , charge , multiplicity , error ) !! Generic parser for %structure section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: charge , multiplicity type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value integer :: io_stat , eq_pos do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %structure section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) select case ( trim ( key )) case ( 'charge' ) read ( value , * , iostat = io_stat ) charge case ( 'multiplicity' ) read ( value , * , iostat = io_stat ) multiplicity case default call error % set ( ERROR_PARSE , \"Unknown key in %structure section: \" // trim ( key )) return end select end do end subroutine parse_structure_generic subroutine parse_geometry_generic ( unit , geom , error ) !! Generic parser for %geometry section (works for both config and molecule) integer , intent ( in ) :: unit type ( geometry_type ), intent ( inout ) :: geom type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , elem integer :: io_stat , natoms , i real ( dp ) :: x , y , z ! Read number of atoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading natoms in %geometry section\" ) return end if read ( line , * , iostat = io_stat ) natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid natoms in %geometry section\" ) return end if geom % natoms = natoms ! Read blank line (comment line in XYZ format) read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading comment line in %geometry section\" ) return end if geom % comment = trim ( line ) ! Allocate arrays allocate ( character ( len = 4 ) :: geom % elements ( natoms )) allocate ( geom % coords ( 3 , natoms )) ! Read coordinates do i = 1 , natoms read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry coordinates\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) == 'end' ) then call error % set ( ERROR_PARSE , \"Unexpected 'end' while reading geometry\" ) return end if read ( line , * , iostat = io_stat ) elem , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid coordinate format in %geometry section\" ) return end if geom % elements ( i ) = trim ( elem ) geom % coords ( 1 , i ) = x geom % coords ( 2 , i ) = y geom % coords ( 3 , i ) = z end do ! Read 'end' marker read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_VALIDATION , \"Missing 'end' in %geometry section\" ) return end if line = adjustl ( line ) if ( trim ( strip_comment ( line )) /= 'end' ) then call error % set ( ERROR_PARSE , \"Expected 'end' after geometry coordinates\" ) return end if end subroutine parse_geometry_generic subroutine parse_fragments_generic ( unit , nfrag , fragments , error ) !! Generic parser for %fragments section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nfrag type ( input_fragment_t ), allocatable , intent ( inout ) :: fragments (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value character ( len = 256 ) :: msg integer :: io_stat , eq_pos , nfrag_local , ifrag nfrag_local = 0 ! First pass: read nfrag do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %fragments section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nfrag' ) then read ( value , * , iostat = io_stat ) nfrag_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nfrag value\" ) return end if exit end if end if end do if ( nfrag_local == 0 ) then ! No fragments, just skip to end call skip_to_end ( unit , error ) return end if nfrag = nfrag_local allocate ( fragments ( nfrag )) ! Parse individual fragments ifrag = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit if ( trim ( line ) == '%fragment' ) then ifrag = ifrag + 1 if ( ifrag > nfrag ) then call error % set ( ERROR_PARSE , \"More fragments than declared nfrag\" ) return end if call parse_fragment ( unit , fragments ( ifrag ), error ) if ( error % has_error ()) return end if end do if ( ifrag /= nfrag ) then write ( msg , '(A,I0,A,I0)' ) \"Expected \" , nfrag , \" fragments, found \" , ifrag call error % set ( ERROR_PARSE , trim ( msg )) return end if end subroutine parse_fragments_generic subroutine parse_connectivity_generic ( unit , nbonds , nbroken , bonds , error ) !! Generic parser for %connectivity section (works for both config and molecule) integer , intent ( in ) :: unit integer , intent ( inout ) :: nbonds , nbroken type ( bond_t ), allocatable , intent ( inout ) :: bonds (:) type ( error_t ), intent ( out ) :: error character ( len = MAX_LINE_LEN ) :: line , key , value , status_str integer :: io_stat , eq_pos , nbonds_local , ibond integer :: atom_i , atom_j , order nbonds_local = 0 ! First pass: read nbonds do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Unexpected end of file in %connectivity section\" ) return end if line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle if ( trim ( strip_comment ( line )) == 'end' ) exit eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbonds' ) then read ( value , * , iostat = io_stat ) nbonds_local if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid nbonds value\" ) return end if exit end if end if end do if ( nbonds_local == 0 ) then ! No bonds, just skip to end call skip_to_end ( unit , error ) return end if nbonds = nbonds_local allocate ( bonds ( nbonds )) ! Read bonds ibond = 0 do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Check for key=value pairs (like nbroken=9) eq_pos = index ( line , '=' ) if ( eq_pos > 0 ) then key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) if ( trim ( key ) == 'nbroken' ) then read ( value , * , iostat = io_stat ) nbroken end if cycle end if if ( trim ( strip_comment ( line )) == 'end' ) exit ! Parse bond line: atom_i atom_j order broken/preserved read ( line , * , iostat = io_stat ) atom_i , atom_j , order , status_str if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Invalid bond format in %connectivity section\" ) return end if ibond = ibond + 1 if ( ibond > nbonds ) then call error % set ( ERROR_PARSE , \"More bonds than declared nbonds\" ) return end if bonds ( ibond )% atom_i = atom_i bonds ( ibond )% atom_j = atom_j bonds ( ibond )% order = order bonds ( ibond )% is_broken = ( trim ( status_str ) == 'broken' ) end do end subroutine parse_connectivity_generic end module mqc_config_parser","tags":"","url":"sourcefile/mqc_config_parser.f90.html"},{"title":"mqc_physical_fragment.f90 – metalquicha","text":"This file contains all routines and types to represent a “physical” fragment or molecule\ni.e., with atomic coordinates, element types, electronic properties, etc. This file depends on sourcefile~~mqc_physical_fragment.f90~~EfferentGraph sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_physical_fragment.f90~~AfferentGraph sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This file contains all routines and types to represent a \"physical\" fragment or molecule !! i.e., with atomic coordinates, element types, electronic properties, etc. module mqc_physical_fragment !! Physical molecular fragment representation and geometry handling !! !! Provides data structures and utilities for managing molecular fragments !! with atomic coordinates, electronic properties, and geometric operations. use pic_types , only : dp , default_int use mqc_geometry , only : geometry_type use mqc_xyz_reader , only : read_xyz_file use mqc_elements , only : element_symbol_to_number , element_number_to_symbol , element_mass use mqc_cgto , only : molecular_basis_type use mqc_config_parser , only : bond_t use mqc_error , only : error_t , ERROR_VALIDATION implicit none private public :: physical_fragment_t !! Single molecular fragment type public :: system_geometry_t !! Complete system geometry type public :: initialize_system_geometry !! System geometry initialization public :: build_fragment_from_indices !! Extract fragment from system public :: build_fragment_from_atom_list !! Build fragment from explicit atom indices (for intersections) public :: check_duplicate_atoms !! Validate fragment has no overlapping atoms ! TODO: in theory there should be a nice way to redistribute for a general matrix of any shape, need to think about this! public :: redistribute_cap_gradients !! Redistribute hydrogen cap gradients to original atoms public :: redistribute_cap_hessian !! Redistribute hydrogen cap Hessian to original atoms public :: to_angstrom , to_bohr !! Unit conversion utilities public :: fragment_centroid !! Geometric centroid calculation public :: fragment_center_of_mass !! Mass-weighted center calculation public :: distance_between_points !! Point-to-point distance public :: distance_between_fragments !! Inter-fragment distance public :: minimal_distance_between_fragments !! Closest approach distance type :: physical_fragment_t !! Physical molecular fragment with atomic coordinates and properties !! !! Represents a molecular fragment containing atomic positions, element types, !! electronic structure information, and basis set data for quantum calculations. integer :: n_atoms !! Number of atoms in this fragment integer , allocatable :: element_numbers (:) !! Atomic numbers (Z values) real ( dp ), allocatable :: coordinates (:, :) !! Cartesian coordinates (3, n_atoms) in Bohr ! Electronic structure properties integer :: charge = 0 !! Net molecular charge (electrons) integer :: multiplicity = 1 !! Spin multiplicity (2S+1) integer :: nelec = 0 !! Total number of electrons ! Hydrogen capping for broken bonds integer :: n_caps = 0 !! Number of hydrogen caps added (always at end of atom list) integer , allocatable :: cap_replaces_atom (:) !! Original atom index that each cap replaces (size: n_caps) ! Gradient redistribution support integer , allocatable :: local_to_global (:) !! Map fragment atom index to system atom index (size: n_atoms - n_caps) ! Quantum chemistry basis set type ( molecular_basis_type ), allocatable :: basis !! Gaussian basis functions contains procedure :: destroy => fragment_destroy !! Memory cleanup procedure :: compute_nelec => fragment_compute_nelec !! Calculate electron count procedure :: set_basis => fragment_set_basis !! Assign basis set end type physical_fragment_t type :: system_geometry_t !! Complete molecular system geometry for fragment-based calculations !! !! Contains the full atomic structure of a molecular cluster organized !! by monomers for efficient fragment generation and MBE calculations. integer :: n_monomers !! Number of monomer units in system integer :: atoms_per_monomer !! Atoms in each monomer (0 if variable-sized) integer :: total_atoms !! Total number of atoms integer , allocatable :: element_numbers (:) !! Atomic numbers for all atoms real ( dp ), allocatable :: coordinates (:, :) !! All coordinates (3, total_atoms) in Bohr ! Electronic structure properties integer :: charge !! Net molecular charge (electrons) integer :: multiplicity !! Spin multiplicity (2S+1) ! For variable-sized fragments (explicit fragment definitions) integer , allocatable :: fragment_sizes (:) !! Number of atoms in each fragment (n_monomers) integer , allocatable :: fragment_atoms (:, :) !! Atom indices for each fragment (max_frag_size, n_monomers), 0-indexed integer , allocatable :: fragment_charges (:) !! Charge for each fragment (n_monomers) integer , allocatable :: fragment_multiplicities (:) !! Multiplicity for each fragment (n_monomers) contains procedure :: destroy => system_destroy !! Memory cleanup end type system_geometry_t ! Physical constants real ( dp ), parameter :: bohr_radius = 0.52917721092_dp !! Bohr radius in Ångström contains pure elemental function to_angstrom ( bohr_value ) result ( angstrom_value ) !! Convert coordinate from Bohr to Angstrom real ( dp ), intent ( in ) :: bohr_value real ( dp ) :: angstrom_value angstrom_value = bohr_value * bohr_radius end function to_angstrom pure elemental function to_bohr ( angstrom_value ) result ( bohr_value ) !! Convert coordinate from Angstrom to Bohr real ( dp ), intent ( in ) :: angstrom_value real ( dp ) :: bohr_value bohr_value = angstrom_value / bohr_radius end function to_bohr subroutine initialize_system_geometry ( full_geom_file , monomer_file , sys_geom , error ) !! Read full geometry and monomer template, initialize system_geometry_t character ( len =* ), intent ( in ) :: full_geom_file , monomer_file type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error type ( geometry_type ) :: full_geom , monomer_geom integer :: i call read_xyz_file ( full_geom_file , full_geom , error ) if ( error % has_error ()) return ! Read monomer template ! this will be changed once we have a proper input file parsing call read_xyz_file ( monomer_file , monomer_geom , error ) if ( error % has_error ()) then call full_geom % destroy () return end if ! Validate that full geometry is a multiple of monomer size sys_geom % atoms_per_monomer = monomer_geom % natoms sys_geom % total_atoms = full_geom % natoms if ( mod ( sys_geom % total_atoms , sys_geom % atoms_per_monomer ) /= 0 ) then call error % set ( ERROR_VALIDATION , \"Full geometry atoms not a multiple of monomer atoms\" ) call full_geom % destroy () call monomer_geom % destroy () return end if sys_geom % n_monomers = sys_geom % total_atoms / sys_geom % atoms_per_monomer ! TODO JORGE: this can be a sys_geom%allocate() allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( full_geom % elements ( i )) end do ! Store coordinates in Bohr (convert from Angstroms) ! TODO JORGE: need a way to handle units sys_geom % coordinates = to_bohr ( full_geom % coords ) call full_geom % destroy () call monomer_geom % destroy () end subroutine initialize_system_geometry subroutine count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) !! Count how many hydrogen caps are needed for a fragment !! A cap is needed when exactly one atom of a broken bond is in the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ), optional :: bonds (:) integer , intent ( out ) :: n_caps integer :: ibond logical :: atom_i_in_frag , atom_j_in_frag n_caps = 0 if (. not . present ( bonds )) return do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle ! Check if exactly one atom of this bond is in the fragment atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) ! Add cap only if one atom in fragment, other not (XOR condition) if (( atom_i_in_frag . and . . not . atom_j_in_frag ) . or . & (. not . atom_i_in_frag . and . atom_j_in_frag )) then n_caps = n_caps + 1 end if end do end subroutine count_hydrogen_caps subroutine add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , base_atom_count ) !! Add hydrogen caps to fragment for broken bonds !! Caps are placed at the position of the atom outside the fragment integer , intent ( in ) :: atoms_in_fragment (:) !! 0-indexed atom indices in fragment type ( bond_t ), intent ( in ) :: bonds (:) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( physical_fragment_t ), intent ( inout ) :: fragment integer , intent ( in ) :: base_atom_count !! Number of non-cap atoms integer :: ibond , cap_idx logical :: atom_i_in_frag , atom_j_in_frag if ( fragment % n_caps == 0 ) return cap_idx = 0 do ibond = 1 , size ( bonds ) if (. not . bonds ( ibond )% is_broken ) cycle atom_i_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_i ) atom_j_in_frag = any ( atoms_in_fragment == bonds ( ibond )% atom_j ) if ( atom_i_in_frag . and . . not . atom_j_in_frag ) then ! atom_i is in fragment, atom_j is not → cap at position of atom_j cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_j (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_j + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_j else if ( atom_j_in_frag . and . . not . atom_i_in_frag ) then ! atom_j is in fragment, atom_i is not → cap at position of atom_i cap_idx = cap_idx + 1 fragment % element_numbers ( base_atom_count + cap_idx ) = 1 ! Hydrogen ! Place H at position of atom_i (1-indexed for coordinates array) fragment % coordinates (:, base_atom_count + cap_idx ) = & sys_geom % coordinates (:, bonds ( ibond )% atom_i + 1 ) fragment % cap_replaces_atom ( cap_idx ) = bonds ( ibond )% atom_i end if end do end subroutine add_hydrogen_caps subroutine build_fragment_from_indices ( sys_geom , monomer_indices , fragment , bonds ) !! Build a fragment on-the-fly from monomer indices with hydrogen capping for broken bonds !! !! Extracts atoms from specified monomers and adds hydrogen caps where bonds are broken. !! Caps are always added at the end of the atom list. !! Supports both fixed-size (identical monomers) and variable-sized fragments. !! !! Example: monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5 !!          If connectivity shows broken bonds, hydrogens are capped at positions of missing atoms type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) type ( physical_fragment_t ), intent ( out ) :: fragment type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity information for capping integer :: n_monomers_in_frag , atoms_per_monomer , n_atoms_no_caps integer :: i , j , mono_idx , atom_start , atom_end , frag_atom_idx integer :: atom_i , atom_j , n_caps integer , allocatable :: atoms_in_fragment (:) !! List of all atom indices in this fragment integer :: iatom , atom_global_idx logical :: use_explicit_fragments n_monomers_in_frag = size ( monomer_indices ) ! Determine if we're using explicit fragment definitions or regular monomer-based use_explicit_fragments = allocated ( sys_geom % fragment_atoms ) if ( use_explicit_fragments ) then ! Variable-sized fragments: count total atoms from fragment definitions n_atoms_no_caps = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) n_atoms_no_caps = n_atoms_no_caps + sys_geom % fragment_sizes ( mono_idx ) end do ! Build list of atom indices (0-indexed) from explicit fragment definitions allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) iatom = iatom + 1 atoms_in_fragment ( iatom ) = sys_geom % fragment_atoms ( j , mono_idx ) end do end do else ! Fixed-size monomers: use atoms_per_monomer atoms_per_monomer = sys_geom % atoms_per_monomer n_atoms_no_caps = n_monomers_in_frag * atoms_per_monomer ! Build list of atom indices in this fragment (0-indexed to match bond indices) allocate ( atoms_in_fragment ( n_atoms_no_caps )) iatom = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer do atom_i = 0 , atoms_per_monomer - 1 iatom = iatom + 1 atoms_in_fragment ( iatom ) = atom_start + atom_i end do end do end if ! Count how many caps we need call count_hydrogen_caps ( atoms_in_fragment , bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms_no_caps + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms_no_caps )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping frag_atom_idx = 0 if ( use_explicit_fragments ) then ! Variable-sized: copy atoms based on explicit fragment definitions do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) do j = 1 , sys_geom % fragment_sizes ( mono_idx ) frag_atom_idx = frag_atom_idx + 1 ! fragment_atoms is 0-indexed, so +1 for Fortran arrays atom_global_idx = sys_geom % fragment_atoms ( j , mono_idx ) + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( frag_atom_idx ) = atom_global_idx ! Store 1-indexed global position end do end do else ! Fixed-size: use atoms_per_monomer do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer + 1 atom_end = mono_idx * atoms_per_monomer ! Copy coordinates and elements do atom_i = atom_start , atom_end frag_atom_idx = frag_atom_idx + 1 fragment % element_numbers ( frag_atom_idx ) = sys_geom % element_numbers ( atom_i ) fragment % coordinates (:, frag_atom_idx ) = sys_geom % coordinates (:, atom_i ) fragment % local_to_global ( frag_atom_idx ) = atom_i ! Store 1-indexed global position end do end do end if ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atoms_in_fragment , bonds , sys_geom , fragment , n_atoms_no_caps ) end if ! Set electronic structure properties from system geometry if ( use_explicit_fragments . and . allocated ( sys_geom % fragment_charges ) . and . & allocated ( sys_geom % fragment_multiplicities )) then ! Explicit fragments: sum charges and multiplicities from constituent fragments fragment % charge = 0 fragment % multiplicity = 1 ! Start with singlet assumption do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) fragment % charge = fragment % charge + sys_geom % fragment_charges ( mono_idx ) end do ! For single fragment, use its specific multiplicity if ( n_monomers_in_frag == 1 ) then fragment % multiplicity = sys_geom % fragment_multiplicities ( monomer_indices ( 1 )) else ! For multi-fragment composites, multiplicity needs careful treatment ! For now, default to system multiplicity (this may need refinement) fragment % multiplicity = sys_geom % multiplicity end if else ! Fixed-size monomers: use system defaults fragment % charge = sys_geom % charge fragment % multiplicity = sys_geom % multiplicity end if call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment ) deallocate ( atoms_in_fragment ) end subroutine build_fragment_from_indices subroutine build_fragment_from_atom_list ( sys_geom , atom_indices , n_atoms , fragment , bonds ) !! Build a fragment from explicit atom list (for GMBE intersection fragments) !! !! Similar to build_fragment_from_indices but takes atom indices directly instead of !! monomer indices. Used for building intersection fragments in GMBE calculations. !! Intersection fragments are ALWAYS NEUTRAL (charge=0, multiplicity=1). !! !! Example: atom_indices = [3, 4, 5] builds fragment from atoms 3, 4, 5 of the system type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: atom_indices (:) !! 0-indexed atom indices integer , intent ( in ) :: n_atoms !! Number of atoms in list type ( physical_fragment_t ), intent ( out ) :: fragment type ( bond_t ), intent ( in ), optional :: bonds (:) !! Connectivity for capping integer :: i , frag_atom_idx , atom_global_idx integer :: n_caps ! Count how many caps we need call count_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , n_caps ) ! Allocate arrays with space for original atoms + caps fragment % n_atoms = n_atoms + n_caps fragment % n_caps = n_caps allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) if ( n_caps > 0 ) allocate ( fragment % cap_replaces_atom ( n_caps )) allocate ( fragment % local_to_global ( n_atoms )) ! Only non-cap atoms ! Copy original atoms and build local→global mapping (atom_indices are 0-indexed, add 1 for Fortran arrays) do i = 1 , n_atoms atom_global_idx = atom_indices ( i ) + 1 ! Convert to 1-indexed fragment % element_numbers ( i ) = sys_geom % element_numbers ( atom_global_idx ) fragment % coordinates (:, i ) = sys_geom % coordinates (:, atom_global_idx ) fragment % local_to_global ( i ) = atom_global_idx ! Store 1-indexed global position end do ! Add hydrogen caps at end (if any) if ( present ( bonds ) . and . n_caps > 0 ) then call add_hydrogen_caps ( atom_indices ( 1 : n_atoms ), bonds , sys_geom , fragment , n_atoms ) end if ! Intersection fragments are ALWAYS NEUTRAL ! Rationale: For polypeptides, intersections are backbone atoms; ! charged side chains are in non-overlapping regions fragment % charge = 0 fragment % multiplicity = 1 call fragment % compute_nelec () ! Validate: check for spatially overlapping atoms call check_duplicate_atoms ( fragment ) end subroutine build_fragment_from_atom_list subroutine redistribute_cap_gradients ( fragment , fragment_gradient , system_gradient ) !! Redistribute hydrogen cap gradients to original atoms !! !! This subroutine handles gradient redistribution for fragments with hydrogen caps. !! Hydrogen caps are virtual atoms added at broken bonds - their gradients represent !! forces at the bond breakpoint and must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate gradient to system using local_to_global mapping !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap gradient to the original atom it replaces (from cap_replaces_atom) !! !! Example: !!   Fragment: [C, C, H_cap] where H_cap replaces atom 5 in system !!   Fragment gradient: [(3,1), (3,2), (3,3)] !!   - Atoms 1,2: accumulate to system using local_to_global !!   - Atom 3 (cap): add gradient to system atom 5 (cap_replaces_atom(1) + 1) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_gradient (:, :) !! (3, n_atoms_fragment) real ( dp ), intent ( inout ) :: system_gradient (:, :) !! (3, n_atoms_system) integer :: i , local_idx , global_idx integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate gradients for real atoms using local→global mapping do i = 1 , n_real_atoms global_idx = fragment % local_to_global ( i ) system_gradient (:, global_idx ) = system_gradient (:, global_idx ) + fragment_gradient (:, i ) end do ! Redistribute cap gradients to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap ! cap_replaces_atom is 0-indexed, add 1 for Fortran arrays global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Add cap gradient to the atom it replaces system_gradient (:, global_original_idx ) = system_gradient (:, global_original_idx ) + & fragment_gradient (:, local_cap_idx ) end do end if end subroutine redistribute_cap_gradients subroutine redistribute_cap_hessian ( fragment , fragment_hessian , system_hessian ) !! Redistribute hydrogen cap Hessian to original atoms !! !! This subroutine handles Hessian redistribution for fragments with hydrogen caps. !! The Hessian is a rank-2 tensor (3N × 3N) representing second derivatives of energy !! with respect to atomic coordinates. Similar to gradient redistribution, cap contributions !! must be transferred to the original atoms they replace. !! !! Algorithm: !!   1. For real atoms (indices 1 to n_atoms - n_caps): !!      Accumulate Hessian blocks to system using local_to_global mapping for both dimensions !!   2. For hydrogen caps (indices n_atoms - n_caps + 1 to n_atoms): !!      Add cap Hessian blocks (row and column) to the original atom it replaces !! !! Note: Hessian is stored as a flattened 2D array (3*n_atoms, 3*n_atoms) !!       where rows and columns are grouped by atoms (x,y,z for atom 1, then x,y,z for atom 2, etc.) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ), intent ( in ) :: fragment_hessian (:, :) !! (3*n_atoms_fragment, 3*n_atoms_fragment) real ( dp ), intent ( inout ) :: system_hessian (:, :) !! (3*n_atoms_system, 3*n_atoms_system) integer :: i , j , local_i , local_j , global_i , global_j integer :: icart , jcart integer :: i_cap , local_cap_idx , global_original_idx integer :: n_real_atoms integer :: i_cap_2 , local_cap_idx_2 , global_original_idx_2 n_real_atoms = fragment % n_atoms - fragment % n_caps ! Accumulate Hessian blocks for real atoms using local→global mapping ! Both row (i) and column (j) dimensions need mapping do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) ! Copy 3×3 block for atom pair (i,j) do icart = 0 , 2 ! x, y, z for atom i do jcart = 0 , 2 ! x, y, z for atom j system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do end do ! Redistribute cap Hessian blocks to original atoms they replace if ( fragment % n_caps > 0 ) then do i_cap = 1 , fragment % n_caps local_cap_idx = n_real_atoms + i_cap global_original_idx = fragment % cap_replaces_atom ( i_cap ) + 1 ! Cap rows: redistribute to original atom (cap derivatives w.r.t. all other atoms) do j = 1 , n_real_atoms global_j = fragment % local_to_global ( j ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_j - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( j - 1 ) + jcart + 1 ) end do end do end do ! Cap columns: redistribute to original atom (all other atoms' derivatives w.r.t. cap) do i = 1 , n_real_atoms global_i = fragment % local_to_global ( i ) do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_i - 1 ) + icart + 1 , 3 * ( global_original_idx - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( i - 1 ) + icart + 1 , 3 * ( local_cap_idx - 1 ) + jcart + 1 ) end do end do end do ! Cap-cap blocks: redistribute to original atom diagonal block do i_cap_2 = 1 , fragment % n_caps local_cap_idx_2 = n_real_atoms + i_cap_2 global_original_idx_2 = fragment % cap_replaces_atom ( i_cap_2 ) + 1 do icart = 0 , 2 do jcart = 0 , 2 system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) = & system_hessian ( 3 * ( global_original_idx - 1 ) + icart + 1 , 3 * ( global_original_idx_2 - 1 ) + jcart + 1 ) + & fragment_hessian ( 3 * ( local_cap_idx - 1 ) + icart + 1 , 3 * ( local_cap_idx_2 - 1 ) + jcart + 1 ) end do end do end do end do end if end subroutine redistribute_cap_hessian subroutine check_duplicate_atoms ( fragment ) !! Validate that fragment has no spatially overlapping atoms !! Checks if any two atoms are too close together (< 0.01 Bohr) !! This catches bugs in geometry construction or fragment building use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( physical_fragment_t ), intent ( in ) :: fragment integer :: i , j , n_atoms real ( dp ) :: distance , dx , dy , dz real ( dp ), parameter :: MIN_ATOM_DISTANCE = 0.01_dp !! Bohr - atoms closer than this are overlapping ! Only check non-cap atoms (caps can be close to replaced atoms) n_atoms = fragment % n_atoms - fragment % n_caps if ( n_atoms < 2 ) return do i = 1 , n_atoms - 1 do j = i + 1 , n_atoms dx = fragment % coordinates ( 1 , i ) - fragment % coordinates ( 1 , j ) dy = fragment % coordinates ( 2 , i ) - fragment % coordinates ( 2 , j ) dz = fragment % coordinates ( 3 , i ) - fragment % coordinates ( 3 , j ) distance = sqrt ( dx * dx + dy * dy + dz * dz ) if ( distance < MIN_ATOM_DISTANCE ) then call logger % error ( \"ERROR: Fragment contains overlapping atoms!\" ) call logger % error ( \"  Atoms \" // to_char ( i ) // \" and \" // to_char ( j ) // \" are too close together\" ) call logger % error ( \"  Distance: \" // to_char ( distance ) // \" Bohr (\" // & to_char ( distance * 0.529177_dp ) // \" Angstrom)\" ) call logger % error ( \"  Atom \" // to_char ( i ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( i )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , i )) // \", \" // & to_char ( fragment % coordinates ( 2 , i )) // \", \" // & to_char ( fragment % coordinates ( 3 , i )) // \") Bohr\" ) call logger % error ( \"  Atom \" // to_char ( j ) // \": \" // & element_number_to_symbol ( fragment % element_numbers ( j )) // & \" at (\" // to_char ( fragment % coordinates ( 1 , j )) // \", \" // & to_char ( fragment % coordinates ( 2 , j )) // \", \" // & to_char ( fragment % coordinates ( 3 , j )) // \") Bohr\" ) call logger % error ( \" \" ) call logger % error ( \"This indicates either:\" ) call logger % error ( \"  1. Bad input geometry (atoms on top of each other)\" ) call logger % error ( \"  2. Bug in fragment construction (duplicate atoms)\" ) error stop \"Overlapping atoms in fragment\" end if end do end do end subroutine check_duplicate_atoms subroutine fragment_destroy ( this ) !! Clean up allocated memory in physical_fragment_t class ( physical_fragment_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % cap_replaces_atom )) deallocate ( this % cap_replaces_atom ) if ( allocated ( this % local_to_global )) deallocate ( this % local_to_global ) if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if this % n_atoms = 0 this % charge = 0 this % multiplicity = 1 this % nelec = 0 this % n_caps = 0 end subroutine fragment_destroy subroutine fragment_compute_nelec ( this ) !! Compute number of electrons from atomic numbers and charge class ( physical_fragment_t ), intent ( inout ) :: this integer :: nuclear_charge nuclear_charge = sum ( this % element_numbers ) this % nelec = nuclear_charge - this % charge end subroutine fragment_compute_nelec subroutine fragment_set_basis ( this , basis ) !! Set the basis set for this fragment class ( physical_fragment_t ), intent ( inout ) :: this type ( molecular_basis_type ), intent ( in ) :: basis if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if allocate ( this % basis ) this % basis = basis end subroutine fragment_set_basis subroutine system_destroy ( this ) !! Clean up allocated memory in system_geometry_t class ( system_geometry_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % fragment_sizes )) deallocate ( this % fragment_sizes ) if ( allocated ( this % fragment_atoms )) deallocate ( this % fragment_atoms ) if ( allocated ( this % fragment_charges )) deallocate ( this % fragment_charges ) if ( allocated ( this % fragment_multiplicities )) deallocate ( this % fragment_multiplicities ) this % n_monomers = 0 this % atoms_per_monomer = 0 this % total_atoms = 0 end subroutine system_destroy pure function fragment_centroid ( fragment ) result ( centroid ) !! Calculate the geometric centroid (center of geometry) of a fragment !! This is the simple average of all atomic coordinates !! Returns coordinates in the same units as the fragment (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ) :: centroid ( 3 ) integer :: i centroid = 0.0_dp do i = 1 , fragment % n_atoms centroid = centroid + fragment % coordinates (:, i ) end do centroid = centroid / real ( fragment % n_atoms , dp ) end function fragment_centroid pure function fragment_center_of_mass ( fragment ) result ( com ) !! Calculate the center of mass of a fragment !! Weights each atomic position by its atomic mass !! Returns coordinates in the same units as the fragment (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ) :: com ( 3 ) real ( dp ) :: total_mass , atom_mass integer :: i com = 0.0_dp total_mass = 0.0_dp do i = 1 , fragment % n_atoms atom_mass = element_mass ( fragment % element_numbers ( i )) com = com + atom_mass * fragment % coordinates (:, i ) total_mass = total_mass + atom_mass end do com = com / total_mass end function fragment_center_of_mass pure function distance_between_points ( point1 , point2 ) result ( distance ) !! Calculate Euclidean distance between two 3D points !! Points should be in the same units (typically Bohr) real ( dp ), intent ( in ) :: point1 ( 3 ), point2 ( 3 ) real ( dp ) :: distance real ( dp ) :: diff ( 3 ) diff = point2 - point1 distance = sqrt ( dot_product ( diff , diff )) end function distance_between_points pure function distance_between_fragments ( frag1 , frag2 , use_com ) result ( distance ) !! Calculate distance between two fragments !! If use_com is .true., uses center of mass; otherwise uses centroid !! Distance is in the same units as the fragment coordinates (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: frag1 , frag2 logical , intent ( in ) :: use_com real ( dp ) :: distance real ( dp ) :: point1 ( 3 ), point2 ( 3 ) if ( use_com ) then point1 = fragment_center_of_mass ( frag1 ) point2 = fragment_center_of_mass ( frag2 ) else point1 = fragment_centroid ( frag1 ) point2 = fragment_centroid ( frag2 ) end if distance = distance_between_points ( point1 , point2 ) end function distance_between_fragments pure function minimal_distance_between_fragments ( frag1 , frag2 ) result ( min_distance ) !! Calculate the minimal distance between any two atoms in two fragments !! This iterates over all atom pairs and finds the closest pair !! Distance is in the same units as the fragment coordinates (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: frag1 , frag2 real ( dp ) :: min_distance real ( dp ) :: current_distance integer :: i , j ! Initialize with a very large value min_distance = huge ( 1.0_dp ) do i = 1 , frag1 % n_atoms do j = 1 , frag2 % n_atoms current_distance = distance_between_points ( frag1 % coordinates (:, i ), & frag2 % coordinates (:, j )) if ( current_distance < min_distance ) then min_distance = current_distance end if end do end do end function minimal_distance_between_fragments end module mqc_physical_fragment","tags":"","url":"sourcefile/mqc_physical_fragment.f90.html"},{"title":"mqc_xyz_reader.f90 – metalquicha","text":"XYZ molecular geometry file reader This file depends on sourcefile~~mqc_xyz_reader.f90~~EfferentGraph sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_xyz_reader.f90~~AfferentGraph sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! XYZ molecular geometry file reader module mqc_xyz_reader !! Provides functions to parse standard XYZ format files containing !! atomic coordinates and element symbols for molecular structures. use pic_types , only : dp use mqc_geometry , only : geometry_type use mqc_error , only : error_t , ERROR_IO , ERROR_PARSE implicit none private public :: read_xyz_file !! Read XYZ file from disk public :: read_xyz_string !! Parse XYZ data from string public :: split_lines !! Split text into lines (for testing) ! Constants integer , parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 !! Maximum element symbol length contains subroutine read_xyz_file ( filename , geom , error ) !! Read molecular geometry from XYZ format file !! !! Parses standard XYZ files with format: !! Line 1: Number of atoms !! Line 2: Comment/title line !! Lines 3+: Element X Y Z (coordinates in Angstrom) character ( len =* ), intent ( in ) :: filename !! Path to XYZ file type ( geometry_type ), intent ( out ) :: geom !! Parsed molecular geometry type ( error_t ), intent ( out ) :: error !! Error handling integer :: unit !! File unit number integer :: io_stat !! I/O operation status integer :: file_size !! File size in bytes logical :: file_exists !! Whether file exists on disk character ( len = :), allocatable :: file_contents !! Full file content buffer ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then call error % set ( ERROR_IO , \"XYZ file not found: \" // trim ( filename )) return end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: file_contents ) ! Open and read entire file as stream open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = io_stat ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error opening file: \" // trim ( filename )) return end if read ( unit , iostat = io_stat ) file_contents close ( unit ) if ( io_stat /= 0 ) then call error % set ( ERROR_IO , \"Error reading file: \" // trim ( filename )) return end if ! Parse the contents call read_xyz_string ( file_contents , geom , error ) end subroutine read_xyz_file pure subroutine read_xyz_string ( xyz_string , geom , error ) !! Parse molecular geometry from XYZ format string character ( len =* ), intent ( in ) :: xyz_string type ( geometry_type ), intent ( out ) :: geom type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: lines (:) integer :: nlines , iatom , io_stat character ( len = 256 ) :: element real ( dp ) :: x , y , z ! Split into lines call split_lines ( xyz_string , lines , nlines ) if ( nlines < 2 ) then call error % set ( ERROR_PARSE , \"XYZ file must have at least 2 lines (natoms + comment)\" ) return end if ! Read number of atoms from first line read ( lines ( 1 ), * , iostat = io_stat ) geom % natoms if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to read number of atoms from first line\" ) return end if if ( geom % natoms < 0 ) then call error % set ( ERROR_PARSE , \"Number of atoms must be non-negative\" ) return end if ! Store comment line geom % comment = trim ( adjustl ( lines ( 2 ))) ! Check we have enough lines if ( nlines < 2 + geom % natoms ) then call error % set ( ERROR_PARSE , \"XYZ file has insufficient lines: expected \" // & trim ( int_to_string ( 2 + geom % natoms )) // \", got \" // & trim ( int_to_string ( nlines ))) return end if ! Allocate arrays allocate ( character ( len = MAX_ELEMENT_SYMBOL_LEN ) :: geom % elements ( geom % natoms )) allocate ( geom % coords ( 3 , geom % natoms )) ! Read atom data do iatom = 1 , geom % natoms read ( lines ( 2 + iatom ), * , iostat = io_stat ) element , x , y , z if ( io_stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse atom data on line \" // & trim ( int_to_string ( 2 + iatom )) // \": '\" // & trim ( lines ( 2 + iatom )) // \"'\" ) return end if geom % elements ( iatom ) = trim ( adjustl ( element )) geom % coords ( 1 , iatom ) = x geom % coords ( 2 , iatom ) = y geom % coords ( 3 , iatom ) = z end do end subroutine read_xyz_string pure function int_to_string ( i ) result ( str ) !! Convert integer to string integer , intent ( in ) :: i character ( len = :), allocatable :: str character ( len = 20 ) :: buffer write ( buffer , '(I0)' ) i str = trim ( adjustl ( buffer )) end function int_to_string pure subroutine split_lines ( text , lines , nlines ) !! Split input text into lines based on CR, LF, or CRLF line endings !! Trailing newlines do not create empty lines character ( len =* ), intent ( in ) :: text character ( len = :), allocatable , intent ( out ) :: lines (:) integer , intent ( out ) :: nlines integer :: i , line_start , line_end , max_line_len character ( len = :), allocatable :: temp_lines (:) if ( len ( text ) == 0 ) then nlines = 0 allocate ( character ( len = 1 ) :: lines ( 0 )) return end if ! Pass 1: Count lines and find maximum line length nlines = 0 max_line_len = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 ! Skip both CR and LF else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 max_line_len = max ( max_line_len , len ( text ) - line_start + 1 ) end if ! Handle empty text or ensure at least length 1 if ( max_line_len == 0 ) max_line_len = 1 ! Allocate output array allocate ( character ( len = max_line_len ) :: temp_lines ( nlines )) ! Pass 2: Extract lines nlines = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = len ( text ) - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if ! Copy to output (use explicit loop for Intel compiler compatibility) allocate ( character ( len = max_line_len ) :: lines ( nlines )) block integer :: iline do iline = 1 , nlines lines ( iline ) = temp_lines ( iline ) end do end block end subroutine split_lines end module mqc_xyz_reader","tags":"","url":"sourcefile/mqc_xyz_reader.f90.html"},{"title":"mqc_cgto.f90 – metalquicha","text":"Data structures for cartesian contracted Gaussian type orbitals (CGTOs) Files dependent on this one sourcefile~~mqc_cgto.f90~~AfferentGraph sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Data structures for cartesian contracted Gaussian type orbitals (CGTOs) module mqc_cgto !! Defines data structures for cartesian contracted Gaussian type orbitals (CGTOs) use pic_types , only : dp implicit none private public :: cgto_type , atomic_basis_type , molecular_basis_type type :: cgto_type !! Contracted Gaussian type orbital (CGTO) data structure integer :: ang_mom !! Angular momentum quantum number (0=s, 1=p, 2=d, etc.) integer :: nfunc !! Number of primitive Gaussians in the contraction real ( dp ), allocatable :: exponents (:) !! Exponents (alpha values) real ( dp ), allocatable :: coefficients (:) !! Contraction coefficients contains procedure :: allocate_arrays => cgto_allocate_arrays procedure :: destroy => cgto_destroy procedure :: num_basis_functions => cgto_num_basis_functions end type cgto_type type :: atomic_basis_type !! Atomic basis set data structure character ( len = :), allocatable :: element !! element symbol type ( cgto_type ), allocatable :: shells (:) !! array of contracted shells integer :: nshells !! number of shells in type contains procedure :: allocate_shells => allocate_basis_shells procedure :: destroy => atomic_basis_destroy procedure :: num_basis_functions => atomic_basis_num_basis_functions end type atomic_basis_type type :: molecular_basis_type !! Molecular basis set data structure (assembled basis) type ( atomic_basis_type ), allocatable :: elements (:) !! array of atomic basis types integer :: nelements !! total number of atoms/elements in a molecule contains procedure :: allocate_elements => basis_set_allocate_elements procedure :: destroy => basis_set_destroy procedure :: num_basis_functions => molecular_basis_num_basis_functions end type molecular_basis_type contains pure subroutine cgto_allocate_arrays ( self , nfunc ) !! Allocate arrays for exponents and coefficients in a CGTO class ( cgto_type ), intent ( inout ) :: self integer , intent ( in ) :: nfunc self % nfunc = nfunc allocate ( self % exponents ( nfunc )) allocate ( self % coefficients ( nfunc )) end subroutine cgto_allocate_arrays pure subroutine cgto_destroy ( self ) !! Clean up allocated memory in a CGTO class ( cgto_type ), intent ( inout ) :: self if ( allocated ( self % exponents )) deallocate ( self % exponents ) if ( allocated ( self % coefficients )) deallocate ( self % coefficients ) self % nfunc = 0 self % ang_mom = 0 end subroutine cgto_destroy pure subroutine allocate_basis_shells ( self , nshells ) !! Allocate array of shells in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nshells self % nshells = nshells allocate ( self % shells ( nshells )) end subroutine allocate_basis_shells pure subroutine atomic_basis_destroy ( self ) !! Clean up allocated memory in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % shells )) then do i = 1 , self % nshells call self % shells ( i )% destroy () end do deallocate ( self % shells ) end if if ( allocated ( self % element )) deallocate ( self % element ) self % nshells = 0 end subroutine atomic_basis_destroy pure subroutine basis_set_allocate_elements ( self , nelements ) !! Allocate array of atomic basis elements in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nelements self % nelements = nelements allocate ( self % elements ( nelements )) end subroutine basis_set_allocate_elements pure subroutine basis_set_destroy ( self ) !! Clean up allocated memory in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % elements )) then do i = 1 , self % nelements call self % elements ( i )% destroy () end do deallocate ( self % elements ) end if self % nelements = 0 end subroutine basis_set_destroy pure function cgto_num_basis_functions ( self ) result ( nbf ) !! Get number of basis functions in a shell (Cartesian) class ( cgto_type ), intent ( in ) :: self integer :: nbf ! Cartesian: (ang_mom+1)*(ang_mom+2)/2 nbf = ( self % ang_mom + 1 ) * ( self % ang_mom + 2 ) / 2 end function cgto_num_basis_functions pure function atomic_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for an atom class ( atomic_basis_type ), intent ( in ) :: self integer :: nbf integer :: ishell nbf = 0 do ishell = 1 , self % nshells nbf = nbf + self % shells ( ishell )% num_basis_functions () end do end function atomic_basis_num_basis_functions pure function molecular_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for the molecule class ( molecular_basis_type ), intent ( in ) :: self integer :: nbf integer :: iatom nbf = 0 do iatom = 1 , self % nelements nbf = nbf + self % elements ( iatom )% num_basis_functions () end do end function molecular_basis_num_basis_functions end module mqc_cgto","tags":"","url":"sourcefile/mqc_cgto.f90.html"},{"title":"mqc_basis_utils.f90 – metalquicha","text":"Utilities for handling basis set names and files This file depends on sourcefile~~mqc_basis_utils.f90~~EfferentGraph sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_basis_utils.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_basis_utils.f90~~AfferentGraph sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_cli_parser.f90 mqc_cli_parser.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_basis_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Utilities for handling basis set names and files module mqc_basis_utils !! Provides utilities for normalizing basis set names and locating basis set files !! !! Normalization rules: !!   * -> s   (e.g., 6-31G* -> 6-31Gs) !!   + -> p   (e.g., 6-31+G -> 6-31pG) !!   (d,p) -> dp (remove parentheses and commas) use mqc_error , only : error_t , ERROR_IO implicit none private public :: normalize_basis_name public :: find_basis_file contains pure function normalize_basis_name ( basis_name ) result ( normalized ) !! Normalize basis set name to filename-safe format !! !! Rules: !!   * -> s !!   + -> p !!   Remove parentheses and commas !! !! Examples: !!   6-31G*      -> 6-31Gs !!   6-31+G*     -> 6-31pGs !!   6-31G(d)    -> 6-31Gd !!   6-311G(d,p) -> 6-311Gdp !!   6-311++G**  -> 6-311ppGss !!   cc-pVDZ     -> cc-pVDZ (unchanged) character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable :: normalized integer :: i , out_pos character ( len = 256 ) :: buffer logical :: in_parens buffer = \"\" out_pos = 0 in_parens = . false . do i = 1 , len_trim ( basis_name ) select case ( basis_name ( i : i )) case ( '*' ) ! Star becomes 's' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 's' case ( '+' ) ! Plus becomes 'p' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 'p' case ( '(' ) ! Start of parentheses - we'll extract contents in_parens = . true . case ( ')' ) ! End of parentheses in_parens = . false . case ( ',' , ' ' ) ! Skip commas and spaces (inside or outside parentheses) continue case default ! Copy character as-is out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = basis_name ( i : i ) end select end do normalized = trim ( buffer ( 1 : out_pos )) end function normalize_basis_name subroutine find_basis_file ( basis_name , filename , error ) !! Find basis set file using normalized name !! !! Search strategy: !!   1. Normalize the basis name (e.g., 6-31G* -> 6-31Gs) !!   2. Look for basis_sets/{normalized}.txt !!   3. If not found, return error !! !! This is a simple, straightforward approach that assumes !! the JSON/mqc input provides the correct basis set name. character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable , intent ( out ) :: filename type ( error_t ), intent ( out ) :: error character ( len = :), allocatable :: normalized logical :: file_exists character ( len = 512 ) :: filepath ! Normalize the basis name normalized = normalize_basis_name ( basis_name ) ! Construct file path: basis_sets/{normalized}.txt filepath = \"basis_sets/\" // trim ( normalized ) // \".txt\" ! Check if file exists inquire ( file = trim ( filepath ), exist = file_exists ) if ( file_exists ) then filename = trim ( filepath ) else call error % set ( ERROR_IO , \"Basis set file not found: \" // trim ( filepath ) // & \" (from basis name: \" // trim ( basis_name ) // \")\" ) end if end subroutine find_basis_file end module mqc_basis_utils","tags":"","url":"sourcefile/mqc_basis_utils.f90.html"},{"title":"mqc_logo.f90 – metalquicha","text":"ASCII art logo display for metalquicha Files dependent on this one sourcefile~~mqc_logo.f90~~AfferentGraph sourcefile~mqc_logo.f90 mqc_logo.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_logo.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! ASCII art logo display for metalquicha module mqc_logo !! Provides the project branding sunflower logo and version information !! displayed at program startup. implicit none private public :: print_logo !! Display ASCII sunflower logo and project info contains subroutine print_logo () !! Print the PIC Chemistry ASCII sunflower logo write ( * , '(A)' ) ' ' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                        __   __' write ( * , '(A)' ) '                     .-(  ''.''  )-.' write ( * , '(A)' ) '                    (   \\  |  /   )' write ( * , '(A)' ) '                   ( ''`-.;;;;;.-''` )' write ( * , '(A)' ) '                  ( :-==;;;;;;;==-: )' write ( * , '(A)' ) '                   (  .-'';;;;;''-.  )' write ( * , '(A)' ) '                    (``  /  |  \\  ``)' write ( * , '(A)' ) '                     ''-(__.''.__)-''' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                      (Art by jgs)' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '    ╔═══════════════════════════════════════════════╗' write ( * , '(A)' ) '    ║              Met\"al q\"uicha                   ║' write ( * , '(A)' ) '    ║                (Sunflower)                    ║' write ( * , '(A)' ) '    ║     A hastily put together framework for      ║' write ( * , '(A)' ) '    ║   Fortran Based High Performance Computing    ║' write ( * , '(A)' ) '    ║                                               ║' write ( * , '(A)' ) '    ║        Case study: quantum chemistry          ║' write ( * , '(A)' ) '    ╚═══════════════════════════════════════════════╝' write ( * , '(A)' ) ' ' end subroutine print_logo end module mqc_logo","tags":"","url":"sourcefile/mqc_logo.f90.html"},{"title":"mqc_mbe.f90 – metalquicha","text":"Many-Body Expansion (MBE) calculation module This file depends on sourcefile~~mqc_mbe.f90~~EfferentGraph sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe.f90~~AfferentGraph sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Many-Body Expansion (MBE) calculation module module mqc_mbe !! Implements hierarchical many-body expansion for fragment-based quantum chemistry !! calculations with MPI parallelization and energy/gradient computation. use pic_types , only : int32 , int64 , dp use pic_timer , only : timer_type use pic_mpi_lib , only : comm_t , send , recv , iprobe , MPI_Status , MPI_ANY_SOURCE , MPI_ANY_TAG use pic_logger , only : logger => global_logger , verbose_level , debug_level , info_level use pic_io , only : to_char use mqc_mbe_io , only : print_detailed_breakdown , print_detailed_breakdown_json use mqc_mpi_tags , only : TAG_WORKER_REQUEST , TAG_WORKER_FRAGMENT , TAG_WORKER_FINISH , & TAG_WORKER_SCALAR_RESULT , & TAG_NODE_REQUEST , TAG_NODE_FRAGMENT , TAG_NODE_FINISH , & TAG_NODE_SCALAR_RESULT use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , build_fragment_from_indices , to_angstrom use mqc_frag_utils , only : get_next_combination , fragment_lookup_t implicit none private ! Public interface public :: compute_mbe_energy , compute_mbe_energy_gradient , compute_mbe_energy_gradient_hessian public :: compute_gmbe_energy !! GMBE energy with intersection correction public :: compute_gmbe_energy_gradient !! GMBE energy and gradient with intersection correction public :: compute_gmbe_energy_gradient_hessian !! GMBE energy, gradient, and Hessian with intersection correction contains subroutine compute_mbe_energy ( polymers , fragment_count , max_level , results , total_energy ) !! Compute the many-body expansion (MBE) energy !! Total = sum(E(i)) + sum(deltaE(ij)) + sum(deltaE(ijk)) + ... !! General n-body correction: !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all lower-order terms !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. !! Detailed breakdown is printed only if logger level is verbose or higher. use mqc_result_types , only : calculation_result_t integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( out ) :: total_energy integer ( int64 ) :: i integer :: fragment_size , body_level , current_log_level real ( dp ), allocatable :: sum_by_level (:), delta_energies (:), energies (:) real ( dp ) :: delta_E logical :: do_detailed_print type ( fragment_lookup_t ) :: lookup type ( timer_type ) :: lookup_timer call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) allocate ( energies ( fragment_count )) sum_by_level = 0.0_dp delta_energies = 0.0_dp ! Extract total energies from results do i = 1_int64 , fragment_count energies ( i ) = results ( i )% energy % total () end do ! Build hash table for fast fragment lookups call lookup_timer % start () call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) call lookup % insert ( polymers ( i , :), fragment_size , i ) end do call lookup_timer % stop () call logger % debug ( \"Time to build lookup table: \" // to_char ( lookup_timer % get_elapsed_time ()) // \" s\" ) call logger % debug ( \"Hash table size: \" // to_char ( lookup % table_size ) // & \", entries: \" // to_char ( lookup % n_entries )) ! Bottom-up computation: process fragments by size (1-body, then 2-body, then 3-body, etc.) ! This eliminates recursion and redundant subset computations do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == 1 ) then ! 1-body: deltaE = E (no subsets to subtract) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: deltaE = E - sum(all subset deltaEs) ! All subsets have already been computed in previous iterations delta_E = compute_mbe ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E end if end do ! Clean up lookup table call lookup % destroy () total_energy = sum ( sum_by_level ) ! Print text summary to console call logger % info ( \"MBE Energy breakdown:\" ) do body_level = 1 , max_level if ( abs ( sum_by_level ( body_level )) > 1e-15_dp ) then block character ( len = 256 ) :: energy_line write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , body_level , \"-body:  \" , sum_by_level ( body_level ) call logger % info ( trim ( energy_line )) end block end if end do block character ( len = 256 ) :: total_line write ( total_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( total_line )) end block ! Print detailed breakdown if requested if ( do_detailed_print ) then call print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) end if ! Always write JSON file for machine-readable output call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy ) deallocate ( sum_by_level , delta_energies , energies ) end subroutine compute_mbe_energy function compute_mbe ( fragment_idx , fragment , lookup , energies , delta_energies , n ) result ( delta_E ) !! Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas) !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all subset deltaE values !! All subsets must have been computed already (guaranteed by processing fragments in order) integer ( int64 ), intent ( in ) :: fragment_idx !! Index of this fragment (already known) integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup !! Pre-built hash table for lookups real ( dp ), intent ( in ) :: energies (:), delta_energies (:) !! Pre-computed delta values real ( dp ) :: delta_E integer :: subset_size , i integer , allocatable :: indices (:), subset (:) integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer energy delta_E = energies ( fragment_idx ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 allocate ( indices ( subset_size )) allocate ( subset ( subset_size )) ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset , subset_size ) if ( subset_idx < 0 ) error stop \"Subset not found in bottom-up MBE!\" ! Subtract pre-computed delta energy delta_E = delta_E - delta_energies ( subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do deallocate ( indices , subset ) end do end function compute_mbe subroutine map_fragment_to_system_gradient ( frag_grad , monomers , sys_geom , sys_grad , bonds ) !! Map fragment gradient to system gradient coordinates with hydrogen cap redistribution !! !! This function rebuilds the fragment to get local→global mappings and cap information, !! then redistributes gradients including hydrogen caps to their original atoms. !! !! If bonds are not present, uses the old simple mapping (no caps possible). use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_gradients use mqc_config_parser , only : bond_t use pic_logger , only : verbose_level real ( dp ), intent ( in ) :: frag_grad (:, :) !! (3, natoms_frag) integer , intent ( in ) :: monomers (:) !! Monomer indices in fragment type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_grad (:, :) !! (3, total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps type ( physical_fragment_t ) :: fragment integer :: i_mon , i_atom , frag_atom_idx , sys_atom_idx integer :: current_log_level ! Explicitly zero out the entire sys_grad array sys_grad = 0.0_dp ! Debug output call logger % configuration ( level = current_log_level ) if ( current_log_level >= debug_level ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,*(i0,1x))' ) \"  Mapping fragment with \" , size ( monomers ), \" monomers: \" , monomers call logger % debug ( trim ( debug_msg )) write ( debug_msg , '(a,i0,a)' ) \"  Fragment has \" , size ( frag_grad , 2 ), \" atoms\" call logger % debug ( trim ( debug_msg )) end block end if if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , bonds ) ! Use new gradient redistribution with cap handling call redistribute_cap_gradients ( fragment , frag_grad , sys_grad ) ! Clean up call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment gradient to system positions (fixed-size monomers only) frag_atom_idx = 0 do i_mon = 1 , size ( monomers ) do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_idx = frag_atom_idx + 1 sys_atom_idx = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom if ( current_log_level >= debug_level . and . i_atom == 1 ) then block character ( len = 256 ) :: debug_msg write ( debug_msg , '(a,i0,a,i0,a,i0)' ) & \"    Monomer \" , monomers ( i_mon ), \": frag atoms \" , & frag_atom_idx , \" -> sys atom \" , sys_atom_idx call logger % debug ( trim ( debug_msg )) end block end if sys_grad (:, sys_atom_idx ) = frag_grad (:, frag_atom_idx ) end do end do end if end subroutine map_fragment_to_system_gradient subroutine compute_mbe_gradient ( fragment_idx , fragment , lookup , results , delta_gradients , n , sys_geom , bonds ) !! Bottom-up computation of n-body gradient correction !! Exactly mirrors the energy MBE logic: deltaG = G - sum(all subset deltaGs) !! All gradients are in system coordinates, so subtraction is simple use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_gradients (:, :, :) !! (3, total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps integer :: subset_size , i integer , allocatable :: indices (:), subset (:) integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer gradient mapped to system coordinates call map_fragment_to_system_gradient ( results ( fragment_idx )% gradient , fragment , & sys_geom , delta_gradients (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) ! This is EXACTLY like the energy calculation, but for each gradient component do subset_size = 1 , n - 1 allocate ( indices ( subset_size )) allocate ( subset ( subset_size )) ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset , subset_size ) if ( subset_idx < 0 ) error stop \"Subset not found in MBE gradient!\" ! Subtract pre-computed delta gradient (simple array subtraction in system coords) delta_gradients (:, :, fragment_idx ) = delta_gradients (:, :, fragment_idx ) - & delta_gradients (:, :, subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do deallocate ( indices , subset ) end do end subroutine compute_mbe_gradient subroutine compute_mbe_energy_gradient ( polymers , fragment_count , max_level , results , sys_geom , & total_energy , total_gradient , bonds ) !! Compute both MBE energy and gradient in a single pass !! This is more efficient than calling compute_mbe_energy and compute_mbe_gradient separately !! as it only builds the lookup table once and processes all fragments in one loop use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level type ( calculation_result_t ), intent ( in ) :: results (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: total_energy real ( dp ), intent ( out ) :: total_gradient (:, :) !! (3, total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps integer ( int64 ) :: i integer :: fragment_size , body_level , current_log_level , iatom real ( dp ), allocatable :: sum_by_level (:), delta_energies (:), energies (:) real ( dp ), allocatable :: delta_gradients (:, :, :) !! (3, total_atoms, fragment_count) real ( dp ) :: delta_E logical :: do_detailed_print type ( fragment_lookup_t ) :: lookup type ( timer_type ) :: lookup_timer ! Validate that all fragments have gradients do i = 1_int64 , fragment_count if (. not . results ( i )% has_gradient ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have gradient!\" ) error stop \"Missing gradient in compute_mbe_energy_gradient\" end if end do call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) ! Allocate arrays for energy allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) allocate ( energies ( fragment_count )) sum_by_level = 0.0_dp delta_energies = 0.0_dp ! Extract total energies from results do i = 1_int64 , fragment_count energies ( i ) = results ( i )% energy % total () end do ! Allocate arrays for gradient allocate ( delta_gradients ( 3 , sys_geom % total_atoms , fragment_count )) delta_gradients = 0.0_dp total_gradient = 0.0_dp ! Build hash table for fast fragment lookups (shared for both energy and gradient) call lookup_timer % start () call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) call lookup % insert ( polymers ( i , :), fragment_size , i ) end do call lookup_timer % stop () call logger % debug ( \"Time to build lookup table: \" // to_char ( lookup_timer % get_elapsed_time ()) // \" s\" ) call logger % debug ( \"Hash table size: \" // to_char ( lookup % table_size ) // & \", entries: \" // to_char ( lookup % n_entries )) ! Bottom-up computation: process fragments by size (1-body, 2-body, 3-body, etc.) ! Compute both energy and gradient deltas in the same loop do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == 1 ) then ! 1-body: deltaE = E, deltaG = G (no subsets to subtract) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) ! Map fragment gradient to system coordinates call map_fragment_to_system_gradient ( results ( i )% gradient , polymers ( i , 1 : fragment_size ), & sys_geom , delta_gradients (:, :, i ), bonds ) else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: deltaE = E - sum(all subset deltaEs), deltaG = G - sum(all subset deltaGs) ! Energy delta delta_E = compute_mbe ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E ! Gradient delta call compute_mbe_gradient ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_gradients , fragment_size , sys_geom , bonds ) end if end do ! Clean up lookup table call lookup % destroy () ! Compute total energy total_energy = sum ( sum_by_level ) ! Compute total gradient do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then total_gradient = total_gradient + delta_gradients (:, :, i ) end if end do ! Print energy breakdown call logger % info ( \"MBE Energy breakdown:\" ) do body_level = 1 , max_level if ( abs ( sum_by_level ( body_level )) > 1e-15_dp ) then block character ( len = 256 ) :: energy_line write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , body_level , \"-body:  \" , sum_by_level ( body_level ) call logger % info ( trim ( energy_line )) end block end if end do block character ( len = 256 ) :: total_line write ( total_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( total_line )) end block ! Print gradient info call logger % info ( \"MBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if verbose and small system if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total MBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if ! Print detailed breakdown if requested if ( do_detailed_print ) then call print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) end if ! Always write JSON file for machine-readable output (include gradient) call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy , total_gradient ) deallocate ( sum_by_level , delta_energies , energies , delta_gradients ) end subroutine compute_mbe_energy_gradient subroutine compute_mbe_energy_gradient_hessian ( polymers , fragment_count , max_level , results , sys_geom , & total_energy , total_gradient , total_hessian , bonds ) !! Compute MBE energy, gradient, and Hessian in a single pass !! Most efficient for simultaneous energy+gradient+Hessian calculations use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_gradients , & redistribute_cap_hessian integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level type ( calculation_result_t ), intent ( in ) :: results (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: total_energy real ( dp ), intent ( out ) :: total_gradient (:, :) !! (3, total_atoms) real ( dp ), intent ( out ) :: total_hessian (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int64 ) :: i integer :: fragment_size , body_level , current_log_level , iatom real ( dp ), allocatable :: sum_by_level (:), delta_energies (:), energies (:) real ( dp ), allocatable :: delta_gradients (:, :, :), delta_hessians (:, :, :) type ( fragment_lookup_t ) :: lookup logical :: do_detailed_print integer :: hess_dim type ( physical_fragment_t ) :: fragment real ( dp ), allocatable :: temp_hess (:, :) real ( dp ) :: delta_E hess_dim = 3 * sys_geom % total_atoms ! Validate all fragments have Hessians do i = 1 , fragment_count if (. not . results ( i )% has_hessian ) then call logger % error ( \"Fragment \" // to_char ( i ) // \" does not have Hessian!\" ) error stop \"Missing Hessian in compute_mbe_energy_gradient_hessian\" end if end do call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) allocate ( energies ( fragment_count )) allocate ( delta_gradients ( 3 , sys_geom % total_atoms , fragment_count )) allocate ( delta_hessians ( hess_dim , hess_dim , fragment_count )) allocate ( temp_hess ( hess_dim , hess_dim )) sum_by_level = 0.0_dp delta_energies = 0.0_dp energies = 0.0_dp delta_gradients = 0.0_dp delta_hessians = 0.0_dp total_gradient = 0.0_dp total_hessian = 0.0_dp ! Build lookup table for fragment indices call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size > 0 . and . fragment_size <= max_level ) then call lookup % insert ( polymers ( i , 1 : fragment_size ), fragment_size , i ) end if end do ! Compute delta energies, gradients, and Hessians for each fragment do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) energies ( i ) = results ( i )% energy % total () if ( fragment_size == 1 ) then ! 1-body: delta = value (no subsets) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) ! Map fragment gradient and Hessian to system coordinates call map_fragment_to_system_gradient ( results ( i )% gradient , polymers ( i , 1 : fragment_size ), & sys_geom , delta_gradients (:, :, i ), bonds ) call map_fragment_to_system_hessian ( results ( i )% hessian , polymers ( i , 1 : fragment_size ), & sys_geom , delta_hessians (:, :, i ), bonds ) else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: delta = value - sum(all subset deltas) delta_E = compute_mbe ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E ! Gradient delta call compute_mbe_gradient ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_gradients , fragment_size , sys_geom , bonds ) ! Hessian delta call compute_mbe_hessian ( i , polymers ( i , 1 : fragment_size ), lookup , & results , delta_hessians , fragment_size , sys_geom , bonds ) end if end do ! Clean up lookup table call lookup % destroy () ! Compute total energy, gradient, and Hessian total_energy = sum ( sum_by_level ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size <= max_level ) then total_gradient = total_gradient + delta_gradients (:, :, i ) total_hessian = total_hessian + delta_hessians (:, :, i ) end if end do ! Print energy breakdown call logger % info ( \"MBE Energy breakdown:\" ) do body_level = 1 , max_level if ( abs ( sum_by_level ( body_level )) > 1e-15_dp ) then block character ( len = 256 ) :: energy_line write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , body_level , \"-body:  \" , sum_by_level ( body_level ) call logger % info ( trim ( energy_line )) end block end if end do block character ( len = 256 ) :: total_line write ( total_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( total_line )) end block ! Print gradient and Hessian info call logger % info ( \"MBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) call logger % info ( \"MBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) ! Print detailed gradient if verbose and small system if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total MBE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if ! Always write JSON file for machine-readable output (include gradient and Hessian) call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy , total_gradient , total_hessian ) deallocate ( sum_by_level , delta_energies , energies , delta_gradients , delta_hessians , temp_hess ) end subroutine compute_mbe_energy_gradient_hessian subroutine map_fragment_to_system_hessian ( frag_hess , monomers , sys_geom , sys_hess , bonds ) !! Map fragment Hessian to system Hessian coordinates with hydrogen cap redistribution use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_hessian use mqc_config_parser , only : bond_t real ( dp ), intent ( in ) :: frag_hess (:, :) !! (3*natoms_frag, 3*natoms_frag) integer , intent ( in ) :: monomers (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( inout ) :: sys_hess (:, :) !! (3*total_atoms, 3*total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: fragment ! Zero out sys_hess = 0.0_dp if ( present ( bonds )) then ! Rebuild fragment to get local→global mapping and cap information call build_fragment_from_indices ( sys_geom , monomers , fragment , bonds ) call redistribute_cap_hessian ( fragment , frag_hess , sys_hess ) call fragment % destroy () else ! Old code path for fragments without hydrogen caps ! Map fragment Hessian to system positions (fixed-size monomers only) block integer :: i_mon , j_mon , i_atom , j_atom integer :: frag_atom_i , frag_atom_j , sys_atom_i , sys_atom_j integer :: frag_row_start , frag_col_start , sys_row_start , sys_col_start integer :: n_monomers n_monomers = size ( monomers ) frag_atom_i = 0 ! Map each monomer's atoms do i_mon = 1 , n_monomers do i_atom = 1 , sys_geom % atoms_per_monomer frag_atom_i = frag_atom_i + 1 sys_atom_i = ( monomers ( i_mon ) - 1 ) * sys_geom % atoms_per_monomer + i_atom frag_row_start = ( frag_atom_i - 1 ) * 3 + 1 sys_row_start = ( sys_atom_i - 1 ) * 3 + 1 ! Map this atom's Hessian blocks with all other atoms in fragment frag_atom_j = 0 do j_mon = 1 , n_monomers do j_atom = 1 , sys_geom % atoms_per_monomer frag_atom_j = frag_atom_j + 1 sys_atom_j = ( monomers ( j_mon ) - 1 ) * sys_geom % atoms_per_monomer + j_atom frag_col_start = ( frag_atom_j - 1 ) * 3 + 1 sys_col_start = ( sys_atom_j - 1 ) * 3 + 1 ! Copy the 3×3 block for this atom pair sys_hess ( sys_row_start : sys_row_start + 2 , sys_col_start : sys_col_start + 2 ) = & frag_hess ( frag_row_start : frag_row_start + 2 , frag_col_start : frag_col_start + 2 ) end do end do end do end do end block end if end subroutine map_fragment_to_system_hessian subroutine compute_mbe_hessian ( fragment_idx , fragment , lookup , results , delta_hessians , n , sys_geom , bonds ) !! Bottom-up computation of n-body Hessian correction !! Mirrors MBE gradient logic but for second derivatives use mqc_result_types , only : calculation_result_t use mqc_config_parser , only : bond_t integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup type ( calculation_result_t ), intent ( in ) :: results (:) real ( dp ), intent ( inout ) :: delta_hessians (:, :, :) !! (3*total_atoms, 3*total_atoms, fragment_count) type ( system_geometry_t ), intent ( in ) :: sys_geom type ( bond_t ), intent ( in ), optional :: bonds (:) integer :: subset_size , i , hess_dim integer , allocatable :: indices (:), subset (:) integer ( int64 ) :: subset_idx logical :: has_next hess_dim = 3 * sys_geom % total_atoms ! Start with the full n-mer Hessian mapped to system coordinates call map_fragment_to_system_hessian ( results ( fragment_idx )% hessian , fragment , & sys_geom , delta_hessians (:, :, fragment_idx ), bonds ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 allocate ( indices ( subset_size )) indices = [( i , i = 1 , subset_size )] allocate ( subset ( subset_size )) has_next = . true . do while ( has_next ) subset = fragment ( indices ) subset_idx = lookup % find ( subset , subset_size ) if ( subset_idx > 0 ) then ! Subtract this subset's delta Hessian delta_hessians (:, :, fragment_idx ) = delta_hessians (:, :, fragment_idx ) - & delta_hessians (:, :, subset_idx ) end if call get_next_combination ( indices , subset_size , n , has_next ) end do deallocate ( indices , subset ) end do end subroutine compute_mbe_hessian subroutine compute_gmbe_energy ( monomers , n_monomers , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , total_energy ) !! Compute GMBE (Generalized Many-Body Expansion) energy with full inclusion-exclusion !! !! For overlapping fragments, the GMBE formula follows the inclusion-exclusion principle: !!   E_total = sum(E_monomers) !!             - sum(E_2-way_intersections) !!             + sum(E_3-way_intersections) !!             - sum(E_4-way_intersections) !!             + ... !! !! Example for three overlapping fragments (gly0, gly1, gly2): !!   E = E(gly0) + E(gly1) + E(gly2) !!       - E(gly0∩gly1) - E(gly0∩gly2) - E(gly1∩gly2) !!       + E(gly0∩gly1∩gly2) !! !! This correctly accounts for all overlapping regions following inclusion-exclusion. use mqc_result_types , only : calculation_result_t integer , intent ( in ) :: monomers (:) !! Monomer indices (1-based) integer , intent ( in ) :: n_monomers !! Number of monomers type ( calculation_result_t ), intent ( in ) :: monomer_results (:) !! Monomer energies integer , intent ( in ) :: n_intersections !! Number of intersection fragments type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) !! Intersection energies integer , intent ( in ), optional :: intersection_sets (:, :) !! k-tuples that created each intersection (n_monomers, n_intersections) integer , intent ( in ), optional :: intersection_levels (:) !! Level k of each intersection real ( dp ), intent ( out ) :: total_energy !! Total GMBE energy integer :: i , k , max_level real ( dp ) :: monomer_energy real ( dp ), allocatable :: level_energies (:) integer , allocatable :: level_counts (:) real ( dp ) :: sign_factor ! Sum monomer energies monomer_energy = 0.0_dp do i = 1 , n_monomers monomer_energy = monomer_energy + monomer_results ( i )% energy % total () end do ! Start with monomer contribution total_energy = monomer_energy if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then ! Find maximum intersection level max_level = maxval ( intersection_levels ) ! Allocate arrays to track contributions by level allocate ( level_energies ( 2 : max_level )) allocate ( level_counts ( 2 : max_level )) level_energies = 0.0_dp level_counts = 0 ! Sum intersection energies by level with alternating signs do i = 1 , n_intersections k = intersection_levels ( i ) level_energies ( k ) = level_energies ( k ) + intersection_results ( i )% energy % total () level_counts ( k ) = level_counts ( k ) + 1 end do ! Apply inclusion-exclusion: sign is (-1)&#94;(k+1) for k-way intersections do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) total_energy = total_energy + sign_factor * level_energies ( k ) end if end do ! Print breakdown call logger % info ( \"GMBE Energy breakdown (Inclusion-Exclusion Principle):\" ) block character ( len = 256 ) :: line write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"):  \" , monomer_energy call logger % info ( trim ( line )) do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) if ( sign_factor > 0.0_dp ) then write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  +\" , level_energies ( k ) else write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  \" , level_energies ( k ) end if call logger % info ( trim ( line )) end if end do write ( line , '(a,f20.10)' ) \"  Total GMBE:      \" , total_energy call logger % info ( trim ( line )) end block ! Print detailed intersection info at debug level if ( n_intersections > 0 ) then call logger % debug ( \"GMBE intersection details:\" ) do i = 1 , n_intersections block character ( len = 512 ) :: detail_line character ( len = 256 ) :: set_str integer :: j , set_size ! Build string of fragment indices in this intersection set_str = \"(\" set_size = 0 do j = 1 , n_monomers if ( intersection_sets ( j , i ) > 0 ) then if ( set_size > 0 ) set_str = trim ( set_str ) // \",\" write ( set_str , '(a,i0)' ) trim ( set_str ), intersection_sets ( j , i ) set_size = set_size + 1 end if end do set_str = trim ( set_str ) // \")\" sign_factor = real (( - 1 ) ** ( intersection_levels ( i ) + 1 ), dp ) write ( detail_line , '(a,i0,a,i0,a,a,a,f16.8)' ) & \"  Intersection \" , i , \": level=\" , intersection_levels ( i ), & \" fragments=\" , trim ( set_str ), \" energy=\" , intersection_results ( i )% energy % total () call logger % debug ( trim ( detail_line )) end block end do end if deallocate ( level_energies , level_counts ) else ! No intersections - just report monomer sum call logger % info ( \"GMBE Energy breakdown:\" ) block character ( len = 256 ) :: line write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"): \" , monomer_energy call logger % info ( trim ( line )) write ( line , '(a,f20.10)' ) \"  Total GMBE:  \" , total_energy call logger % info ( trim ( line )) end block end if end subroutine compute_gmbe_energy subroutine compute_gmbe_energy_gradient ( monomers , n_monomers , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , & sys_geom , total_energy , total_gradient , bonds ) !! Compute GMBE (Generalized Many-Body Expansion) energy and gradient with full inclusion-exclusion !! !! Extends compute_gmbe_energy to also compute gradients for overlapping fragments. !! Gradient redistribution handles hydrogen caps at broken bonds. !! !! For overlapping fragments, the GMBE formula follows the inclusion-exclusion principle: !!   E_total = sum(E_monomers) - sum(E_2-way) + sum(E_3-way) - ... !!   ∇E_total = sum(∇E_monomers) - sum(∇E_2-way) + sum(∇E_3-way) - ... use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_indices , build_fragment_from_atom_list , & redistribute_cap_gradients use mqc_config_parser , only : bond_t use pic_logger , only : info_level integer , intent ( in ) :: monomers (:) !! Monomer indices (1-based) integer , intent ( in ) :: n_monomers !! Number of monomers type ( calculation_result_t ), intent ( in ) :: monomer_results (:) !! Monomer energies and gradients integer , intent ( in ) :: n_intersections !! Number of intersection fragments type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) !! Intersection energies and gradients integer , intent ( in ), optional :: intersection_sets (:, :) !! k-tuples that created each intersection (n_monomers, n_intersections) integer , intent ( in ), optional :: intersection_levels (:) !! Level k of each intersection type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: total_energy !! Total GMBE energy real ( dp ), intent ( out ) :: total_gradient (:, :) !! Total GMBE gradient (3, total_atoms) type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond information for caps integer :: i , k , max_level , current_log_level real ( dp ) :: monomer_energy real ( dp ), allocatable :: level_energies (:) integer , allocatable :: level_counts (:) real ( dp ) :: sign_factor type ( physical_fragment_t ) :: fragment integer , allocatable :: monomer_idx (:) ! Zero out total gradient total_gradient = 0.0_dp ! Sum monomer energies and gradients monomer_energy = 0.0_dp do i = 1 , n_monomers monomer_energy = monomer_energy + monomer_results ( i )% energy % total () ! Accumulate monomer gradients if ( monomer_results ( i )% has_gradient ) then ! Rebuild fragment to get local→global mapping allocate ( monomer_idx ( 1 )) monomer_idx ( 1 ) = monomers ( i ) call build_fragment_from_indices ( sys_geom , monomer_idx , fragment , bonds ) call redistribute_cap_gradients ( fragment , monomer_results ( i )% gradient , total_gradient ) call fragment % destroy () deallocate ( monomer_idx ) end if end do ! Start with monomer contribution total_energy = monomer_energy if ( n_intersections > 0 . and . present ( intersection_results ) . and . & present ( intersection_sets ) . and . present ( intersection_levels )) then ! Find maximum intersection level max_level = maxval ( intersection_levels ) ! Allocate arrays to track contributions by level allocate ( level_energies ( 2 : max_level )) allocate ( level_counts ( 2 : max_level )) level_energies = 0.0_dp level_counts = 0 ! Sum intersection energies by level with alternating signs do i = 1 , n_intersections k = intersection_levels ( i ) sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) level_energies ( k ) = level_energies ( k ) + intersection_results ( i )% energy % total () level_counts ( k ) = level_counts ( k ) + 1 ! Accumulate intersection gradients with sign if ( intersection_results ( i )% has_gradient ) then ! Intersection gradients are accumulated with the same sign as energy ! Note: We don't need to rebuild intersection fragments here because ! the gradient redistribution was already done during fragment calculation ! via build_fragment_from_atom_list ! TODO: This needs to be implemented properly - we need the fragment geometry ! to get the local→global mapping. For now, log a warning. call logger % warning ( \"GMBE gradient with intersections not fully implemented yet!\" ) call logger % warning ( \"Intersection gradient redistribution requires storing fragment geometry\" ) end if end do ! Apply inclusion-exclusion to energy: sign is (-1)&#94;(k+1) for k-way intersections do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) total_energy = total_energy + sign_factor * level_energies ( k ) end if end do ! Print breakdown call logger % info ( \"GMBE Energy breakdown (Inclusion-Exclusion Principle):\" ) block character ( len = 256 ) :: line write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"):  \" , monomer_energy call logger % info ( trim ( line )) do k = 2 , max_level if ( level_counts ( k ) > 0 ) then sign_factor = real (( - 1 ) ** ( k + 1 ), dp ) if ( sign_factor > 0.0_dp ) then write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  +\" , level_energies ( k ) else write ( line , '(a,i0,a,i0,a,f20.10)' ) \"  \" , k , \"-way ∩ (\" , level_counts ( k ), \"):  \" , level_energies ( k ) end if call logger % info ( trim ( line )) end if end do write ( line , '(a,f20.10)' ) \"  Total GMBE:      \" , total_energy call logger % info ( trim ( line )) end block deallocate ( level_energies , level_counts ) else ! No intersections - just report monomer sum call logger % info ( \"GMBE Energy breakdown:\" ) block character ( len = 256 ) :: line write ( line , '(a,i0,a,f20.10)' ) \"  Monomers (\" , n_monomers , \"): \" , monomer_energy call logger % info ( trim ( line )) write ( line , '(a,f20.10)' ) \"  Total GMBE:  \" , total_energy call logger % info ( trim ( line )) end block end if ! Print gradient info (same format as MBE) call logger % info ( \"GMBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE Gradient (Hartree/Bohr):\" ) do i = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , i , \": \" , & total_gradient ( 1 , i ), total_gradient ( 2 , i ), total_gradient ( 3 , i ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end subroutine compute_gmbe_energy_gradient subroutine compute_gmbe_energy_gradient_hessian ( monomers , n_monomers , monomer_results , & n_intersections , intersection_results , & intersection_sets , intersection_levels , & sys_geom , total_energy , total_gradient , total_hessian , bonds ) !! Compute GMBE energy, gradient, and Hessian with full inclusion-exclusion !! TODO: Full implementation with intersection Hessians pending use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : build_fragment_from_indices , redistribute_cap_gradients , & redistribute_cap_hessian use mqc_config_parser , only : bond_t use pic_logger , only : info_level integer , intent ( in ) :: monomers (:) integer , intent ( in ) :: n_monomers type ( calculation_result_t ), intent ( in ) :: monomer_results (:) integer , intent ( in ) :: n_intersections type ( calculation_result_t ), intent ( in ), optional :: intersection_results (:) integer , intent ( in ), optional :: intersection_sets (:, :) integer , intent ( in ), optional :: intersection_levels (:) type ( system_geometry_t ), intent ( in ) :: sys_geom real ( dp ), intent ( out ) :: total_energy real ( dp ), intent ( out ) :: total_gradient (:, :) real ( dp ), intent ( out ) :: total_hessian (:, :) type ( bond_t ), intent ( in ), optional :: bonds (:) integer :: i , k , max_level , current_log_level , hess_dim real ( dp ) :: monomer_energy real ( dp ), allocatable :: level_energies (:) integer , allocatable :: level_counts (:) real ( dp ) :: sign_factor type ( physical_fragment_t ) :: fragment integer , allocatable :: monomer_idx (:) ! Zero out outputs total_gradient = 0.0_dp total_hessian = 0.0_dp hess_dim = 3 * sys_geom % total_atoms ! Sum monomer energies, gradients, and Hessians monomer_energy = 0.0_dp do i = 1 , n_monomers monomer_energy = monomer_energy + monomer_results ( i )% energy % total () ! Accumulate monomer gradients if ( monomer_results ( i )% has_gradient ) then allocate ( monomer_idx ( 1 )) monomer_idx ( 1 ) = monomers ( i ) call build_fragment_from_indices ( sys_geom , monomer_idx , fragment , bonds ) call redistribute_cap_gradients ( fragment , monomer_results ( i )% gradient , total_gradient ) if ( monomer_results ( i )% has_hessian ) then call redistribute_cap_hessian ( fragment , monomer_results ( i )% hessian , total_hessian ) end if call fragment % destroy () deallocate ( monomer_idx ) end if end do total_energy = monomer_energy ! Intersection Hessians not yet implemented if ( n_intersections > 0 . and . present ( intersection_results )) then call logger % warning ( \"GMBE Hessian with intersections not yet fully implemented!\" ) call logger % warning ( \"Only monomer Hessians will be included\" ) end if ! Print info call logger % info ( \"GMBE Energy breakdown:\" ) call logger % info ( \"  Monomers (\" // to_char ( n_monomers ) // \"): \" // to_char ( monomer_energy )) call logger % info ( \"  Total GMBE:  \" // to_char ( total_energy )) call logger % info ( \"GMBE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) call logger % info ( \"GMBE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) end subroutine compute_gmbe_energy_gradient_hessian end module mqc_mbe","tags":"","url":"sourcefile/mqc_mbe.f90.html"},{"title":"mqc_basis_file_reader.f90 – metalquicha","text":"this file contains the modules and routines to open and read a GAMESS formatted basis set file Files dependent on this one sourcefile~~mqc_basis_file_reader.f90~~AfferentGraph sourcefile~mqc_basis_file_reader.f90 mqc_basis_file_reader.f90 sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_basis_file_reader.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this file contains the modules and routines to open and read a GAMESS formatted basis set file module mqc_basis_file_reader !! Module for reading and parsing GAMESS formatted basis set files use pic_types , only : int32 , dp implicit none private public :: basis_file_t , open_basis_file , extract_element , strings_equal type :: basis_file_t !! Container for basis set file contents character ( len = :), allocatable :: full_content character ( len = :), allocatable :: data_section end type basis_file_t contains subroutine open_basis_file ( basis_file , filename ) !! Open and read a GAMESS formatted basis set file type ( basis_file_t ), intent ( out ) :: basis_file character ( len =* ), intent ( in ) :: filename integer :: unit , iostat , file_size logical :: file_exists integer :: data_start , data_end ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then error stop \"Basis set file not found: \" // filename end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: basis_file % full_content ) ! Open and read entire file open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = iostat ) if ( iostat /= 0 ) error stop \"Error opening file: \" // filename read ( unit , iostat = iostat ) basis_file % full_content if ( iostat /= 0 ) error stop \"Error reading file: \" // filename close ( unit ) ! Extract the $DATA section data_start = index ( basis_file % full_content , \"$DATA\" ) if ( data_start == 0 ) then error stop \"Could not find $DATA section in basis set file\" end if data_end = index ( basis_file % full_content ( data_start :), \"$END\" ) if ( data_end == 0 ) then error stop \"Could not find $END marker in basis set file\" end if ! Store just the data section (between $DATA and $END) basis_file % data_section = basis_file % full_content ( data_start + 5 : data_start + data_end - 2 ) end subroutine open_basis_file function extract_element ( basis_file , element ) result ( element_content ) !! Extract the basis set data for a specific element from the basis file type ( basis_file_t ), intent ( in ) :: basis_file character ( len =* ), intent ( in ) :: element character ( len = :), allocatable :: element_content integer :: start_pos , end_pos , i character ( len = :), allocatable :: search_element logical :: at_line_start ! Convert element to uppercase for searching search_element = uppercase ( trim ( element )) ! Find the element name (it appears on its own line) start_pos = index ( basis_file % data_section , new_line ( 'a' ) // trim ( search_element ) // new_line ( 'a' )) if ( start_pos == 0 ) then ! Try without leading newline (might be first element after $DATA) if ( index ( basis_file % data_section , trim ( search_element ) // new_line ( 'a' )) == 1 ) then start_pos = 1 else error stop \"Element not found in basis set file: \" // element end if else start_pos = start_pos + 1 ! Skip the leading newline end if ! Find the next element by looking for a line that: ! - Starts with an uppercase letter ! - Has a second character that is also a letter (not a space or number) ! This distinguishes \"CARBON\" from \"S   3\" end_pos = len ( basis_file % data_section ) at_line_start = . false . i = start_pos + len ( search_element ) + 1 do while ( i < len ( basis_file % data_section )) if ( basis_file % data_section ( i : i ) == new_line ( 'a' )) then at_line_start = . true . i = i + 1 cycle end if if ( at_line_start ) then ! We're at the start of a new line if ( is_uppercase_letter ( basis_file % data_section ( i : i ))) then ! Check if next character is also a letter if ( i + 1 <= len ( basis_file % data_section )) then if ( is_letter ( basis_file % data_section ( i + 1 : i + 1 ))) then ! Found next element! end_pos = i - 1 exit end if end if end if at_line_start = . false . end if i = i + 1 end do ! Extract the section element_content = basis_file % data_section ( start_pos : end_pos ) end function extract_element pure function is_letter ( c ) result ( is_alpha ) !! Check if character is a letter (A-Z or a-z) character ( len = 1 ), intent ( in ) :: c logical :: is_alpha integer :: ic ic = iachar ( c ) is_alpha = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) . or . & ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) end function is_letter pure function uppercase ( str ) result ( upper ) !! Convert a string to uppercase, should use pic_ascii! character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: upper integer :: i , ic allocate ( character ( len = len ( str )) :: upper ) upper = str do i = 1 , len ( str ) ic = iachar ( str ( i : i )) if ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) then upper ( i : i ) = achar ( ic - 32 ) end if end do end function uppercase pure function is_uppercase_letter ( c ) result ( is_upper ) !! Check if character is an uppercase letter (A-Z) character ( len = 1 ), intent ( in ) :: c logical :: is_upper integer :: ic ic = iachar ( c ) is_upper = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) end function is_uppercase_letter !> Compare two strings after trimming and adjusting (removing leading/trailing whitespace) pure function strings_equal ( str1 , str2 ) result ( equal ) !! Compare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) character ( len =* ), intent ( in ) :: str1 , str2 logical :: equal equal = trim ( adjustl ( str1 )) == trim ( adjustl ( str2 )) end function strings_equal end module mqc_basis_file_reader","tags":"","url":"sourcefile/mqc_basis_file_reader.f90.html"},{"title":"mqc_fragment_lookup.f90 – metalquicha","text":"Hash-based lookup table for fast fragment index retrieval Files dependent on this one sourcefile~~mqc_fragment_lookup.f90~~AfferentGraph sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Hash-based lookup table for fast fragment index retrieval module mqc_fragment_lookup !! Provides O(1) hash table for mapping monomer combinations to fragment indices use pic_types , only : int32 , int64 , dp use pic_sorting , only : sort use pic_hash_32bit , only : fnv_1a_hash implicit none private public :: fragment_lookup_t !! Hash-based lookup table type type :: hash_entry_t !! Single entry in hash table (private helper type) integer , allocatable :: key (:) !! Sorted monomer indices integer ( int64 ) :: value !! Fragment index type ( hash_entry_t ), pointer :: next => null () !! Chain for collisions end type hash_entry_t type :: fragment_lookup_t !! Hash-based lookup table for O(1) fragment index retrieval integer :: table_size = 0 type ( hash_entry_t ), allocatable :: table (:) integer ( int64 ) :: n_entries = 0 logical :: initialized = . false . contains procedure :: init => fragment_lookup_init procedure :: insert => fragment_lookup_insert procedure :: find => fragment_lookup_find procedure :: destroy => fragment_lookup_destroy end type fragment_lookup_t contains subroutine fragment_lookup_init ( this , estimated_entries ) !! Initialize hash table with estimated size class ( fragment_lookup_t ), intent ( inout ) :: this integer ( int64 ), intent ( in ) :: estimated_entries integer :: i ! Use prime number close to estimated size for better distribution this % table_size = next_prime_internal ( int ( estimated_entries * 1.3_dp )) allocate ( this % table ( this % table_size )) ! Initialize all entries as empty do i = 1 , this % table_size nullify ( this % table ( i )% next ) end do this % n_entries = 0 this % initialized = . true . end subroutine fragment_lookup_init subroutine fragment_lookup_insert ( this , monomers , n , fragment_idx ) !! Insert a monomer combination -> fragment index mapping class ( fragment_lookup_t ), intent ( inout ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ), intent ( in ) :: fragment_idx integer ( int32 ) :: hash_val integer :: bucket type ( hash_entry_t ), pointer :: new_entry integer , allocatable :: sorted_key (:) if (. not . this % initialized ) error stop \"Hash table not initialized\" ! Sort monomers for canonical key allocate ( sorted_key ( n )) sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Check if this is the first entry in bucket if (. not . allocated ( this % table ( bucket )% key )) then ! First entry in this bucket - use the head entry allocate ( this % table ( bucket )% key ( n )) this % table ( bucket )% key = sorted_key this % table ( bucket )% value = fragment_idx this % n_entries = this % n_entries + 1 else ! Bucket already has entries - chain new entry allocate ( new_entry ) allocate ( new_entry % key ( n )) new_entry % key = sorted_key new_entry % value = fragment_idx new_entry % next => this % table ( bucket )% next this % table ( bucket )% next => new_entry this % n_entries = this % n_entries + 1 end if deallocate ( sorted_key ) end subroutine fragment_lookup_insert function fragment_lookup_find ( this , monomers , n ) result ( idx ) !! Find fragment index for given monomer combination class ( fragment_lookup_t ), intent ( in ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ) :: idx integer ( int32 ) :: hash_val integer :: bucket , sorted_key ( n ) type ( hash_entry_t ), pointer :: entry ! Sort monomers for canonical key sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Search chain if ( allocated ( this % table ( bucket )% key )) then if ( arrays_equal_internal ( this % table ( bucket )% key , sorted_key , n )) then idx = this % table ( bucket )% value return end if entry => this % table ( bucket )% next do while ( associated ( entry )) if ( arrays_equal_internal ( entry % key , sorted_key , n )) then idx = entry % value return end if entry => entry % next end do end if ! Not found idx = - 1 end function fragment_lookup_find subroutine fragment_lookup_destroy ( this ) !! Clean up hash table and all chains class ( fragment_lookup_t ), intent ( inout ) :: this integer :: i type ( hash_entry_t ), pointer :: entry , next_entry if (. not . this % initialized ) return do i = 1 , this % table_size ! Free chain entry => this % table ( i )% next do while ( associated ( entry )) next_entry => entry % next if ( allocated ( entry % key )) deallocate ( entry % key ) deallocate ( entry ) entry => next_entry end do ! Free bucket head if ( allocated ( this % table ( i )% key )) deallocate ( this % table ( i )% key ) end do deallocate ( this % table ) this % initialized = . false . end subroutine fragment_lookup_destroy ! Helper functions for hash table pure function arrays_equal_internal ( a , b , n ) result ( equal ) !! Check if two arrays are equal integer , intent ( in ) :: a (:), b (:), n logical :: equal integer :: i equal = . true . if ( size ( a ) /= n . or . size ( b ) /= n ) then equal = . false . return end if do i = 1 , n if ( a ( i ) /= b ( i )) then equal = . false . return end if end do end function arrays_equal_internal pure function next_prime_internal ( n ) result ( p ) !! Find next prime number >= n (simple implementation) integer , intent ( in ) :: n integer :: p , i logical :: is_prime p = max ( n , 2 ) if ( modulo ( p , 2 ) == 0 ) p = p + 1 do is_prime = . true . do i = 3 , int ( sqrt ( real ( p ))) + 1 , 2 if ( modulo ( p , i ) == 0 ) then is_prime = . false . exit end if end do if ( is_prime ) return p = p + 2 end do end function next_prime_internal end module mqc_fragment_lookup","tags":"","url":"sourcefile/mqc_fragment_lookup.f90.html"},{"title":"mqc_cli_parser.f90 – metalquicha","text":"Command line argument parsing for metalquicha This file depends on sourcefile~~mqc_cli_parser.f90~~EfferentGraph sourcefile~mqc_cli_parser.f90 mqc_cli_parser.f90 sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_basis_utils.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_basis_utils.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Command line argument parsing for metalquicha module mqc_cli_parser !! Handles parsing of command line options including geometry files, !! basis set specifications, and help/usage display. use mqc_basis_utils , only : normalize_basis_name , find_basis_file use mqc_error , only : error_t , ERROR_PARSE , ERROR_IO implicit none private public :: cli_args_type !! Parsed command line arguments container public :: parse_command_line !! Main argument parsing routine public :: print_usage !! Display program usage information public :: normalize_basis_name !! Standardize basis set names public :: find_basis_file !! Locate basis set files type :: cli_args_type !! Container for parsed command line arguments !! !! Stores file paths and options extracted from command line, !! with automatic memory management for string allocations. character ( len = :), allocatable :: xyz_file !! Input XYZ geometry file path character ( len = :), allocatable :: basis_name !! Basis set name (e.g., \"6-31G\") contains procedure :: destroy => cli_args_destroy !! Memory cleanup end type cli_args_type contains subroutine parse_command_line ( args , error ) !! Parse command line arguments for geometry file and basis set !! !! Extracts XYZ file path and basis set name from command line, !! validates arguments, and handles help requests. type ( cli_args_type ), intent ( out ) :: args !! Parsed argument container type ( error_t ), intent ( out ) :: error !! Error object integer :: nargs !! Number of command line arguments character ( len = 256 ) :: arg_buffer !! Temporary argument buffer integer :: arg_len !! Length of current argument integer :: stat !! Local status for intrinsic calls ! Get number of command line arguments nargs = command_argument_count () ! Check for help flag if ( nargs >= 1 ) then call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading command line argument 1\" ) return end if arg_buffer = trim ( arg_buffer ) if ( arg_buffer == \"-h\" . or . arg_buffer == \"--help\" ) then call print_usage () call error % set ( ERROR_PARSE , \"HELP_REQUESTED\" ) ! Special marker for help return end if end if ! Validate number of arguments if ( nargs < 2 ) then call error % set ( ERROR_PARSE , \"Error: Insufficient arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if if ( nargs > 2 ) then call error % set ( ERROR_PARSE , \"Error: Too many arguments. Expected 2 arguments (geometry.xyz basis_name)\" ) call print_usage () return end if ! Parse argument 1: XYZ file call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading geometry file argument\" ) return end if args % xyz_file = trim ( arg_buffer ) ! Parse argument 2: Basis set name call get_command_argument ( 2 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Error reading basis set name argument\" ) return end if args % basis_name = trim ( arg_buffer ) end subroutine parse_command_line !> Print usage information subroutine print_usage () character ( len = 256 ) :: prog_name integer :: stat call get_command_argument ( 0 , prog_name , status = stat ) if ( stat /= 0 ) prog_name = \"pic_basis_reader\" print * print * , \"Usage: \" , trim ( prog_name ), \" <geometry.xyz> <basis_name>\" print * print * , \"Arguments:\" print * , \"  geometry.xyz   XYZ format molecular geometry file\" print * , \"  basis_name     Name of basis set (e.g., 6-31G, 6-311G**)\" print * print * , \"Options:\" print * , \"  -h, --help     Show this help message\" print * print * , \"Example:\" print * , \"  \" , trim ( prog_name ), \" water.xyz 6-31G\" print * end subroutine print_usage !> Clean up CLI args subroutine cli_args_destroy ( this ) class ( cli_args_type ), intent ( inout ) :: this if ( allocated ( this % xyz_file )) deallocate ( this % xyz_file ) if ( allocated ( this % basis_name )) deallocate ( this % basis_name ) end subroutine cli_args_destroy end module mqc_cli_parser","tags":"","url":"sourcefile/mqc_cli_parser.f90.html"},{"title":"mqc_finite_differences.f90 – metalquicha","text":"Finite difference utilities for numerical derivatives This file depends on sourcefile~~mqc_finite_differences.f90~~EfferentGraph sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_finite_differences.f90~~AfferentGraph sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Finite difference utilities for numerical derivatives module mqc_finite_differences !! Provides utilities for generating perturbed geometries and computing !! numerical derivatives via finite differences (gradients, Hessians, etc.) use pic_types , only : dp use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: generate_perturbed_geometries !! Generate forward/backward displacements public :: displaced_geometry_t !! Container for displaced geometry public :: finite_diff_hessian_from_gradients !! Compute Hessian from gradient differences public :: copy_and_displace_geometry !! Copy and displace geometry ! Default displacement step size (Bohr) real ( dp ), parameter , public :: DEFAULT_DISPLACEMENT = 0.01_dp !! ~0.05 Angstrom type :: displaced_geometry_t !! Container for a single displaced geometry integer :: atom_index !! Which atom was displaced (1-based) integer :: coordinate !! Which coordinate was displaced (1=x, 2=y, 3=z) integer :: direction !! +1 for forward, -1 for backward real ( dp ) :: displacement !! Displacement magnitude in Bohr type ( physical_fragment_t ) :: geometry !! The displaced geometry contains procedure :: destroy => displaced_geometry_destroy end type displaced_geometry_t contains subroutine generate_perturbed_geometries ( reference_geom , displacement , forward_geoms , backward_geoms ) !! Generate all forward and backward displaced geometries for finite difference calculations !! !! For a system with N atoms, this generates: !!   - 3N forward-displaced geometries (+x, +y, +z for each atom) !!   - 3N backward-displaced geometries (-x, -y, -z for each atom) !! !! These can be used to compute: !!   - Gradient: from energies at ±displacement !!   - Hessian: from gradients at ±displacement !! !! Args: !!   reference_geom: The reference geometry to perturb !!   displacement: Step size in Bohr (typical: 0.001 Bohr) !!   forward_geoms: Output array of forward-displaced geometries (size: 3*n_atoms) !!   backward_geoms: Output array of backward-displaced geometries (size: 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: displacement type ( displaced_geometry_t ), intent ( out ), allocatable :: forward_geoms (:) type ( displaced_geometry_t ), intent ( out ), allocatable :: backward_geoms (:) integer :: n_atoms , n_displacements integer :: iatom , icoord , idx integer :: i n_atoms = reference_geom % n_atoms n_displacements = 3 * n_atoms ! x, y, z for each atom allocate ( forward_geoms ( n_displacements )) allocate ( backward_geoms ( n_displacements )) ! Generate all displaced geometries idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 ! x, y, z idx = idx + 1 ! Forward displacement (+h) forward_geoms ( idx )% atom_index = iatom forward_geoms ( idx )% coordinate = icoord forward_geoms ( idx )% direction = + 1 forward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , + displacement , & forward_geoms ( idx )% geometry ) ! Backward displacement (-h) backward_geoms ( idx )% atom_index = iatom backward_geoms ( idx )% coordinate = icoord backward_geoms ( idx )% direction = - 1 backward_geoms ( idx )% displacement = displacement call copy_and_displace_geometry ( reference_geom , iatom , icoord , - displacement , & backward_geoms ( idx )% geometry ) end do end do end subroutine generate_perturbed_geometries subroutine copy_and_displace_geometry ( reference_geom , atom_idx , coord_idx , displacement , displaced_geom ) !! Create a copy of reference geometry with one coordinate displaced !! !! Args: !!   reference_geom: Original geometry to copy !!   atom_idx: Atom to displace (1-based) !!   coord_idx: Coordinate to displace (1=x, 2=y, 3=z) !!   displacement: Amount to displace in Bohr (positive or negative) !!   displaced_geom: Output displaced geometry type ( physical_fragment_t ), intent ( in ) :: reference_geom integer , intent ( in ) :: atom_idx , coord_idx real ( dp ), intent ( in ) :: displacement type ( physical_fragment_t ), intent ( out ) :: displaced_geom ! Copy basic properties displaced_geom % n_atoms = reference_geom % n_atoms displaced_geom % charge = reference_geom % charge displaced_geom % multiplicity = reference_geom % multiplicity displaced_geom % nelec = reference_geom % nelec displaced_geom % n_caps = reference_geom % n_caps ! Allocate and copy arrays allocate ( displaced_geom % element_numbers ( displaced_geom % n_atoms )) allocate ( displaced_geom % coordinates ( 3 , displaced_geom % n_atoms )) displaced_geom % element_numbers = reference_geom % element_numbers displaced_geom % coordinates = reference_geom % coordinates ! Copy hydrogen cap information if present if ( reference_geom % n_caps > 0 ) then allocate ( displaced_geom % cap_replaces_atom ( displaced_geom % n_caps )) displaced_geom % cap_replaces_atom = reference_geom % cap_replaces_atom end if ! Copy gradient redistribution mapping if present if ( allocated ( reference_geom % local_to_global )) then allocate ( displaced_geom % local_to_global ( size ( reference_geom % local_to_global ))) displaced_geom % local_to_global = reference_geom % local_to_global end if ! Apply displacement to specified coordinate displaced_geom % coordinates ( coord_idx , atom_idx ) = & displaced_geom % coordinates ( coord_idx , atom_idx ) + displacement ! Copy basis set if present (same basis, just different geometry) if ( allocated ( reference_geom % basis )) then ! Note: Basis set will need to be rebuilt with new coordinates ! For now, we don't copy it - it should be set up during calculation end if end subroutine copy_and_displace_geometry subroutine finite_diff_hessian_from_gradients ( reference_geom , forward_gradients , backward_gradients , & displacement , hessian ) !! Compute Hessian matrix from finite differences of gradients !! !! Uses central finite differences: H_ij = (grad_i(+h) - grad_i(-h)) / (2h) !! !! Args: !!   reference_geom: Reference geometry (for dimensioning) !!   forward_gradients: Gradients at forward-displaced geometries (3*n_atoms, 3, n_atoms) !!   backward_gradients: Gradients at backward-displaced geometries (3*n_atoms, 3, n_atoms) !!   displacement: Step size used in Bohr !!   hessian: Output Hessian matrix (3*n_atoms, 3*n_atoms) type ( physical_fragment_t ), intent ( in ) :: reference_geom real ( dp ), intent ( in ) :: forward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: backward_gradients (:, :, :) !! (n_displacements, 3, n_atoms) real ( dp ), intent ( in ) :: displacement real ( dp ), intent ( out ), allocatable :: hessian (:, :) !! (3*n_atoms, 3*n_atoms) integer :: n_atoms , n_coords integer :: iatom , jatom , icoord , jcoord integer :: i_global , j_global integer :: disp_idx n_atoms = reference_geom % n_atoms n_coords = 3 * n_atoms allocate ( hessian ( n_coords , n_coords )) hessian = 0.0_dp ! Build Hessian using central differences ! H[i,j] = d²E/(dx_i dx_j) = (dE/dx_j at x_i+h - dE/dx_j at x_i-h) / (2h) disp_idx = 0 do iatom = 1 , n_atoms do icoord = 1 , 3 disp_idx = disp_idx + 1 i_global = 3 * ( iatom - 1 ) + icoord ! For each displacement, compute derivatives of all gradient components do jatom = 1 , n_atoms do jcoord = 1 , 3 j_global = 3 * ( jatom - 1 ) + jcoord ! Central difference: (grad_j(+h) - grad_j(-h)) / (2h) hessian ( i_global , j_global ) = & ( forward_gradients ( disp_idx , jcoord , jatom ) - & backward_gradients ( disp_idx , jcoord , jatom )) / ( 2.0_dp * displacement ) end do end do end do end do end subroutine finite_diff_hessian_from_gradients subroutine displaced_geometry_destroy ( this ) !! Clean up memory for displaced geometry class ( displaced_geometry_t ), intent ( inout ) :: this call this % geometry % destroy () end subroutine displaced_geometry_destroy end module mqc_finite_differences","tags":"","url":"sourcefile/mqc_finite_differences.f90.html"},{"title":"mqc_libcint_interface.f90 – metalquicha","text":"Libcint Fortran interface module Source Code !! Libcint Fortran interface module module mqc_libcint_interface !! Provides Fortran interface to the Libcint library for integral calculations !use libcint_fortran implicit none private end module mqc_libcint_interface","tags":"","url":"sourcefile/mqc_libcint_interface.f90.html"},{"title":"mqc_calc_types.f90 – metalquicha","text":"Calculation type constants for quantum chemistry calculations Files dependent on this one sourcefile~~mqc_calc_types.f90~~AfferentGraph sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Calculation type constants for quantum chemistry calculations module mqc_calc_types !! Defines integer constants for calculation types to avoid string comparisons !! throughout the codebase. Provides conversion utilities between string !! representations and integer constants. use pic_types , only : int32 implicit none private ! Public constants public :: CALC_TYPE_ENERGY , CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN public :: CALC_TYPE_UNKNOWN ! Public functions public :: calc_type_from_string , calc_type_to_string ! Calculation type constants integer ( int32 ), parameter :: CALC_TYPE_UNKNOWN = 0 integer ( int32 ), parameter :: CALC_TYPE_ENERGY = 1 integer ( int32 ), parameter :: CALC_TYPE_GRADIENT = 2 integer ( int32 ), parameter :: CALC_TYPE_HESSIAN = 3 contains pure function calc_type_from_string ( calc_type_str ) result ( calc_type ) !! Convert calculation type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns CALC_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: calc_type_str !! Input string (e.g., \"energy\", \"gradient\") integer ( int32 ) :: calc_type !! Output integer constant character ( len = len_trim ( calc_type_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( calc_type_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) case ( 'energy' ) calc_type = CALC_TYPE_ENERGY case ( 'gradient' ) calc_type = CALC_TYPE_GRADIENT case ( 'hessian' ) calc_type = CALC_TYPE_HESSIAN case default calc_type = CALC_TYPE_UNKNOWN end select end function calc_type_from_string pure function calc_type_to_string ( calc_type ) result ( calc_type_str ) !! Convert calculation type integer constant to string !! !! Provides human-readable string representation of calculation type. integer ( int32 ), intent ( in ) :: calc_type !! Input integer constant character ( len = :), allocatable :: calc_type_str !! Output string representation select case ( calc_type ) case ( CALC_TYPE_ENERGY ) calc_type_str = \"energy\" case ( CALC_TYPE_GRADIENT ) calc_type_str = \"gradient\" case ( CALC_TYPE_HESSIAN ) calc_type_str = \"hessian\" case default calc_type_str = \"unknown\" end select end function calc_type_to_string end module mqc_calc_types","tags":"","url":"sourcefile/mqc_calc_types.f90.html"},{"title":"mqc_driver.f90 – metalquicha","text":"Main calculation driver module for metalquicha This file depends on sourcefile~~mqc_driver.f90~~EfferentGraph sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_error.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_driver.f90~~AfferentGraph sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Main calculation driver module for metalquicha module mqc_driver !! Handles both fragmented (many-body expansion) and unfragmented calculations !! with MPI parallelization and node-based work distribution. use pic_types , only : int32 , int64 , dp use pic_mpi_lib , only : comm_t , abort_comm , bcast , allgather use pic_logger , only : logger => global_logger use pic_io , only : to_char use omp_lib , only : omp_get_max_threads , omp_set_num_threads use mqc_mbe_fragment_distribution_scheme , only : global_coordinator , node_coordinator , node_worker , unfragmented_calculation , & serial_fragment_processor , do_fragment_work , distributed_unfragmented_hessian use mqc_gmbe_fragment_distribution_scheme , only : serial_gmbe_pie_processor , gmbe_pie_coordinator use mqc_frag_utils , only : get_nfrags , create_monomer_list , generate_fragment_list , generate_intersections , & gmbe_enumerate_pie_terms , binomial , combine use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , & build_fragment_from_indices , build_fragment_from_atom_list use mqc_config_adapter , only : driver_config_t , config_to_driver , config_to_system_geometry use mqc_method_types , only : method_type_to_string use mqc_calc_types , only : calc_type_to_string , CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_config_parser , only : bond_t , mqc_config_t use mqc_mbe , only : compute_gmbe_energy use mqc_result_types , only : calculation_result_t use mqc_error , only : error_t use mqc_io_helpers , only : set_molecule_suffix , get_output_json_filename use mqc_json , only : merge_multi_molecule_json implicit none private public :: run_calculation !! Main entry point for all calculations public :: run_multi_molecule_calculations !! Multi-molecule calculation dispatcher contains subroutine run_calculation ( world_comm , node_comm , config , sys_geom , bonds ) !! Main calculation dispatcher - routes to fragmented or unfragmented calculation !! !! Determines calculation type based on nlevel and dispatches to appropriate !! calculation routine with proper MPI setup and validation. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator type ( driver_config_t ), intent ( in ) :: config !! Driver configuration type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information ! Local variables integer :: max_level !! Maximum fragment level (nlevel from config) integer :: i !! Loop counter ! Set max_level from config max_level = config % nlevel if ( world_comm % rank () == 0 ) then call logger % info ( \"============================================\" ) call logger % info ( \"Loaded geometry:\" ) call logger % info ( \"  Total monomers: \" // to_char ( sys_geom % n_monomers )) call logger % info ( \"  Atoms per monomer: \" // to_char ( sys_geom % atoms_per_monomer )) call logger % info ( \"  Total atoms: \" // to_char ( sys_geom % total_atoms )) call logger % info ( \"  Fragment level: \" // to_char ( max_level )) call logger % info ( \"============================================\" ) end if ! Warn if overlapping fragments flag is set but nlevel=0 if ( config % allow_overlapping_fragments . and . max_level == 0 ) then if ( world_comm % rank () == 0 ) then call logger % warning ( \"allow_overlapping_fragments is set to true, but nlevel=0\" ) call logger % warning ( \"Running unfragmented calculation - overlapping fragments flag will be ignored\" ) end if end if ! GMBE (overlapping fragments) with inclusion-exclusion principle ! GMBE(1): Base fragments are monomers ! GMBE(N): Base fragments are N-mers (e.g., dimers for N=2) ! Algorithm: Generate primaries, use DFS to enumerate overlapping cliques, ! accumulate PIE coefficients per unique atom set, evaluate each once if ( max_level == 0 ) then call omp_set_num_threads ( 1 ) call run_unfragmented_calculation ( world_comm , sys_geom , config % method , config % calc_type , bonds ) else call run_fragmented_calculation ( world_comm , node_comm , config % method , config % calc_type , sys_geom , max_level , & config % allow_overlapping_fragments , & config % max_intersection_level , bonds ) end if end subroutine run_calculation subroutine run_unfragmented_calculation ( world_comm , sys_geom , method , calc_type , bonds ) !! Handle unfragmented calculation (nlevel=0) !! !! For single-molecule mode: Only rank 0 runs (validates single rank) !! For multi-molecule mode: ALL ranks can run (each with their own molecule) !! For Hessian calculations with multiple ranks: Uses distributed parallelization type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( system_geometry_t ), intent ( in ) :: sys_geom !! Complete system geometry integer ( int32 ), intent ( in ) :: method !! Quantum chemistry method integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information ! For Hessian calculations with multiple ranks, use distributed approach if ( calc_type == CALC_TYPE_HESSIAN . and . world_comm % size () > 1 ) then if ( world_comm % rank () == 0 ) then call logger % info ( \" \" ) call logger % info ( \"Running distributed unfragmented Hessian calculation\" ) call logger % info ( \"  MPI ranks: \" // to_char ( world_comm % size ())) call logger % info ( \" \" ) end if call distributed_unfragmented_hessian ( world_comm , sys_geom , method ) return end if ! Check if this is multi-molecule mode or single-molecule mode ! In multi-molecule mode, each rank processes its own molecule ! In single-molecule mode, only rank 0 should work if ( world_comm % size () == 1 . or . world_comm % rank () == 0 ) then ! Either single-rank calculation, or rank 0 in multi-rank setup call logger % info ( \" \" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) call logger % info ( \" \" ) call unfragmented_calculation ( sys_geom , method , calc_type , bonds ) else if ( sys_geom % total_atoms > 0 ) then ! Multi-molecule mode: non-zero rank with a molecule call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Running unfragmented calculation\" ) call unfragmented_calculation ( sys_geom , method , calc_type , bonds ) end if end subroutine run_unfragmented_calculation subroutine run_fragmented_calculation ( world_comm , node_comm , method , calc_type , sys_geom , max_level , & allow_overlapping_fragments , max_intersection_level , bonds ) !! Handle fragmented calculation (nlevel > 0) !! !! Generates fragments, distributes work across MPI processes organized in nodes, !! and coordinates many-body expansion calculation using hierarchical parallelism. !! If allow_overlapping_fragments=true, uses GMBE with intersection correction. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator integer ( int32 ), intent ( in ) :: method !! Quantum chemistry method integer ( int32 ), intent ( in ) :: calc_type !! Calculation type type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info integer , intent ( in ) :: max_level !! Maximum fragment level for MBE logical , intent ( in ) :: allow_overlapping_fragments !! Use GMBE for overlapping fragments integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth for GMBE type ( bond_t ), intent ( in ), optional :: bonds (:) !! Bond connectivity information integer ( int64 ) :: total_fragments !! Total number of fragments generated (int64 to handle large systems) integer , allocatable :: polymers (:, :) !! Fragment composition array (fragment, monomer_indices) integer :: num_nodes !! Number of compute nodes integer :: i , j !! Loop counters integer , allocatable :: node_leader_ranks (:) !! Ranks of processes that lead each node integer , allocatable :: monomers (:) !! Temporary monomer list for fragment generation integer ( int64 ) :: n_expected_frags !! Expected number of fragments based on combinatorics (int64 to handle large systems) integer ( int64 ) :: n_rows !! Number of rows needed for polymers array (int64 to handle large systems) integer :: global_node_rank !! Global rank if this process leads a node, -1 otherwise integer , allocatable :: all_node_leader_ranks (:) !! Node leader status for all ranks ! GMBE-specific variables (old approach - kept for compatibility) integer , allocatable :: intersections (:, :) !! Intersection atom lists (max_atoms, n_intersections) integer , allocatable :: intersection_sets (:, :) !! k-tuples for each intersection (n_monomers, n_intersections) integer , allocatable :: intersection_levels (:) !! Level k of each intersection (n_intersections) integer :: n_intersections , n_monomers !! Counts for GMBE ! GMBE PIE-based variables (new approach) integer :: n_primaries !! Number of primary polymers integer ( int64 ) :: n_primaries_i64 !! For binomial calculation integer , allocatable :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , allocatable :: pie_coefficients (:) !! PIE coefficient for each term integer :: n_pie_terms !! Number of unique PIE terms ! Generate fragments if ( world_comm % rank () == 0 ) then if ( allow_overlapping_fragments ) then ! GMBE mode: PIE-based inclusion-exclusion ! GMBE(1): primaries are monomers ! GMBE(N): primaries are N-mers (e.g., dimers for N=2) ! Generate primaries if ( max_level == 1 ) then ! GMBE(1): primaries are base monomers n_primaries = sys_geom % n_monomers allocate ( polymers ( n_primaries , 1 )) do i = 1 , n_primaries polymers ( i , 1 ) = i end do else ! GMBE(N): primaries are all C(M, N) N-tuples n_primaries_i64 = binomial ( sys_geom % n_monomers , max_level ) n_primaries = int ( n_primaries_i64 ) allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_primaries , max_level )) polymers = 0 call create_monomer_list ( monomers ) total_fragments = 0_int64 call combine ( monomers , sys_geom % n_monomers , max_level , polymers , total_fragments ) n_primaries = int ( total_fragments ) deallocate ( monomers ) end if call logger % info ( \"Generated \" // to_char ( n_primaries ) // \" primary \" // to_char ( max_level ) // \"-mers for GMBE(\" // & to_char ( max_level ) // \")\" ) ! Use DFS to enumerate PIE terms with coefficients call gmbe_enumerate_pie_terms ( sys_geom , polymers , n_primaries , max_level , max_intersection_level , & pie_atom_sets , pie_coefficients , n_pie_terms ) call logger % info ( \"GMBE PIE enumeration complete: \" // to_char ( n_pie_terms ) // \" unique subsystems to evaluate\" ) ! For now: total_fragments = n_pie_terms (each PIE term is a subsystem to evaluate) total_fragments = int ( n_pie_terms , int64 ) else ! Standard MBE mode ! Calculate expected number of fragments n_expected_frags = get_nfrags ( sys_geom % n_monomers , max_level ) n_rows = n_expected_frags ! Allocate monomer list and polymers array allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_rows , max_level )) polymers = 0 ! Create monomer list [1, 2, 3, ..., n_monomers] call create_monomer_list ( monomers ) ! Generate all fragments (includes monomers in polymers array) total_fragments = 0_int64 ! First add monomers do i = 1 , sys_geom % n_monomers total_fragments = total_fragments + 1_int64 polymers ( total_fragments , 1 ) = i end do ! Then add n-mers for n >= 2 call generate_fragment_list ( monomers , max_level , polymers , total_fragments ) deallocate ( monomers ) call logger % info ( \"Generated fragments:\" ) call logger % info ( \"  Total fragments: \" // to_char ( total_fragments )) call logger % info ( \"  Max level: \" // to_char ( max_level )) end if end if ! Broadcast total_fragments to all ranks call bcast ( world_comm , total_fragments , 1 , 0 ) ! Determine node leaders global_node_rank = - 1 if ( node_comm % rank () == 0 ) global_node_rank = world_comm % rank () allocate ( all_node_leader_ranks ( world_comm % size ())) call allgather ( world_comm , global_node_rank , all_node_leader_ranks ) num_nodes = count ( all_node_leader_ranks /= - 1 ) if ( world_comm % rank () == 0 ) then call logger % info ( \"Running with \" // to_char ( num_nodes ) // \" node(s)\" ) end if allocate ( node_leader_ranks ( num_nodes )) i = 0 do j = 1 , world_comm % size () if ( all_node_leader_ranks ( j ) /= - 1 ) then i = i + 1 node_leader_ranks ( i ) = all_node_leader_ranks ( j ) end if end do deallocate ( all_node_leader_ranks ) ! Execute appropriate role if ( world_comm % size () == 1 ) then ! Single rank: process fragments serially call logger % info ( \"Running in serial mode (single MPI rank)\" ) if ( allow_overlapping_fragments ) then ! GMBE serial processing with PIE coefficients call serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , sys_geom , method , calc_type , bonds ) else ! Standard MBE serial processing call serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method , calc_type , bonds ) end if else if ( world_comm % leader () . and . node_comm % leader ()) then ! Global coordinator (rank 0, node leader on node 0) call omp_set_num_threads ( omp_get_max_threads ()) call logger % verbose ( \"Rank 0: Acting as global coordinator\" ) if ( allow_overlapping_fragments ) then ! GMBE MPI processing - PIE-based approach call gmbe_pie_coordinator ( world_comm , node_comm , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method , calc_type , bonds ) else ! Standard MBE MPI processing call global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , calc_type , bonds ) end if else if ( node_comm % leader ()) then ! Node coordinator (node leader on other nodes) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as node coordinator\" ) ! Node coordinator works for both MBE and GMBE (receives fragments from global coordinator) call node_coordinator ( world_comm , node_comm , calc_type ) else ! Worker call omp_set_num_threads ( 1 ) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as worker\" ) ! Worker processes work for both MBE and GMBE (fragment_type distinguishes them) call node_worker ( world_comm , node_comm , sys_geom , method , calc_type , bonds ) end if ! Cleanup if ( world_comm % rank () == 0 ) then if ( allocated ( polymers )) deallocate ( polymers ) if ( allocated ( node_leader_ranks )) deallocate ( node_leader_ranks ) if ( allocated ( intersections )) deallocate ( intersections ) if ( allocated ( intersection_sets )) deallocate ( intersection_sets ) if ( allocated ( intersection_levels )) deallocate ( intersection_levels ) if ( allocated ( pie_atom_sets )) deallocate ( pie_atom_sets ) if ( allocated ( pie_coefficients )) deallocate ( pie_coefficients ) end if end subroutine run_fragmented_calculation subroutine run_multi_molecule_calculations ( world_comm , node_comm , mqc_config ) !! Run calculations for multiple molecules with MPI parallelization !! Each molecule is independent, so assign one molecule per rank use mqc_config_parser , only : mqc_config_t use mqc_config_adapter , only : config_to_system_geometry use mqc_error , only : error_t use mqc_io_helpers , only : set_molecule_suffix , get_output_json_filename use mqc_json , only : merge_multi_molecule_json type ( comm_t ), intent ( in ) :: world_comm type ( comm_t ), intent ( in ) :: node_comm type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ) :: config type ( system_geometry_t ) :: sys_geom type ( comm_t ) :: mol_comm , mol_node_comm type ( error_t ) :: error integer :: imol , my_rank , num_ranks , color integer :: molecules_processed character ( len = :), allocatable :: mol_name logical :: has_fragmented_molecules character ( len = 256 ), allocatable :: individual_json_files (:) my_rank = world_comm % rank () num_ranks = world_comm % size () ! Allocate array to track individual JSON files for merging allocate ( individual_json_files ( mqc_config % nmol )) ! Check if any molecules have fragments (nlevel > 0) has_fragmented_molecules = . false . do imol = 1 , mqc_config % nmol if ( mqc_config % molecules ( imol )% nfrag > 0 ) then has_fragmented_molecules = . true . exit end if end do if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"Multi-molecule mode: \" // to_char ( mqc_config % nmol ) // \" molecules\" ) call logger % info ( \"MPI ranks: \" // to_char ( num_ranks )) if ( has_fragmented_molecules ) then call logger % info ( \"Mode: Sequential execution (fragmented molecules detected)\" ) call logger % info ( \"  Each molecule will use all \" // to_char ( num_ranks ) // \" rank(s) for its calculation\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Mode: Sequential execution (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) call logger % info ( \"Note: More ranks than molecules - ranks \" // to_char ( mqc_config % nmol ) // & \" to \" // to_char ( num_ranks - 1 ) // \" will be idle\" ) else call logger % info ( \"Mode: Parallel execution (one molecule per rank)\" ) end if call logger % info ( \"============================================\" ) call logger % info ( \" \" ) end if ! Determine execution mode: ! 1. Sequential: Single rank OR fragmented molecules (each molecule needs all ranks) ! 2. Parallel: Multiple ranks AND unfragmented molecules (distribute molecules across ranks) molecules_processed = 0 if ( num_ranks == 1 . or . has_fragmented_molecules ) then ! Sequential mode: process all molecules one after another ! Each molecule uses all available ranks for its calculation do imol = 1 , mqc_config % nmol ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Processing molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) end if ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then if ( my_rank == 0 ) then call logger % error ( \"Error converting geometry for \" // mol_name // \": \" // error % get_message ()) end if call abort_comm ( world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % molecules ( imol )% bonds ) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () if ( my_rank == 0 ) then call logger % info ( \"Completed molecule \" // to_char ( imol ) // \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) end if molecules_processed = molecules_processed + 1 end do else ! Multiple ranks: distribute molecules across ranks (one per rank) if ( my_rank < mqc_config % nmol ) then imol = my_rank + 1 ! This rank has a molecule to process ! Determine molecule name for logging if ( allocated ( mqc_config % molecules ( imol )% name )) then mol_name = mqc_config % molecules ( imol )% name else mol_name = \"molecule_\" // to_char ( imol ) end if call logger % info ( \" \" ) call logger % info ( \"--------------------------------------------\" ) call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Processing molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) call logger % info ( \"--------------------------------------------\" ) ! Convert to driver configuration for this molecule call config_to_driver ( mqc_config , config , molecule_index = imol ) ! Convert geometry for this molecule call config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index = imol ) if ( error % has_error ()) then call logger % error ( \"Rank \" // to_char ( my_rank ) // \": Error converting geometry for \" // mol_name // \": \" // error % get_message ()) call abort_comm ( world_comm , 1 ) end if ! Set output filename suffix for this molecule call set_molecule_suffix ( \"_\" // trim ( mol_name )) ! Run calculation for this molecule call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % molecules ( imol )% bonds ) ! Track the JSON filename for later merging individual_json_files ( imol ) = get_output_json_filename () ! Clean up for this molecule call sys_geom % destroy () call logger % info ( \"Rank \" // to_char ( my_rank ) // \": Completed molecule \" // to_char ( imol ) // & \"/\" // to_char ( mqc_config % nmol ) // \": \" // mol_name ) molecules_processed = 1 else ! Idle rank - no molecule assigned call logger % verbose ( \"Rank \" // to_char ( my_rank ) // \": No molecule assigned (idle)\" ) end if end if ! Synchronize all ranks call world_comm % barrier () ! Merge individual JSON files into one combined file (rank 0 only) if ( my_rank == 0 ) then call merge_multi_molecule_json ( individual_json_files , mqc_config % nmol ) end if if ( my_rank == 0 ) then call logger % info ( \" \" ) call logger % info ( \"============================================\" ) call logger % info ( \"All \" // to_char ( mqc_config % nmol ) // \" molecules completed\" ) if ( has_fragmented_molecules ) then call logger % info ( \"Execution: Sequential (each molecule used all ranks)\" ) else if ( num_ranks == 1 ) then call logger % info ( \"Execution: Sequential (single rank)\" ) else if ( num_ranks > mqc_config % nmol ) then call logger % info ( \"Execution: Parallel (active ranks: \" // to_char ( mqc_config % nmol ) // \"/\" // to_char ( num_ranks ) // \")\" ) else call logger % info ( \"Execution: Parallel (all ranks active)\" ) end if call logger % info ( \"============================================\" ) end if end subroutine run_multi_molecule_calculations end module mqc_driver","tags":"","url":"sourcefile/mqc_driver.f90.html"},{"title":"mqc_method_xtb.f90 – metalquicha","text":"Extended Tight-Binding (xTB) quantum chemistry method implementation This file depends on sourcefile~~mqc_method_xtb.f90~~EfferentGraph sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_xtb.f90~~AfferentGraph sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Extended Tight-Binding (xTB) quantum chemistry method implementation module mqc_method_xtb !! Provides GFN1-xTB and GFN2-xTB methods via the tblite library, !! implementing the abstract method interface for energy and gradient calculations. use pic_types , only : dp use mqc_method_base , only : qc_method_t use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t ! tblite imports (reuse from mqc_mbe) use mctc_env , only : wp , error_type use mctc_io , only : structure_type , new use pic_timer , only : timer_type use tblite_context_type , only : context_type use tblite_wavefunction , only : wavefunction_type , new_wavefunction use tblite_xtb_calculator , only : xtb_calculator use tblite_xtb_gfn1 , only : new_gfn1_calculator use tblite_xtb_gfn2 , only : new_gfn2_calculator use tblite_xtb_singlepoint , only : xtb_singlepoint implicit none private public :: xtb_method_t !! XTB method implementation type type , extends ( qc_method_t ) :: xtb_method_t !! Extended Tight-Binding (xTB) method implementation !! !! Concrete implementation of the abstract quantum chemistry method !! interface for GFN1-xTB and GFN2-xTB calculations via tblite. character ( len = :), allocatable :: variant !! XTB variant: \"gfn1\" or \"gfn2\" logical :: verbose = . false . !! Print calculation details real ( wp ) :: accuracy = 0.01_wp !! Numerical accuracy parameter real ( wp ) :: kt = 30 0.0_wp * 3.166808578545117e-06_wp !! Electronic temperature (300 K) contains procedure :: calc_energy => xtb_calc_energy !! Energy-only calculation procedure :: calc_gradient => xtb_calc_gradient !! Energy + gradient calculation procedure :: calc_hessian => xtb_calc_hessian !! Placeholder for Hessian calculation end type xtb_method_t contains subroutine xtb_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity if ( this % verbose ) then print * , \"XTB: Calculating energy using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure ! charge is real(wp), multiplicity converted to uhf (unpaired electrons) call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default error stop \"Unknown XTB variant: \" // this % variant end select if ( allocated ( error )) then error stop \"Failed to create XTB calculator\" end if ! Create wavefunction and run single point calculation call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt ) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , verbosity = verbosity ) ! Store result (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () end if deallocate ( num , xyz ) end subroutine xtb_calc_energy subroutine xtb_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity real ( wp ), allocatable :: gradient (:, :) real ( wp ), allocatable :: sigma (:, :) if ( this % verbose ) then print * , \"XTB: Calculating gradient using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default error stop \"Unknown XTB variant: \" // this % variant end select if ( allocated ( error )) then error stop \"Failed to create XTB calculator\" end if ! Allocate gradient and sigma arrays allocate ( gradient ( 3 , fragment % n_atoms )) allocate ( sigma ( 3 , 3 )) ! Create wavefunction and run single point calculation with gradient call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt , grad = . true .) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , & gradient = gradient , sigma = sigma , verbosity = verbosity ) ! Store results (XTB is a semi-empirical method, store as SCF energy) result % energy % scf = real ( energy , dp ) result % has_energy = . true . ! Store gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = real ( gradient , dp ) result % has_gradient = . true . ! Store sigma (stress tensor) allocate ( result % sigma ( 3 , 3 )) result % sigma = real ( sigma , dp ) result % has_sigma = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy % total () print * , \"XTB: Gradient norm =\" , sqrt ( sum ( result % gradient ** 2 )) print * , \"XTB: Gradient calculation complete\" end if deallocate ( num , xyz , gradient , sigma ) end subroutine xtb_calc_gradient subroutine xtb_calc_hessian ( this , fragment , result ) !! Calculate Hessian using finite differences of gradients !! !! Since tblite does not natively support analytic Hessians, this routine !! computes the Hessian numerically via central finite differences: !!   H[i,j] = (grad_j(x_i + h) - grad_j(x_i - h)) / (2h) !! !! This requires 6N gradient calculations (forward and backward for each coordinate) use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT use pic_logger , only : logger => global_logger use pic_io , only : to_char class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result type ( displaced_geometry_t ), allocatable :: forward_geoms (:), backward_geoms (:) real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) type ( calculation_result_t ) :: disp_result real ( dp ) :: displacement integer :: n_atoms , n_displacements , i n_atoms = fragment % n_atoms n_displacements = 3 * n_atoms if ( this % verbose ) then call logger % info ( \"XTB: Computing Hessian via finite differences\" ) call logger % info ( \"  Method: Central differences of gradients\" ) call logger % info ( \"  Atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) end if ! Use default displacement (0.001 Bohr ~ 0.0005 Angstrom) displacement = DEFAULT_DISPLACEMENT ! Generate all perturbed geometries call generate_perturbed_geometries ( fragment , displacement , forward_geoms , backward_geoms ) ! Allocate storage for gradients at displaced geometries allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) ! Compute gradients at all forward-displaced geometries if ( this % verbose ) then call logger % info ( \"  Computing forward-displaced gradients...\" ) end if do i = 1 , n_displacements ! Forward call this % calc_gradient ( forward_geoms ( i )% geometry , disp_result ) if (. not . disp_result % has_gradient ) then call logger % error ( \"Failed to compute gradient for forward displacement \" // to_char ( i )) error stop \"Finite difference Hessian: gradient calculation failed\" end if forward_gradients ( i , :, :) = disp_result % gradient call disp_result % destroy () ! Backward call this % calc_gradient ( backward_geoms ( i )% geometry , disp_result ) if (. not . disp_result % has_gradient ) then call logger % error ( \"Failed to compute gradient for backward displacement \" // to_char ( i )) error stop \"Finite difference Hessian: gradient calculation failed\" end if backward_gradients ( i , :, :) = disp_result % gradient call disp_result % destroy () end do if ( this % verbose ) then call logger % info ( \"  Forward and backward gradient calculations complete \" ) end if ! Compute Hessian from finite differences if ( this % verbose ) then call logger % info ( \"  Assembling Hessian matrix...\" ) end if call finite_diff_hessian_from_gradients ( fragment , forward_gradients , backward_gradients , & displacement , result % hessian ) ! Also compute energy and gradient at reference geometry for completeness call this % calc_gradient ( fragment , disp_result ) result % energy = disp_result % energy result % has_energy = disp_result % has_energy if ( disp_result % has_gradient ) then allocate ( result % gradient ( 3 , n_atoms )) result % gradient = disp_result % gradient result % has_gradient = . true . end if call disp_result % destroy () result % has_hessian = . true . if ( this % verbose ) then call logger % info ( \"  Hessian calculation complete\" ) end if ! Cleanup deallocate ( forward_gradients , backward_gradients ) do i = 1 , n_displacements call forward_geoms ( i )% destroy () call backward_geoms ( i )% destroy () end do deallocate ( forward_geoms , backward_geoms ) end subroutine xtb_calc_hessian end module mqc_method_xtb","tags":"","url":"sourcefile/mqc_method_xtb.f90.html"},{"title":"main.f90 – metalquicha","text":"Main program for metalquicha quantum chemistry calculations Input format: .mqc (section-based format) Usage: metalquicha input_file.mqc This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~main.f90->sourcefile~mqc_error.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~main.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_logo.f90 mqc_logo.f90 sourcefile~main.f90->sourcefile~mqc_logo.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Main program for metalquicha quantum chemistry calculations !! !! Input format: .mqc (section-based format) !! !! Usage: metalquicha input_file.mqc program main !! Orchestrates MPI initialization, input parsing, geometry loading, !! and dispatches to appropriate calculation routines (fragmented or unfragmented). use pic_logger , only : logger => global_logger , info_level use pic_io , only : to_char use pic_mpi_lib , only : pic_mpi_init , comm_world , comm_t , abort_comm , pic_mpi_finalize use mqc_driver , only : run_calculation , run_multi_molecule_calculations use mqc_physical_fragment , only : system_geometry_t use mqc_config_parser , only : mqc_config_t , read_mqc_file use mqc_config_adapter , only : driver_config_t , config_to_driver , config_to_system_geometry , get_logger_level use mqc_io_helpers , only : set_output_json_filename , ends_with use mqc_logo , only : print_logo use pic_timer , only : timer_type use mqc_error , only : error_t implicit none type ( timer_type ) :: my_timer !! Execution timing type ( comm_t ) :: world_comm !! Global MPI communicator type ( comm_t ) :: node_comm !! Node-local MPI communicator type ( driver_config_t ) :: config !! Driver configuration type ( mqc_config_t ) :: mqc_config !! Parsed .mqc file type ( system_geometry_t ) :: sys_geom !! Loaded molecular system type ( error_t ) :: error !! Error handling integer :: stat !! Status code for file I/O character ( len = :), allocatable :: errmsg !! Error messages for file I/O character ( len = 256 ) :: input_file !! Input file name ! Initialize MPI ! pic-mpi will call mpi_init_thread when needed call pic_mpi_init () ! Create communicators world_comm = comm_world () node_comm = world_comm % split () if ( world_comm % rank () == 0 ) then call print_logo () call my_timer % start () end if ! Parse command line arguments if ( command_argument_count () == 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"No input file specified. Usage: mqc input_file.mqc\" ) end if call abort_comm ( world_comm , 1 ) else if ( command_argument_count () == 1 ) then call get_command_argument ( 1 , input_file , status = stat ) if ( stat /= 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error reading command line argument\" ) end if call abort_comm ( world_comm , 1 ) end if input_file = trim ( input_file ) call set_output_json_filename ( input_file ) ! Validate file extension if (. not . ends_with ( input_file , '.mqc' )) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Invalid input file extension. Expected .mqc\" ) end if call abort_comm ( world_comm , 1 ) end if else if ( world_comm % rank () == 0 ) then call logger % error ( \"Too many arguments. Usage: metalquicha [input_file.mqc]\" ) end if call abort_comm ( world_comm , 1 ) end if ! Parse .mqc input file if ( world_comm % rank () == 0 ) then call logger % info ( \"Reading input file: \" // trim ( input_file )) end if call read_mqc_file ( input_file , mqc_config , error ) if ( error % has_error ()) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error reading .mqc file: \" // error % get_message ()) end if call abort_comm ( world_comm , 1 ) end if ! Configure logger if ( allocated ( mqc_config % log_level )) then call logger % configure ( get_logger_level ( mqc_config % log_level )) if ( world_comm % rank () == 0 ) then call logger % info ( \"Logger verbosity set to: \" // trim ( mqc_config % log_level )) end if end if ! Handle single vs multiple molecules if ( mqc_config % nmol == 0 ) then ! Single molecule mode (backward compatible) call config_to_driver ( mqc_config , config ) call config_to_system_geometry ( mqc_config , sys_geom , error ) if ( error % has_error ()) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error converting geometry: \" // error % get_message ()) end if call abort_comm ( world_comm , 1 ) end if call run_calculation ( world_comm , node_comm , config , sys_geom , mqc_config % bonds ) call sys_geom % destroy () else ! Multi-molecule mode: loop over all molecules call run_multi_molecule_calculations ( world_comm , node_comm , mqc_config ) end if if ( world_comm % rank () == 0 ) then call my_timer % stop () call logger % info ( \"Total processing time: \" // to_char ( my_timer % get_elapsed_time ()) // \" s\" ) end if call mqc_config % destroy () call world_comm % finalize () call node_comm % finalize () call pic_mpi_finalize () end program main","tags":"","url":"sourcefile/main.f90.html"},{"title":"mqc_mpi_tags.f90 – metalquicha","text":"contains MPI tags used in the MQC parallel implementation Files dependent on this one sourcefile~~mqc_mpi_tags.f90~~AfferentGraph sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! contains MPI tags used in the MQC parallel implementation module mqc_mpi_tags !! Module defining MPI communication tags for clarity and maintainability use pic_types , only : default_int implicit none private ! Local worker communication tags (shared memory within a node) integer ( default_int ), parameter , public :: TAG_WORKER_REQUEST = 200 !! Worker requests work from node coordinator integer ( default_int ), parameter , public :: TAG_WORKER_FRAGMENT = 201 !! Coordinator sends fragment data to worker integer ( default_int ), parameter , public :: TAG_WORKER_FINISH = 202 !! Coordinator signals worker to finish integer ( default_int ), parameter , public :: TAG_WORKER_SCALAR_RESULT = 203 !! Worker sends scalar results back to coordinator integer ( default_int ), parameter , public :: TAG_WORKER_MATRIX_RESULT = 204 !! Worker sends matrix results back to coordinator ! Remote node communication tags (between nodes via world communicator) integer ( default_int ), parameter , public :: TAG_NODE_REQUEST = 300 !! Node coordinator requests work from global coordinator integer ( default_int ), parameter , public :: TAG_NODE_FRAGMENT = 301 !! Global coordinator sends fragment data to node coordinator integer ( default_int ), parameter , public :: TAG_NODE_FINISH = 302 !! Global coordinator signals node coordinator to finish integer ( default_int ), parameter , public :: TAG_NODE_SCALAR_RESULT = 303 !! Node coordinator sends results (fragment_idx + scalar) to global coordinator integer ( default_int ), parameter , public :: TAG_NODE_MATRIX_RESULT = 304 !! Node coordinator sends matrix results to global coordinator end module mqc_mpi_tags","tags":"","url":"sourcefile/mqc_mpi_tags.f90.html"},{"title":"mqc_geometry.f90 – metalquicha","text":"Geometry data structure for molecular systems Files dependent on this one sourcefile~~mqc_geometry.f90~~AfferentGraph sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Geometry data structure for molecular systems module mqc_geometry !! Defines the geometry data structure for molecular systems use pic_types , only : dp implicit none private public :: geometry_type ! Parameters integer , parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 type :: geometry_type !! Molecular geometry data structure integer :: natoms character ( len = :), allocatable :: elements (:) real ( dp ), allocatable :: coords (:, :) ! coords(3, natoms) character ( len = :), allocatable :: comment contains procedure :: destroy => geometry_destroy end type geometry_type contains subroutine geometry_destroy ( this ) !! Clean up allocated memory in geometry_type class ( geometry_type ), intent ( inout ) :: this if ( allocated ( this % elements )) deallocate ( this % elements ) if ( allocated ( this % coords )) deallocate ( this % coords ) if ( allocated ( this % comment )) deallocate ( this % comment ) this % natoms = 0 end subroutine geometry_destroy end module mqc_geometry","tags":"","url":"sourcefile/mqc_geometry.f90.html"},{"title":"mqc_gmbe_fragment_distribution_scheme.f90 – metalquicha","text":"Generalized Many-Body Expansion (GMBE) fragment distribution module This file depends on sourcefile~~mqc_gmbe_fragment_distribution_scheme.f90~~EfferentGraph sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_gmbe_fragment_distribution_scheme.f90~~AfferentGraph sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Generalized Many-Body Expansion (GMBE) fragment distribution module module mqc_gmbe_fragment_distribution_scheme !! Implements fragment distribution schemes for GMBE calculations with overlapping fragments !! Handles both serial and MPI-parallelized distribution of monomers and intersection fragments use pic_types , only : int32 , int64 , dp use pic_timer , only : timer_type use mqc_calc_types , only : CALC_TYPE_GRADIENT use pic_mpi_lib , only : comm_t , send , recv , isend , irecv , wait , iprobe , MPI_Status , request_t , MPI_ANY_SOURCE , MPI_ANY_TAG use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_mpi_tags , only : TAG_WORKER_REQUEST , TAG_WORKER_FRAGMENT , TAG_WORKER_FINISH , & TAG_WORKER_SCALAR_RESULT , & TAG_NODE_REQUEST , TAG_NODE_FRAGMENT , TAG_NODE_FINISH , & TAG_NODE_SCALAR_RESULT use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , build_fragment_from_indices , & build_fragment_from_atom_list use mqc_config_parser , only : bond_t use mqc_result_types , only : calculation_result_t , result_send , result_isend , result_recv , result_irecv use mqc_mbe_fragment_distribution_scheme , only : do_fragment_work use mqc_mbe_io , only : print_gmbe_json , print_gmbe_pie_json implicit none private ! Public interface public :: serial_gmbe_pie_processor !! PIE-based serial processor public :: gmbe_pie_coordinator !! PIE-based MPI coordinator contains subroutine serial_gmbe_pie_processor ( pie_atom_sets , pie_coefficients , n_pie_terms , sys_geom , method , calc_type , bonds ) !! Serial GMBE processor using PIE coefficients !! Evaluates each unique atom set once and sums with PIE coefficients !! Supports energy-only, energy+gradient, and energy+gradient+Hessian calculations use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN , CALC_TYPE_ENERGY , calc_type_to_string use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian use pic_logger , only : info_level integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer , intent ( in ) :: n_pie_terms type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method , calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( physical_fragment_t ) :: phys_frag type ( calculation_result_t ), allocatable :: results (:) integer :: i , n_atoms , max_atoms , iatom , current_log_level , hess_dim integer , allocatable :: atom_list (:) real ( dp ) :: total_energy , term_energy real ( dp ), allocatable :: pie_energies (:) !! Store individual energies for JSON output real ( dp ), allocatable :: total_gradient (:, :) !! Total gradient (3, total_atoms) real ( dp ), allocatable :: term_gradient (:, :) !! Temporary gradient for each term real ( dp ), allocatable :: total_hessian (:, :) !! Total Hessian (3*total_atoms, 3*total_atoms) real ( dp ), allocatable :: term_hessian (:, :) !! Temporary Hessian for each term integer :: coeff call logger % info ( \"Processing \" // to_char ( n_pie_terms ) // \" unique PIE terms...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type )) total_energy = 0.0_dp max_atoms = size ( pie_atom_sets , 1 ) allocate ( pie_energies ( n_pie_terms )) allocate ( results ( n_pie_terms )) ! Allocate gradient and Hessian arrays if needed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) allocate ( term_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp end if do i = 1 , n_pie_terms coeff = pie_coefficients ( i ) ! Skip terms with zero coefficient (shouldn't happen, but safety check) if ( coeff == 0 ) then pie_energies ( i ) = 0.0_dp ! Mark as skipped cycle end if ! Extract atom list for this term n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , i ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms == 0 ) then pie_energies ( i ) = 0.0_dp ! Mark as skipped cycle end if allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , i ) ! Build fragment from atom list call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , bonds ) ! Compute energy (and gradient if requested) call do_fragment_work ( i , results ( i ), method , phys_frag , calc_type ) term_energy = results ( i )% energy % total () ! Store energy for JSON output pie_energies ( i ) = term_energy ! Accumulate with PIE coefficient total_energy = total_energy + real ( coeff , dp ) * term_energy ! Accumulate gradient if present if (( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) . and . results ( i )% has_gradient ) then ! Map fragment gradient to system coordinates with proper cap handling term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( i )% gradient , term_gradient ) ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( coeff , dp ) * term_gradient end if ! Accumulate Hessian if present if ( calc_type == CALC_TYPE_HESSIAN . and . results ( i )% has_hessian ) then ! Map fragment Hessian to system coordinates with proper cap handling term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( i )% hessian , term_hessian ) ! Accumulate with PIE coefficient total_hessian = total_hessian + real ( coeff , dp ) * term_hessian end if call logger % verbose ( \"PIE term \" // to_char ( i ) // \"/\" // to_char ( n_pie_terms ) // & \": \" // to_char ( n_atoms ) // \" atoms, coeff=\" // to_char ( coeff ) // & \", E=\" // to_char ( term_energy )) deallocate ( atom_list ) call phys_frag % destroy () end do call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) ! Print gradient info if computed if ( calc_type == CALC_TYPE_GRADIENT . or . calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end if ! Print Hessian info if computed if ( calc_type == CALC_TYPE_HESSIAN ) then call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) end if call logger % info ( \" \" ) ! Write JSON output call print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) deallocate ( pie_energies , results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( term_gradient )) deallocate ( term_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) if ( allocated ( term_hessian )) deallocate ( term_hessian ) end subroutine serial_gmbe_pie_processor subroutine gmbe_pie_coordinator ( world_comm , node_comm , pie_atom_sets , pie_coefficients , n_pie_terms , & node_leader_ranks , num_nodes , sys_geom , method , calc_type , bonds ) !! MPI coordinator for PIE-based GMBE calculations !! Distributes PIE terms across MPI ranks and accumulates results use mqc_calc_types , only : CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_physical_fragment , only : redistribute_cap_gradients , redistribute_cap_hessian type ( comm_t ), intent ( in ) :: world_comm , node_comm integer , intent ( in ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_pie_terms) integer , intent ( in ) :: pie_coefficients (:) !! PIE coefficient for each term integer , intent ( in ) :: n_pie_terms integer , intent ( in ) :: node_leader_ranks (:), num_nodes type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method , calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( timer_type ) :: coord_timer integer :: current_term_idx , results_received , finished_nodes integer :: request_source , dummy_msg , term_idx type ( MPI_Status ) :: status , local_status logical :: handling_local_workers , has_pending integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer :: worker_term_map ( node_comm % size ()) integer :: worker_source real ( dp ) :: total_energy real ( dp ), allocatable :: total_gradient (:, :) real ( dp ), allocatable :: total_hessian (:, :) integer :: hess_dim ! MPI request handles type ( request_t ) :: req current_term_idx = n_pie_terms finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( node_comm % size () > 1 ) results_received = 0 worker_term_map = 0 allocate ( results ( n_pie_terms )) call logger % verbose ( \"GMBE PIE coordinator starting with \" // to_char ( n_pie_terms ) // & \" PIE terms for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers if ( handling_local_workers ) then do call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE if ( worker_term_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no term was assigned!\" ) error stop \"Invalid worker_term_map state\" end if call result_irecv ( results ( worker_term_map ( worker_source )), node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) worker_term_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1 , n_pie_terms / 10 )) == 0 . or . results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit call irecv ( world_comm , term_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( term_idx ), world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) results_received = results_received + 1 if ( mod ( results_received , max ( 1 , n_pie_terms / 10 )) == 0 . or . results_received == n_pie_terms ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( n_pie_terms ) // \" PIE terms [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_term_idx >= 1 ) then call send_pie_term_to_node ( world_comm , current_term_idx , pie_atom_sets , request_source ) current_term_idx = current_term_idx - 1 else call isend ( world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < node_comm % size () - 1 ) then call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then if ( worker_term_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_term_idx >= 1 ) then call send_pie_term_to_worker ( node_comm , current_term_idx , pie_atom_sets , local_status % MPI_SOURCE ) worker_term_map ( local_status % MPI_SOURCE ) = current_term_idx current_term_idx = current_term_idx - 1 else call isend ( node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= node_comm % size () - 1 & . and . results_received >= n_pie_terms ) then handling_local_workers = . false . finished_nodes = finished_nodes + 1 end if end do call logger % verbose ( \"GMBE PIE coordinator finished all terms\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all PIE terms \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Accumulate results with PIE coefficients call logger % info ( \" \" ) call logger % info ( \"Computing GMBE PIE energy...\" ) call coord_timer % start () total_energy = 0.0_dp do term_idx = 1 , n_pie_terms total_energy = total_energy + real ( pie_coefficients ( term_idx ), dp ) * results ( term_idx )% energy % total () end do ! Handle gradients if computed if ( calc_type == CALC_TYPE_GRADIENT ) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp do term_idx = 1 , n_pie_terms if ( results ( term_idx )% has_gradient ) then ! Map fragment gradient to system coordinates block real ( dp ), allocatable :: term_gradient (:, :) type ( physical_fragment_t ) :: phys_frag integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , bonds ) call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) call phys_frag % destroy () deallocate ( atom_list ) end if ! Accumulate with PIE coefficient total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print detailed gradient if info level and small system block use pic_logger , only : info_level integer :: iatom , current_log_level call logger % configuration ( level = current_log_level ) if ( current_log_level >= info_level . and . sys_geom % total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Total GMBE PIE Gradient (Hartree/Bohr):\" ) do iatom = 1 , sys_geom % total_atoms block character ( len = 256 ) :: grad_line write ( grad_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & total_gradient ( 1 , iatom ), total_gradient ( 2 , iatom ), total_gradient ( 3 , iatom ) call logger % info ( trim ( grad_line )) end block end do call logger % info ( \" \" ) end if end block deallocate ( total_gradient ) end if ! Handle Hessians if computed if ( calc_type == CALC_TYPE_HESSIAN ) then hess_dim = 3 * sys_geom % total_atoms allocate ( total_hessian ( hess_dim , hess_dim )) total_hessian = 0.0_dp ! Also allocate gradient for Hessian calculations if (. not . allocated ( total_gradient )) then allocate ( total_gradient ( 3 , sys_geom % total_atoms )) total_gradient = 0.0_dp end if do term_idx = 1 , n_pie_terms if ( results ( term_idx )% has_hessian . or . results ( term_idx )% has_gradient ) then block real ( dp ), allocatable :: term_gradient (:, :), term_hessian (:, :) type ( physical_fragment_t ) :: phys_frag integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do if ( n_atoms > 0 ) then allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) ! Build fragment to get proper mapping call build_fragment_from_atom_list ( sys_geom , atom_list , n_atoms , phys_frag , bonds ) ! Redistribute gradient if present if ( results ( term_idx )% has_gradient ) then allocate ( term_gradient ( 3 , sys_geom % total_atoms )) term_gradient = 0.0_dp call redistribute_cap_gradients ( phys_frag , results ( term_idx )% gradient , term_gradient ) total_gradient = total_gradient + real ( pie_coefficients ( term_idx ), dp ) * term_gradient deallocate ( term_gradient ) end if ! Redistribute Hessian if present if ( results ( term_idx )% has_hessian ) then allocate ( term_hessian ( hess_dim , hess_dim )) term_hessian = 0.0_dp call redistribute_cap_hessian ( phys_frag , results ( term_idx )% hessian , term_hessian ) total_hessian = total_hessian + real ( pie_coefficients ( term_idx ), dp ) * term_hessian deallocate ( term_hessian ) end if call phys_frag % destroy () deallocate ( atom_list ) end if end block end if end do ! Print gradient information call logger % info ( \"GMBE PIE gradient computation completed\" ) call logger % info ( \"  Total gradient norm: \" // to_char ( sqrt ( sum ( total_gradient ** 2 )))) ! Print Hessian information call logger % info ( \"GMBE PIE Hessian computation completed\" ) call logger % info ( \"  Total Hessian Frobenius norm: \" // to_char ( sqrt ( sum ( total_hessian ** 2 )))) end if call coord_timer % stop () call logger % info ( \"Time to compute GMBE PIE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call logger % info ( \" \" ) call logger % info ( \"GMBE PIE calculation completed successfully\" ) call logger % info ( \"Final GMBE energy: \" // to_char ( total_energy ) // \" Hartree\" ) call logger % info ( \" \" ) ! Write JSON output (reuse existing function) block real ( dp ), allocatable :: pie_energies (:) allocate ( pie_energies ( n_pie_terms )) do term_idx = 1 , n_pie_terms pie_energies ( term_idx ) = results ( term_idx )% energy % total () end do call print_gmbe_pie_json ( pie_atom_sets , pie_coefficients , pie_energies , n_pie_terms , total_energy , & total_gradient , total_hessian ) deallocate ( pie_energies ) end block deallocate ( results ) if ( allocated ( total_gradient )) deallocate ( total_gradient ) if ( allocated ( total_hessian )) deallocate ( total_hessian ) end subroutine gmbe_pie_coordinator subroutine send_pie_term_to_node ( world_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to remote node coordinator type ( comm_t ), intent ( in ) :: world_comm integer , intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( world_comm , term_idx , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , n_atoms , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , atom_list , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_node subroutine send_pie_term_to_worker ( node_comm , term_idx , pie_atom_sets , dest_rank ) !! Send PIE term (atom list) to local worker type ( comm_t ), intent ( in ) :: node_comm integer , intent ( in ) :: term_idx integer , intent ( in ) :: pie_atom_sets (:, :) integer , intent ( in ) :: dest_rank integer :: n_atoms , max_atoms integer , allocatable :: atom_list (:) integer ( int32 ) :: fragment_type type ( request_t ) :: req ( 4 ) ! PIE terms always use atom lists (type 1) fragment_type = 1 ! Extract atom list for this term max_atoms = size ( pie_atom_sets , 1 ) n_atoms = 0 do while ( n_atoms < max_atoms . and . pie_atom_sets ( n_atoms + 1 , term_idx ) >= 0 ) n_atoms = n_atoms + 1 end do allocate ( atom_list ( n_atoms )) atom_list = pie_atom_sets ( 1 : n_atoms , term_idx ) call isend ( node_comm , term_idx , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , n_atoms , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , atom_list , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( atom_list ) end subroutine send_pie_term_to_worker end module mqc_gmbe_fragment_distribution_scheme","tags":"","url":"sourcefile/mqc_gmbe_fragment_distribution_scheme.f90.html"},{"title":"mqc_config_adapter.f90 – metalquicha","text":"Adapter module to convert mqc_config_t to internal driver structures\nThis module provides a bridge between the .mqc file format and the driver backend This file depends on sourcefile~~mqc_config_adapter.f90~~EfferentGraph sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_config_adapter.f90~~AfferentGraph sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Adapter module to convert mqc_config_t to internal driver structures !! This module provides a bridge between the .mqc file format and the driver backend module mqc_config_adapter !! Provides conversion utilities from mqc_config_t to driver-compatible structures use pic_types , only : dp , int32 use mqc_config_parser , only : mqc_config_t use mqc_physical_fragment , only : system_geometry_t , to_bohr use mqc_elements , only : element_symbol_to_number use mqc_error , only : error_t , ERROR_VALIDATION implicit none private public :: driver_config_t !! Minimal config for driver public :: config_to_driver , config_to_system_geometry public :: get_logger_level !! Convert log level string to integer public :: check_fragment_overlap !! Check for overlapping fragments (for testing) !! Minimal configuration for driver (internal use only) type :: driver_config_t integer ( int32 ) :: method !! QC method constant integer ( int32 ) :: calc_type !! Calculation type constant integer :: nlevel = 0 !! Fragmentation level (0 = unfragmented) logical :: allow_overlapping_fragments !! Enable GMBE for overlapping fragments integer :: max_intersection_level = 999 !! Maximum k-way intersection depth for GMBE (default: no limit) end type driver_config_t contains subroutine config_to_driver ( mqc_config , driver_config , molecule_index ) !! Convert mqc_config_t to minimal driver_config_t !! Extracts only the fields needed by the driver !! If molecule_index is provided, uses that molecule's fragment count type ( mqc_config_t ), intent ( in ) :: mqc_config type ( driver_config_t ), intent ( out ) :: driver_config integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: nfrag_to_use ! Copy method and calc_type (already integers) driver_config % method = mqc_config % method driver_config % calc_type = mqc_config % calc_type ! Determine fragment count if ( present ( molecule_index )) then ! Multi-molecule mode: use specific molecule's fragment count if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then nfrag_to_use = 0 else nfrag_to_use = mqc_config % molecules ( molecule_index )% nfrag end if else ! Single molecule mode (backward compatible) nfrag_to_use = mqc_config % nfrag end if ! Set fragmentation level ! For unfragmented calculations (nfrag=0), nlevel must be 0 if ( nfrag_to_use == 0 ) then driver_config % nlevel = 0 else driver_config % nlevel = mqc_config % frag_level end if ! Set GMBE overlapping fragments flag driver_config % allow_overlapping_fragments = mqc_config % allow_overlapping_fragments ! Set GMBE maximum intersection level driver_config % max_intersection_level = mqc_config % max_intersection_level end subroutine config_to_driver subroutine config_to_system_geometry ( mqc_config , sys_geom , error , molecule_index ) !! Convert mqc_config_t geometry to system_geometry_t !! For unfragmented calculations (nfrag=0), treats entire system as single unit !! For fragmented calculations, currently assumes monomer-based fragmentation !! If molecule_index is provided, uses that specific molecule from multi-molecule mode type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer , intent ( in ), optional :: molecule_index !! Which molecule to use (for multi-molecule mode) integer :: i logical :: use_angstrom ! Determine units use_angstrom = . true . if ( allocated ( mqc_config % units )) then if ( trim ( mqc_config % units ) == 'bohr' ) then use_angstrom = . false . end if end if ! Handle multi-molecule vs single molecule mode if ( present ( molecule_index )) then ! Multi-molecule mode: extract specific molecule if ( molecule_index < 1 . or . molecule_index > mqc_config % nmol ) then call error % set ( ERROR_VALIDATION , \"Invalid molecule_index in multi-molecule mode\" ) return end if call molecule_to_system_geometry ( mqc_config % molecules ( molecule_index ), & sys_geom , use_angstrom , mqc_config % allow_overlapping_fragments , error ) else ! Single molecule mode (backward compatible) ! Check if geometry is loaded if ( mqc_config % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in mqc_config\" ) return end if if ( mqc_config % nfrag == 0 ) then ! Unfragmented calculation: entire system is one \"monomer\" call geometry_to_system_unfragmented ( mqc_config % geometry , sys_geom , use_angstrom ) sys_geom % charge = mqc_config % charge sys_geom % multiplicity = mqc_config % multiplicity else ! Fragmented calculation with explicit fragments call geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) if ( error % has_error ()) return end if end if end subroutine config_to_system_geometry subroutine geometry_to_system_unfragmented ( geom , sys_geom , use_angstrom ) !! Convert geometry to system_geometry_t for unfragmented calculation !! Treats entire system as a single monomer use mqc_geometry , only : geometry_type type ( geometry_type ), intent ( in ) :: geom type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom integer :: i ! For unfragmented: n_monomers=1, atoms_per_monomer=natoms sys_geom % n_monomers = 1 sys_geom % atoms_per_monomer = geom % natoms sys_geom % total_atoms = geom % natoms allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine geometry_to_system_unfragmented subroutine initialize_fragmented_system ( nfrag , geom , fragments , charge , multiplicity , & allow_overlapping , use_angstrom , sys_geom , error ) !! Shared helper to initialize system_geometry_t for fragmented calculations !! Handles fragment allocation, size checking, and overlap validation use mqc_geometry , only : geometry_type use mqc_config_parser , only : input_fragment_t integer , intent ( in ) :: nfrag type ( geometry_type ), intent ( in ) :: geom type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: charge , multiplicity logical , intent ( in ) :: allow_overlapping logical , intent ( in ) :: use_angstrom type ( system_geometry_t ), intent ( out ) :: sys_geom type ( error_t ), intent ( out ) :: error integer :: i , j , atoms_in_first_frag , max_frag_size logical :: all_same_size ! Set up basic system geometry sys_geom % n_monomers = nfrag sys_geom % total_atoms = geom % natoms sys_geom % charge = charge sys_geom % multiplicity = multiplicity ! Allocate fragment info arrays allocate ( sys_geom % fragment_sizes ( nfrag )) allocate ( sys_geom % fragment_charges ( nfrag )) allocate ( sys_geom % fragment_multiplicities ( nfrag )) ! Get fragment sizes max_frag_size = 0 atoms_in_first_frag = size ( fragments ( 1 )% indices ) all_same_size = . true . do i = 1 , nfrag sys_geom % fragment_sizes ( i ) = size ( fragments ( i )% indices ) sys_geom % fragment_charges ( i ) = fragments ( i )% charge sys_geom % fragment_multiplicities ( i ) = fragments ( i )% multiplicity max_frag_size = max ( max_frag_size , sys_geom % fragment_sizes ( i )) if ( sys_geom % fragment_sizes ( i ) /= atoms_in_first_frag ) then all_same_size = . false . end if end do ! Allocate fragment_atoms array allocate ( sys_geom % fragment_atoms ( max_frag_size , nfrag )) sys_geom % fragment_atoms = - 1 ! Initialize with invalid index ! Store fragment atom indices (0-indexed from input file) do i = 1 , nfrag do j = 1 , sys_geom % fragment_sizes ( i ) sys_geom % fragment_atoms ( j , i ) = fragments ( i )% indices ( j ) end do end do ! Check for overlapping fragments if not allowed if (. not . allow_overlapping ) then call check_fragment_overlap ( fragments , nfrag , error ) if ( error % has_error ()) return end if ! Set atoms_per_monomer: use common size if identical, else 0 if ( all_same_size ) then sys_geom % atoms_per_monomer = atoms_in_first_frag else sys_geom % atoms_per_monomer = 0 ! Signal variable-sized fragments end if allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) ! Convert element symbols to atomic numbers do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( geom % elements ( i )) end do ! Store coordinates (convert to Bohr if needed) if ( use_angstrom ) then sys_geom % coordinates = to_bohr ( geom % coords ) else sys_geom % coordinates = geom % coords end if end subroutine initialize_fragmented_system subroutine geometry_to_system_fragmented ( mqc_config , sys_geom , use_angstrom , error ) !! Convert geometry to system_geometry_t for fragmented calculation !! Supports both identical and variable-sized fragments type ( mqc_config_t ), intent ( in ) :: mqc_config type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error call initialize_fragmented_system ( mqc_config % nfrag , mqc_config % geometry , mqc_config % fragments , & mqc_config % charge , mqc_config % multiplicity , & mqc_config % allow_overlapping_fragments , use_angstrom , & sys_geom , error ) end subroutine geometry_to_system_fragmented subroutine molecule_to_system_geometry ( mol , sys_geom , use_angstrom , allow_overlapping , error ) !! Convert a molecule_t to system_geometry_t !! Handles both unfragmented (nfrag=0) and fragmented molecules use mqc_config_parser , only : molecule_t type ( molecule_t ), intent ( in ) :: mol type ( system_geometry_t ), intent ( out ) :: sys_geom logical , intent ( in ) :: use_angstrom type ( error_t ), intent ( out ) :: error logical , intent ( in ) :: allow_overlapping ! Check if geometry is loaded if ( mol % geometry % natoms == 0 ) then call error % set ( ERROR_VALIDATION , \"No geometry loaded in molecule\" ) return end if if ( mol % nfrag == 0 ) then ! Unfragmented molecule call geometry_to_system_unfragmented ( mol % geometry , sys_geom , use_angstrom ) sys_geom % charge = mol % charge sys_geom % multiplicity = mol % multiplicity else ! Fragmented molecule call initialize_fragmented_system ( mol % nfrag , mol % geometry , mol % fragments , & mol % charge , mol % multiplicity , & allow_overlapping , use_angstrom , & sys_geom , error ) end if end subroutine molecule_to_system_geometry function get_logger_level ( level_string ) result ( level_int ) !! Convert string log level to integer value !! This function uses the pic_logger constants use pic_logger , only : debug_level , verbose_level , info_level , performance_level , & warning_level , error_level , knowledge_level character ( len =* ), intent ( in ) :: level_string integer :: level_int select case ( trim ( adjustl ( level_string ))) case ( 'debug' , 'Debug' , 'DEBUG' ) level_int = debug_level case ( 'verbose' , 'Verbose' , 'VERBOSE' ) level_int = verbose_level case ( 'info' , 'Info' , 'INFO' ) level_int = info_level case ( 'performance' , 'Performance' , 'PERFORMANCE' ) level_int = performance_level case ( 'warning' , 'Warning' , 'WARNING' ) level_int = warning_level case ( 'error' , 'Error' , 'ERROR' ) level_int = error_level case ( 'knowledge' , 'Knowledge' , 'KNOWLEDGE' ) level_int = knowledge_level case default ! Default to info level if unknown level_int = info_level end select end function get_logger_level subroutine check_fragment_overlap ( fragments , nfrag , error ) !! Check if any atoms appear in multiple fragments !! This is O(nfrag * natoms_per_frag&#94;2) which is acceptable for typical fragment sizes use mqc_config_parser , only : input_fragment_t use pic_io , only : to_char type ( input_fragment_t ), intent ( in ) :: fragments (:) integer , intent ( in ) :: nfrag type ( error_t ), intent ( out ) :: error integer :: i , j , k , l integer :: atom_i , atom_j ! Compare each pair of fragments do i = 1 , nfrag - 1 do j = i + 1 , nfrag ! Compare atoms in fragment i with atoms in fragment j do k = 1 , size ( fragments ( i )% indices ) atom_i = fragments ( i )% indices ( k ) do l = 1 , size ( fragments ( j )% indices ) atom_j = fragments ( j )% indices ( l ) if ( atom_i == atom_j ) then ! Found overlapping atom call error % set ( ERROR_VALIDATION , \"Overlapping fragments detected: fragments \" // to_char ( i ) // \" and \" // & to_char ( j ) // \" both contain atom \" // to_char ( atom_i ) // & \". Set allow_overlapping_fragments = true to allow this.\" ) return end if end do end do end do end do end subroutine check_fragment_overlap end module mqc_config_adapter","tags":"","url":"sourcefile/mqc_config_adapter.f90.html"},{"title":"mqc_io_helpers.f90 – metalquicha","text":"IO helper utilities for file naming and string operations\nProvides utilities for output filename management and string parsing Files dependent on this one sourcefile~~mqc_io_helpers.f90~~AfferentGraph sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! IO helper utilities for file naming and string operations !! Provides utilities for output filename management and string parsing module mqc_io_helpers implicit none private character ( len = 256 ), save :: output_json_filename = \"results.json\" character ( len = 256 ), save :: current_basename = \"\" public :: set_output_json_filename , get_output_json_filename , get_basename public :: set_molecule_suffix public :: get_molecule_name , ends_with contains subroutine set_output_json_filename ( input_filename ) !! Set the JSON output filename based on input filename !! Example: \"water.mqc\" -> \"output_water.json\" character ( len =* ), intent ( in ) :: input_filename integer :: dot_pos , slash_pos character ( len = 256 ) :: basename ! Find last slash (if any) to extract basename slash_pos = index ( input_filename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = input_filename ( slash_pos + 1 :) else basename = input_filename end if ! Find last dot to remove extension dot_pos = index ( basename , '.' , back = . true .) if ( dot_pos > 0 ) then basename = basename ( 1 : dot_pos - 1 ) end if ! Store basename for later use current_basename = trim ( basename ) ! Construct output filename: output_<basename>.json output_json_filename = \"output_\" // trim ( basename ) // \".json\" end subroutine set_output_json_filename subroutine set_molecule_suffix ( suffix ) !! Append a suffix to the output filename (e.g., for multi-molecule mode) !! Example: suffix=\"_mol1\" -> \"output_multi_structure_mol1.json\" character ( len =* ), intent ( in ) :: suffix if ( len_trim ( current_basename ) > 0 ) then output_json_filename = \"output_\" // trim ( current_basename ) // trim ( suffix ) // \".json\" end if end subroutine set_molecule_suffix function get_output_json_filename () result ( filename ) !! Get the current JSON output filename character ( len = 256 ) :: filename filename = trim ( output_json_filename ) end function get_output_json_filename function get_basename () result ( basename ) !! Get the base name without \"output_\" prefix and \".json\" suffix !! Example: \"output_w1.json\" -> \"w1\" character ( len = 256 ) :: basename integer :: start_pos , end_pos ! Remove \"output_\" prefix (7 characters) start_pos = 8 ! Find \".json\" suffix end_pos = index ( output_json_filename , '.json' , back = . true .) - 1 if ( end_pos > start_pos ) then basename = output_json_filename ( start_pos : end_pos ) else basename = \"unknown\" end if end function get_basename function get_molecule_name ( filename ) result ( name ) !! Extract molecule name from filename !! Example: \"output_multi_structure_molecule_1.json\" -> \"molecule_1\" character ( len =* ), intent ( in ) :: filename character ( len = 256 ) :: name integer :: start_pos , end_pos ! Find \"_molecule_\" or similar pattern start_pos = index ( filename , '_molecule_' ) if ( start_pos == 0 ) start_pos = index ( filename , '_mol_' ) if ( start_pos > 0 ) then start_pos = start_pos + 1 ! Skip leading underscore end_pos = index ( filename , '.json' ) - 1 if ( end_pos > start_pos ) then name = filename ( start_pos : end_pos ) else name = \"unknown\" end if else name = \"unknown\" end if end function get_molecule_name logical function ends_with ( str , suffix ) !! Check if string ends with suffix character ( len =* ), intent ( in ) :: str , suffix integer :: str_len , suffix_len str_len = len_trim ( str ) suffix_len = len_trim ( suffix ) if ( suffix_len > str_len ) then ends_with = . false . return end if ends_with = ( str ( str_len - suffix_len + 1 : str_len ) == suffix ) end function ends_with end module mqc_io_helpers","tags":"","url":"sourcefile/mqc_io_helpers.f90.html"},{"title":"mqc_mbe_fragment_distribution_scheme.F90 – metalquicha","text":"Many-Body Expansion (MBE) calculation module This file depends on sourcefile~~mqc_mbe_fragment_distribution_scheme.f90~~EfferentGraph sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_io_helpers.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe_fragment_distribution_scheme.f90~~AfferentGraph sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Many-Body Expansion (MBE) calculation module module mqc_mbe_fragment_distribution_scheme !! Implements hierarchical many-body expansion for fragment-based quantum chemistry !! calculations with MPI parallelization and energy/gradient computation. use pic_types , only : int32 , int64 , dp use pic_timer , only : timer_type use pic_blas_interfaces , only : pic_gemm , pic_dot use pic_mpi_lib , only : comm_t , send , recv , isend , irecv , wait , iprobe , MPI_Status , & request_t , MPI_ANY_SOURCE , MPI_ANY_TAG , abort_comm use pic_logger , only : logger => global_logger , verbose_level , info_level use pic_io , only : to_char use mqc_mbe_io , only : print_fragment_xyz , print_unfragmented_json use omp_lib , only : omp_set_num_threads , omp_get_max_threads use mqc_mbe , only : compute_mbe_energy , compute_mbe_energy_gradient , compute_mbe_energy_gradient_hessian use mqc_mpi_tags , only : TAG_WORKER_REQUEST , TAG_WORKER_FRAGMENT , TAG_WORKER_FINISH , & TAG_WORKER_SCALAR_RESULT , & TAG_NODE_REQUEST , TAG_NODE_FRAGMENT , TAG_NODE_FINISH , & TAG_NODE_SCALAR_RESULT use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , build_fragment_from_indices , & build_fragment_from_atom_list , to_angstrom , check_duplicate_atoms use mqc_method_types , only : method_type_to_string use mqc_calc_types , only : calc_type_to_string , CALC_TYPE_ENERGY , CALC_TYPE_GRADIENT , CALC_TYPE_HESSIAN use mqc_config_parser , only : bond_t ! Method API imports #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif use mqc_result_types , only : calculation_result_t , result_send , result_isend , result_recv , result_irecv implicit none private ! Public interface public :: do_fragment_work , global_coordinator , node_coordinator public :: serial_fragment_processor public :: node_worker , unfragmented_calculation , distributed_unfragmented_hessian contains subroutine do_fragment_work ( fragment_idx , result , method , phys_frag , calc_type ) !! Process a single fragment for quantum chemistry calculation !! !! Performs energy and gradient calculation on a molecular fragment using !! specified quantum chemistry method (GFN-xTB variants). !! Verbosity is controlled by the global logger level. use pic_logger , only : verbose_level integer , intent ( in ) :: fragment_idx !! Fragment index for identification type ( calculation_result_t ), intent ( out ) :: result !! Computation results integer ( int32 ), intent ( in ) :: method !! QC method type ( physical_fragment_t ), intent ( in ), optional :: phys_frag !! Fragment geometry integer ( int32 ), intent ( in ), optional :: calc_type !! Calculation type integer :: current_log_level !! Current logger verbosity level logical :: is_verbose !! Whether verbose output is enabled integer ( int32 ) :: calc_type_local !! Local copy of calc_type with default #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc !! XTB calculator instance #endif ! Set default calc_type if not provided if ( present ( calc_type )) then calc_type_local = calc_type else calc_type_local = CALC_TYPE_ENERGY ! Default to energy-only calculation end if ! Query logger to determine verbosity call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) ! Print fragment geometry if provided and verbose mode is enabled if ( present ( phys_frag )) then if ( is_verbose ) then call print_fragment_xyz ( fragment_idx , phys_frag ) end if #ifndef MQC_WITHOUT_TBLITE ! Setup XTB method xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = is_verbose ! Run the calculation using the method API select case ( calc_type_local ) case ( CALC_TYPE_ENERGY ) call xtb_calc % calc_energy ( phys_frag , result ) case ( CALC_TYPE_GRADIENT ) call xtb_calc % calc_gradient ( phys_frag , result ) case ( CALC_TYPE_HESSIAN ) call xtb_calc % calc_hessian ( phys_frag , result ) case default call logger % error ( \"Unknown calc_type: \" // calc_type_to_string ( calc_type_local )) error stop \"Invalid calc_type in do_fragment_work\" end select #else call logger % error ( \"XTB method requested but tblite support not compiled in\" ) call logger % error ( \"Please rebuild with -DMQC_ENABLE_TBLITE=ON\" ) error stop \"tblite support not available\" #endif else ! For empty fragments, set energy to zero call result % energy % reset () result % has_energy = . true . end if end subroutine do_fragment_work subroutine global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes , sys_geom , calc_type , bonds ) !! Global coordinator for distributing fragments to node coordinators !! will act as a node coordinator for a single node calculation !! Uses int64 for total_fragments to handle large fragment counts that overflow int32. type ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level , num_nodes integer , intent ( in ) :: polymers (:, :), node_leader_ranks (:) type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ), optional :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( timer_type ) :: coord_timer integer ( int64 ) :: current_fragment , results_received integer :: finished_nodes integer :: request_source , dummy_msg , fragment_idx type ( MPI_Status ) :: status , local_status logical :: handling_local_workers logical :: has_pending integer ( int32 ) :: calc_type_local ! For local workers integer :: local_finished_workers , local_dummy ! Storage for results type ( calculation_result_t ), allocatable :: results (:) integer ( int64 ) :: worker_fragment_map ( node_comm % size ()) integer :: worker_source ! MPI request handles for non-blocking operations type ( request_t ) :: req ! Set default calc_type if not provided if ( present ( calc_type )) then calc_type_local = calc_type else calc_type_local = CALC_TYPE_ENERGY end if current_fragment = total_fragments finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( node_comm % size () > 1 ) results_received = 0_int64 ! Allocate storage for results allocate ( results ( total_fragments )) worker_fragment_map = 0 call logger % verbose ( \"Global coordinator starting with \" // to_char ( total_fragments ) // & \" fragments for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers ! This MUST be checked before sending new work to avoid race conditions if ( handling_local_workers ) then ! Keep checking for results until there are none pending do call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state\" end if ! Receive result and store it using the fragment index for this worker call result_irecv ( results ( worker_fragment_map ( worker_source )), node_comm , worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clear the mapping since we've received the result worker_fragment_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit ! Receive fragment index and result from node coordinator ! TODO: serialize the data for better performance call irecv ( world_comm , fragment_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call result_irecv ( results ( fragment_idx ), world_comm , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_fragment >= 1 ) then call send_fragment_to_node ( world_comm , current_fragment , polymers , request_source ) current_fragment = current_fragment - 1 else call isend ( world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < node_comm % size () - 1 ) then call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_fragment >= 1 ) then call send_fragment_to_worker ( node_comm , current_fragment , polymers , & local_status % MPI_SOURCE ) ! Track which fragment was sent to this worker worker_fragment_map ( local_status % MPI_SOURCE ) = current_fragment current_fragment = current_fragment - 1 else call isend ( node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if ! If worker still has pending results, skip the work request ! It will be processed on the next iteration after results are received end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= node_comm % size () - 1 & . and . results_received >= total_fragments ) then handling_local_workers = . false . if ( num_nodes == 1 ) then finished_nodes = finished_nodes + 1 call logger % debug ( \"Manually incremented finished_nodes for self\" ) else finished_nodes = finished_nodes + 1 call logger % verbose ( \"Global coordinator finished local workers\" ) end if end if end do call logger % verbose ( \"Global coordinator finished all fragments\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) block real ( dp ) :: mbe_total_energy real ( dp ), allocatable :: mbe_total_gradient (:, :) real ( dp ), allocatable :: mbe_total_hessian (:, :) ! Compute the many-body expansion call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Use combined function if computing gradients or Hessians (more efficient) if ( calc_type_local == CALC_TYPE_HESSIAN ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for Hessian calculation in global_coordinator\" ) error stop \"Missing sys_geom for Hessian calculation\" end if allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) allocate ( mbe_total_hessian ( 3 * sys_geom % total_atoms , 3 * sys_geom % total_atoms )) call compute_mbe_energy_gradient_hessian ( polymers , total_fragments , max_level , results , sys_geom , & mbe_total_energy , mbe_total_gradient , mbe_total_hessian , bonds ) deallocate ( mbe_total_gradient , mbe_total_hessian ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for gradient calculation in global_coordinator\" ) error stop \"Missing sys_geom for gradient calculation\" end if allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) call compute_mbe_energy_gradient ( polymers , total_fragments , max_level , results , sys_geom , & mbe_total_energy , mbe_total_gradient , bonds ) deallocate ( mbe_total_gradient ) else call compute_mbe_energy ( polymers , total_fragments , max_level , results , mbe_total_energy ) end if call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end block ! Cleanup deallocate ( results ) end subroutine global_coordinator subroutine send_fragment_to_node ( world_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to remote node coordinator !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int32 ) :: fragment_idx_int32 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int32 = int ( fragment_idx , kind = int32 ) call isend ( world_comm , fragment_idx_int32 , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_type , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , fragment_size , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) call isend ( world_comm , fragment_indices , dest_rank , TAG_NODE_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_node subroutine send_fragment_to_worker ( node_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to local worker !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer ( int32 ) :: fragment_type integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 4 ) integer ( int32 ) :: fragment_idx_int32 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! Standard MBE always uses monomer indices (type 0) fragment_type = 0 ! TODO: serialize the data for better performance fragment_idx_int32 = int ( fragment_idx , kind = int32 ) call isend ( node_comm , fragment_idx_int32 , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_type , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , fragment_size , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) call isend ( node_comm , fragment_indices , dest_rank , TAG_WORKER_FRAGMENT , req ( 4 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) call wait ( req ( 4 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_worker subroutine node_coordinator ( world_comm , node_comm , calc_type ) !! Node coordinator for distributing fragments to local workers !! Handles work requests and result collection from local workers class ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int32 ), intent ( in ), optional :: calc_type integer ( int32 ) :: fragment_idx , fragment_size , fragment_type , dummy_msg integer ( int32 ) :: finished_workers integer ( int32 ), allocatable :: fragment_indices (:) type ( MPI_Status ) :: status , global_status logical :: local_message_pending , more_fragments , has_result integer ( int32 ) :: local_dummy ! For tracking worker-fragment mapping and collecting results integer ( int32 ) :: worker_fragment_map ( node_comm % size ()) integer ( int32 ) :: worker_source type ( calculation_result_t ) :: worker_result ! MPI request handles for non-blocking operations type ( request_t ) :: req finished_workers = 0 more_fragments = . true . dummy_msg = 0 worker_fragment_map = 0 do while ( finished_workers < node_comm % size () - 1 ) ! PRIORITY 1: Check for incoming results from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_result , status ) if ( has_result ) then worker_source = status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Node coordinator received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state in node coordinator\" end if ! Receive result from worker call result_irecv ( worker_result , node_comm , worker_source , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Forward results to global coordinator with fragment index call isend ( world_comm , worker_fragment_map ( worker_source ), 0 , TAG_NODE_SCALAR_RESULT , req ) ! fragment_idx call wait ( req ) call result_isend ( worker_result , world_comm , 0 , TAG_NODE_SCALAR_RESULT , req ) ! result call wait ( req ) ! Clear the mapping worker_fragment_map ( worker_source ) = 0 end if ! PRIORITY 2: Check for work requests from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , local_message_pending , status ) if ( local_message_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( more_fragments ) then call isend ( world_comm , dummy_msg , 0 , TAG_NODE_REQUEST , req ) call wait ( req ) call irecv ( world_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , global_status ) if ( global_status % MPI_TAG == TAG_NODE_FRAGMENT ) then ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( world_comm , fragment_type , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) call irecv ( world_comm , fragment_size , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( world_comm , fragment_indices , 0 , TAG_NODE_FRAGMENT , global_status ) ! Forward to worker call isend ( node_comm , fragment_idx , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_type , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_size , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_indices , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Track which fragment was sent to this worker worker_fragment_map ( status % MPI_SOURCE ) = fragment_idx deallocate ( fragment_indices ) else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 more_fragments = . false . end if else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end if end do end subroutine node_coordinator subroutine node_worker ( world_comm , node_comm , sys_geom , method , calc_type , bonds ) !! Node worker for processing fragments assigned by node coordinator class ( comm_t ), intent ( in ) :: world_comm , node_comm type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ), optional :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int32 ) :: fragment_idx , fragment_size , dummy_msg integer ( int32 ) :: fragment_type !! 0 = monomer (indices), 1 = intersection (atom list) integer ( int32 ), allocatable :: fragment_indices (:) type ( calculation_result_t ) :: result type ( MPI_Status ) :: status type ( physical_fragment_t ) :: phys_frag ! MPI request handles for non-blocking operations type ( request_t ) :: req dummy_msg = 0 do call isend ( node_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( node_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) select case ( status % MPI_TAG ) case ( TAG_WORKER_FRAGMENT ) ! Receive fragment type (0 = monomer indices, 1 = intersection atom list) call irecv ( node_comm , fragment_type , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call irecv ( node_comm , fragment_size , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( node_comm , fragment_indices , 0 , TAG_WORKER_FRAGMENT , status ) ! Build physical fragment based on type if ( present ( sys_geom )) then if ( fragment_type == 0 ) then ! Monomer: fragment_indices are monomer indices call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , bonds ) else ! Intersection: fragment_indices are atom indices call build_fragment_from_atom_list ( sys_geom , fragment_indices , fragment_size , phys_frag , bonds ) end if ! Process the chemistry fragment with physical geometry call do_fragment_work ( fragment_idx , result , method , phys_frag , calc_type ) call phys_frag % destroy () else ! Process without physical geometry (old behavior) call do_fragment_work ( fragment_idx , result , method , calc_type = calc_type ) end if ! Send result back to coordinator call result_isend ( result , node_comm , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clean up result call result % destroy () deallocate ( fragment_indices ) case ( TAG_WORKER_FINISH ) exit case default ! Unexpected MPI tag - this should not happen in normal operation call logger % error ( \"Worker received unexpected MPI tag: \" // to_char ( status % MPI_TAG )) call logger % error ( \"Expected TAG_WORKER_FRAGMENT or TAG_WORKER_FINISH\" ) error stop \"MPI protocol error in node_worker\" end select end do end subroutine node_worker subroutine unfragmented_calculation ( sys_geom , method , calc_type , bonds ) !! Run unfragmented calculation on the entire system (nlevel=0) !! This is a simple single-process calculation without MPI distribution type ( system_geometry_t ), intent ( in ), optional :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ), optional :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) type ( calculation_result_t ) :: result integer :: total_atoms type ( physical_fragment_t ) :: full_system integer :: i if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for unfragmented calculation\" ) error stop \"Missing geometry in unfragmented_calculation\" end if total_atoms = sys_geom % total_atoms call logger % info ( \"============================================\" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( total_atoms )) call logger % info ( \"============================================\" ) ! Build the full system as a single fragment ! For overlapping fragments, we use the full system directly (not concatenating fragments) full_system % n_atoms = total_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( total_atoms )) allocate ( full_system % coordinates ( 3 , total_atoms )) ! Copy all atoms from system geometry full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates ! Set charge and multiplicity from system full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () ! Validate geometry (check for spatially overlapping atoms) call check_duplicate_atoms ( full_system ) ! Process the full system call do_fragment_work ( 0_int32 , result , method , phys_frag = full_system , calc_type = calc_type ) call logger % info ( \"============================================\" ) call logger % info ( \"Unfragmented calculation completed\" ) block character ( len = 256 ) :: result_line integer :: current_log_level , iatom , i , j real ( dp ) :: hess_norm write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) ! Print full gradient if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 100 ) then call logger % info ( \" \" ) call logger % info ( \"Gradient (Hartree/Bohr):\" ) do iatom = 1 , total_atoms write ( result_line , '(a,i5,a,3f20.12)' ) \"  Atom \" , iatom , \": \" , & result % gradient ( 1 , iatom ), result % gradient ( 2 , iatom ), result % gradient ( 3 , iatom ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if if ( result % has_hessian ) then ! Compute Frobenius norm of Hessian hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) ! Print full Hessian if verbose and system is small call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level . and . total_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * total_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * total_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if end block call logger % info ( \"============================================\" ) call print_unfragmented_json ( result ) call result % destroy () end subroutine unfragmented_calculation subroutine serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method , calc_type , bonds ) !! Process all fragments serially in single-rank mode !! This is used when running with only 1 MPI rank integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: polymers (:, :), max_level type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method integer ( int32 ), intent ( in ), optional :: calc_type type ( bond_t ), intent ( in ), optional :: bonds (:) integer ( int64 ) :: frag_idx integer :: fragment_size , current_log_level , iatom integer , allocatable :: fragment_indices (:) type ( calculation_result_t ), allocatable :: results (:) real ( dp ) :: mbe_total_energy real ( dp ), allocatable :: mbe_total_gradient (:, :) real ( dp ), allocatable :: mbe_total_hessian (:, :) type ( physical_fragment_t ) :: phys_frag type ( timer_type ) :: coord_timer integer ( int32 ) :: calc_type_local ! Set default calc_type if not provided if ( present ( calc_type )) then calc_type_local = calc_type else calc_type_local = CALC_TYPE_ENERGY end if call logger % info ( \"Processing \" // to_char ( total_fragments ) // \" fragments serially...\" ) call logger % info ( \"  Calculation type: \" // calc_type_to_string ( calc_type_local )) allocate ( results ( total_fragments )) call omp_set_num_threads ( 1 ) call coord_timer % start () do frag_idx = 1_int64 , total_fragments fragment_size = count ( polymers ( frag_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( frag_idx , 1 : fragment_size ) call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag , bonds ) call do_fragment_work ( int ( frag_idx ), results ( frag_idx ), method , phys_frag , calc_type = calc_type_local ) ! Debug output for gradients if ( calc_type_local == CALC_TYPE_GRADIENT . and . results ( frag_idx )% has_gradient ) then call logger % configuration ( level = current_log_level ) if ( current_log_level >= verbose_level ) then block character ( len = 512 ) :: debug_line integer :: iatom_local write ( debug_line , '(a,i0,a,*(i0,1x))' ) \"Fragment \" , frag_idx , \" monomers: \" , fragment_indices call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Energy: \" , results ( frag_idx )% energy % total () call logger % verbose ( trim ( debug_line )) write ( debug_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( results ( frag_idx )% gradient ** 2 )) call logger % verbose ( trim ( debug_line )) if ( size ( results ( frag_idx )% gradient , 2 ) <= 20 ) then call logger % verbose ( \"  Fragment gradient:\" ) do iatom_local = 1 , size ( results ( frag_idx )% gradient , 2 ) write ( debug_line , '(a,i3,a,3f20.12)' ) \"    Atom \" , iatom_local , \": \" , & results ( frag_idx )% gradient ( 1 , iatom_local ), & results ( frag_idx )% gradient ( 2 , iatom_local ), & results ( frag_idx )% gradient ( 3 , iatom_local ) call logger % verbose ( trim ( debug_line )) end do end if end block end if end if call phys_frag % destroy () deallocate ( fragment_indices ) if ( mod ( frag_idx , max ( 1_int64 , total_fragments / 10 )) == 0 . or . frag_idx == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( frag_idx ) // \"/\" // to_char ( total_fragments ) // & \" fragments [\" // to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call omp_set_num_threads ( omp_get_max_threads ()) call logger % info ( \"All fragments processed\" ) call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () ! Use combined function if computing gradients or Hessians (more efficient) if ( calc_type_local == CALC_TYPE_HESSIAN ) then allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) allocate ( mbe_total_hessian ( 3 * sys_geom % total_atoms , 3 * sys_geom % total_atoms )) call compute_mbe_energy_gradient_hessian ( polymers , total_fragments , max_level , results , sys_geom , & mbe_total_energy , mbe_total_gradient , mbe_total_hessian , bonds ) deallocate ( mbe_total_gradient , mbe_total_hessian ) else if ( calc_type_local == CALC_TYPE_GRADIENT ) then allocate ( mbe_total_gradient ( 3 , sys_geom % total_atoms )) call compute_mbe_energy_gradient ( polymers , total_fragments , max_level , results , sys_geom , & mbe_total_energy , mbe_total_gradient , bonds ) deallocate ( mbe_total_gradient ) else call compute_mbe_energy ( polymers , total_fragments , max_level , results , mbe_total_energy ) end if call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) deallocate ( results ) end subroutine serial_fragment_processor subroutine distributed_unfragmented_hessian ( world_comm , sys_geom , method ) !! Compute Hessian for unfragmented system using MPI distribution !! !! Uses a dynamic work queue approach: workers request displacement indices !! from rank 0, compute gradients, and send results back. This provides !! better load balancing than static work distribution. use mqc_finite_differences , only : generate_perturbed_geometries , displaced_geometry_t , & finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT , & copy_and_displace_geometry #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method integer :: my_rank , n_ranks my_rank = world_comm % rank () n_ranks = world_comm % size () if ( my_rank == 0 ) then ! Rank 0 is the coordinator call hessian_coordinator ( world_comm , sys_geom , method ) else ! Other ranks are workers call hessian_worker ( world_comm , sys_geom , method ) end if ! Synchronize all ranks before returning call world_comm % barrier () end subroutine distributed_unfragmented_hessian subroutine hessian_coordinator ( world_comm , sys_geom , method ) !! Coordinator for distributed Hessian calculation !! Distributes displacement work and collects gradient results use mqc_finite_differences , only : finite_diff_hessian_from_gradients , DEFAULT_DISPLACEMENT #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method type ( physical_fragment_t ) :: full_system type ( timer_type ) :: coord_timer real ( dp ), allocatable :: forward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: backward_gradients (:, :, :) ! (n_displacements, 3, n_atoms) real ( dp ), allocatable :: hessian (:, :) real ( dp ), allocatable :: grad_buffer (:, :) type ( calculation_result_t ) :: result real ( dp ) :: displacement integer :: n_atoms , n_displacements , n_ranks integer :: current_disp , finished_workers , dummy_msg , worker_rank integer :: disp_idx , gradient_type ! gradient_type: 1=forward, 2=backward type ( MPI_Status ) :: status logical :: has_pending type ( request_t ) :: req integer :: current_log_level logical :: is_verbose character ( len = 256 ) :: result_line real ( dp ) :: hess_norm integer :: i , j #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc #endif n_ranks = world_comm % size () n_atoms = sys_geom % total_atoms n_displacements = 3 * n_atoms displacement = DEFAULT_DISPLACEMENT call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) call logger % info ( \"============================================\" ) call logger % info ( \"Distributed unfragmented Hessian calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( n_atoms )) call logger % info ( \"  Gradient calculations needed: \" // to_char ( 2 * n_displacements )) call logger % info ( \"  MPI ranks: \" // to_char ( n_ranks )) call logger % info ( \"  Work distribution: Dynamic queue\" ) call logger % info ( \"============================================\" ) ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge call full_system % compute_nelec () ! Allocate storage for all gradients allocate ( forward_gradients ( n_displacements , 3 , n_atoms )) allocate ( backward_gradients ( n_displacements , 3 , n_atoms )) allocate ( grad_buffer ( 3 , n_atoms )) current_disp = 1 finished_workers = 0 ! Process work requests and collect results call coord_timer % start () do while ( finished_workers < n_ranks - 1 ) ! Check for incoming gradient results call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE ! Receive: displacement index, gradient type (1=forward, 2=backward), gradient data call irecv ( world_comm , disp_idx , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call irecv ( world_comm , gradient_type , worker_rank , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call recv ( world_comm , grad_buffer , worker_rank , TAG_WORKER_SCALAR_RESULT , status ) ! Store gradient in appropriate array if ( gradient_type == 1 ) then forward_gradients ( disp_idx , :, :) = grad_buffer else backward_gradients ( disp_idx , :, :) = grad_buffer end if ! Log progress every 10% or at completion (count both forward and backward) if ( gradient_type == 2 ) then ! Only log after backward gradient to count complete displacements if ( mod ( disp_idx , max ( 1 , n_displacements / 10 )) == 0 . or . disp_idx == n_displacements ) then call logger % info ( \"  Completed \" // to_char ( disp_idx ) // \"/\" // to_char ( n_displacements ) // & \" displacement pairs in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end if end if end if ! Check for work requests from workers call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , status ) if ( has_pending ) then worker_rank = status % MPI_SOURCE call irecv ( world_comm , dummy_msg , worker_rank , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_disp <= n_displacements ) then ! Send next displacement index to worker call isend ( world_comm , current_disp , worker_rank , TAG_WORKER_FRAGMENT , req ) call wait ( req ) current_disp = current_disp + 1 else ! No more work - tell worker to finish call isend ( world_comm , - 1 , worker_rank , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end do deallocate ( grad_buffer ) call coord_timer % stop () call logger % info ( \"All gradient calculations completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Assemble Hessian from finite differences call logger % info ( \"  Assembling Hessian matrix...\" ) call coord_timer % start () call finite_diff_hessian_from_gradients ( full_system , forward_gradients , backward_gradients , & displacement , hessian ) call coord_timer % stop () call logger % info ( \"Hessian assembly completed in \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) ! Compute energy and gradient at reference geometry call logger % info ( \"  Computing reference energy and gradient...\" ) #ifndef MQC_WITHOUT_TBLITE xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = is_verbose call xtb_calc % calc_gradient ( full_system , result ) #endif ! Store Hessian in result if ( allocated ( result % hessian )) deallocate ( result % hessian ) allocate ( result % hessian ( size ( hessian , 1 ), size ( hessian , 2 ))) result % hessian = hessian result % has_hessian = . true . ! Print results call logger % info ( \"============================================\" ) call logger % info ( \"Distributed Hessian calculation completed\" ) write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , result % energy % total () call logger % info ( trim ( result_line )) if ( result % has_gradient ) then write ( result_line , '(a,f25.15)' ) \"  Gradient norm: \" , sqrt ( sum ( result % gradient ** 2 )) call logger % info ( trim ( result_line )) end if if ( result % has_hessian ) then hess_norm = sqrt ( sum ( result % hessian ** 2 )) write ( result_line , '(a,f25.15)' ) \"  Hessian Frobenius norm: \" , hess_norm call logger % info ( trim ( result_line )) if ( is_verbose . and . n_atoms < 20 ) then call logger % info ( \" \" ) call logger % info ( \"Hessian matrix (Hartree/Bohr&#94;2):\" ) do i = 1 , 3 * n_atoms write ( result_line , '(a,i5,a,999f15.8)' ) \"  Row \" , i , \": \" , ( result % hessian ( i , j ), j = 1 , 3 * n_atoms ) call logger % info ( trim ( result_line )) end do call logger % info ( \" \" ) end if end if call logger % info ( \"============================================\" ) ! Output JSON call print_unfragmented_json ( result ) ! Cleanup call result % destroy () deallocate ( forward_gradients , backward_gradients ) if ( allocated ( hessian )) deallocate ( hessian ) end subroutine hessian_coordinator subroutine hessian_worker ( world_comm , sys_geom , method ) !! Worker for distributed Hessian calculation !! Requests displacement indices, computes gradients, and sends results back use mqc_finite_differences , only : DEFAULT_DISPLACEMENT , copy_and_displace_geometry #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif type ( comm_t ), intent ( in ) :: world_comm type ( system_geometry_t ), intent ( in ) :: sys_geom integer ( int32 ), intent ( in ) :: method type ( physical_fragment_t ) :: full_system , displaced_geom type ( calculation_result_t ) :: grad_result real ( dp ) :: displacement integer :: n_atoms , disp_idx , atom_idx , coord , gradient_type , dummy_msg type ( MPI_Status ) :: status type ( request_t ) :: req #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc #endif n_atoms = sys_geom % total_atoms displacement = DEFAULT_DISPLACEMENT ! Build full system geometry full_system % n_atoms = n_atoms full_system % n_caps = 0 allocate ( full_system % element_numbers ( n_atoms )) allocate ( full_system % coordinates ( 3 , n_atoms )) full_system % element_numbers = sys_geom % element_numbers full_system % coordinates = sys_geom % coordinates full_system % charge = sys_geom % charge full_system % multiplicity = sys_geom % multiplicity call full_system % compute_nelec () #ifndef MQC_WITHOUT_TBLITE ! Setup XTB method xtb_calc % variant = method_type_to_string ( method ) xtb_calc % verbose = . false . dummy_msg = 0 do ! Request work from coordinator call isend ( world_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( world_comm , disp_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) if ( status % MPI_TAG == TAG_WORKER_FINISH ) exit ! Compute displacement index to atom and coordinate atom_idx = ( disp_idx - 1 ) / 3 + 1 coord = mod ( disp_idx - 1 , 3 ) + 1 ! Compute FORWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , displacement , displaced_geom ) call xtb_calc % calc_gradient ( displaced_geom , grad_result ) if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (1=forward), gradient data gradient_type = 1 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call grad_result % destroy () call displaced_geom % destroy () ! Compute BACKWARD gradient call copy_and_displace_geometry ( full_system , atom_idx , coord , - displacement , displaced_geom ) call xtb_calc % calc_gradient ( displaced_geom , grad_result ) if (. not . grad_result % has_gradient ) then call logger % error ( \"Worker failed gradient for displacement \" // to_char ( disp_idx )) call abort_comm ( world_comm , 1 ) end if ! Send: displacement index, gradient type (2=backward), gradient data gradient_type = 2 call isend ( world_comm , disp_idx , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call isend ( world_comm , gradient_type , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) call send ( world_comm , grad_result % gradient , 0 , TAG_WORKER_SCALAR_RESULT ) call grad_result % destroy () call displaced_geom % destroy () end do #else call logger % error ( \"XTB method requested but tblite support not compiled in\" ) call abort_comm ( world_comm , 1 ) #endif end subroutine hessian_worker end module mqc_mbe_fragment_distribution_scheme","tags":"","url":"sourcefile/mqc_mbe_fragment_distribution_scheme.f90.html"},{"title":"mqc_basis_reader.f90 – metalquicha","text":"This file contains basis set reader routines for basis sets This file depends on sourcefile~~mqc_basis_reader.f90~~EfferentGraph sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_file_reader.f90 mqc_basis_file_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_basis_file_reader.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_error.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This file contains basis set reader routines for basis sets module mqc_basis_reader !! Gaussian basis set parser and molecular basis construction !! !! Provides utilities for parsing Gaussian-type orbital basis sets !! from text files and building molecular basis sets for quantum calculations. use mqc_cgto , only : cgto_type , atomic_basis_type , molecular_basis_type use mqc_basis_file_reader , only : strings_equal use mqc_error , only : error_t , ERROR_PARSE use pic_types , only : dp implicit none private public :: classify_line !! Determine basis file line type public :: parse_element_basis !! Parse basis for single element public :: build_molecular_basis !! Build complete molecular basis public :: ang_mom_char_to_int !! Convert angular momentum character to integer public :: ang_mom_int_to_char !! Convert angular momentum integer to character ! Basis file line classification constants integer , parameter , public :: LINE_UNKNOWN = 0 !! Unrecognized line type integer , parameter , public :: LINE_ATOM = 1 !! Element specification line integer , parameter , public :: LINE_SHELL = 2 !! Shell definition line integer , parameter , public :: LINE_FUNCTION = 3 !! Basis function coefficient line contains pure function ang_mom_char_to_int ( ang_mom_char ) result ( ang_mom ) !! Convert angular momentum character to integer !! !! Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6 !! Special case: L=-1 (combined S+P shell, requires splitting) character ( len = 1 ), intent ( in ) :: ang_mom_char !! Angular momentum symbol integer :: ang_mom !! Corresponding integer value select case ( ang_mom_char ) case ( 'S' ) ang_mom = 0 case ( 'P' ) ang_mom = 1 case ( 'D' ) ang_mom = 2 case ( 'F' ) ang_mom = 3 case ( 'G' ) ang_mom = 4 case ( 'H' ) ang_mom = 5 case ( 'I' ) ang_mom = 6 case ( 'L' ) ang_mom = - 1 ! Special case: L shells are split into S+P case default ang_mom = - 1 end select end function ang_mom_char_to_int pure function ang_mom_int_to_char ( ang_mom ) result ( ang_mom_char ) !! Convert angular momentum integer to character !! !! Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I !! Returns '?' for invalid input values. integer , intent ( in ) :: ang_mom !! Angular momentum quantum number character ( len = 1 ) :: ang_mom_char !! Corresponding symbol character select case ( ang_mom ) case ( 0 ) ang_mom_char = 'S' case ( 1 ) ang_mom_char = 'P' case ( 2 ) ang_mom_char = 'D' case ( 3 ) ang_mom_char = 'F' case ( 4 ) ang_mom_char = 'G' case ( 5 ) ang_mom_char = 'H' case ( 6 ) ang_mom_char = 'I' case default ang_mom_char = '?' end select end function ang_mom_int_to_char pure function classify_line ( line ) result ( line_type ) !! Classify a line from a gamess formatted basis set file character ( len =* ), intent ( in ) :: line integer :: line_type character ( len = :), allocatable :: line_trim line_trim = trim ( adjustl ( line )) if ( is_blank_or_control ( line_trim )) then line_type = LINE_UNKNOWN else if ( is_function_line ( line_trim )) then line_type = LINE_FUNCTION else if ( is_shell_header ( line_trim )) then line_type = LINE_SHELL else line_type = LINE_ATOM end if end function classify_line pure function is_blank_or_control ( line ) result ( res ) !! Check if a line is blank or a control line (starts with '$') character ( len =* ), intent ( in ) :: line logical :: res integer :: trimmed_len trimmed_len = len_trim ( line ) if ( trimmed_len == 0 ) then res = . true . else res = ( line ( 1 : 1 ) == '$' ) end if end function is_blank_or_control pure function is_function_line ( line ) result ( res ) !! Check if a line is a function coefficient line (starts with a number) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char if ( len_trim ( line ) == 0 ) then res = . false . return end if first_char = line ( 1 : 1 ) res = ( first_char >= '0' . and . first_char <= '9' ) end function is_function_line pure function is_shell_header ( line ) result ( res ) !! Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char integer :: ios , dummy res = . false . if ( len_trim ( line ) == 0 ) return first_char = line ( 1 : 1 ) if (. not . any ( first_char == [ 'S' , 'P' , 'D' , 'F' , 'G' , 'H' , 'I' , 'L' ])) return read ( line ( 2 :), * , iostat = ios ) dummy res = ( ios == 0 ) end function is_shell_header pure subroutine parse_element_basis ( basis_string , element_name , atom_basis , error ) !! Parse basis set for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( out ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: nshells ! Pass 1: Find the element and count its shells call count_shells_for_element ( basis_string , element_name , nshells , error ) if ( error % has_error ()) return if ( nshells == 0 ) then call error % set ( ERROR_PARSE , \"Element \" // trim ( element_name ) // \" not found in basis file\" ) return end if ! ! Allocate shells atom_basis % element = trim ( element_name ) call atom_basis % allocate_shells ( nshells ) ! ! Pass 2: Parse and fill shell data call fill_element_basis ( basis_string , element_name , atom_basis , error ) end subroutine parse_element_basis pure subroutine count_shells_for_element ( basis_string , element_name , nshells , error ) !! Count the number of shells for a specific element in a GAMESS formatted basis string, character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name integer , intent ( out ) :: nshells type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_target_element , found_element character ( len = 1 ) :: ang_mom nshells = 0 in_target_element = . false . found_element = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) case ( LINE_ATOM ) ! Check if this is our target element if ( strings_equal ( line , element_name )) then in_target_element = . true . found_element = . true . else ! Different element - stop counting if we were in target if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Extract angular momentum line = adjustl ( line ) ang_mom = line ( 1 : 1 ) ! L shells become 2 shells (S + P) if ( ang_mom == 'L' ) then nshells = nshells + 2 else nshells = nshells + 1 end if end if case ( LINE_UNKNOWN ) ! Skip blank lines and comments continue case default ! Skip any other line types (e.g., LINE_FUNCTION) continue end select line_start = line_end end do ! Check if we found the element at all if (. not . found_element ) then call error % set ( ERROR_PARSE , \"Element not found in basis string: \" // trim ( element_name )) end if end subroutine count_shells_for_element pure subroutine get_next_line ( string , line_start , line , line_end ) !! Extract the next line from a string starting at line_start character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: line_start character ( len =* ), intent ( out ) :: line integer , intent ( out ) :: line_end integer :: newline_pos if ( line_start > len ( string )) then line = '' line_end = 0 return end if newline_pos = index ( string ( line_start :), new_line ( 'a' )) if ( newline_pos == 0 ) then ! Last line (no newline at end) line = string ( line_start :) line_end = len ( string ) + 1 else line = string ( line_start : line_start + newline_pos - 2 ) line_end = line_start + newline_pos end if end subroutine get_next_line pure subroutine parse_shell_header ( line , ang_mom , nfunc , stat ) !! Parse shell header line (e.g., \"S 2\" or \"L 3\") character ( len =* ), intent ( in ) :: line character ( len = 1 ), intent ( out ) :: ang_mom integer , intent ( out ) :: nfunc integer , intent ( out ) :: stat character ( len = 256 ) :: line_trim line_trim = adjustl ( line ) ang_mom = line_trim ( 1 : 1 ) ! Read the number of functions read ( line_trim ( 2 :), * , iostat = stat ) nfunc end subroutine parse_shell_header pure subroutine parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) !! Parse function line (e.g., \"1 1.0 2.0\" or \"1 1.0 2.0 3.0\" for L shells) character ( len =* ), intent ( in ) :: line integer , intent ( out ) :: func_num real ( dp ), intent ( out ) :: exponent real ( dp ), intent ( out ) :: coeff_s real ( dp ), intent ( out ), optional :: coeff_p logical , intent ( out ) :: has_p integer , intent ( out ) :: stat real ( dp ) :: temp_p has_p = . false . ! Try to read 4 values (func_num, exponent, coeff_s, coeff_p) read ( line , * , iostat = stat ) func_num , exponent , coeff_s , temp_p if ( stat == 0 ) then ! Successfully read 4 values - this is an L shell has_p = . true . if ( present ( coeff_p )) coeff_p = temp_p else ! Try reading just 3 values (func_num, exponent, coeff_s) read ( line , * , iostat = stat ) func_num , exponent , coeff_s end if end subroutine parse_function_line pure subroutine fill_element_basis ( basis_string , element_name , atom_basis , error ) !! Fill in the shell data for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( inout ) :: atom_basis type ( error_t ), intent ( out ) :: error integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_data_block , in_target_element character ( len = 1 ) :: ang_mom integer :: nfunc , func_num , ishell , ifunc real ( dp ) :: exponent , coeff_s , coeff_p logical :: has_p ! L shell handling: we split into two shells, need to track both logical :: reading_l_shell integer :: l_shell_s_idx , l_shell_p_idx integer :: stat in_data_block = . false . in_target_element = . false . ishell = 0 reading_l_shell = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) ! case (LINE_UNKNOWN) !   if (index(line, '$DATA') > 0) then !     in_data_block = .true. !   else if (index(line, '$END') > 0) then !     exit !   end if case ( LINE_ATOM ) if ( strings_equal ( line , element_name )) then in_target_element = . true . else if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Parse shell header call parse_shell_header ( line , ang_mom , nfunc , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse shell header: \" // trim ( line )) return end if if ( ang_mom == 'L' ) then ! L shell: create two shells (S and P) reading_l_shell = . true . ishell = ishell + 1 l_shell_s_idx = ishell atom_basis % shells ( ishell )% ang_mom = 0 ! S call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ishell = ishell + 1 l_shell_p_idx = ishell atom_basis % shells ( ishell )% ang_mom = 1 ! P call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 ! Reset function counter else ! Regular shell reading_l_shell = . false . ishell = ishell + 1 ! Set angular momentum (S=0, P=1, D=2, F=3, G=4, H=5, I=6) atom_basis % shells ( ishell )% ang_mom = ang_mom_char_to_int ( ang_mom ) call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 end if end if case ( LINE_FUNCTION ) if ( in_target_element ) then call parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) if ( stat /= 0 ) then call error % set ( ERROR_PARSE , \"Failed to parse function line: \" // trim ( line )) return end if ifunc = ifunc + 1 if ( reading_l_shell ) then if (. not . has_p ) then call error % set ( ERROR_PARSE , \"L shell requires both S and P coefficients\" ) return end if ! Store in both S and P shells atom_basis % shells ( l_shell_s_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_s_idx )% coefficients ( ifunc ) = coeff_s atom_basis % shells ( l_shell_p_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_p_idx )% coefficients ( ifunc ) = coeff_p else ! Store in current shell atom_basis % shells ( ishell )% exponents ( ifunc ) = exponent atom_basis % shells ( ishell )% coefficients ( ifunc ) = coeff_s end if end if case default ! Skip unknown line types (e.g., LINE_UNKNOWN, blank lines, comments) continue end select line_start = line_end end do end subroutine fill_element_basis pure subroutine find_unique_strings ( input_array , unique_array , nunique ) !! Find unique strings in an array !! Returns array of unique strings and count character ( len =* ), intent ( in ) :: input_array (:) character ( len = :), allocatable , intent ( out ) :: unique_array (:) integer , intent ( out ) :: nunique integer :: i , j , n logical :: is_unique character ( len = len ( input_array )), allocatable :: temp_unique (:) n = size ( input_array ) allocate ( temp_unique ( n )) ! Max possible size nunique = 0 do i = 1 , n is_unique = . true . ! Check if we've already seen this string do j = 1 , nunique if ( strings_equal ( input_array ( i ), temp_unique ( j ))) then is_unique = . false . exit end if end do if ( is_unique ) then nunique = nunique + 1 temp_unique ( nunique ) = input_array ( i ) end if end do ! Allocate output array with exact size and copy allocate ( character ( len = len ( input_array )) :: unique_array ( nunique )) unique_array = temp_unique ( 1 : nunique ) end subroutine find_unique_strings pure subroutine copy_atomic_basis ( source , dest ) !! Deep copy of atomic basis data from source to dest type ( atomic_basis_type ), intent ( in ) :: source type ( atomic_basis_type ), intent ( out ) :: dest integer :: ishell dest % element = source % element call dest % allocate_shells ( source % nshells ) do ishell = 1 , source % nshells dest % shells ( ishell )% ang_mom = source % shells ( ishell )% ang_mom call dest % shells ( ishell )% allocate_arrays ( source % shells ( ishell )% nfunc ) dest % shells ( ishell )% exponents = source % shells ( ishell )% exponents dest % shells ( ishell )% coefficients = source % shells ( ishell )% coefficients end do end subroutine copy_atomic_basis subroutine build_molecular_basis ( basis_string , element_names , mol_basis , error ) !! Build molecular basis from geometry and basis file !! Only parses unique elements, then copies basis data to atoms character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_names (:) !! Element for each atom in geometry order type ( molecular_basis_type ), intent ( out ) :: mol_basis type ( error_t ), intent ( out ) :: error integer :: iatom , natoms , iunique , nunique character ( len = :), allocatable :: unique_elements (:) type ( atomic_basis_type ), allocatable :: unique_bases (:) integer :: match_idx match_idx = 0 natoms = size ( element_names ) ! Find unique elements call find_unique_strings ( element_names , unique_elements , nunique ) print * , \"Found \" , nunique , \" unique elements out of \" , natoms , \" atoms\" ! Allocate for unique bases allocate ( unique_bases ( nunique )) ! Parse basis for each unique element do iunique = 1 , nunique print * , \"Parsing basis for: \" , trim ( unique_elements ( iunique )) call parse_element_basis ( basis_string , unique_elements ( iunique ), & unique_bases ( iunique ), error ) if ( error % has_error ()) then ! Prepend context to error message call error % set ( ERROR_PARSE , \"Failed to parse basis for element \" // & trim ( unique_elements ( iunique )) // \": \" // error % get_message ()) return end if end do ! Allocate molecular basis and assign to each atom call mol_basis % allocate_elements ( natoms ) do iatom = 1 , natoms ! Find which unique element this atom corresponds to do iunique = 1 , nunique if ( strings_equal ( element_names ( iatom ), unique_elements ( iunique ))) then match_idx = iunique exit end if end do ! Copy the basis data call copy_atomic_basis ( unique_bases ( match_idx ), mol_basis % elements ( iatom )) end do ! Clean up do iunique = 1 , nunique call unique_bases ( iunique )% destroy () end do end subroutine build_molecular_basis end module mqc_basis_reader","tags":"","url":"sourcefile/mqc_basis_reader.f90.html"},{"title":"mqc_frag_utils.f90 – metalquicha","text":"Fragment generation and manipulation utilities This file depends on sourcefile~~mqc_frag_utils.f90~~EfferentGraph sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_combinatorics.f90 mqc_combinatorics.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_combinatorics.f90 sourcefile~mqc_fragment_lookup.f90 mqc_fragment_lookup.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_fragment_lookup.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_frag_utils.f90~~AfferentGraph sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Fragment generation and manipulation utilities module mqc_frag_utils !! Provides combinatorial functions and algorithms for generating molecular !! fragments, managing fragment lists, and performing many-body expansion calculations. !! !! This module re-exports functionality from specialized modules: !! - mqc_combinatorics: Pure combinatorial mathematics !! - mqc_fragment_lookup: Hash-based fragment index lookup !! - mqc_gmbe_utils: GMBE intersection and PIE enumeration use mqc_combinatorics , only : & binomial , & get_nfrags , & create_monomer_list , & generate_fragment_list , & combine , & get_next_combination , & next_combination_init , & next_combination , & print_combos use mqc_fragment_lookup , only : fragment_lookup_t use mqc_gmbe_utils , only : & find_fragment_intersection , & generate_intersections , & compute_polymer_atoms , & generate_polymer_intersections , & gmbe_enumerate_pie_terms implicit none private ! Re-export from mqc_combinatorics public :: binomial public :: create_monomer_list public :: generate_fragment_list public :: combine public :: get_nfrags public :: get_next_combination public :: next_combination_init public :: next_combination public :: print_combos ! Re-export from mqc_fragment_lookup public :: fragment_lookup_t ! Re-export from mqc_gmbe_utils public :: find_fragment_intersection public :: generate_intersections public :: compute_polymer_atoms public :: generate_polymer_intersections public :: gmbe_enumerate_pie_terms end module mqc_frag_utils","tags":"","url":"sourcefile/mqc_frag_utils.f90.html"},{"title":"mqc_method_types.f90 – metalquicha","text":"Method type constants for quantum chemistry methods Files dependent on this one sourcefile~~mqc_method_types.f90~~AfferentGraph sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Method type constants for quantum chemistry methods module mqc_method_types !! Defines integer constants for quantum chemistry methods to avoid string comparisons !! throughout the codebase. Provides conversion utilities between string !! representations and integer constants. use pic_types , only : int32 implicit none private ! Public constants public :: METHOD_TYPE_GFN1 , METHOD_TYPE_GFN2 , METHOD_TYPE_HF public :: METHOD_TYPE_UNKNOWN ! Public functions public :: method_type_from_string , method_type_to_string ! Method type constants integer ( int32 ), parameter :: METHOD_TYPE_UNKNOWN = 0 integer ( int32 ), parameter :: METHOD_TYPE_GFN1 = 1 integer ( int32 ), parameter :: METHOD_TYPE_GFN2 = 2 integer ( int32 ), parameter :: METHOD_TYPE_HF = 3 contains pure function method_type_from_string ( method_str ) result ( method_type ) !! Convert method type string to integer constant !! !! Performs case-insensitive comparison and returns appropriate constant. !! Returns METHOD_TYPE_UNKNOWN for unrecognized strings. character ( len =* ), intent ( in ) :: method_str !! Input string (e.g., \"gfn1\", \"gfn2\", \"hf\") integer ( int32 ) :: method_type !! Output integer constant character ( len = len_trim ( method_str )) :: lower_str integer :: i ! Convert to lowercase for case-insensitive comparison lower_str = trim ( adjustl ( method_str )) do i = 1 , len ( lower_str ) if ( lower_str ( i : i ) >= 'A' . and . lower_str ( i : i ) <= 'Z' ) then lower_str ( i : i ) = achar ( iachar ( lower_str ( i : i )) + 32 ) end if end do ! Match against known types select case ( lower_str ) case ( 'gfn1' ) method_type = METHOD_TYPE_GFN1 case ( 'gfn2' ) method_type = METHOD_TYPE_GFN2 case ( 'hf' ) method_type = METHOD_TYPE_HF case default method_type = METHOD_TYPE_UNKNOWN end select end function method_type_from_string pure function method_type_to_string ( method_type ) result ( method_str ) !! Convert method type integer constant to string !! !! Provides human-readable string representation of method type. integer ( int32 ), intent ( in ) :: method_type !! Input integer constant character ( len = :), allocatable :: method_str !! Output string representation select case ( method_type ) case ( METHOD_TYPE_GFN1 ) method_str = \"gfn1\" case ( METHOD_TYPE_GFN2 ) method_str = \"gfn2\" case ( METHOD_TYPE_HF ) method_str = \"hf\" case default method_str = \"unknown\" end select end function method_type_to_string end module mqc_method_types","tags":"","url":"sourcefile/mqc_method_types.f90.html"},{"title":"mqc_error.f90 – metalquicha","text":"Error handling module for metalquicha\nProvides a unified error type to replace stat/errmsg pairs Files dependent on this one sourcefile~~mqc_error.f90~~AfferentGraph sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90 mqc_config_adapter.f90 sourcefile~main.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~main.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_basis_utils.f90 mqc_basis_utils.f90 sourcefile~mqc_basis_utils.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cli_parser.f90 mqc_cli_parser.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_cli_parser.f90->sourcefile~mqc_basis_utils.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_config_adapter.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_error.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_adapter.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_finite_differences.f90 mqc_finite_differences.f90 sourcefile~mqc_finite_differences.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_finite_differences.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Error handling module for metalquicha !! Provides a unified error type to replace stat/errmsg pairs module mqc_error implicit none private public :: error_t public :: SUCCESS , ERROR_GENERIC , ERROR_IO , ERROR_PARSE , ERROR_VALIDATION !! Error codes integer , parameter :: SUCCESS = 0 integer , parameter :: ERROR_GENERIC = 1 integer , parameter :: ERROR_IO = 2 integer , parameter :: ERROR_PARSE = 3 integer , parameter :: ERROR_VALIDATION = 4 !! Unified error type type :: error_t integer :: code = SUCCESS !! Error code (0 = no error) character ( len = :), allocatable :: message !! Error message contains procedure :: has_error => error_has_error procedure :: set => error_set procedure :: clear => error_clear procedure :: get_code => error_get_code procedure :: get_message => error_get_message end type error_t contains pure function error_has_error ( this ) result ( has_err ) !! Check if an error is set class ( error_t ), intent ( in ) :: this logical :: has_err has_err = ( this % code /= SUCCESS ) end function error_has_error pure subroutine error_set ( this , code , message ) !! Set an error with code and message class ( error_t ), intent ( inout ) :: this integer , intent ( in ) :: code character ( len =* ), intent ( in ) :: message this % code = code this % message = trim ( message ) end subroutine error_set pure subroutine error_clear ( this ) !! Clear the error state class ( error_t ), intent ( inout ) :: this this % code = SUCCESS if ( allocated ( this % message )) deallocate ( this % message ) end subroutine error_clear pure function error_get_code ( this ) result ( code ) !! Get the error code class ( error_t ), intent ( in ) :: this integer :: code code = this % code end function error_get_code pure function error_get_message ( this ) result ( message ) !! Get the error message class ( error_t ), intent ( in ) :: this character ( len = :), allocatable :: message if ( allocated ( this % message )) then message = this % message else message = \"\" end if end function error_get_message end module mqc_error","tags":"","url":"sourcefile/mqc_error.f90.html"},{"title":"mqc_gmbe_utils.f90 – metalquicha","text":"GMBE (Generalized Many-Body Expansion) utilities for overlapping fragments This file depends on sourcefile~~mqc_gmbe_utils.f90~~EfferentGraph sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_gmbe_utils.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_config_parser.f90 mqc_config_parser.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_config_parser.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_error.f90 mqc_error.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_error.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_error.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_calc_types.f90 mqc_calc_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_calc_types.f90 sourcefile~mqc_method_types.f90 mqc_method_types.f90 sourcefile~mqc_config_parser.f90->sourcefile~mqc_method_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_error.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_gmbe_utils.f90~~AfferentGraph sourcefile~mqc_gmbe_utils.f90 mqc_gmbe_utils.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_frag_utils.f90->sourcefile~mqc_gmbe_utils.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_gmbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_gmbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! GMBE (Generalized Many-Body Expansion) utilities for overlapping fragments module mqc_gmbe_utils !! Provides functions for computing fragment intersections, generating k-way !! intersections, and enumerating PIE (Principle of Inclusion-Exclusion) terms !! for GMBE calculations with overlapping molecular fragments. use pic_types , only : default_int , int32 , int64 , dp use pic_logger , only : logger => global_logger use pic_io , only : to_char implicit none private public :: find_fragment_intersection !! Find shared atoms between two fragments public :: generate_intersections !! Generate all k-way intersections for GMBE public :: compute_polymer_atoms !! Compute atom list for polymer (union of fragments) public :: generate_polymer_intersections !! Generate intersections for polymers public :: gmbe_enumerate_pie_terms !! DFS-based PIE coefficient enumeration contains function find_fragment_intersection ( frag1_atoms , n1 , frag2_atoms , n2 , & intersection , n_intersect ) result ( has_intersection ) !! Find shared atoms between two fragments (for GMBE with overlapping fragments) !! !! This function identifies atoms that appear in both fragments, which is essential !! for computing intersection-corrected energies in GMBE. !! !! Algorithm: O(n1 * n2) brute-force comparison !! - Loop through all atoms in fragment 1 !! - For each atom, check if it appears in fragment 2 !! - Collect all shared atoms !! !! Returns: !!   .true. if fragments share at least one atom, .false. otherwise !! !! Output: !!   intersection - allocatable array containing shared atom indices !!   n_intersect - number of shared atoms integer , intent ( in ) :: frag1_atoms (:) !! Atom indices in fragment 1 (0-indexed) integer , intent ( in ) :: n1 !! Number of atoms in fragment 1 integer , intent ( in ) :: frag2_atoms (:) !! Atom indices in fragment 2 (0-indexed) integer , intent ( in ) :: n2 !! Number of atoms in fragment 2 integer , allocatable , intent ( out ) :: intersection (:) !! Shared atom indices integer , intent ( out ) :: n_intersect !! Number of shared atoms logical :: has_intersection integer :: i , j integer , allocatable :: temp_intersection (:) integer :: temp_count ! Allocate temporary array (max possible size is min(n1, n2)) allocate ( temp_intersection ( min ( n1 , n2 ))) temp_count = 0 ! Find all shared atoms do i = 1 , n1 do j = 1 , n2 if ( frag1_atoms ( i ) == frag2_atoms ( j )) then ! Found a shared atom temp_count = temp_count + 1 temp_intersection ( temp_count ) = frag1_atoms ( i ) exit ! Move to next atom in frag1 end if end do end do ! Set output n_intersect = temp_count has_intersection = ( temp_count > 0 ) ! Allocate and copy result if intersection exists if ( has_intersection ) then allocate ( intersection ( n_intersect )) intersection = temp_intersection ( 1 : n_intersect ) end if deallocate ( temp_intersection ) end function find_fragment_intersection subroutine generate_intersections ( sys_geom , monomers , polymers , n_monomers , max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for k=2 to min(max_intersection_level, n_monomers) !! !! For a system with overlapping fragments, this computes k-way intersections !! following the inclusion-exclusion principle for GMBE. !! The max_intersection_level parameter controls the maximum depth to avoid combinatorial explosion. !! !! Algorithm: !! - For each k from 2 to min(max_intersection_level, n_monomers): !!   - Generate all C(n_monomers, k) combinations !!   - For each combination, compute intersection of all k fragments !!   - Store non-empty intersections with their level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:) !! Monomer indices integer , intent ( inout ) :: polymers (:, :) !! Output: monomers stored here integer , intent ( in ) :: n_monomers !! Number of monomers integer , intent ( in ) :: max_intersection_level !! Maximum k-way intersection depth integer , allocatable , intent ( out ) :: intersections (:, :) !! Intersection atom lists integer , allocatable , intent ( out ) :: intersection_sets (:, :) !! Which k-tuple created each intersection integer , allocatable , intent ( out ) :: intersection_levels (:) !! Level (k) of each intersection integer , intent ( out ) :: n_intersections !! Number of intersections found ! Temporaries for storing intersections integer , allocatable :: temp_intersections (:, :) integer , allocatable :: temp_sets (:, :) integer , allocatable :: temp_levels (:) integer , allocatable :: temp_intersection (:) integer , allocatable :: current_intersection (:) integer :: temp_n_intersect , current_n_intersect logical :: has_intersection integer :: k , intersection_count , max_atoms , max_intersections , max_k_level integer :: i , idx integer , allocatable :: combination (:) ! Store monomers in polymers array polymers ( 1 : n_monomers , 1 ) = monomers ( 1 : n_monomers ) if ( n_monomers < 2 ) then n_intersections = 0 return end if ! Count maximum possible intersections: sum of C(n,k) for k=2 to n ! For small n, this is 2&#94;n - n - 1 max_intersections = 2 ** n_monomers - n_monomers - 1 ! Find maximum atoms in any fragment for allocation max_atoms = maxval ( sys_geom % fragment_sizes ( 1 : n_monomers )) ! Allocate temporary arrays allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_monomers , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 ! Determine actual maximum intersection level to use max_k_level = min ( max_intersection_level , n_monomers ) if ( max_k_level < n_monomers ) then call logger % info ( \"Generating k-way intersections up to k=\" // to_char ( max_k_level ) // & \" (limited by max_intersection_level)\" ) else call logger % info ( \"Generating all k-way intersections for GMBE (inclusion-exclusion principle)\" ) end if ! Loop over intersection levels k from 2 to max_k_level do k = 2 , max_k_level ! Generate all C(n_monomers, k) combinations allocate ( combination ( k )) call generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_monomers , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_monomers , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , max_k_level idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else call logger % info ( \"No intersections found (fragments are non-overlapping)\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections recursive subroutine generate_k_way_intersections_for_level ( sys_geom , monomers , n_monomers , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Helper to generate all k-way intersections at a specific level k use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomers (:), n_monomers , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , mono_idx , frag_size logical :: has_intersection ! Generate combinations using an iterative approach call next_combination_init ( combination , k ) do ! Compute intersection of all fragments in this combination has_intersection = . false . ! Start with the first fragment in the combination mono_idx = monomers ( combination ( 1 )) frag_size = sys_geom % fragment_sizes ( mono_idx ) allocate ( current_intersection ( frag_size )) current_intersection = sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ) current_n_intersect = frag_size ! Intersect with each subsequent fragment do i = 2 , k mono_idx = monomers ( combination ( i )) frag_size = sys_geom % fragment_sizes ( mono_idx ) has_intersection = find_fragment_intersection ( & current_intersection , current_n_intersect , & sys_geom % fragment_atoms ( 1 : frag_size , mono_idx ), frag_size , & temp_intersection , temp_n_intersect ) if (. not . has_intersection ) then ! Intersection is empty, break early deallocate ( current_intersection ) if ( allocated ( temp_intersection )) deallocate ( temp_intersection ) exit end if ! Replace current_intersection with the new intersection deallocate ( current_intersection ) allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection current_n_intersect = temp_n_intersect deallocate ( temp_intersection ) end do ! If we have a non-empty intersection, store it if ( has_intersection . and . allocated ( current_intersection )) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection temp_sets ( 1 : k , intersection_count ) = monomers ( combination ) temp_levels ( intersection_count ) = k deallocate ( current_intersection ) end if ! Get next combination if (. not . next_combination ( combination , k , n_monomers )) exit end do end subroutine generate_k_way_intersections_for_level subroutine next_combination_init ( combination , k ) !! Initialize combination to [1, 2, ..., k] integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k integer :: i do i = 1 , k combination ( i ) = i end do end subroutine next_combination_init function next_combination ( combination , k , n ) result ( has_next ) !! Generate next combination in lexicographic order !! Returns .true. if there's a next combination, .false. if we've exhausted all integer , intent ( inout ) :: combination (:) integer , intent ( in ) :: k , n logical :: has_next integer :: i has_next = . true . ! Find the rightmost element that can be incremented i = k do while ( i >= 1 ) if ( combination ( i ) < n - k + i ) then combination ( i ) = combination ( i ) + 1 ! Reset all elements to the right do while ( i < k ) i = i + 1 combination ( i ) = combination ( i - 1 ) + 1 end do return end if i = i - 1 end do ! No more combinations has_next = . false . end function next_combination subroutine compute_polymer_atoms ( sys_geom , polymer , polymer_size , atom_list , n_atoms ) !! Compute the atom list for a polymer (union of atoms from base fragments) !! polymer(:) contains base fragment indices (1-based) use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymer (:) !! Base fragment indices in this polymer integer , intent ( in ) :: polymer_size !! Number of base fragments in polymer integer , allocatable , intent ( out ) :: atom_list (:) !! Unique atoms in this polymer integer , intent ( out ) :: n_atoms !! Number of unique atoms integer , allocatable :: temp_atoms (:) integer :: i , j , frag_idx , frag_size , temp_count logical :: already_present ! Allocate temporary array (worst case: all atoms from all fragments) allocate ( temp_atoms ( sys_geom % total_atoms )) temp_count = 0 ! Loop through each base fragment in the polymer do i = 1 , polymer_size frag_idx = polymer ( i ) if ( frag_idx == 0 ) exit ! Padding zeros frag_size = sys_geom % fragment_sizes ( frag_idx ) ! Add each atom from this fragment (avoid duplicates) do j = 1 , frag_size already_present = . false . ! Check if this atom is already in our list block integer :: k , current_atom current_atom = sys_geom % fragment_atoms ( j , frag_idx ) do k = 1 , temp_count if ( temp_atoms ( k ) == current_atom ) then already_present = . true . exit end if end do end block ! Add if not already present if (. not . already_present ) then temp_count = temp_count + 1 temp_atoms ( temp_count ) = sys_geom % fragment_atoms ( j , frag_idx ) end if end do end do ! Copy to output array n_atoms = temp_count allocate ( atom_list ( n_atoms )) atom_list = temp_atoms ( 1 : n_atoms ) deallocate ( temp_atoms ) end subroutine compute_polymer_atoms subroutine generate_polymer_intersections ( sys_geom , polymers , n_polymers , max_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate all k-way intersections for polymers at any level (GMBE-N) !! This works with dynamically generated polymers, not just base fragments use mqc_physical_fragment , only : system_geometry_t use pic_logger , only : logger => global_logger use pic_io , only : to_char type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: polymers (:, :) !! Polymer definitions (n_polymers, max_level) integer , intent ( in ) :: n_polymers , max_level integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer , allocatable :: polymer_atoms (:, :) !! Atom lists for each polymer integer , allocatable :: polymer_n_atoms (:) !! Number of atoms in each polymer integer :: max_atoms_per_polymer integer :: i , polymer_size , max_intersection_level call logger % info ( \"Computing atom compositions for \" // to_char ( n_polymers ) // \" polymers...\" ) ! First, compute atom list for each polymer ! Find max atoms needed max_atoms_per_polymer = 0 do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) ! Worst case: all atoms from all fragments in this polymer max_atoms_per_polymer = max ( max_atoms_per_polymer , polymer_size * maxval ( sys_geom % fragment_sizes )) end do allocate ( polymer_atoms ( max_atoms_per_polymer , n_polymers )) allocate ( polymer_n_atoms ( n_polymers )) polymer_atoms = 0 ! Compute atoms for each polymer do i = 1 , n_polymers polymer_size = count ( polymers ( i , :) > 0 ) block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , polymers ( i , 1 : polymer_size ), polymer_size , atom_list , n_atoms ) polymer_n_atoms ( i ) = n_atoms polymer_atoms ( 1 : n_atoms , i ) = atom_list deallocate ( atom_list ) end block end do call logger % info ( \"Finding intersections between polymers...\" ) ! For GMBE(N), limit intersections to level N+1 to prevent combinatorial explosion ! GMBE(2): dimers → 3-way intersections max ! GMBE(3): trimers → 4-way intersections max max_intersection_level = max_level + 1 call logger % info ( \"Limiting intersections to level \" // to_char ( max_intersection_level ) // & \" (polymer level \" // to_char ( max_level ) // \" + 1)\" ) ! Now generate intersections between these polymer atom sets call generate_intersections_from_atom_lists ( polymer_atoms , polymer_n_atoms , n_polymers , & max_intersection_level , & intersections , intersection_sets , intersection_levels , n_intersections ) deallocate ( polymer_atoms , polymer_n_atoms ) end subroutine generate_polymer_intersections subroutine generate_intersections_from_atom_lists ( atom_lists , n_atoms_list , n_sets , max_k_level , & intersections , intersection_sets , intersection_levels , n_intersections ) !! Generate k-way intersections from arbitrary atom lists (not tied to sys_geom) !! max_k_level limits the maximum intersection order to prevent combinatorial explosion use pic_logger , only : logger => global_logger use pic_io , only : to_char integer , intent ( in ) :: atom_lists (:, :) !! (max_atoms, n_sets) integer , intent ( in ) :: n_atoms_list (:) !! Number of atoms in each set integer , intent ( in ) :: n_sets !! Number of sets (polymers) integer , intent ( in ) :: max_k_level !! Maximum intersection level to compute integer , allocatable , intent ( out ) :: intersections (:, :) integer , allocatable , intent ( out ) :: intersection_sets (:, :) integer , allocatable , intent ( out ) :: intersection_levels (:) integer , intent ( out ) :: n_intersections integer :: max_intersections , max_atoms integer , allocatable :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer :: intersection_count , k , idx , actual_max_k integer , allocatable :: combination (:) if ( n_sets < 2 ) then n_intersections = 0 return end if ! Limit k-way intersections to min(max_k_level, n_sets) actual_max_k = min ( max_k_level , n_sets ) max_intersections = 2 ** n_sets - n_sets - 1 max_atoms = maxval ( n_atoms_list ) allocate ( temp_intersections ( max_atoms , max_intersections )) allocate ( temp_sets ( n_sets , max_intersections )) allocate ( temp_levels ( max_intersections )) temp_intersections = 0 temp_sets = 0 intersection_count = 0 call logger % info ( \"Generating k-way intersections (k=2 to \" // to_char ( actual_max_k ) // \")\" ) ! Loop over intersection levels k from 2 to actual_max_k do k = 2 , actual_max_k allocate ( combination ( k )) call generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , & combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) deallocate ( combination ) end do n_intersections = intersection_count ! Allocate output arrays if ( n_intersections > 0 ) then allocate ( intersections ( max_atoms , n_intersections )) allocate ( intersection_sets ( n_sets , n_intersections )) allocate ( intersection_levels ( n_intersections )) intersections = temp_intersections ( 1 : max_atoms , 1 : n_intersections ) intersection_sets = temp_sets ( 1 : n_sets , 1 : n_intersections ) intersection_levels = temp_levels ( 1 : n_intersections ) call logger % info ( \"Generated \" // to_char ( n_intersections ) // \" total intersections:\" ) do k = 2 , actual_max_k idx = count ( intersection_levels == k ) if ( idx > 0 ) then call logger % info ( \"  \" // to_char ( idx ) // \" intersections at level \" // to_char ( k )) end if end do else allocate ( intersections ( 1 , 0 )) allocate ( intersection_sets ( 1 , 0 )) allocate ( intersection_levels ( 0 )) call logger % info ( \"No intersections found\" ) end if deallocate ( temp_intersections , temp_sets , temp_levels ) end subroutine generate_intersections_from_atom_lists subroutine generate_k_way_intersections_from_lists ( atom_lists , n_atoms_list , n_sets , k , combination , max_atoms , & temp_intersections , temp_sets , temp_levels , intersection_count ) !! Generate all k-way intersections from atom lists integer , intent ( in ) :: atom_lists (:, :), n_atoms_list (:), n_sets , k , max_atoms integer , intent ( inout ) :: combination (:) integer , intent ( inout ) :: temp_intersections (:, :), temp_sets (:, :), temp_levels (:) integer , intent ( inout ) :: intersection_count integer , allocatable :: current_intersection (:), temp_intersection (:) integer :: current_n_intersect , temp_n_intersect integer :: i , j , set_idx logical :: has_intersection call next_combination_init ( combination , k ) do ! Compute intersection of all sets in this combination has_intersection = . false . ! Start with the first set in the combination set_idx = combination ( 1 ) allocate ( current_intersection ( n_atoms_list ( set_idx ))) current_intersection = atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) current_n_intersect = n_atoms_list ( set_idx ) ! Intersect with each subsequent set do i = 2 , k set_idx = combination ( i ) allocate ( temp_intersection ( current_n_intersect )) ! Find intersection temp_n_intersect = 0 do j = 1 , current_n_intersect if ( any ( atom_lists ( 1 : n_atoms_list ( set_idx ), set_idx ) == current_intersection ( j ))) then temp_n_intersect = temp_n_intersect + 1 temp_intersection ( temp_n_intersect ) = current_intersection ( j ) end if end do ! Update current intersection deallocate ( current_intersection ) if ( temp_n_intersect > 0 ) then allocate ( current_intersection ( temp_n_intersect )) current_intersection = temp_intersection ( 1 : temp_n_intersect ) current_n_intersect = temp_n_intersect has_intersection = . true . else has_intersection = . false . end if deallocate ( temp_intersection ) if (. not . has_intersection ) exit end do ! Store if we found an intersection if ( has_intersection . and . current_n_intersect > 0 ) then intersection_count = intersection_count + 1 temp_intersections ( 1 : current_n_intersect , intersection_count ) = current_intersection ( 1 : current_n_intersect ) temp_sets ( 1 : k , intersection_count ) = combination ( 1 : k ) temp_levels ( intersection_count ) = k end if if ( allocated ( current_intersection )) deallocate ( current_intersection ) ! Get next combination if (. not . next_combination ( combination , k , n_sets )) exit end do end subroutine generate_k_way_intersections_from_lists subroutine gmbe_enumerate_pie_terms ( sys_geom , primaries , n_primaries , polymer_level , max_k_level , & pie_atom_sets , pie_coefficients , n_pie_terms ) !! Enumerate all unique intersections via DFS and accumulate PIE coefficients !! This implements the GMBE(N) algorithm with inclusion-exclusion principle !! !! Algorithm: !! 1. For each primary i, start DFS with clique=[i] !! 2. Recursively grow cliques by adding overlapping primaries !! 3. For each clique of size k, compute intersection and add PIE coefficient: !!    coefficient = (+1) if k odd, (-1) if k even !! 4. Accumulate coefficients for each unique atom set use mqc_physical_fragment , only : system_geometry_t type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: primaries (:, :) !! Primary polymers (n_primaries, polymer_level) integer , intent ( in ) :: n_primaries !! Number of primary polymers integer , intent ( in ) :: polymer_level !! Level of primaries (1=monomers, 2=dimers, etc.) integer , intent ( in ) :: max_k_level !! Maximum clique size (intersection depth limit) integer , allocatable , intent ( out ) :: pie_atom_sets (:, :) !! Unique atom sets (max_atoms, n_terms) integer , allocatable , intent ( out ) :: pie_coefficients (:) !! PIE coefficient for each term integer , intent ( out ) :: n_pie_terms !! Number of unique PIE terms ! Temporary storage for PIE terms (allocate generously) integer , parameter :: MAX_PIE_TERMS = 100000 ! Adjust if needed integer , allocatable :: temp_atom_sets (:, :) integer , allocatable :: temp_coefficients (:) integer , allocatable :: primary_atoms (:, :) !! Precomputed atom lists for each primary integer , allocatable :: primary_n_atoms (:) !! Atom counts for each primary integer , allocatable :: clique (:) !! Current clique being built integer , allocatable :: current_atoms (:) !! Current intersection atoms integer , allocatable :: candidates (:) !! Candidate primaries to add integer :: i , j , max_atoms , n_candidates call logger % info ( \"Enumerating GMBE PIE terms via DFS...\" ) ! Find maximum atoms in any fragment max_atoms = sys_geom % total_atoms ! Allocate temporary storage allocate ( temp_atom_sets ( max_atoms , MAX_PIE_TERMS )) allocate ( temp_coefficients ( MAX_PIE_TERMS )) temp_atom_sets = - 1 temp_coefficients = 0 n_pie_terms = 0 ! Precompute atom lists for all primaries allocate ( primary_atoms ( max_atoms , n_primaries )) allocate ( primary_n_atoms ( n_primaries )) primary_atoms = - 1 do i = 1 , n_primaries block integer , allocatable :: atom_list (:) integer :: n_atoms call compute_polymer_atoms ( sys_geom , primaries ( i , :), polymer_level , atom_list , n_atoms ) primary_n_atoms ( i ) = n_atoms primary_atoms ( 1 : n_atoms , i ) = atom_list ( 1 : n_atoms ) deallocate ( atom_list ) end block end do ! Allocate work arrays allocate ( clique ( max_k_level )) allocate ( current_atoms ( max_atoms )) allocate ( candidates ( n_primaries )) ! Start DFS from each primary do i = 1 , n_primaries ! Initial clique: just primary i clique ( 1 ) = i current_atoms ( 1 : primary_n_atoms ( i )) = primary_atoms ( 1 : primary_n_atoms ( i ), i ) ! Candidates: all primaries after i (to avoid duplicates) n_candidates = n_primaries - i if ( n_candidates > 0 ) then candidates ( 1 : n_candidates ) = [( i + j , j = 1 , n_candidates )] end if ! DFS from this primary call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , 1 , current_atoms ( 1 : primary_n_atoms ( i )), primary_n_atoms ( i ), & candidates , n_candidates , max_k_level , & temp_atom_sets , temp_coefficients , n_pie_terms , MAX_PIE_TERMS ) end do ! Copy to output arrays if ( n_pie_terms > 0 ) then allocate ( pie_atom_sets ( max_atoms , n_pie_terms )) allocate ( pie_coefficients ( n_pie_terms )) pie_atom_sets = temp_atom_sets (:, 1 : n_pie_terms ) pie_coefficients = temp_coefficients ( 1 : n_pie_terms ) end if call logger % info ( \"Generated \" // to_char ( n_pie_terms ) // \" unique PIE terms\" ) ! Cleanup deallocate ( temp_atom_sets , temp_coefficients , primary_atoms , primary_n_atoms ) deallocate ( clique , current_atoms , candidates ) end subroutine gmbe_enumerate_pie_terms recursive subroutine dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & clique , clique_size , current_atoms , n_current_atoms , & candidates , n_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms ) !! DFS helper: accumulate PIE coefficients for intersections integer , intent ( in ) :: primary_atoms (:, :) !! Precomputed atom lists integer , intent ( in ) :: primary_n_atoms (:) !! Atom counts integer , intent ( in ) :: n_primaries , max_atoms integer , intent ( in ) :: clique (:) !! Current clique integer , intent ( in ) :: clique_size !! Size of current clique integer , intent ( in ) :: current_atoms (:) !! Atoms in current intersection integer , intent ( in ) :: n_current_atoms !! Number of atoms in intersection integer , intent ( in ) :: candidates (:) !! Candidate primaries integer , intent ( in ) :: n_candidates integer , intent ( in ) :: max_k_level integer , intent ( inout ) :: atom_sets (:, :) integer , intent ( inout ) :: coefficients (:) integer , intent ( inout ) :: n_terms integer , intent ( in ) :: max_terms integer :: sign , term_idx , i , candidate_idx integer , allocatable :: new_atoms (:), new_candidates (:) integer :: n_new_atoms , n_new_candidates logical :: found ! Skip empty intersections if ( n_current_atoms == 0 ) return ! Compute PIE sign: (+1) for odd clique size, (-1) for even sign = merge ( 1 , - 1 , mod ( clique_size , 2 ) == 1 ) ! Find or create entry for this atom set found = . false . do i = 1 , n_terms if ( atom_sets_equal ( atom_sets (:, i ), current_atoms , n_current_atoms )) then coefficients ( i ) = coefficients ( i ) + sign found = . true . exit end if end do if (. not . found ) then ! New atom set if ( n_terms >= max_terms ) then call logger % error ( \"Exceeded maximum PIE terms (\" // to_char ( max_terms ) // \")\" ) return end if n_terms = n_terms + 1 atom_sets ( 1 : n_current_atoms , n_terms ) = current_atoms ( 1 : n_current_atoms ) atom_sets ( n_current_atoms + 1 :, n_terms ) = - 1 coefficients ( n_terms ) = sign end if ! Stop if we've reached maximum clique size if ( clique_size >= max_k_level ) return if ( n_candidates == 0 ) return ! Try adding each candidate to the clique allocate ( new_atoms ( max_atoms )) allocate ( new_candidates ( n_primaries )) do i = 1 , n_candidates candidate_idx = candidates ( i ) ! Compute intersection with this candidate call intersect_atom_lists ( current_atoms , n_current_atoms , & primary_atoms (:, candidate_idx ), primary_n_atoms ( candidate_idx ), & new_atoms , n_new_atoms ) ! Skip if no intersection if ( n_new_atoms == 0 ) cycle ! New candidates: must come after this one and overlap with new_atoms n_new_candidates = 0 do term_idx = i + 1 , n_candidates block integer :: test_candidate , test_n_intersect integer , allocatable :: test_intersect (:) test_candidate = candidates ( term_idx ) allocate ( test_intersect ( max_atoms )) call intersect_atom_lists ( new_atoms , n_new_atoms , & primary_atoms (:, test_candidate ), primary_n_atoms ( test_candidate ), & test_intersect , test_n_intersect ) if ( test_n_intersect > 0 ) then n_new_candidates = n_new_candidates + 1 new_candidates ( n_new_candidates ) = test_candidate end if deallocate ( test_intersect ) end block end do ! Recurse block integer :: new_clique ( clique_size + 1 ) new_clique ( 1 : clique_size ) = clique ( 1 : clique_size ) new_clique ( clique_size + 1 ) = candidate_idx call dfs_pie_accumulate ( primary_atoms , primary_n_atoms , n_primaries , max_atoms , & new_clique , clique_size + 1 , new_atoms , n_new_atoms , & new_candidates , n_new_candidates , max_k_level , & atom_sets , coefficients , n_terms , max_terms ) end block end do deallocate ( new_atoms , new_candidates ) end subroutine dfs_pie_accumulate function atom_sets_equal ( set1 , set2 , n_atoms ) result ( equal ) !! Check if two atom sets are equal (assuming sorted) integer , intent ( in ) :: set1 (:), set2 (:) integer , intent ( in ) :: n_atoms logical :: equal integer :: i equal = . true . do i = 1 , n_atoms if ( set1 ( i ) /= set2 ( i )) then equal = . false . return end if end do end function atom_sets_equal subroutine intersect_atom_lists ( atoms1 , n1 , atoms2 , n2 , intersection , n_intersect ) !! Compute intersection of two atom lists integer , intent ( in ) :: atoms1 (:), n1 , atoms2 (:), n2 integer , intent ( out ) :: intersection (:) integer , intent ( out ) :: n_intersect integer :: i , j n_intersect = 0 do i = 1 , n1 if ( atoms1 ( i ) < 0 ) cycle do j = 1 , n2 if ( atoms2 ( j ) < 0 ) cycle if ( atoms1 ( i ) == atoms2 ( j )) then n_intersect = n_intersect + 1 intersection ( n_intersect ) = atoms1 ( i ) exit end if end do end do end subroutine intersect_atom_lists end module mqc_gmbe_utils","tags":"","url":"sourcefile/mqc_gmbe_utils.f90.html"},{"title":"mqc_json.f90 – metalquicha","text":"JSON output utilities for multi-molecule calculations This file depends on sourcefile~~mqc_json.f90~~EfferentGraph sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_io_helpers.f90 mqc_io_helpers.f90 sourcefile~mqc_json.f90->sourcefile~mqc_io_helpers.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_json.f90~~AfferentGraph sourcefile~mqc_json.f90 mqc_json.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_json.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! JSON output utilities for multi-molecule calculations module mqc_json use pic_logger , only : logger => global_logger use pic_io , only : to_char implicit none private public :: merge_multi_molecule_json contains subroutine merge_multi_molecule_json ( individual_files , nmol ) !! Merge individual molecule JSON files into a single combined file use mqc_io_helpers , only : get_molecule_name character ( len = 256 ), intent ( in ) :: individual_files (:) integer , intent ( in ) :: nmol integer :: imol , unit_in , unit_out , io_stat , slash_pos , dot_pos character ( len = 10000 ) :: line character ( len = 256 ) :: output_file , basename logical :: file_exists ! Determine combined output filename from first individual file ! Example: \"output_multi_structure_molecule_1.json\" -> \"output_multi_structure.json\" basename = individual_files ( 1 ) slash_pos = index ( basename , '/' , back = . true .) if ( slash_pos > 0 ) then basename = basename ( slash_pos + 1 :) end if ! Remove \"_molecule_1\" or similar suffix dot_pos = index ( basename , '_molecule_' ) if ( dot_pos > 0 ) then output_file = basename ( 1 : dot_pos - 1 ) // \".json\" else output_file = \"output_combined.json\" end if ! Open combined output file open ( newunit = unit_out , file = trim ( output_file ), status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open \" // trim ( output_file ) // \" for writing\" ) return end if call logger % info ( \"Merging \" // to_char ( nmol ) // \" molecule JSON files into \" // trim ( output_file )) ! Write opening brace and top-level key (basename without \"output_\" and \".json\") dot_pos = index ( output_file , '.json' ) if ( dot_pos > 0 ) then basename = output_file ( 8 : dot_pos - 1 ) ! Skip \"output_\" else basename = \"combined\" end if write ( unit_out , '(a)' ) \"{\" write ( unit_out , '(a)' ) '  \"' // trim ( basename ) // '\": {' ! Process each individual JSON file do imol = 1 , nmol inquire ( file = trim ( individual_files ( imol )), exist = file_exists ) if (. not . file_exists ) cycle open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) cycle ! Read all lines from the individual JSON file call read_json_content ( unit_in , imol , unit_out , individual_files ( imol )) close ( unit_in ) ! Delete individual file open ( newunit = unit_in , file = trim ( individual_files ( imol )), status = 'old' , action = 'readwrite' ) close ( unit_in , status = 'delete' ) end do ! Close last molecule write ( unit_out , '(a)' ) '    }' ! Close top-level key and file write ( unit_out , '(a)' ) '  }' write ( unit_out , '(a)' ) '}' close ( unit_out ) call logger % info ( \"Combined JSON written to \" // trim ( output_file )) end subroutine merge_multi_molecule_json subroutine read_json_content ( unit_in , mol_index , unit_out , filename ) !! Read and write JSON content from an individual molecule file !! Properly handles nested structures from fragmented calculations use mqc_io_helpers , only : get_molecule_name integer , intent ( in ) :: unit_in , mol_index , unit_out character ( len =* ), intent ( in ) :: filename character ( len = 10000 ), allocatable :: all_lines (:) character ( len = 10000 ) :: line integer :: io_stat , nlines , i ! Read all lines into memory allocate ( all_lines ( 1000 )) ! Reasonable size for most JSON files nlines = 0 do read ( unit_in , '(a)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit nlines = nlines + 1 if ( nlines > size ( all_lines )) then ! Reallocate if needed call logger % error ( \"JSON file too large: \" // trim ( filename )) return end if all_lines ( nlines ) = line end do ! Lines structure: ! 1: \"{\" ! 2: '  \"molecule_name\": {' ! 3..(n-2): content ! n-1: \"  }\" ! n: \"}\" if ( nlines < 3 ) then call logger % error ( \"Invalid JSON structure: \" // trim ( filename )) return end if ! Write molecule key (extracted from filename) if ( mol_index > 1 ) write ( unit_out , '(a)' ) '    },' write ( unit_out , '(a)' ) '    \"' // trim ( get_molecule_name ( filename )) // '\" : {' ! Write all content lines (from line 3 to line n-2) do i = 3 , nlines - 2 write ( unit_out , '(a)' ) '  ' // trim ( all_lines ( i )) ! Add 2 spaces for proper indentation end do deallocate ( all_lines ) end subroutine read_json_content end module mqc_json","tags":"","url":"sourcefile/mqc_json.f90.html"}]}