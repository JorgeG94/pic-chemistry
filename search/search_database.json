var tipuesearch = {"pages":[{"title":" metalquicha ","text":"metalquicha Metalquicha API Documentation Met’al q’uicha (metalquicha) Building Notes on Fortran compiler compatibility Building with the Fortran Package Manager (FPM) Obtaining the FPM Warning This API documentation is a work in progress. Metalquicha API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . Met’al q’uicha (metalquicha) Yes, this is AI generated (the image) if you know an artist, please let me know. Met’al q’uicha (the Huastec (tenek) word for sunflower), which I’ll just write as metalquicha, is a sample quantum chemistry backend\nwith focus on using the pic library and its derivatives: pic-mpi and pic-blas which are Fortran based implementations of commonly used routines such as sorting algorithms,\narray handling, strings, loggers, timers, etc. While pic-mpi and pic-blas provide modern Fortran wrappers and interfaces to MPI and BLAS implementations in a portable way. Specifically, the MPI\nlibrary lets the user switch betwen the mpi and mpi_f08 modules with ease. Additionally, users can opt to try the vapaa backend for the mpi_f08 module\nto ensure cross compiler portability. Please report any issues associated here and in vapaa. The main purpose of this package is to showcase the ability of being able to write\nsimple, powerful Fortran based programs that are able to access massively parallel\necosystems with ease. Metalquicha implements a naive backend for unfragmented and fragmented quantum chemistry\ncalculations. Currently, metalquicha uses tblite as\nits chemistry engine which performs energy calculations. If you are interested in contributing, please see here . Pic is the main project here and all the contributions fall downstream. Building You will need an internet connection to download the dependencies. The main dependencies are: CMake A Fortran compiler An MPI installation A BLAS/LAPACK install TBLITE (will be downloaded automatically) You can then simply: mkdir build\ncd build\ncmake ../\nmake -j Notes on Fortran compiler compatibility If you enable tblite (enabled by default at the moment) you are going to be blocked by which compilers does tblite\nsupport. If you decide to not build tblite and just build the framework the code will work with most modern compilers. Building with the Fortran Package Manager (FPM) FPM will only work if you are building with openblas, since the linking step is hardcoded. Simply then just do: fpm install --prefix . --compiler mpifort --profile release Obtaining the FPM Install the FPM following the instructions and then simply: fpm install Developer Info Jorge Luis Galvez Vallejo","tags":"home","url":"index.html"},{"title":"input_config_t – metalquicha ","text":"type, public :: input_config_t Configuration data structure for calculation parameters Stores parsed input file contents including file paths,\nmethod selection, and fragmentation level. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: geom_file Path to system geometry XYZ file character(len=:), public, allocatable :: log_level Logger verbosity level (debug/verbose/info/warning/error) character(len=:), public, allocatable :: method QC method (gfn1, gfn2) character(len=:), public, allocatable :: monomer_file Path to monomer template XYZ file integer, public :: nlevel = 1 Fragmentation level (default: 1) Type-Bound Procedures procedure, public :: destroy => config_destroy Cleanup allocated memory private  subroutine config_destroy (this) Clean up allocated memory in input_config_t Arguments Type Intent Optional Attributes Name class( input_config_t ), intent(inout) :: this Source Code type :: input_config_t !! Configuration data structure for calculation parameters !! !! Stores parsed input file contents including file paths, !! method selection, and fragmentation level. character ( len = :), allocatable :: geom_file !! Path to system geometry XYZ file character ( len = :), allocatable :: monomer_file !! Path to monomer template XYZ file character ( len = :), allocatable :: method !! QC method (gfn1, gfn2) character ( len = :), allocatable :: log_level !! Logger verbosity level (debug/verbose/info/warning/error) integer :: nlevel = 1 !! Fragmentation level (default: 1) contains procedure :: destroy => config_destroy !! Cleanup allocated memory end type input_config_t","tags":"","url":"type/input_config_t.html"},{"title":"physical_fragment_t – metalquicha ","text":"type, public :: physical_fragment_t Physical molecular fragment with atomic coordinates and properties Represents a molecular fragment containing atomic positions, element types,\nelectronic structure information, and basis set data for quantum calculations. Inherits type~~physical_fragment_t~~InheritsGraph type~physical_fragment_t physical_fragment_t type~molecular_basis_type molecular_basis_type type~physical_fragment_t->type~molecular_basis_type basis type~atomic_basis_type atomic_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( molecular_basis_type ), public, allocatable :: basis Gaussian basis functions integer, public :: charge = 0 Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) Cartesian coordinates (3, n_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers (Z values) integer, public :: multiplicity = 1 Spin multiplicity (2S+1) integer, public :: n_atoms Number of atoms in this fragment integer, public :: nelec = 0 Total number of electrons Type-Bound Procedures procedure, public :: compute_nelec => fragment_compute_nelec Calculate electron count private  subroutine fragment_compute_nelec (this) Compute number of electrons from atomic numbers and charge Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this procedure, public :: destroy => fragment_destroy Memory cleanup private  subroutine fragment_destroy (this) Clean up allocated memory in physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this procedure, public :: set_basis => fragment_set_basis Assign basis set private  subroutine fragment_set_basis (this, basis) Set the basis set for this fragment Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis Source Code type :: physical_fragment_t !! Physical molecular fragment with atomic coordinates and properties !! !! Represents a molecular fragment containing atomic positions, element types, !! electronic structure information, and basis set data for quantum calculations. integer :: n_atoms !! Number of atoms in this fragment integer , allocatable :: element_numbers (:) !! Atomic numbers (Z values) real ( dp ), allocatable :: coordinates (:, :) !! Cartesian coordinates (3, n_atoms) in Bohr ! Electronic structure properties integer :: charge = 0 !! Net molecular charge (electrons) integer :: multiplicity = 1 !! Spin multiplicity (2S+1) integer :: nelec = 0 !! Total number of electrons ! Quantum chemistry basis set type ( molecular_basis_type ), allocatable :: basis !! Gaussian basis functions contains procedure :: destroy => fragment_destroy !! Memory cleanup procedure :: compute_nelec => fragment_compute_nelec !! Calculate electron count procedure :: set_basis => fragment_set_basis !! Assign basis set end type physical_fragment_t","tags":"","url":"type/physical_fragment_t.html"},{"title":"system_geometry_t – metalquicha ","text":"type, public :: system_geometry_t Complete molecular system geometry for fragment-based calculations Contains the full atomic structure of a molecular cluster organized\nby monomers for efficient fragment generation and MBE calculations. Components Type Visibility Attributes Name Initial integer, public :: atoms_per_monomer Atoms in each monomer (assumed identical) real(kind=dp), public, allocatable :: coordinates (:,:) All coordinates (3, total_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers for all atoms integer, public :: n_monomers Number of monomer units in system integer, public :: total_atoms Total number of atoms (n_monomers × atoms_per_monomer) Type-Bound Procedures procedure, public :: destroy => system_destroy Memory cleanup private  subroutine system_destroy (this) Clean up allocated memory in system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this Source Code type :: system_geometry_t !! Complete molecular system geometry for fragment-based calculations !! !! Contains the full atomic structure of a molecular cluster organized !! by monomers for efficient fragment generation and MBE calculations. integer :: n_monomers !! Number of monomer units in system integer :: atoms_per_monomer !! Atoms in each monomer (assumed identical) integer :: total_atoms !! Total number of atoms (n_monomers × atoms_per_monomer) integer , allocatable :: element_numbers (:) !! Atomic numbers for all atoms real ( dp ), allocatable :: coordinates (:, :) !! All coordinates (3, total_atoms) in Bohr contains procedure :: destroy => system_destroy !! Memory cleanup end type system_geometry_t","tags":"","url":"type/system_geometry_t.html"},{"title":"atomic_basis_type – metalquicha ","text":"type, public :: atomic_basis_type Atomic basis set data structure Inherits type~~atomic_basis_type~~InheritsGraph type~atomic_basis_type atomic_basis_type type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~atomic_basis_type~~InheritedByGraph type~atomic_basis_type atomic_basis_type type~molecular_basis_type molecular_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: element element symbol integer, public :: nshells number of shells in type type( cgto_type ), public, allocatable :: shells (:) array of contracted shells Type-Bound Procedures procedure, public :: allocate_shells => allocate_basis_shells private pure subroutine allocate_basis_shells (self, nshells) Allocate array of shells in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells procedure, public :: destroy => atomic_basis_destroy private pure subroutine atomic_basis_destroy (self) Clean up allocated memory in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self procedure, public :: num_basis_functions => atomic_basis_num_basis_functions private pure function atomic_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for an atom Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer Source Code type :: atomic_basis_type !! Atomic basis set data structure character ( len = :), allocatable :: element !! element symbol type ( cgto_type ), allocatable :: shells (:) !! array of contracted shells integer :: nshells !! number of shells in type contains procedure :: allocate_shells => allocate_basis_shells procedure :: destroy => atomic_basis_destroy procedure :: num_basis_functions => atomic_basis_num_basis_functions end type atomic_basis_type","tags":"","url":"type/atomic_basis_type.html"},{"title":"cgto_type – metalquicha ","text":"type, public :: cgto_type Contracted Gaussian type orbital (CGTO) data structure Inherited by type~~cgto_type~~InheritedByGraph type~cgto_type cgto_type type~atomic_basis_type atomic_basis_type type~atomic_basis_type->type~cgto_type shells type~molecular_basis_type molecular_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: ang_mom Angular momentum quantum number (0=s, 1=p, 2=d, etc.) real(kind=dp), public, allocatable :: coefficients (:) Contraction coefficients real(kind=dp), public, allocatable :: exponents (:) Exponents (alpha values) integer, public :: nfunc Number of primitive Gaussians in the contraction Type-Bound Procedures procedure, public :: allocate_arrays => cgto_allocate_arrays private pure subroutine cgto_allocate_arrays (self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc procedure, public :: destroy => cgto_destroy private pure subroutine cgto_destroy (self) Clean up allocated memory in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self procedure, public :: num_basis_functions => cgto_num_basis_functions private pure function cgto_num_basis_functions (self) result(nbf) Get number of basis functions in a shell (Cartesian) Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer Source Code type :: cgto_type !! Contracted Gaussian type orbital (CGTO) data structure integer :: ang_mom !! Angular momentum quantum number (0=s, 1=p, 2=d, etc.) integer :: nfunc !! Number of primitive Gaussians in the contraction real ( dp ), allocatable :: exponents (:) !! Exponents (alpha values) real ( dp ), allocatable :: coefficients (:) !! Contraction coefficients contains procedure :: allocate_arrays => cgto_allocate_arrays procedure :: destroy => cgto_destroy procedure :: num_basis_functions => cgto_num_basis_functions end type cgto_type","tags":"","url":"type/cgto_type.html"},{"title":"molecular_basis_type – metalquicha ","text":"type, public :: molecular_basis_type Molecular basis set data structure (assembled basis) Inherits type~~molecular_basis_type~~InheritsGraph type~molecular_basis_type molecular_basis_type type~atomic_basis_type atomic_basis_type type~molecular_basis_type->type~atomic_basis_type elements type~cgto_type cgto_type type~atomic_basis_type->type~cgto_type shells Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~molecular_basis_type~~InheritedByGraph type~molecular_basis_type molecular_basis_type type~physical_fragment_t physical_fragment_t type~physical_fragment_t->type~molecular_basis_type basis Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( atomic_basis_type ), public, allocatable :: elements (:) array of atomic basis types integer, public :: nelements total number of atoms/elements in a molecule Type-Bound Procedures procedure, public :: allocate_elements => basis_set_allocate_elements private pure subroutine basis_set_allocate_elements (self, nelements) Allocate array of atomic basis elements in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements procedure, public :: destroy => basis_set_destroy private pure subroutine basis_set_destroy (self) Clean up allocated memory in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self procedure, public :: num_basis_functions => molecular_basis_num_basis_functions private pure function molecular_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for the molecule Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Source Code type :: molecular_basis_type !! Molecular basis set data structure (assembled basis) type ( atomic_basis_type ), allocatable :: elements (:) !! array of atomic basis types integer :: nelements !! total number of atoms/elements in a molecule contains procedure :: allocate_elements => basis_set_allocate_elements procedure :: destroy => basis_set_destroy procedure :: num_basis_functions => molecular_basis_num_basis_functions end type molecular_basis_type","tags":"","url":"type/molecular_basis_type.html"},{"title":"calculation_result_t – metalquicha ","text":"type, public :: calculation_result_t Container for quantum chemistry calculation results Stores computed quantities from QC calculations with flags\nindicating which properties have been computed. Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dipole (:) Dipole moment vector (3) (Debye) real(kind=dp), public :: energy = 0.0_dp Total electronic energy (Hartree) real(kind=dp), public, allocatable :: gradient (:,:) Energy gradient (3, natoms) (Hartree/Bohr) logical, public :: has_dipole = .false. Dipole moment has been computed logical, public :: has_energy = .false. Energy has been computed logical, public :: has_gradient = .false. Gradient has been computed logical, public :: has_hessian = .false. Hessian has been computed real(kind=dp), public, allocatable :: hessian (:,:) Energy hessian (future implementation) Type-Bound Procedures procedure, public :: destroy => result_destroy Clean up allocated memory private  subroutine result_destroy (this) Clean up allocated memory in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this procedure, public :: reset => result_reset Reset all values and flags private  subroutine result_reset (this) Reset all values and flags in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Source Code type :: calculation_result_t !! Container for quantum chemistry calculation results !! !! Stores computed quantities from QC calculations with flags !! indicating which properties have been computed. real ( dp ) :: energy = 0.0_dp !! Total electronic energy (Hartree) real ( dp ), allocatable :: gradient (:, :) !! Energy gradient (3, natoms) (Hartree/Bohr) real ( dp ), allocatable :: hessian (:, :) !! Energy hessian (future implementation) real ( dp ), allocatable :: dipole (:) !! Dipole moment vector (3) (Debye) ! Computation status flags logical :: has_energy = . false . !! Energy has been computed logical :: has_gradient = . false . !! Gradient has been computed logical :: has_hessian = . false . !! Hessian has been computed logical :: has_dipole = . false . !! Dipole moment has been computed contains procedure :: destroy => result_destroy !! Clean up allocated memory procedure :: reset => result_reset !! Reset all values and flags end type calculation_result_t","tags":"","url":"type/calculation_result_t.html"},{"title":"xtb_method_t – metalquicha ","text":"type, public, extends( qc_method_t ) :: xtb_method_t Extended Tight-Binding (xTB) method implementation Concrete implementation of the abstract quantum chemistry method\ninterface for GFN1-xTB and GFN2-xTB calculations via tblite. Inherits type~~xtb_method_t~~InheritsGraph type~xtb_method_t xtb_method_t type~qc_method_t qc_method_t type~xtb_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=wp), public :: accuracy = 0.01_wp Numerical accuracy parameter real(kind=wp), public :: kt = 300.0_wp*3.166808578545117e-06_wp Electronic temperature (300 K) character(len=:), public, allocatable :: variant XTB variant: “gfn1” or “gfn2” logical, public :: verbose = .false. Print calculation details Type-Bound Procedures procedure, public :: calc_energy => xtb_calc_energy Energy-only calculation private  subroutine xtb_calc_energy (this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_gradient => xtb_calc_gradient Energy + gradient calculation private  subroutine xtb_calc_gradient (this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code type , extends ( qc_method_t ) :: xtb_method_t !! Extended Tight-Binding (xTB) method implementation !! !! Concrete implementation of the abstract quantum chemistry method !! interface for GFN1-xTB and GFN2-xTB calculations via tblite. character ( len = :), allocatable :: variant !! XTB variant: \"gfn1\" or \"gfn2\" logical :: verbose = . false . !! Print calculation details real ( wp ) :: accuracy = 0.01_wp !! Numerical accuracy parameter real ( wp ) :: kt = 30 0.0_wp * 3.166808578545117e-06_wp !! Electronic temperature (300 K) contains procedure :: calc_energy => xtb_calc_energy !! Energy-only calculation procedure :: calc_gradient => xtb_calc_gradient !! Energy + gradient calculation end type xtb_method_t","tags":"","url":"type/xtb_method_t.html"},{"title":"basis_file_t – metalquicha ","text":"type, public :: basis_file_t Container for basis set file contents Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: data_section character(len=:), public, allocatable :: full_content Source Code type :: basis_file_t !! Container for basis set file contents character ( len = :), allocatable :: full_content character ( len = :), allocatable :: data_section end type basis_file_t","tags":"","url":"type/basis_file_t.html"},{"title":"cli_args_type – metalquicha ","text":"type, public :: cli_args_type Container for parsed command line arguments Stores file paths and options extracted from command line,\nwith automatic memory management for string allocations. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: basis_name Basis set name (e.g., “6-31G”) character(len=:), public, allocatable :: xyz_file Input XYZ geometry file path Type-Bound Procedures procedure, public :: destroy => cli_args_destroy Memory cleanup private  subroutine cli_args_destroy (this) Clean up CLI args Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this Source Code type :: cli_args_type !! Container for parsed command line arguments !! !! Stores file paths and options extracted from command line, !! with automatic memory management for string allocations. character ( len = :), allocatable :: xyz_file !! Input XYZ geometry file path character ( len = :), allocatable :: basis_name !! Basis set name (e.g., \"6-31G\") contains procedure :: destroy => cli_args_destroy !! Memory cleanup end type cli_args_type","tags":"","url":"type/cli_args_type.html"},{"title":"geometry_type – metalquicha ","text":"type, public :: geometry_type Molecular geometry data structure Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: comment real(kind=dp), public, allocatable :: coords (:,:) character(len=:), public, allocatable :: elements (:) integer, public :: natoms Type-Bound Procedures procedure, public :: destroy => geometry_destroy private  subroutine geometry_destroy (this) Clean up allocated memory in geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this Source Code type :: geometry_type !! Molecular geometry data structure integer :: natoms character ( len = :), allocatable :: elements (:) real ( dp ), allocatable :: coords (:, :) ! coords(3, natoms) character ( len = :), allocatable :: comment contains procedure :: destroy => geometry_destroy end type geometry_type","tags":"","url":"type/geometry_type.html"},{"title":"qc_method_t – metalquicha ","text":"type, public, abstract :: qc_method_t Abstract base type for all quantum chemistry methods Defines the required interface for energy and gradient calculations\nthat must be implemented by all concrete method types (XTB, HF, etc.). Inherited by type~~qc_method_t~~InheritedByGraph type~qc_method_t qc_method_t type~hf_method_t hf_method_t type~hf_method_t->type~qc_method_t type~xtb_method_t xtb_method_t type~xtb_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( calc_energy_interface ), public, deferred :: calc_energy Energy calculation interface subroutine calc_energy_interface(this, fragment, result) Prototype Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results procedure( calc_gradient_interface ), public, deferred :: calc_gradient Gradient calculation interface subroutine calc_gradient_interface(this, fragment, result) Prototype Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Source Code type , abstract :: qc_method_t !! Abstract base type for all quantum chemistry methods !! !! Defines the required interface for energy and gradient calculations !! that must be implemented by all concrete method types (XTB, HF, etc.). contains procedure ( calc_energy_interface ), deferred :: calc_energy !! Energy calculation interface procedure ( calc_gradient_interface ), deferred :: calc_gradient !! Gradient calculation interface end type qc_method_t","tags":"","url":"type/qc_method_t.html"},{"title":"hf_method_t – metalquicha ","text":"type, public, extends( qc_method_t ) :: hf_method_t Hartree-Fock method implementation Inherits type~~hf_method_t~~InheritsGraph type~hf_method_t hf_method_t type~hf_options_t hf_options_t type~hf_method_t->type~hf_options_t options type~qc_method_t qc_method_t type~hf_method_t->type~qc_method_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( hf_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => hf_calc_energy private  subroutine hf_calc_energy (this, fragment, result) Calculate electronic energy using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result procedure, public :: calc_gradient => hf_calc_gradient private  subroutine hf_calc_gradient (this, fragment, result) Calculate energy gradient using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Source Code type , extends ( qc_method_t ) :: hf_method_t !! Hartree-Fock method implementation type ( hf_options_t ) :: options contains procedure :: calc_energy => hf_calc_energy procedure :: calc_gradient => hf_calc_gradient end type hf_method_t","tags":"","url":"type/hf_method_t.html"},{"title":"hf_options_t – metalquicha ","text":"type, public :: hf_options_t Hartree-Fock calculation options Inherited by type~~hf_options_t~~InheritedByGraph type~hf_options_t hf_options_t type~hf_method_t hf_method_t type~hf_method_t->type~hf_options_t options Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), public :: conv_tol = 1.0e-8_dp Energy convergence threshold integer, public :: max_iter = 100 Maximum SCF iterations logical, public :: spherical = .false. Use spherical (true) or Cartesian (false) basis logical, public :: verbose = .true. Print SCF iterations Source Code type :: hf_options_t !! Hartree-Fock calculation options integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: conv_tol = 1.0e-8_dp !! Energy convergence threshold logical :: spherical = . false . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . true . !! Print SCF iterations end type hf_options_t","tags":"","url":"type/hf_options_t.html"},{"title":"fragment_lookup_t – metalquicha ","text":"type, public :: fragment_lookup_t Hash-based lookup table for O(1) fragment index retrieval Inherits type~~fragment_lookup_t~~InheritsGraph type~fragment_lookup_t fragment_lookup_t type~hash_entry_t hash_entry_t type~fragment_lookup_t->type~hash_entry_t table type~hash_entry_t->type~hash_entry_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: initialized = .false. integer(kind=int64), public :: n_entries = 0 type( hash_entry_t ), public, allocatable :: table (:) integer, public :: table_size = 0 Type-Bound Procedures procedure, public :: destroy => fragment_lookup_destroy private  subroutine fragment_lookup_destroy (this) Clean up hash table and all chains Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this procedure, public :: find => fragment_lookup_find private  function fragment_lookup_find (this, monomers, n) result(idx) Find fragment index for given monomer combination Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) procedure, public :: init => fragment_lookup_init private  subroutine fragment_lookup_init (this, estimated_entries) Initialize hash table with estimated size Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries procedure, public :: insert => fragment_lookup_insert private  subroutine fragment_lookup_insert (this, monomers, n, fragment_idx) Insert a monomer combination -> fragment index mapping Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx Source Code type :: fragment_lookup_t !! Hash-based lookup table for O(1) fragment index retrieval integer :: table_size = 0 type ( hash_entry_t ), allocatable :: table (:) integer ( int64 ) :: n_entries = 0 logical :: initialized = . false . contains procedure :: init => fragment_lookup_init procedure :: insert => fragment_lookup_insert procedure :: find => fragment_lookup_find procedure :: destroy => fragment_lookup_destroy end type fragment_lookup_t","tags":"","url":"type/fragment_lookup_t.html"},{"title":"hash_entry_t – metalquicha ","text":"type, private :: hash_entry_t Single entry in hash table (private helper type) Inherited by type~~hash_entry_t~~InheritedByGraph type~hash_entry_t hash_entry_t type~hash_entry_t->type~hash_entry_t next type~fragment_lookup_t fragment_lookup_t type~fragment_lookup_t->type~hash_entry_t table Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public, allocatable :: key (:) Sorted monomer indices type( hash_entry_t ), public, pointer :: next => null() Chain for collisions integer(kind=int64), public :: value Fragment index Source Code type :: hash_entry_t !! Single entry in hash table (private helper type) integer , allocatable :: key (:) !! Sorted monomer indices integer ( int64 ) :: value !! Fragment index type ( hash_entry_t ), pointer :: next => null () !! Chain for collisions end type hash_entry_t","tags":"","url":"type/hash_entry_t.html"},{"title":"calc_energy_interface – metalquicha","text":"interface private  subroutine calc_energy_interface(this, fragment, result) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results Description Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method.","tags":"","url":"interface/calc_energy_interface.html"},{"title":"calc_gradient_interface – metalquicha","text":"interface private  subroutine calc_gradient_interface(this, fragment, result) Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Description Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method.","tags":"","url":"interface/calc_gradient_interface.html"},{"title":"get_logger_level – metalquicha","text":"public  function get_logger_level(level_string) result(level_int) Uses pic_logger proc~~get_logger_level~~UsesGraph proc~get_logger_level get_logger_level pic_logger pic_logger proc~get_logger_level->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Convert string log level to integer value\nThis function uses the pic_logger constants Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: level_string Return Value integer Called by proc~~get_logger_level~~CalledByGraph proc~get_logger_level get_logger_level program~main main program~main->proc~get_logger_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_logger_level ( level_string ) result ( level_int ) !! Convert string log level to integer value !! This function uses the pic_logger constants use pic_logger , only : debug_level , verbose_level , info_level , performance_level , & warning_level , error_level , knowledge_level character ( len =* ), intent ( in ) :: level_string integer :: level_int select case ( trim ( adjustl ( level_string ))) case ( 'debug' , 'Debug' , 'DEBUG' ) level_int = debug_level case ( 'verbose' , 'Verbose' , 'VERBOSE' ) level_int = verbose_level case ( 'info' , 'Info' , 'INFO' ) level_int = info_level case ( 'performance' , 'Performance' , 'PERFORMANCE' ) level_int = performance_level case ( 'warning' , 'Warning' , 'WARNING' ) level_int = warning_level case ( 'error' , 'Error' , 'ERROR' ) level_int = error_level case ( 'knowledge' , 'Knowledge' , 'KNOWLEDGE' ) level_int = knowledge_level case default ! Default to info level if unknown level_int = info_level end select end function get_logger_level","tags":"","url":"proc/get_logger_level.html"},{"title":"remove_quotes – metalquicha","text":"private  function remove_quotes(str) result(cleaned) Remove surrounding quotes from string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:), allocatable Called by proc~~remove_quotes~~CalledByGraph proc~remove_quotes remove_quotes proc~read_input_file read_input_file proc~read_input_file->proc~remove_quotes program~main main program~main->proc~read_input_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: end_pos integer, private :: start_pos character(len=len), private :: temp Source Code function remove_quotes ( str ) result ( cleaned ) !! Remove surrounding quotes from string character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: cleaned character ( len = len ( str )) :: temp integer :: start_pos , end_pos temp = adjustl ( str ) start_pos = 1 end_pos = len_trim ( temp ) ! Remove leading quote if ( end_pos > 0 ) then if ( temp ( 1 : 1 ) == '\"' . or . temp ( 1 : 1 ) == \"'\" ) then start_pos = 2 end if end if ! Remove trailing quote if ( end_pos > 0 ) then if ( temp ( end_pos : end_pos ) == '\"' . or . temp ( end_pos : end_pos ) == \"'\" ) then end_pos = end_pos - 1 end if end if if ( end_pos >= start_pos ) then cleaned = temp ( start_pos : end_pos ) else cleaned = \"\" end if end function remove_quotes","tags":"","url":"proc/remove_quotes.html"},{"title":"read_input_file – metalquicha","text":"public  subroutine read_input_file(filename, config, stat, errmsg) Simple parser for key=value input files\nLooks for: geom=”path/to/geometry.xyz”\n           monomer_symbols=”path/to/monomer.xyz”\n           method=”gfn1” or “gfn2” (defaults to gfn2)\n           nlevel=N (fragmentation level, defaults to 1)\n           log_level=”debug|verbose|info|performance|warning|error|knowledge” (defaults to info) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Path to input file to parse type( input_config_t ), intent(out) :: config Parsed configuration data integer, intent(out) :: stat Status code (0 = success, >0 = error) character(len=:), intent(out), allocatable :: errmsg Error message on failure Calls proc~~read_input_file~~CallsGraph proc~read_input_file read_input_file proc~remove_quotes remove_quotes proc~read_input_file->proc~remove_quotes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_input_file~~CalledByGraph proc~read_input_file read_input_file program~main main program~main->proc~read_input_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: eq_pos Position of ‘=’ character in line logical, private :: file_exists Whether input file exists integer, private :: io_stat I/O operation status character(len=512), private :: key Parsed key name character(len=512), private :: line Current line being parsed integer, private :: unit File unit number character(len=512), private :: value Parsed value string Source Code subroutine read_input_file ( filename , config , stat , errmsg ) !! Simple parser for key=value input files !! Looks for: geom=\"path/to/geometry.xyz\" !!            monomer_symbols=\"path/to/monomer.xyz\" !!            method=\"gfn1\" or \"gfn2\" (defaults to gfn2) !!            nlevel=N (fragmentation level, defaults to 1) !!            log_level=\"debug|verbose|info|performance|warning|error|knowledge\" (defaults to info) character ( len =* ), intent ( in ) :: filename !! Path to input file to parse type ( input_config_t ), intent ( out ) :: config !! Parsed configuration data integer , intent ( out ) :: stat !! Status code (0 = success, >0 = error) character ( len = :), allocatable , intent ( out ) :: errmsg !! Error message on failure integer :: unit !! File unit number integer :: io_stat !! I/O operation status character ( len = 512 ) :: line !! Current line being parsed character ( len = 512 ) :: key !! Parsed key name character ( len = 512 ) :: value !! Parsed value string integer :: eq_pos !! Position of '=' character in line logical :: file_exists !! Whether input file exists stat = 0 inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then stat = 1 errmsg = \"Input file not found: \" // trim ( filename ) return end if open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then stat = io_stat errmsg = \"Error opening input file: \" // trim ( filename ) return end if ! Read line by line do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit ! Skip empty lines and comments line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Find '=' sign eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle ! Extract key and value key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) ! Remove quotes from value if present value = remove_quotes ( value ) ! Parse recognized keys select case ( trim ( key )) case ( 'geom' ) config % geom_file = trim ( value ) case ( 'monomer_symbols' ) config % monomer_file = trim ( value ) case ( 'method' ) ! Validate that method is gfn1 or gfn2 select case ( trim ( value )) case ( 'gfn1' , 'gfn2' ) config % method = trim ( value ) case default stat = 1 errmsg = \"Invalid method: \" // trim ( value ) // \" (supported: gfn1, gfn2)\" return end select case ( 'nlevel' ) read ( value , * , iostat = io_stat ) config % nlevel if ( io_stat /= 0 ) then stat = 1 errmsg = \"Invalid value for nlevel: \" // trim ( value ) return end if if ( config % nlevel < 0 ) then stat = 1 errmsg = \"nlevel must be >= 0 (0 for unfragmented calculation)\" return end if case ( 'log_level' ) ! Validate log level select case ( trim ( value )) case ( 'debug' , 'Debug' , 'DEBUG' , & 'verbose' , 'Verbose' , 'VERBOSE' , & 'info' , 'Info' , 'INFO' , & 'performance' , 'Performance' , 'PERFORMANCE' , & 'warning' , 'Warning' , 'WARNING' , & 'error' , 'Error' , 'ERROR' , & 'knowledge' , 'Knowledge' , 'KNOWLEDGE' ) config % log_level = trim ( value ) case default stat = 1 errmsg = \"Invalid log_level: \" // trim ( value ) // & \" (supported: debug, verbose, info, performance, warning, error, knowledge)\" return end select case default ! Ignore unrecognized keys continue end select end do close ( unit ) ! Validate required fields if (. not . allocated ( config % geom_file )) then stat = 1 errmsg = \"Missing required field: geom\" return end if if (. not . allocated ( config % monomer_file )) then stat = 1 errmsg = \"Missing required field: monomer_symbols\" return end if ! Set default method if not specified if (. not . allocated ( config % method )) then config % method = \"gfn2\" ! Default to GFN2-xTB end if ! Set default log_level if not specified if (. not . allocated ( config % log_level )) then config % log_level = \"info\" ! Default to info level end if end subroutine read_input_file","tags":"","url":"proc/read_input_file.html"},{"title":"config_destroy – metalquicha","text":"private  subroutine config_destroy(this) Clean up allocated memory in input_config_t Type Bound input_config_t Arguments Type Intent Optional Attributes Name class( input_config_t ), intent(inout) :: this Called by proc~~config_destroy~~CalledByGraph proc~config_destroy input_config_t%config_destroy program~main main program~main->proc~config_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine config_destroy ( this ) !! Clean up allocated memory in input_config_t class ( input_config_t ), intent ( inout ) :: this if ( allocated ( this % geom_file )) deallocate ( this % geom_file ) if ( allocated ( this % monomer_file )) deallocate ( this % monomer_file ) if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % log_level )) deallocate ( this % log_level ) end subroutine config_destroy","tags":"","url":"proc/config_destroy.html"},{"title":"distance_between_fragments – metalquicha","text":"public pure function distance_between_fragments(frag1, frag2, use_com) result(distance) Calculate distance between two fragments\nIf use_com is .true., uses center of mass; otherwise uses centroid\nDistance is in the same units as the fragment coordinates (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: frag1 type( physical_fragment_t ), intent(in) :: frag2 logical, intent(in) :: use_com Return Value real(kind=dp) Calls proc~~distance_between_fragments~~CallsGraph proc~distance_between_fragments distance_between_fragments proc~distance_between_points distance_between_points proc~distance_between_fragments->proc~distance_between_points proc~fragment_center_of_mass fragment_center_of_mass proc~distance_between_fragments->proc~fragment_center_of_mass proc~fragment_centroid fragment_centroid proc~distance_between_fragments->proc~fragment_centroid proc~element_mass element_mass proc~fragment_center_of_mass->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: point1 (3) real(kind=dp), private :: point2 (3) Source Code pure function distance_between_fragments ( frag1 , frag2 , use_com ) result ( distance ) !! Calculate distance between two fragments !! If use_com is .true., uses center of mass; otherwise uses centroid !! Distance is in the same units as the fragment coordinates (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: frag1 , frag2 logical , intent ( in ) :: use_com real ( dp ) :: distance real ( dp ) :: point1 ( 3 ), point2 ( 3 ) if ( use_com ) then point1 = fragment_center_of_mass ( frag1 ) point2 = fragment_center_of_mass ( frag2 ) else point1 = fragment_centroid ( frag1 ) point2 = fragment_centroid ( frag2 ) end if distance = distance_between_points ( point1 , point2 ) end function distance_between_fragments","tags":"","url":"proc/distance_between_fragments.html"},{"title":"distance_between_points – metalquicha","text":"public pure function distance_between_points(point1, point2) result(distance) Calculate Euclidean distance between two 3D points\nPoints should be in the same units (typically Bohr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: point1 (3) real(kind=dp), intent(in) :: point2 (3) Return Value real(kind=dp) Called by proc~~distance_between_points~~CalledByGraph proc~distance_between_points distance_between_points proc~distance_between_fragments distance_between_fragments proc~distance_between_fragments->proc~distance_between_points proc~minimal_distance_between_fragments minimal_distance_between_fragments proc~minimal_distance_between_fragments->proc~distance_between_points Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: diff (3) Source Code pure function distance_between_points ( point1 , point2 ) result ( distance ) !! Calculate Euclidean distance between two 3D points !! Points should be in the same units (typically Bohr) real ( dp ), intent ( in ) :: point1 ( 3 ), point2 ( 3 ) real ( dp ) :: distance real ( dp ) :: diff ( 3 ) diff = point2 - point1 distance = sqrt ( dot_product ( diff , diff )) end function distance_between_points","tags":"","url":"proc/distance_between_points.html"},{"title":"fragment_center_of_mass – metalquicha","text":"public pure function fragment_center_of_mass(fragment) result(com) Calculate the center of mass of a fragment\nWeights each atomic position by its atomic mass\nReturns coordinates in the same units as the fragment (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment Return Value real(kind=dp), (3) Calls proc~~fragment_center_of_mass~~CallsGraph proc~fragment_center_of_mass fragment_center_of_mass proc~element_mass element_mass proc~fragment_center_of_mass->proc~element_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_center_of_mass~~CalledByGraph proc~fragment_center_of_mass fragment_center_of_mass proc~distance_between_fragments distance_between_fragments proc~distance_between_fragments->proc~fragment_center_of_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: atom_mass integer, private :: i real(kind=dp), private :: total_mass Source Code pure function fragment_center_of_mass ( fragment ) result ( com ) !! Calculate the center of mass of a fragment !! Weights each atomic position by its atomic mass !! Returns coordinates in the same units as the fragment (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ) :: com ( 3 ) real ( dp ) :: total_mass , atom_mass integer :: i com = 0.0_dp total_mass = 0.0_dp do i = 1 , fragment % n_atoms atom_mass = element_mass ( fragment % element_numbers ( i )) com = com + atom_mass * fragment % coordinates (:, i ) total_mass = total_mass + atom_mass end do com = com / total_mass end function fragment_center_of_mass","tags":"","url":"proc/fragment_center_of_mass.html"},{"title":"fragment_centroid – metalquicha","text":"public pure function fragment_centroid(fragment) result(centroid) Calculate the geometric centroid (center of geometry) of a fragment\nThis is the simple average of all atomic coordinates\nReturns coordinates in the same units as the fragment (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment Return Value real(kind=dp), (3) Called by proc~~fragment_centroid~~CalledByGraph proc~fragment_centroid fragment_centroid proc~distance_between_fragments distance_between_fragments proc~distance_between_fragments->proc~fragment_centroid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure function fragment_centroid ( fragment ) result ( centroid ) !! Calculate the geometric centroid (center of geometry) of a fragment !! This is the simple average of all atomic coordinates !! Returns coordinates in the same units as the fragment (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ) :: centroid ( 3 ) integer :: i centroid = 0.0_dp do i = 1 , fragment % n_atoms centroid = centroid + fragment % coordinates (:, i ) end do centroid = centroid / real ( fragment % n_atoms , dp ) end function fragment_centroid","tags":"","url":"proc/fragment_centroid.html"},{"title":"minimal_distance_between_fragments – metalquicha","text":"public pure function minimal_distance_between_fragments(frag1, frag2) result(min_distance) Calculate the minimal distance between any two atoms in two fragments\nThis iterates over all atom pairs and finds the closest pair\nDistance is in the same units as the fragment coordinates (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: frag1 type( physical_fragment_t ), intent(in) :: frag2 Return Value real(kind=dp) Calls proc~~minimal_distance_between_fragments~~CallsGraph proc~minimal_distance_between_fragments minimal_distance_between_fragments proc~distance_between_points distance_between_points proc~minimal_distance_between_fragments->proc~distance_between_points Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: current_distance integer, private :: i integer, private :: j Source Code pure function minimal_distance_between_fragments ( frag1 , frag2 ) result ( min_distance ) !! Calculate the minimal distance between any two atoms in two fragments !! This iterates over all atom pairs and finds the closest pair !! Distance is in the same units as the fragment coordinates (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: frag1 , frag2 real ( dp ) :: min_distance real ( dp ) :: current_distance integer :: i , j ! Initialize with a very large value min_distance = huge ( 1.0_dp ) do i = 1 , frag1 % n_atoms do j = 1 , frag2 % n_atoms current_distance = distance_between_points ( frag1 % coordinates (:, i ), & frag2 % coordinates (:, j )) if ( current_distance < min_distance ) then min_distance = current_distance end if end do end do end function minimal_distance_between_fragments","tags":"","url":"proc/minimal_distance_between_fragments.html"},{"title":"to_angstrom – metalquicha","text":"public pure elemental function to_angstrom(bohr_value) result(angstrom_value) Convert coordinate from Bohr to Angstrom Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: bohr_value Return Value real(kind=dp) Called by proc~~to_angstrom~~CalledByGraph proc~to_angstrom to_angstrom proc~print_fragment_xyz print_fragment_xyz proc~print_fragment_xyz->proc~to_angstrom proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental function to_angstrom ( bohr_value ) result ( angstrom_value ) !! Convert coordinate from Bohr to Angstrom real ( dp ), intent ( in ) :: bohr_value real ( dp ) :: angstrom_value angstrom_value = bohr_value * bohr_radius end function to_angstrom","tags":"","url":"proc/to_angstrom.html"},{"title":"to_bohr – metalquicha","text":"public pure elemental function to_bohr(angstrom_value) result(bohr_value) Convert coordinate from Angstrom to Bohr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: angstrom_value Return Value real(kind=dp) Called by proc~~to_bohr~~CalledByGraph proc~to_bohr to_bohr proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~to_bohr program~main main program~main->proc~initialize_system_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental function to_bohr ( angstrom_value ) result ( bohr_value ) !! Convert coordinate from Angstrom to Bohr real ( dp ), intent ( in ) :: angstrom_value real ( dp ) :: bohr_value bohr_value = angstrom_value / bohr_radius end function to_bohr","tags":"","url":"proc/to_bohr.html"},{"title":"build_fragment_from_indices – metalquicha","text":"public pure subroutine build_fragment_from_indices(sys_geom, monomer_indices, fragment) Build a fragment on-the-fly from monomer indices\ne.g., monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5 Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) type( physical_fragment_t ), intent(out) :: fragment Called by proc~~build_fragment_from_indices~~CalledByGraph proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker node_worker proc~node_worker->proc~build_fragment_from_indices proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~build_fragment_from_indices proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~build_fragment_from_indices proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: atom_end integer, private :: atom_start integer, private :: atoms_per_monomer integer, private :: frag_atom_idx integer, private :: i integer, private :: mono_idx integer, private :: n_monomers_in_frag Source Code pure subroutine build_fragment_from_indices ( sys_geom , monomer_indices , fragment ) !! Build a fragment on-the-fly from monomer indices !! e.g., monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5 type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) type ( physical_fragment_t ), intent ( out ) :: fragment integer :: n_monomers_in_frag , atoms_per_monomer integer :: i , mono_idx , atom_start , atom_end , frag_atom_idx n_monomers_in_frag = size ( monomer_indices ) atoms_per_monomer = sys_geom % atoms_per_monomer fragment % n_atoms = n_monomers_in_frag * atoms_per_monomer allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) frag_atom_idx = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer + 1 atom_end = mono_idx * atoms_per_monomer fragment % element_numbers ( frag_atom_idx + 1 : frag_atom_idx + atoms_per_monomer ) = & sys_geom % element_numbers ( atom_start : atom_end ) fragment % coordinates (:, frag_atom_idx + 1 : frag_atom_idx + atoms_per_monomer ) = & sys_geom % coordinates (:, atom_start : atom_end ) frag_atom_idx = frag_atom_idx + atoms_per_monomer end do end subroutine build_fragment_from_indices","tags":"","url":"proc/build_fragment_from_indices.html"},{"title":"initialize_system_geometry – metalquicha","text":"public  subroutine initialize_system_geometry(full_geom_file, monomer_file, sys_geom, stat, errmsg) Read full geometry and monomer template, initialize system_geometry_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full_geom_file character(len=*), intent(in) :: monomer_file type( system_geometry_t ), intent(out) :: sys_geom integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg Calls proc~~initialize_system_geometry~~CallsGraph proc~initialize_system_geometry initialize_system_geometry proc~element_symbol_to_number element_symbol_to_number proc~initialize_system_geometry->proc~element_symbol_to_number proc~geometry_destroy geometry_type%geometry_destroy proc~initialize_system_geometry->proc~geometry_destroy proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~to_bohr to_bohr proc~initialize_system_geometry->proc~to_bohr to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~initialize_system_geometry~~CalledByGraph proc~initialize_system_geometry initialize_system_geometry program~main main program~main->proc~initialize_system_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( geometry_type ), private :: full_geom integer, private :: i type( geometry_type ), private :: monomer_geom Source Code subroutine initialize_system_geometry ( full_geom_file , monomer_file , sys_geom , stat , errmsg ) !! Read full geometry and monomer template, initialize system_geometry_t character ( len =* ), intent ( in ) :: full_geom_file , monomer_file type ( system_geometry_t ), intent ( out ) :: sys_geom integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg type ( geometry_type ) :: full_geom , monomer_geom integer :: i call read_xyz_file ( full_geom_file , full_geom , stat , errmsg ) if ( stat /= 0 ) return ! Read monomer template ! this will be changed once we have a proper input file parsing call read_xyz_file ( monomer_file , monomer_geom , stat , errmsg ) if ( stat /= 0 ) then call full_geom % destroy () return end if ! Validate that full geometry is a multiple of monomer size sys_geom % atoms_per_monomer = monomer_geom % natoms sys_geom % total_atoms = full_geom % natoms if ( mod ( sys_geom % total_atoms , sys_geom % atoms_per_monomer ) /= 0 ) then stat = 1 errmsg = \"Full geometry atoms not a multiple of monomer atoms\" call full_geom % destroy () call monomer_geom % destroy () return end if sys_geom % n_monomers = sys_geom % total_atoms / sys_geom % atoms_per_monomer ! TODO JORGE: this can be a sys_geom%allocate() allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( full_geom % elements ( i )) end do ! Store coordinates in Bohr (convert from Angstroms) ! TODO JORGE: need a way to handle units sys_geom % coordinates = to_bohr ( full_geom % coords ) call full_geom % destroy () call monomer_geom % destroy () stat = 0 end subroutine initialize_system_geometry","tags":"","url":"proc/initialize_system_geometry.html"},{"title":"fragment_compute_nelec – metalquicha","text":"private  subroutine fragment_compute_nelec(this) Compute number of electrons from atomic numbers and charge Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this Variables Type Visibility Attributes Name Initial integer, private :: nuclear_charge Source Code subroutine fragment_compute_nelec ( this ) !! Compute number of electrons from atomic numbers and charge class ( physical_fragment_t ), intent ( inout ) :: this integer :: nuclear_charge nuclear_charge = sum ( this % element_numbers ) this % nelec = nuclear_charge - this % charge end subroutine fragment_compute_nelec","tags":"","url":"proc/fragment_compute_nelec.html"},{"title":"fragment_destroy – metalquicha","text":"private  subroutine fragment_destroy(this) Clean up allocated memory in physical_fragment_t Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this Calls proc~~fragment_destroy~~CallsGraph proc~fragment_destroy physical_fragment_t%fragment_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_destroy~~CalledByGraph proc~fragment_destroy physical_fragment_t%fragment_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fragment_destroy ( this ) !! Clean up allocated memory in physical_fragment_t class ( physical_fragment_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if this % n_atoms = 0 this % charge = 0 this % multiplicity = 1 this % nelec = 0 end subroutine fragment_destroy","tags":"","url":"proc/fragment_destroy.html"},{"title":"fragment_set_basis – metalquicha","text":"private  subroutine fragment_set_basis(this, basis) Set the basis set for this fragment Type Bound physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis Calls proc~~fragment_set_basis~~CallsGraph proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_set_basis->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fragment_set_basis ( this , basis ) !! Set the basis set for this fragment class ( physical_fragment_t ), intent ( inout ) :: this type ( molecular_basis_type ), intent ( in ) :: basis if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if allocate ( this % basis ) this % basis = basis end subroutine fragment_set_basis","tags":"","url":"proc/fragment_set_basis.html"},{"title":"system_destroy – metalquicha","text":"private  subroutine system_destroy(this) Clean up allocated memory in system_geometry_t Type Bound system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this Source Code subroutine system_destroy ( this ) !! Clean up allocated memory in system_geometry_t class ( system_geometry_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) this % n_monomers = 0 this % atoms_per_monomer = 0 this % total_atoms = 0 end subroutine system_destroy","tags":"","url":"proc/system_destroy.html"},{"title":"atomic_basis_num_basis_functions – metalquicha","text":"private pure function atomic_basis_num_basis_functions(self) result(nbf) Get total number of basis functions for an atom Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer Calls proc~~atomic_basis_num_basis_functions~~CallsGraph proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~atomic_basis_num_basis_functions~~CalledByGraph proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ishell Source Code pure function atomic_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for an atom class ( atomic_basis_type ), intent ( in ) :: self integer :: nbf integer :: ishell nbf = 0 do ishell = 1 , self % nshells nbf = nbf + self % shells ( ishell )% num_basis_functions () end do end function atomic_basis_num_basis_functions","tags":"","url":"proc/atomic_basis_num_basis_functions.html"},{"title":"cgto_num_basis_functions – metalquicha","text":"private pure function cgto_num_basis_functions(self) result(nbf) Get number of basis functions in a shell (Cartesian) Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer Called by proc~~cgto_num_basis_functions~~CalledByGraph proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function cgto_num_basis_functions ( self ) result ( nbf ) !! Get number of basis functions in a shell (Cartesian) class ( cgto_type ), intent ( in ) :: self integer :: nbf ! Cartesian: (ang_mom+1)*(ang_mom+2)/2 nbf = ( self % ang_mom + 1 ) * ( self % ang_mom + 2 ) / 2 end function cgto_num_basis_functions","tags":"","url":"proc/cgto_num_basis_functions.html"},{"title":"molecular_basis_num_basis_functions – metalquicha","text":"private pure function molecular_basis_num_basis_functions(self) result(nbf) Get total number of basis functions for the molecule Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Calls proc~~molecular_basis_num_basis_functions~~CallsGraph proc~molecular_basis_num_basis_functions molecular_basis_type%molecular_basis_num_basis_functions proc~atomic_basis_num_basis_functions atomic_basis_type%atomic_basis_num_basis_functions proc~molecular_basis_num_basis_functions->proc~atomic_basis_num_basis_functions proc~cgto_num_basis_functions cgto_type%cgto_num_basis_functions proc~atomic_basis_num_basis_functions->proc~cgto_num_basis_functions Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom Source Code pure function molecular_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for the molecule class ( molecular_basis_type ), intent ( in ) :: self integer :: nbf integer :: iatom nbf = 0 do iatom = 1 , self % nelements nbf = nbf + self % elements ( iatom )% num_basis_functions () end do end function molecular_basis_num_basis_functions","tags":"","url":"proc/molecular_basis_num_basis_functions.html"},{"title":"allocate_basis_shells – metalquicha","text":"private pure subroutine allocate_basis_shells(self, nshells) Allocate array of shells in an atomic basis Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells Called by proc~~allocate_basis_shells~~CalledByGraph proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis copy_atomic_basis proc~copy_atomic_basis->proc~allocate_basis_shells proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~allocate_basis_shells proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine allocate_basis_shells ( self , nshells ) !! Allocate array of shells in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nshells self % nshells = nshells allocate ( self % shells ( nshells )) end subroutine allocate_basis_shells","tags":"","url":"proc/allocate_basis_shells.html"},{"title":"atomic_basis_destroy – metalquicha","text":"private pure subroutine atomic_basis_destroy(self) Clean up allocated memory in an atomic basis Type Bound atomic_basis_type Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self Calls proc~~atomic_basis_destroy~~CallsGraph proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~atomic_basis_destroy~~CalledByGraph proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~atomic_basis_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine atomic_basis_destroy ( self ) !! Clean up allocated memory in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % shells )) then do i = 1 , self % nshells call self % shells ( i )% destroy () end do deallocate ( self % shells ) end if if ( allocated ( self % element )) deallocate ( self % element ) self % nshells = 0 end subroutine atomic_basis_destroy","tags":"","url":"proc/atomic_basis_destroy.html"},{"title":"basis_set_allocate_elements – metalquicha","text":"private pure subroutine basis_set_allocate_elements(self, nelements) Allocate array of atomic basis elements in a molecular basis set Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements Called by proc~~basis_set_allocate_elements~~CalledByGraph proc~basis_set_allocate_elements molecular_basis_type%basis_set_allocate_elements proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~basis_set_allocate_elements Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine basis_set_allocate_elements ( self , nelements ) !! Allocate array of atomic basis elements in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nelements self % nelements = nelements allocate ( self % elements ( nelements )) end subroutine basis_set_allocate_elements","tags":"","url":"proc/basis_set_allocate_elements.html"},{"title":"basis_set_destroy – metalquicha","text":"private pure subroutine basis_set_destroy(self) Clean up allocated memory in a molecular basis set Type Bound molecular_basis_type Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self Calls proc~~basis_set_destroy~~CallsGraph proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~basis_set_destroy~~CalledByGraph proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine basis_set_destroy ( self ) !! Clean up allocated memory in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % elements )) then do i = 1 , self % nelements call self % elements ( i )% destroy () end do deallocate ( self % elements ) end if self % nelements = 0 end subroutine basis_set_destroy","tags":"","url":"proc/basis_set_destroy.html"},{"title":"cgto_allocate_arrays – metalquicha","text":"private pure subroutine cgto_allocate_arrays(self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc Called by proc~~cgto_allocate_arrays~~CalledByGraph proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis copy_atomic_basis proc~copy_atomic_basis->proc~cgto_allocate_arrays proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~cgto_allocate_arrays proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~parse_element_basis->proc~fill_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine cgto_allocate_arrays ( self , nfunc ) !! Allocate arrays for exponents and coefficients in a CGTO class ( cgto_type ), intent ( inout ) :: self integer , intent ( in ) :: nfunc self % nfunc = nfunc allocate ( self % exponents ( nfunc )) allocate ( self % coefficients ( nfunc )) end subroutine cgto_allocate_arrays","tags":"","url":"proc/cgto_allocate_arrays.html"},{"title":"cgto_destroy – metalquicha","text":"private pure subroutine cgto_destroy(self) Clean up allocated memory in a CGTO Type Bound cgto_type Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self Called by proc~~cgto_destroy~~CalledByGraph proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~atomic_basis_destroy proc~fragment_destroy physical_fragment_t%fragment_destroy proc~fragment_destroy->proc~basis_set_destroy proc~fragment_set_basis physical_fragment_t%fragment_set_basis proc~fragment_set_basis->proc~basis_set_destroy proc~node_worker node_worker proc~node_worker->proc~fragment_destroy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~fragment_destroy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine cgto_destroy ( self ) !! Clean up allocated memory in a CGTO class ( cgto_type ), intent ( inout ) :: self if ( allocated ( self % exponents )) deallocate ( self % exponents ) if ( allocated ( self % coefficients )) deallocate ( self % coefficients ) self % nfunc = 0 self % ang_mom = 0 end subroutine cgto_destroy","tags":"","url":"proc/cgto_destroy.html"},{"title":"result_destroy – metalquicha","text":"private  subroutine result_destroy(this) Clean up allocated memory in calculation_result_t Type Bound calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Calls proc~~result_destroy~~CallsGraph proc~result_destroy calculation_result_t%result_destroy proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~result_destroy~~CalledByGraph proc~result_destroy calculation_result_t%result_destroy proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~result_destroy proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_destroy ( this ) !! Clean up allocated memory in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) call this % reset () end subroutine result_destroy","tags":"","url":"proc/result_destroy.html"},{"title":"result_reset – metalquicha","text":"private  subroutine result_reset(this) Reset all values and flags in calculation_result_t Type Bound calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this Called by proc~~result_reset~~CalledByGraph proc~result_reset calculation_result_t%result_reset proc~result_destroy calculation_result_t%result_destroy proc~result_destroy->proc~result_reset proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~result_destroy proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine result_reset ( this ) !! Reset all values and flags in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this this % energy = 0.0_dp this % has_energy = . false . this % has_gradient = . false . this % has_hessian = . false . this % has_dipole = . false . end subroutine result_reset","tags":"","url":"proc/result_reset.html"},{"title":"run_calculation – metalquicha","text":"public  subroutine run_calculation(world_comm, node_comm, config, sys_geom) Main calculation dispatcher - routes to fragmented or unfragmented calculation Determines calculation type based on nlevel and dispatches to appropriate\ncalculation routine with proper MPI setup and validation. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator type( input_config_t ), intent(in) :: config Parsed input configuration type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info Calls proc~~run_calculation~~CallsGraph proc~run_calculation run_calculation info info proc~run_calculation->info omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation to_char to_char proc~run_calculation->to_char proc~run_fragmented_calculation->info proc~run_fragmented_calculation->omp_set_num_threads proc~run_fragmented_calculation->to_char allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~node_coordinator node_coordinator proc~run_fragmented_calculation->proc~node_coordinator proc~node_worker node_worker proc~run_fragmented_calculation->proc~node_worker proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->proc~serial_fragment_processor verbose verbose proc~run_fragmented_calculation->verbose proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char abort_comm abort_comm proc~run_unfragmented_calculation->abort_comm error error proc~run_unfragmented_calculation->error proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~combine combine proc~generate_fragment_list->proc~combine proc~binomial binomial proc~get_nfrags->proc~binomial proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->error proc~global_coordinator->verbose debug debug proc~global_coordinator->debug get_elapsed_time get_elapsed_time proc~global_coordinator->get_elapsed_time iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend proc~compute_mbe_energy compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker start start proc~global_coordinator->start proc~node_coordinator->to_char proc~node_coordinator->error proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend recv recv proc~node_coordinator->recv proc~node_worker->irecv proc~node_worker->isend proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~do_fragment_work do_fragment_work proc~node_worker->proc~do_fragment_work proc~fragment_destroy physical_fragment_t%fragment_destroy proc~node_worker->proc~fragment_destroy proc~node_worker->recv proc~serial_fragment_processor->info proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->to_char proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~do_fragment_work proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char proc~unfragmented_calculation->error all_monomer_indices all_monomer_indices proc~unfragmented_calculation->all_monomer_indices proc~unfragmented_calculation->proc~build_fragment_from_indices proc~unfragmented_calculation->proc~do_fragment_work temp_indices temp_indices proc~unfragmented_calculation->temp_indices proc~combine_util combine_util proc~combine->proc~combine_util proc~compute_mbe_energy->info proc~compute_mbe_energy->to_char proc~compute_mbe_energy->debug proc~compute_mbe_energy->get_elapsed_time proc~compute_mbe_energy->start configuration configuration proc~compute_mbe_energy->configuration proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~do_fragment_work->configuration proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~result_destroy calculation_result_t%result_destroy proc~do_fragment_work->proc~result_destroy proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~combine_util->proc~combine_util proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort proc~print_detailed_breakdown->verbose header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->info proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~print_detailed_breakdown_json->warning proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_calculation~~CalledByGraph proc~run_calculation run_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: matrix_size Size of gradient matrix (natoms*3), tmp integer, private :: max_level Maximum fragment level (nlevel from config) Source Code subroutine run_calculation ( world_comm , node_comm , config , sys_geom ) !! Main calculation dispatcher - routes to fragmented or unfragmented calculation !! !! Determines calculation type based on nlevel and dispatches to appropriate !! calculation routine with proper MPI setup and validation. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator type ( input_config_t ), intent ( in ) :: config !! Parsed input configuration type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info ! Local variables integer :: max_level !! Maximum fragment level (nlevel from config) integer :: matrix_size !! Size of gradient matrix (natoms*3), tmp ! Set max_level from config ! TODO JORGE: change to max fragmentation level max_level = config % nlevel ! Set matrix_size based on atoms per monomer (natoms * 3 for gradient) ! TODO JORGE: this is temporary, until we define a result_struct that will initialize itself matrix_size = sys_geom % atoms_per_monomer * 3 if ( world_comm % rank () == 0 ) then call logger % info ( \"============================================\" ) call logger % info ( \"Loaded geometry:\" ) call logger % info ( \"  Total monomers: \" // to_char ( sys_geom % n_monomers )) call logger % info ( \"  Atoms per monomer: \" // to_char ( sys_geom % atoms_per_monomer )) call logger % info ( \"  Total atoms: \" // to_char ( sys_geom % total_atoms )) call logger % info ( \"  Fragment level: \" // to_char ( max_level )) call logger % info ( \"  Matrix size (natoms*3): \" // to_char ( matrix_size )) call logger % info ( \"============================================\" ) end if if ( max_level == 0 ) then call omp_set_num_threads ( 1 ) call run_unfragmented_calculation ( world_comm , sys_geom , config % method ) else call run_fragmented_calculation ( world_comm , node_comm , config % method , sys_geom , max_level , & matrix_size ) end if end subroutine run_calculation","tags":"","url":"proc/run_calculation.html"},{"title":"run_fragmented_calculation – metalquicha","text":"private  subroutine run_fragmented_calculation(world_comm, node_comm, method, sys_geom, max_level, matrix_size) Handle fragmented calculation (nlevel > 0) Generates fragments, distributes work across MPI processes organized in nodes,\nand coordinates many-body expansion calculation using hierarchical parallelism. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator character(len=*), intent(in) :: method Quantum chemistry method (gfn1/gfn2) type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info integer, intent(in) :: max_level Maximum fragment level for MBE integer, intent(in) :: matrix_size Size of gradient matrix (natoms*3) Calls proc~~run_fragmented_calculation~~CallsGraph proc~run_fragmented_calculation run_fragmented_calculation allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast info info proc~run_fragmented_calculation->info leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads omp_set_num_threads omp_set_num_threads proc~run_fragmented_calculation->omp_set_num_threads proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~node_coordinator node_coordinator proc~run_fragmented_calculation->proc~node_coordinator proc~node_worker node_worker proc~run_fragmented_calculation->proc~node_worker proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->proc~serial_fragment_processor to_char to_char proc~run_fragmented_calculation->to_char verbose verbose proc~run_fragmented_calculation->verbose proc~combine combine proc~generate_fragment_list->proc~combine proc~binomial binomial proc~get_nfrags->proc~binomial proc~global_coordinator->info proc~global_coordinator->to_char proc~global_coordinator->verbose debug debug proc~global_coordinator->debug error error proc~global_coordinator->error get_elapsed_time get_elapsed_time proc~global_coordinator->get_elapsed_time iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend proc~compute_mbe_energy compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker start start proc~global_coordinator->start proc~node_coordinator->to_char proc~node_coordinator->error proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend recv recv proc~node_coordinator->recv proc~node_worker->irecv proc~node_worker->isend proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~do_fragment_work do_fragment_work proc~node_worker->proc~do_fragment_work proc~fragment_destroy physical_fragment_t%fragment_destroy proc~node_worker->proc~fragment_destroy proc~node_worker->recv proc~serial_fragment_processor->info proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->to_char proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~do_fragment_work proc~serial_fragment_processor->proc~fragment_destroy proc~serial_fragment_processor->start proc~combine_util combine_util proc~combine->proc~combine_util proc~compute_mbe_energy->info proc~compute_mbe_energy->to_char proc~compute_mbe_energy->debug proc~compute_mbe_energy->get_elapsed_time proc~compute_mbe_energy->start configuration configuration proc~compute_mbe_energy->configuration proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~do_fragment_work->configuration proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~result_destroy calculation_result_t%result_destroy proc~do_fragment_work->proc~result_destroy proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~combine_util->proc~combine_util proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort proc~print_detailed_breakdown->verbose header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->info proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~print_detailed_breakdown_json->warning proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~fragment_lookup_find->fnv_1a_hash proc~fragment_lookup_find->sort proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_fragmented_calculation~~CalledByGraph proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, allocatable :: all_node_leader_ranks (:) Node leader status for all ranks integer, private :: global_node_rank Global rank if this process leads a node, -1 otherwise integer, private :: i Loop counters integer, private :: j Loop counters integer, private, allocatable :: monomers (:) Temporary monomer list for fragment generation integer(kind=int64), private :: n_expected_frags Expected number of fragments based on combinatorics (int64 to handle large systems) integer(kind=int64), private :: n_rows Number of rows needed for polymers array (int64 to handle large systems) integer, private, allocatable :: node_leader_ranks (:) Ranks of processes that lead each node integer, private :: num_nodes Number of compute nodes integer, private, allocatable :: polymers (:,:) Fragment composition array (fragment, monomer_indices) integer(kind=int64), private :: total_fragments Total number of fragments generated (int64 to handle large systems) Source Code subroutine run_fragmented_calculation ( world_comm , node_comm , method , sys_geom , max_level , matrix_size ) !! Handle fragmented calculation (nlevel > 0) !! !! Generates fragments, distributes work across MPI processes organized in nodes, !! and coordinates many-body expansion calculation using hierarchical parallelism. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator character ( len =* ), intent ( in ) :: method !! Quantum chemistry method (gfn1/gfn2) type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info integer , intent ( in ) :: max_level !! Maximum fragment level for MBE integer , intent ( in ) :: matrix_size !! Size of gradient matrix (natoms*3) integer ( int64 ) :: total_fragments !! Total number of fragments generated (int64 to handle large systems) integer , allocatable :: polymers (:, :) !! Fragment composition array (fragment, monomer_indices) integer :: num_nodes !! Number of compute nodes integer :: i , j !! Loop counters integer , allocatable :: node_leader_ranks (:) !! Ranks of processes that lead each node integer , allocatable :: monomers (:) !! Temporary monomer list for fragment generation integer ( int64 ) :: n_expected_frags !! Expected number of fragments based on combinatorics (int64 to handle large systems) integer ( int64 ) :: n_rows !! Number of rows needed for polymers array (int64 to handle large systems) integer :: global_node_rank !! Global rank if this process leads a node, -1 otherwise integer , allocatable :: all_node_leader_ranks (:) !! Node leader status for all ranks ! Generate fragments if ( world_comm % rank () == 0 ) then ! Calculate expected number of fragments n_expected_frags = get_nfrags ( sys_geom % n_monomers , max_level ) n_rows = n_expected_frags ! Allocate monomer list and polymers array allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_rows , max_level )) polymers = 0 ! Create monomer list [1, 2, 3, ..., n_monomers] call create_monomer_list ( monomers ) ! Generate all fragments (includes monomers in polymers array) total_fragments = 0_int64 ! First add monomers do i = 1 , sys_geom % n_monomers total_fragments = total_fragments + 1_int64 polymers ( total_fragments , 1 ) = i end do ! Then add n-mers for n >= 2 call generate_fragment_list ( monomers , max_level , polymers , total_fragments ) deallocate ( monomers ) call logger % info ( \"Generated fragments:\" ) call logger % info ( \"  Total fragments: \" // to_char ( total_fragments )) call logger % info ( \"  Max level: \" // to_char ( max_level )) end if ! Broadcast total_fragments to all ranks call bcast ( world_comm , total_fragments , 1 , 0 ) ! Determine node leaders global_node_rank = - 1 if ( node_comm % rank () == 0 ) global_node_rank = world_comm % rank () allocate ( all_node_leader_ranks ( world_comm % size ())) call allgather ( world_comm , global_node_rank , all_node_leader_ranks ) num_nodes = count ( all_node_leader_ranks /= - 1 ) if ( world_comm % rank () == 0 ) then call logger % info ( \"Running with \" // to_char ( num_nodes ) // \" node(s)\" ) end if allocate ( node_leader_ranks ( num_nodes )) i = 0 do j = 1 , world_comm % size () if ( all_node_leader_ranks ( j ) /= - 1 ) then i = i + 1 node_leader_ranks ( i ) = all_node_leader_ranks ( j ) end if end do deallocate ( all_node_leader_ranks ) ! Execute appropriate role if ( world_comm % size () == 1 ) then ! Single rank: process fragments serially call logger % info ( \"Running in serial mode (single MPI rank)\" ) call serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method ) else if ( world_comm % leader () . and . node_comm % leader ()) then ! Global coordinator (rank 0, node leader on node 0) call omp_set_num_threads ( omp_get_max_threads ()) call logger % verbose ( \"Rank 0: Acting as global coordinator\" ) call global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes ) else if ( node_comm % leader ()) then ! Node coordinator (node leader on other nodes) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as node coordinator\" ) call node_coordinator ( world_comm , node_comm ) else ! Worker call omp_set_num_threads ( 1 ) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as worker\" ) call node_worker ( world_comm , node_comm , sys_geom , method ) end if ! Cleanup if ( world_comm % rank () == 0 ) then if ( allocated ( polymers )) deallocate ( polymers ) if ( allocated ( node_leader_ranks )) deallocate ( node_leader_ranks ) end if end subroutine run_fragmented_calculation","tags":"","url":"proc/run_fragmented_calculation.html"},{"title":"run_unfragmented_calculation – metalquicha","text":"private  subroutine run_unfragmented_calculation(world_comm, sys_geom, method) Handle unfragmented calculation (nlevel=0) Validates single MPI rank requirement and runs direct calculation\non entire system using OpenMP for parallelization. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type( system_geometry_t ), intent(in) :: sys_geom Complete system geometry character(len=*), intent(in) :: method Quantum chemistry method (gfn1/gfn2) Calls proc~~run_unfragmented_calculation~~CallsGraph proc~run_unfragmented_calculation run_unfragmented_calculation abort_comm abort_comm proc~run_unfragmented_calculation->abort_comm error error proc~run_unfragmented_calculation->error info info proc~run_unfragmented_calculation->info proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation to_char to_char proc~run_unfragmented_calculation->to_char proc~unfragmented_calculation->error proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char all_monomer_indices all_monomer_indices proc~unfragmented_calculation->all_monomer_indices proc~build_fragment_from_indices build_fragment_from_indices proc~unfragmented_calculation->proc~build_fragment_from_indices proc~do_fragment_work do_fragment_work proc~unfragmented_calculation->proc~do_fragment_work temp_indices temp_indices proc~unfragmented_calculation->temp_indices configuration configuration proc~do_fragment_work->configuration proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~result_destroy calculation_result_t%result_destroy proc~do_fragment_work->proc~result_destroy proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_unfragmented_calculation~~CalledByGraph proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine run_unfragmented_calculation ( world_comm , sys_geom , method ) !! Handle unfragmented calculation (nlevel=0) !! !! Validates single MPI rank requirement and runs direct calculation !! on entire system using OpenMP for parallelization. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( system_geometry_t ), intent ( in ) :: sys_geom !! Complete system geometry character ( len =* ), intent ( in ) :: method !! Quantum chemistry method (gfn1/gfn2) ! Validate that only a single rank is used for unfragmented calculation ! (parallelism comes from OpenMP threads, not MPI ranks) if ( world_comm % size () > 1 ) then ! TODO JORGE: maybe don't fail? prune the extra ranks ? if ( world_comm % rank () == 0 ) then call logger % error ( \" \" ) call logger % error ( \"Unfragmented calculation (nlevel=0) requires exactly 1 MPI rank\" ) call logger % error ( \"  Parallelism is achieved through OpenMP threads, not MPI\" ) call logger % error ( \"  Current number of MPI ranks: \" // to_char ( world_comm % size ()) // \" (must be 1)\" ) call logger % error ( \" \" ) call logger % error ( \"Please run with a single MPI rank (e.g., mpirun -np 1 ...)\" ) call logger % error ( \"Use OMP_NUM_THREADS to control thread-level parallelism\" ) call logger % error ( \" \" ) end if call abort_comm ( world_comm , 1 ) end if if ( world_comm % rank () == 0 ) then call logger % info ( \" \" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \" \" ) call unfragmented_calculation ( sys_geom , method ) end if end subroutine run_unfragmented_calculation","tags":"","url":"proc/run_unfragmented_calculation.html"},{"title":"xtb_calc_energy – metalquicha","text":"private  subroutine xtb_calc_energy(this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Type Bound xtb_method_t Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~xtb_calc_energy~~CallsGraph proc~xtb_calc_energy xtb_method_t%xtb_calc_energy new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~xtb_calc_energy~~CalledByGraph proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~xtb_calc_energy proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~xtb_calc_gradient->proc~xtb_calc_energy proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(xtb_calculator), private :: calc type(context_type), private :: ctx real(kind=wp), private :: energy type(error_type), private, allocatable :: error type(structure_type), private :: mol integer, private, allocatable :: num (:) integer, private :: verbosity type(wavefunction_type), private :: wfn real(kind=wp), private, allocatable :: xyz (:,:) Source Code subroutine xtb_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity if ( this % verbose ) then print * , \"XTB: Calculating energy using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure ! charge is real(wp), multiplicity converted to uhf (unpaired electrons) call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default error stop \"Unknown XTB variant: \" // this % variant end select if ( allocated ( error )) then error stop \"Failed to create XTB calculator\" end if ! Create wavefunction and run single point calculation call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt ) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , verbosity = verbosity ) ! Store result result % energy = real ( energy , dp ) result % has_energy = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy end if deallocate ( num , xyz ) end subroutine xtb_calc_energy","tags":"","url":"proc/xtb_calc_energy.html"},{"title":"xtb_calc_gradient – metalquicha","text":"private  subroutine xtb_calc_gradient(this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Type Bound xtb_method_t Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~xtb_calc_gradient~~CallsGraph proc~xtb_calc_gradient xtb_method_t%xtb_calc_gradient proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~xtb_calc_gradient->proc~xtb_calc_energy new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine xtb_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! TODO: Implement gradient calculation using tblite ! For now, just get energy and return zero gradient if ( this % verbose ) then print * , \"XTB: Calculating gradient using \" , this % variant end if ! First get energy call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient (TODO: get real gradient from tblite) allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . if ( this % verbose ) then print * , \"XTB: Gradient calculation complete (dummy for now)\" end if end subroutine xtb_calc_gradient","tags":"","url":"proc/xtb_calc_gradient.html"},{"title":"extract_element – metalquicha","text":"public  function extract_element(basis_file, element) result(element_content) Extract the basis set data for a specific element from the basis file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(in) :: basis_file character(len=*), intent(in) :: element Return Value character(len=:), allocatable Calls proc~~extract_element~~CallsGraph proc~extract_element extract_element proc~is_letter is_letter proc~extract_element->proc~is_letter proc~is_uppercase_letter is_uppercase_letter proc~extract_element->proc~is_uppercase_letter proc~uppercase uppercase proc~extract_element->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: at_line_start integer, private :: end_pos integer, private :: i character(len=:), private, allocatable :: search_element integer, private :: start_pos Source Code function extract_element ( basis_file , element ) result ( element_content ) !! Extract the basis set data for a specific element from the basis file type ( basis_file_t ), intent ( in ) :: basis_file character ( len =* ), intent ( in ) :: element character ( len = :), allocatable :: element_content integer :: start_pos , end_pos , i character ( len = :), allocatable :: search_element logical :: at_line_start ! Convert element to uppercase for searching search_element = uppercase ( trim ( element )) ! Find the element name (it appears on its own line) start_pos = index ( basis_file % data_section , new_line ( 'a' ) // trim ( search_element ) // new_line ( 'a' )) if ( start_pos == 0 ) then ! Try without leading newline (might be first element after $DATA) if ( index ( basis_file % data_section , trim ( search_element ) // new_line ( 'a' )) == 1 ) then start_pos = 1 else error stop \"Element not found in basis set file: \" // element end if else start_pos = start_pos + 1 ! Skip the leading newline end if ! Find the next element by looking for a line that: ! - Starts with an uppercase letter ! - Has a second character that is also a letter (not a space or number) ! This distinguishes \"CARBON\" from \"S   3\" end_pos = len ( basis_file % data_section ) at_line_start = . false . i = start_pos + len ( search_element ) + 1 do while ( i < len ( basis_file % data_section )) if ( basis_file % data_section ( i : i ) == new_line ( 'a' )) then at_line_start = . true . i = i + 1 cycle end if if ( at_line_start ) then ! We're at the start of a new line if ( is_uppercase_letter ( basis_file % data_section ( i : i ))) then ! Check if next character is also a letter if ( i + 1 <= len ( basis_file % data_section )) then if ( is_letter ( basis_file % data_section ( i + 1 : i + 1 ))) then ! Found next element! end_pos = i - 1 exit end if end if end if at_line_start = . false . end if i = i + 1 end do ! Extract the section element_content = basis_file % data_section ( start_pos : end_pos ) end function extract_element","tags":"","url":"proc/extract_element.html"},{"title":"strings_equal – metalquicha","text":"public pure function strings_equal(str1, str2) result(equal) Compare two strings after trimming and adjusting (removing leading/trailing whitespace)\nCompare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical Called by proc~~strings_equal~~CalledByGraph proc~strings_equal strings_equal proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~strings_equal proc~find_unique_strings find_unique_strings proc~build_molecular_basis->proc~find_unique_strings proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~strings_equal proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~strings_equal proc~find_unique_strings->proc~strings_equal proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function strings_equal ( str1 , str2 ) result ( equal ) !! Compare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) character ( len =* ), intent ( in ) :: str1 , str2 logical :: equal equal = trim ( adjustl ( str1 )) == trim ( adjustl ( str2 )) end function strings_equal","tags":"","url":"proc/strings_equal.html"},{"title":"is_letter – metalquicha","text":"private pure function is_letter(c) result(is_alpha) Check if character is a letter (A-Z or a-z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_letter~~CalledByGraph proc~is_letter is_letter proc~extract_element extract_element proc~extract_element->proc~is_letter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code pure function is_letter ( c ) result ( is_alpha ) !! Check if character is a letter (A-Z or a-z) character ( len = 1 ), intent ( in ) :: c logical :: is_alpha integer :: ic ic = iachar ( c ) is_alpha = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) . or . & ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) end function is_letter","tags":"","url":"proc/is_letter.html"},{"title":"is_uppercase_letter – metalquicha","text":"private pure function is_uppercase_letter(c) result(is_upper) Check if character is an uppercase letter (A-Z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical Called by proc~~is_uppercase_letter~~CalledByGraph proc~is_uppercase_letter is_uppercase_letter proc~extract_element extract_element proc~extract_element->proc~is_uppercase_letter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code pure function is_uppercase_letter ( c ) result ( is_upper ) !! Check if character is an uppercase letter (A-Z) character ( len = 1 ), intent ( in ) :: c logical :: is_upper integer :: ic ic = iachar ( c ) is_upper = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) end function is_uppercase_letter","tags":"","url":"proc/is_uppercase_letter.html"},{"title":"uppercase – metalquicha","text":"private pure function uppercase(str) result(upper) Convert a string to uppercase, should use pic_ascii! Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:), allocatable Called by proc~~uppercase~~CalledByGraph proc~uppercase uppercase proc~extract_element extract_element proc~extract_element->proc~uppercase Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: ic Source Code pure function uppercase ( str ) result ( upper ) !! Convert a string to uppercase, should use pic_ascii! character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: upper integer :: i , ic allocate ( character ( len = len ( str )) :: upper ) upper = str do i = 1 , len ( str ) ic = iachar ( str ( i : i )) if ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) then upper ( i : i ) = achar ( ic - 32 ) end if end do end function uppercase","tags":"","url":"proc/uppercase.html"},{"title":"open_basis_file – metalquicha","text":"public  subroutine open_basis_file(basis_file, filename) Open and read a GAMESS formatted basis set file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(out) :: basis_file character(len=*), intent(in) :: filename Variables Type Visibility Attributes Name Initial integer, private :: data_end integer, private :: data_start logical, private :: file_exists integer, private :: file_size integer, private :: iostat integer, private :: unit Source Code subroutine open_basis_file ( basis_file , filename ) !! Open and read a GAMESS formatted basis set file type ( basis_file_t ), intent ( out ) :: basis_file character ( len =* ), intent ( in ) :: filename integer :: unit , iostat , file_size logical :: file_exists integer :: data_start , data_end ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then error stop \"Basis set file not found: \" // filename end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: basis_file % full_content ) ! Open and read entire file open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = iostat ) if ( iostat /= 0 ) error stop \"Error opening file: \" // filename read ( unit , iostat = iostat ) basis_file % full_content if ( iostat /= 0 ) error stop \"Error reading file: \" // filename close ( unit ) ! Extract the $DATA section data_start = index ( basis_file % full_content , \"$DATA\" ) if ( data_start == 0 ) then error stop \"Could not find $DATA section in basis set file\" end if data_end = index ( basis_file % full_content ( data_start :), \"$END\" ) if ( data_end == 0 ) then error stop \"Could not find $END marker in basis set file\" end if ! Store just the data section (between $DATA and $END) basis_file % data_section = basis_file % full_content ( data_start + 5 : data_start + data_end - 2 ) end subroutine open_basis_file","tags":"","url":"proc/open_basis_file.html"},{"title":"normalize_basis_name – metalquicha","text":"public  function normalize_basis_name(basis_name) result(normalized) Normalize basis set name to filename-safe format\nRules: * -> s, + -> p, remove parentheses and their contents\nExamples:\n  6-31G -> 6-31Gs\n  6-31+G -> 6-31pGs\n  6-31G(d)    -> 6-31Gd\n  6-311G(d,p) -> 6-31Gdp\n  6-311++G**  -> 6-311ppGss Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name Return Value character(len=:), allocatable Called by proc~~normalize_basis_name~~CalledByGraph proc~normalize_basis_name normalize_basis_name proc~find_basis_file find_basis_file proc~find_basis_file->proc~normalize_basis_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: buffer integer, private :: i logical, private :: in_parens integer, private :: out_pos Source Code function normalize_basis_name ( basis_name ) result ( normalized ) character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable :: normalized integer :: i , out_pos character ( len = 256 ) :: buffer logical :: in_parens buffer = \"\" out_pos = 0 in_parens = . false . do i = 1 , len_trim ( basis_name ) select case ( basis_name ( i : i )) case ( '*' ) ! Star becomes 's' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 's' case ( '+' ) ! Plus becomes 'p' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 'p' case ( '(' ) ! Start of parentheses - we'll extract contents in_parens = . true . case ( ')' ) ! End of parentheses in_parens = . false . case ( ',' , ' ' ) ! Skip commas and spaces inside parentheses if ( in_parens ) cycle ! Keep them outside parentheses out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = basis_name ( i : i ) case default ! Copy character as-is out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = basis_name ( i : i ) end select end do normalized = trim ( buffer ( 1 : out_pos )) end function normalize_basis_name","tags":"","url":"proc/normalize_basis_name.html"},{"title":"find_basis_file – metalquicha","text":"public  subroutine find_basis_file(basis_name, filename, stat, errmsg) Find basis file, trying multiple name variants\nSearches in:\n  1. basis_sets/ subdirectory\n  2. Current directory\nTries name variants:\n  1. Exact name as given\n  2. Normalized name (with * -> s, + -> p, etc.)\n  3. Common synonyms Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name character(len=:), intent(out), allocatable :: filename integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg Calls proc~~find_basis_file~~CallsGraph proc~find_basis_file find_basis_file proc~normalize_basis_name normalize_basis_name proc~find_basis_file->proc~normalize_basis_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: file_exists integer, private :: i integer, private :: j character(len=:), private, allocatable :: normalized integer, private :: nvariants character(len=256), private, dimension(2) :: search_dirs character(len=256), private :: test_path character(len=256), private, dimension(10) :: variants Source Code subroutine find_basis_file ( basis_name , filename , stat , errmsg ) character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable , intent ( out ) :: filename integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg character ( len = :), allocatable :: normalized logical :: file_exists integer :: i , j character ( len = 256 ), dimension ( 10 ) :: variants integer :: nvariants character ( len = 256 ) :: test_path character ( len = 256 ), dimension ( 2 ) :: search_dirs stat = 0 nvariants = 0 ! Define search directories (in order of priority) search_dirs ( 1 ) = \"basis_sets/\" search_dirs ( 2 ) = \"\" ! Current directory ! Variant 1: Exact name nvariants = nvariants + 1 variants ( nvariants ) = trim ( basis_name ) // \".txt\" ! Variant 2: Normalized name normalized = normalize_basis_name ( basis_name ) if ( trim ( normalized ) /= trim ( basis_name )) then nvariants = nvariants + 1 variants ( nvariants ) = trim ( normalized ) // \".txt\" end if ! Variant 3: Common synonyms ! 6-31G* = 6-31G(d) if ( trim ( basis_name ) == \"6-31G*\" . or . trim ( basis_name ) == \"6-31G(d)\" ) then nvariants = nvariants + 1 variants ( nvariants ) = \"6-31Gs.txt\" nvariants = nvariants + 1 variants ( nvariants ) = \"6-31Gd.txt\" end if ! 6-31G** = 6-31G(d,p) if ( trim ( basis_name ) == \"6-31G**\" . or . trim ( basis_name ) == \"6-31G(d,p)\" ) then nvariants = nvariants + 1 variants ( nvariants ) = \"6-31Gss.txt\" nvariants = nvariants + 1 variants ( nvariants ) = \"6-31Gdp.txt\" end if ! 6-311G* = 6-311G(d) if ( trim ( basis_name ) == \"6-311G*\" . or . trim ( basis_name ) == \"6-311G(d)\" ) then nvariants = nvariants + 1 variants ( nvariants ) = \"6-311Gs.txt\" nvariants = nvariants + 1 variants ( nvariants ) = \"6-311Gd.txt\" end if ! Try each directory with each variant do j = 1 , 2 do i = 1 , nvariants test_path = trim ( search_dirs ( j )) // trim ( variants ( i )) inquire ( file = trim ( test_path ), exist = file_exists ) if ( file_exists ) then filename = trim ( test_path ) return end if end do end do ! None found - return error with all paths tried stat = 1 errmsg = \"Basis set file not found. Tried: \" do j = 1 , 2 do i = 1 , nvariants test_path = trim ( search_dirs ( j )) // trim ( variants ( i )) if ( i == 1 . and . j == 1 ) then errmsg = errmsg // trim ( test_path ) else errmsg = errmsg // \", \" // trim ( test_path ) end if end do end do end subroutine find_basis_file","tags":"","url":"proc/find_basis_file.html"},{"title":"parse_command_line – metalquicha","text":"public  subroutine parse_command_line(args, stat, errmsg) Parse command line arguments for geometry file and basis set Extracts XYZ file path and basis set name from command line,\nvalidates arguments, and handles help requests. Arguments Type Intent Optional Attributes Name type( cli_args_type ), intent(out) :: args Parsed argument container integer, intent(out) :: stat Status (0=success, >0=error) character(len=:), intent(out), allocatable :: errmsg Error message Calls proc~~parse_command_line~~CallsGraph proc~parse_command_line parse_command_line proc~print_usage print_usage proc~parse_command_line->proc~print_usage Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: arg_buffer Temporary argument buffer integer, private :: arg_len Length of current argument integer, private :: nargs Number of command line arguments Source Code subroutine parse_command_line ( args , stat , errmsg ) !! Parse command line arguments for geometry file and basis set !! !! Extracts XYZ file path and basis set name from command line, !! validates arguments, and handles help requests. type ( cli_args_type ), intent ( out ) :: args !! Parsed argument container integer , intent ( out ) :: stat !! Status (0=success, >0=error) character ( len = :), allocatable , intent ( out ) :: errmsg !! Error message integer :: nargs !! Number of command line arguments character ( len = 256 ) :: arg_buffer !! Temporary argument buffer integer :: arg_len !! Length of current argument stat = 0 ! Get number of command line arguments nargs = command_argument_count () ! Check for help flag if ( nargs >= 1 ) then call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then errmsg = \"Error reading command line argument 1\" return end if arg_buffer = trim ( arg_buffer ) if ( arg_buffer == \"-h\" . or . arg_buffer == \"--help\" ) then call print_usage () stat = - 1 ! Special code to indicate help was requested return end if end if ! Validate number of arguments if ( nargs < 2 ) then stat = 1 errmsg = \"Error: Insufficient arguments. Expected 2 arguments (geometry.xyz basis_name)\" call print_usage () return end if if ( nargs > 2 ) then stat = 1 errmsg = \"Error: Too many arguments. Expected 2 arguments (geometry.xyz basis_name)\" call print_usage () return end if ! Parse argument 1: XYZ file call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then errmsg = \"Error reading geometry file argument\" return end if args % xyz_file = trim ( arg_buffer ) ! Parse argument 2: Basis set name call get_command_argument ( 2 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then errmsg = \"Error reading basis set name argument\" return end if args % basis_name = trim ( arg_buffer ) ! Reset stat to success stat = 0 end subroutine parse_command_line","tags":"","url":"proc/parse_command_line.html"},{"title":"print_usage – metalquicha","text":"public  subroutine print_usage() Print usage information Arguments None Called by proc~~print_usage~~CalledByGraph proc~print_usage print_usage proc~parse_command_line parse_command_line proc~parse_command_line->proc~print_usage Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: prog_name integer, private :: stat Source Code subroutine print_usage () character ( len = 256 ) :: prog_name integer :: stat call get_command_argument ( 0 , prog_name , status = stat ) if ( stat /= 0 ) prog_name = \"pic_basis_reader\" print * print * , \"Usage: \" , trim ( prog_name ), \" <geometry.xyz> <basis_name>\" print * print * , \"Arguments:\" print * , \"  geometry.xyz   XYZ format molecular geometry file\" print * , \"  basis_name     Name of basis set (e.g., 6-31G, 6-311G**)\" print * print * , \"Options:\" print * , \"  -h, --help     Show this help message\" print * print * , \"Example:\" print * , \"  \" , trim ( prog_name ), \" water.xyz 6-31G\" print * end subroutine print_usage","tags":"","url":"proc/print_usage.html"},{"title":"cli_args_destroy – metalquicha","text":"private  subroutine cli_args_destroy(this) Clean up CLI args Type Bound cli_args_type Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this Source Code subroutine cli_args_destroy ( this ) class ( cli_args_type ), intent ( inout ) :: this if ( allocated ( this % xyz_file )) deallocate ( this % xyz_file ) if ( allocated ( this % basis_name )) deallocate ( this % basis_name ) end subroutine cli_args_destroy","tags":"","url":"proc/cli_args_destroy.html"},{"title":"int_to_string – metalquicha","text":"private pure function int_to_string(i) result(str) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Called by proc~~int_to_string~~CalledByGraph proc~int_to_string int_to_string proc~read_xyz_string read_xyz_string proc~read_xyz_string->proc~int_to_string proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file program~main main program~main->proc~initialize_system_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: buffer Source Code pure function int_to_string ( i ) result ( str ) !! Convert integer to string integer , intent ( in ) :: i character ( len = :), allocatable :: str character ( len = 20 ) :: buffer write ( buffer , '(I0)' ) i str = trim ( adjustl ( buffer )) end function int_to_string","tags":"","url":"proc/int_to_string.html"},{"title":"read_xyz_file – metalquicha","text":"public  subroutine read_xyz_file(filename, geom, stat, errmsg) Read molecular geometry from XYZ format file Parses standard XYZ files with format:\nLine 1: Number of atoms\nLine 2: Comment/title line\nLines 3+: Element X Y Z (coordinates in Angstrom) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Path to XYZ file type( geometry_type ), intent(out) :: geom Parsed molecular geometry integer, intent(out) :: stat Status (0=success, >0=error) character(len=:), intent(out), allocatable :: errmsg Error message Calls proc~~read_xyz_file~~CallsGraph proc~read_xyz_file read_xyz_file proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_xyz_file~~CalledByGraph proc~read_xyz_file read_xyz_file proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file program~main main program~main->proc~initialize_system_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: file_contents Full file content buffer logical, private :: file_exists Whether file exists on disk integer, private :: file_size File size in bytes integer, private :: io_stat I/O operation status integer, private :: unit File unit number Source Code subroutine read_xyz_file ( filename , geom , stat , errmsg ) !! Read molecular geometry from XYZ format file !! !! Parses standard XYZ files with format: !! Line 1: Number of atoms !! Line 2: Comment/title line !! Lines 3+: Element X Y Z (coordinates in Angstrom) character ( len =* ), intent ( in ) :: filename !! Path to XYZ file type ( geometry_type ), intent ( out ) :: geom !! Parsed molecular geometry integer , intent ( out ) :: stat !! Status (0=success, >0=error) character ( len = :), allocatable , intent ( out ) :: errmsg !! Error message integer :: unit !! File unit number integer :: io_stat !! I/O operation status integer :: file_size !! File size in bytes logical :: file_exists !! Whether file exists on disk character ( len = :), allocatable :: file_contents !! Full file content buffer stat = 0 ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then stat = 1 errmsg = \"XYZ file not found: \" // trim ( filename ) return end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: file_contents ) ! Open and read entire file as stream open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = io_stat ) if ( io_stat /= 0 ) then stat = io_stat errmsg = \"Error opening file: \" // trim ( filename ) return end if read ( unit , iostat = io_stat ) file_contents close ( unit ) if ( io_stat /= 0 ) then stat = io_stat errmsg = \"Error reading file: \" // trim ( filename ) return end if ! Parse the contents call read_xyz_string ( file_contents , geom , stat , errmsg ) end subroutine read_xyz_file","tags":"","url":"proc/read_xyz_file.html"},{"title":"read_xyz_string – metalquicha","text":"public pure subroutine read_xyz_string(xyz_string, geom, stat, errmsg) Parse molecular geometry from XYZ format string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xyz_string type( geometry_type ), intent(out) :: geom integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg Calls proc~~read_xyz_string~~CallsGraph proc~read_xyz_string read_xyz_string proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_xyz_string~~CalledByGraph proc~read_xyz_string read_xyz_string proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file program~main main program~main->proc~initialize_system_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: element integer, private :: iatom integer, private :: io_stat character(len=:), private, allocatable :: lines (:) integer, private :: nlines real(kind=dp), private :: x real(kind=dp), private :: y real(kind=dp), private :: z Source Code pure subroutine read_xyz_string ( xyz_string , geom , stat , errmsg ) !! Parse molecular geometry from XYZ format string character ( len =* ), intent ( in ) :: xyz_string type ( geometry_type ), intent ( out ) :: geom integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg character ( len = :), allocatable :: lines (:) integer :: nlines , iatom , io_stat character ( len = 256 ) :: element real ( dp ) :: x , y , z stat = 0 ! Split into lines call split_lines ( xyz_string , lines , nlines ) if ( nlines < 2 ) then stat = 1 errmsg = \"XYZ file must have at least 2 lines (natoms + comment)\" return end if ! Read number of atoms from first line read ( lines ( 1 ), * , iostat = io_stat ) geom % natoms if ( io_stat /= 0 ) then stat = 1 errmsg = \"Failed to read number of atoms from first line\" return end if if ( geom % natoms < 0 ) then stat = 1 errmsg = \"Number of atoms must be non-negative\" return end if ! Store comment line geom % comment = trim ( adjustl ( lines ( 2 ))) ! Check we have enough lines if ( nlines < 2 + geom % natoms ) then stat = 1 errmsg = \"XYZ file has insufficient lines: expected \" // & trim ( int_to_string ( 2 + geom % natoms )) // \", got \" // & trim ( int_to_string ( nlines )) return end if ! Allocate arrays allocate ( character ( len = MAX_ELEMENT_SYMBOL_LEN ) :: geom % elements ( geom % natoms )) allocate ( geom % coords ( 3 , geom % natoms )) ! Read atom data do iatom = 1 , geom % natoms read ( lines ( 2 + iatom ), * , iostat = io_stat ) element , x , y , z if ( io_stat /= 0 ) then stat = 1 errmsg = \"Failed to parse atom data on line \" // & trim ( int_to_string ( 2 + iatom )) // \": '\" // & trim ( lines ( 2 + iatom )) // \"'\" return end if geom % elements ( iatom ) = trim ( adjustl ( element )) geom % coords ( 1 , iatom ) = x geom % coords ( 2 , iatom ) = y geom % coords ( 3 , iatom ) = z end do end subroutine read_xyz_string","tags":"","url":"proc/read_xyz_string.html"},{"title":"split_lines – metalquicha","text":"public pure subroutine split_lines(text, lines, nlines) Split input text into lines based on CR, LF, or CRLF line endings\nTrailing newlines do not create empty lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text character(len=:), intent(out), allocatable :: lines (:) integer, intent(out) :: nlines Called by proc~~split_lines~~CalledByGraph proc~split_lines split_lines proc~read_xyz_string read_xyz_string proc~read_xyz_string->proc~split_lines proc~read_xyz_file read_xyz_file proc~read_xyz_file->proc~read_xyz_string proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~read_xyz_file program~main main program~main->proc~initialize_system_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: line_end integer, private :: line_start integer, private :: max_line_len character(len=:), private, allocatable :: temp_lines (:) Source Code pure subroutine split_lines ( text , lines , nlines ) !! Split input text into lines based on CR, LF, or CRLF line endings !! Trailing newlines do not create empty lines character ( len =* ), intent ( in ) :: text character ( len = :), allocatable , intent ( out ) :: lines (:) integer , intent ( out ) :: nlines integer :: i , line_start , line_end , max_line_len character ( len = :), allocatable :: temp_lines (:) if ( len ( text ) == 0 ) then nlines = 0 allocate ( character ( len = 1 ) :: lines ( 0 )) return end if ! Pass 1: Count lines and find maximum line length nlines = 0 max_line_len = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 ! Skip both CR and LF else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 max_line_len = max ( max_line_len , len ( text ) - line_start + 1 ) end if ! Handle empty text or ensure at least length 1 if ( max_line_len == 0 ) max_line_len = 1 ! Allocate output array allocate ( character ( len = max_line_len ) :: temp_lines ( nlines )) ! Pass 2: Extract lines nlines = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = len ( text ) - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if ! Copy to output (use explicit loop for Intel compiler compatibility) allocate ( character ( len = max_line_len ) :: lines ( nlines )) block integer :: iline do iline = 1 , nlines lines ( iline ) = temp_lines ( iline ) end do end block end subroutine split_lines","tags":"","url":"proc/split_lines.html"},{"title":"geometry_destroy – metalquicha","text":"private  subroutine geometry_destroy(this) Clean up allocated memory in geometry_type Type Bound geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this Called by proc~~geometry_destroy~~CalledByGraph proc~geometry_destroy geometry_type%geometry_destroy proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~geometry_destroy program~main main program~main->proc~initialize_system_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine geometry_destroy ( this ) !! Clean up allocated memory in geometry_type class ( geometry_type ), intent ( inout ) :: this if ( allocated ( this % elements )) deallocate ( this % elements ) if ( allocated ( this % coords )) deallocate ( this % coords ) if ( allocated ( this % comment )) deallocate ( this % comment ) this % natoms = 0 end subroutine geometry_destroy","tags":"","url":"proc/geometry_destroy.html"},{"title":"get_frag_level_name – metalquicha","text":"private  function get_frag_level_name(frag_level) result(level_name) Map body level (n-mer) to descriptive name\nSupports up to decamers (10-mers), then falls back to “N-mers” format Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag_level Return Value character(len=32) Called by proc~~get_frag_level_name~~CalledByGraph proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown print_detailed_breakdown proc~print_detailed_breakdown->proc~get_frag_level_name proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_frag_level_name ( frag_level ) result ( level_name ) !! Map body level (n-mer) to descriptive name !! Supports up to decamers (10-mers), then falls back to \"N-mers\" format integer , intent ( in ) :: frag_level character ( len = 32 ) :: level_name select case ( frag_level ) case ( 1 ) level_name = \"monomers\" case ( 2 ) level_name = \"dimers\" case ( 3 ) level_name = \"trimers\" case ( 4 ) level_name = \"tetramers\" case ( 5 ) level_name = \"pentamers\" case ( 6 ) level_name = \"hexamers\" case ( 7 ) level_name = \"heptamers\" case ( 8 ) level_name = \"octamers\" case ( 9 ) level_name = \"nonamers\" case ( 10 ) level_name = \"decamers\" case default ! For levels > 10, use generic format write ( level_name , '(i0,a)' ) frag_level , \"-mers\" end select end function get_frag_level_name","tags":"","url":"proc/get_frag_level_name.html"},{"title":"print_detailed_breakdown – metalquicha","text":"public  subroutine print_detailed_breakdown(polymers, fragment_count, max_level, energies, delta_energies) Print detailed energy breakdown for each fragment\nShows full energy and deltaE correction for all monomers, dimers, trimers, etc.\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) Calls proc~~print_detailed_breakdown~~CallsGraph proc~print_detailed_breakdown print_detailed_breakdown header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name verbose verbose proc~print_detailed_breakdown->verbose warning warning proc~print_detailed_breakdown->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_detailed_breakdown~~CalledByGraph proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~print_detailed_breakdown proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: count_by_level character(len=512), private :: energy_line integer, private :: frag_level integer, private :: fragment_size character(len=512), private :: fragment_str integer(kind=int64), private :: i integer, private :: j Source Code subroutine print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) !! Print detailed energy breakdown for each fragment !! Shows full energy and deltaE correction for all monomers, dimers, trimers, etc. !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) integer ( int64 ) :: i integer :: fragment_size , j , frag_level character ( len = 512 ) :: fragment_str , energy_line integer ( int64 ) :: count_by_level call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) call logger % verbose ( \"Detailed Energy Breakdown by Fragment\" ) call logger % verbose ( \"============================================\" ) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). Using generic N-mers notation.\" ) end if do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then call logger % verbose ( \" \" ) block character ( len = 256 ) :: header character ( len = 32 ) :: level_name level_name = get_frag_level_name ( frag_level ) write ( header , '(a,a,i0,a)' ) trim ( level_name ), \" (\" , count_by_level , \" fragments):\" ! Capitalize first letter if ( len_trim ( level_name ) > 0 ) then if ( level_name ( 1 : 1 ) >= 'a' . and . level_name ( 1 : 1 ) <= 'z' ) then header ( 1 : 1 ) = achar ( iachar ( header ( 1 : 1 )) - 32 ) end if end if call logger % verbose ( trim ( header )) end block call logger % verbose ( \"--------------------------------------------\" ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then fragment_str = \"[\" do j = 1 , fragment_size if ( j > 1 ) then write ( fragment_str , '(a,a,i0)' ) trim ( fragment_str ), \",\" , polymers ( i , j ) else write ( fragment_str , '(a,i0)' ) trim ( fragment_str ), polymers ( i , j ) end if end do write ( fragment_str , '(a,a)' ) trim ( fragment_str ), \"]\" if ( frag_level == 1 ) then write ( energy_line , '(a,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ) else write ( energy_line , '(a,a,f20.10,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ), & \"   deltaE: \" , delta_energies ( i ) end if call logger % verbose ( trim ( energy_line )) end if end do end if end do call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) end subroutine print_detailed_breakdown","tags":"","url":"proc/print_detailed_breakdown.html"},{"title":"print_detailed_breakdown_json – metalquicha","text":"public  subroutine print_detailed_breakdown_json(polymers, fragment_count, max_level, energies, delta_energies, sum_by_level, total_energy) Write detailed energy breakdown to results.json file\nOutputs structured JSON with all fragment energies and deltaE corrections\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) real(kind=dp), intent(in) :: sum_by_level (:) real(kind=dp), intent(in) :: total_energy Calls proc~~print_detailed_breakdown_json~~CallsGraph proc~print_detailed_breakdown_json print_detailed_breakdown_json error error proc~print_detailed_breakdown_json->error info info proc~print_detailed_breakdown_json->info proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown_json->proc~get_frag_level_name warning warning proc~print_detailed_breakdown_json->warning Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_detailed_breakdown_json~~CalledByGraph proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: count_by_level logical, private :: first_fragment logical, private :: first_level integer, private :: frag_level integer, private :: fragment_size integer(kind=int64), private :: i integer, private :: io_stat integer, private :: j character(len=512), private :: json_line character(len=32), private :: level_name integer, private :: unit Source Code subroutine print_detailed_breakdown_json ( polymers , fragment_count , max_level , & energies , delta_energies , sum_by_level , total_energy ) !! Write detailed energy breakdown to results.json file !! Outputs structured JSON with all fragment energies and deltaE corrections !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) real ( dp ), intent ( in ) :: sum_by_level (:), total_energy integer ( int64 ) :: i integer :: fragment_size , j , frag_level , unit , io_stat character ( len = 512 ) :: json_line integer ( int64 ) :: count_by_level logical :: first_level , first_fragment character ( len = 32 ) :: level_name open ( newunit = unit , file = 'results.json' , status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open results.json for writing\" ) return end if call logger % info ( \"Writing JSON output to results.json\" ) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). JSON will use generic N-mers notation.\" ) end if write ( unit , '(a)' ) \"{\" write ( unit , '(a)' ) '  \"mbe_breakdown\": {' write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '    \"levels\": [' first_level = . true . do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then if (. not . first_level ) then write ( unit , '(a)' ) '      },' end if first_level = . false . write ( unit , '(a)' ) '      {' level_name = get_frag_level_name ( frag_level ) write ( json_line , '(a,i0,a)' ) '        \"frag_level\": ' , frag_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,a,a)' ) '        \"name\": \"' , trim ( level_name ), '\",' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '        \"count\": ' , count_by_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '        \"total_energy\": ' , sum_by_level ( frag_level ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '        \"fragments\": [' first_fragment = . true . do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then if (. not . first_fragment ) then write ( unit , '(a)' ) '          },' end if first_fragment = . false . write ( unit , '(a)' ) '          {' json_line = '            \"indices\": [' do j = 1 , fragment_size if ( j > 1 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , polymers ( i , j ) else write ( json_line , '(a,i0)' ) trim ( json_line ), polymers ( i , j ) end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '            \"energy\": ' , energies ( i ) if ( frag_level > 1 ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '            \"delta_energy\": ' , delta_energies ( i ) end if write ( unit , '(a)' ) trim ( json_line ) end if end do if (. not . first_fragment ) then write ( unit , '(a)' ) '          }' end if write ( unit , '(a)' ) '        ]' end if end do if (. not . first_level ) then write ( unit , '(a)' ) '      }' end if write ( unit , '(a)' ) '    ]' write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"JSON output written successfully to results.json\" ) end subroutine print_detailed_breakdown_json","tags":"","url":"proc/print_detailed_breakdown_json.html"},{"title":"print_fragment_xyz – metalquicha","text":"public  subroutine print_fragment_xyz(fragment_idx, phys_frag) Print fragment geometry in XYZ format Arguments Type Intent Optional Attributes Name integer, intent(in) :: fragment_idx type( physical_fragment_t ), intent(in) :: phys_frag Calls proc~~print_fragment_xyz~~CallsGraph proc~print_fragment_xyz print_fragment_xyz info info proc~print_fragment_xyz->info proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom to_char to_char proc~print_fragment_xyz->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_fragment_xyz~~CalledByGraph proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: coord_line integer, private :: i character(len=2), private :: symbol Source Code subroutine print_fragment_xyz ( fragment_idx , phys_frag ) !! Print fragment geometry in XYZ format integer , intent ( in ) :: fragment_idx type ( physical_fragment_t ), intent ( in ) :: phys_frag integer :: i character ( len = 2 ) :: symbol character ( len = 256 ) :: coord_line call logger % info ( \"=========================================\" ) call logger % info ( \" Fragment \" // to_char ( fragment_idx )) call logger % info ( \" Number of atoms: \" // to_char ( phys_frag % n_atoms )) call logger % info ( \" Coordinates in Angstroms:\" ) call logger % info ( \"-----------------------------------------\" ) do i = 1 , phys_frag % n_atoms symbol = element_number_to_symbol ( phys_frag % element_numbers ( i )) ! Convert from Bohr back to Angstroms for printing write ( coord_line , '(a2,3f15.8)' ) symbol , to_angstrom ( phys_frag % coordinates ( 1 : 3 , i )) call logger % info ( trim ( coord_line )) end do call logger % info ( \"=========================================\" ) end subroutine print_fragment_xyz","tags":"","url":"proc/print_fragment_xyz.html"},{"title":"do_fragment_work – metalquicha","text":"public  subroutine do_fragment_work(fragment_idx, water_energy, C_flat, method, phys_frag) Uses pic_logger proc~~do_fragment_work~~UsesGraph proc~do_fragment_work do_fragment_work pic_logger pic_logger proc~do_fragment_work->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Process a single fragment for quantum chemistry calculation Performs energy and gradient calculation on a molecular fragment using\nspecified quantum chemistry method (GFN-xTB variants).\nVerbosity is controlled by the global logger level. Arguments Type Intent Optional Attributes Name integer, intent(in) :: fragment_idx Fragment index for identification real(kind=dp), intent(out) :: water_energy Computed energy for this fragment real(kind=dp), intent(out), allocatable :: C_flat (:) Flattened gradient array character(len=*), intent(in) :: method QC method (gfn1, gfn2) type( physical_fragment_t ), intent(in), optional :: phys_frag Fragment geometry Calls proc~~do_fragment_work~~CallsGraph proc~do_fragment_work do_fragment_work configuration configuration proc~do_fragment_work->configuration proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~result_destroy calculation_result_t%result_destroy proc~do_fragment_work->proc~result_destroy proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy info info proc~print_fragment_xyz->info proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom to_char to_char proc~print_fragment_xyz->to_char proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~do_fragment_work~~CalledByGraph proc~do_fragment_work do_fragment_work proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: current_log_level Current logger verbosity level logical, private :: is_verbose Whether verbose output is enabled type( calculation_result_t ), private :: result Computation results type( xtb_method_t ), private :: xtb_calc XTB calculator instance Source Code subroutine do_fragment_work ( fragment_idx , & water_energy , C_flat , method , phys_frag ) !! Process a single fragment for quantum chemistry calculation !! !! Performs energy and gradient calculation on a molecular fragment using !! specified quantum chemistry method (GFN-xTB variants). !! Verbosity is controlled by the global logger level. use pic_logger , only : verbose_level integer , intent ( in ) :: fragment_idx !! Fragment index for identification real ( dp ), intent ( out ) :: water_energy !! Computed energy for this fragment real ( dp ), allocatable , intent ( out ) :: C_flat (:) !! Flattened gradient array character ( len =* ), intent ( in ) :: method !! QC method (gfn1, gfn2) type ( physical_fragment_t ), intent ( in ), optional :: phys_frag !! Fragment geometry integer :: current_log_level !! Current logger verbosity level logical :: is_verbose !! Whether verbose output is enabled #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc !! XTB calculator instance #endif type ( calculation_result_t ) :: result !! Computation results ! Query logger to determine verbosity call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) ! Print fragment geometry if provided and verbose mode is enabled if ( present ( phys_frag )) then if ( is_verbose ) then call print_fragment_xyz ( fragment_idx , phys_frag ) end if #ifndef MQC_WITHOUT_TBLITE ! Setup XTB method xtb_calc % variant = method xtb_calc % verbose = is_verbose ! Run the calculation using the method API call xtb_calc % calc_energy ( phys_frag , result ) water_energy = result % energy ! Clean up result call result % destroy () #else call logger % error ( \"XTB method requested but tblite support not compiled in\" ) call logger % error ( \"Please rebuild with -DMQC_ENABLE_TBLITE=ON\" ) error stop \"tblite support not available\" #endif else water_energy = 0.0_dp end if ! Return empty vector for C_flat allocate ( C_flat ( 1 )) C_flat ( 1 ) = 0.0_dp end subroutine do_fragment_work","tags":"","url":"proc/do_fragment_work.html"},{"title":"global_coordinator – metalquicha","text":"public  subroutine global_coordinator(world_comm, node_comm, total_fragments, polymers, max_level, node_leader_ranks, num_nodes) Global coordinator for distributing fragments to node coordinators\nwill act as a node coordinator for a single node calculation\nUses int64 for total_fragments to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes Calls proc~~global_coordinator~~CallsGraph proc~global_coordinator global_coordinator debug debug proc~global_coordinator->debug error error proc~global_coordinator->error get_elapsed_time get_elapsed_time proc~global_coordinator->get_elapsed_time info info proc~global_coordinator->info iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend proc~compute_mbe_energy compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker start start proc~global_coordinator->start to_char to_char proc~global_coordinator->to_char verbose verbose proc~global_coordinator->verbose proc~compute_mbe_energy->debug proc~compute_mbe_energy->get_elapsed_time proc~compute_mbe_energy->info proc~compute_mbe_energy->start proc~compute_mbe_energy->to_char configuration configuration proc~compute_mbe_energy->configuration proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort proc~print_detailed_breakdown->verbose header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->info proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~print_detailed_breakdown_json->warning proc~fragment_lookup_find->fnv_1a_hash proc~fragment_lookup_find->sort proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~global_coordinator~~CalledByGraph proc~global_coordinator global_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type(timer_type), private :: coord_timer integer(kind=int64), private :: current_fragment integer, private :: dummy_msg integer, private :: finished_nodes integer, private :: fragment_idx logical, private :: handling_local_workers logical, private :: has_pending integer, private :: local_dummy integer, private :: local_finished_workers type(MPI_Status), private :: local_status type(request_t), private :: req integer, private :: request_source integer(kind=int64), private :: results_received real(kind=dp), private, allocatable :: scalar_results (:) type(MPI_Status), private :: status integer(kind=int64), private :: worker_fragment_map (node_comm%size()) integer, private :: worker_source Source Code subroutine global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes ) !! Global coordinator for distributing fragments to node coordinators !! will act as a node coordinator for a single node calculation !! Uses int64 for total_fragments to handle large fragment counts that overflow int32. type ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level , num_nodes integer , intent ( in ) :: polymers (:, :), node_leader_ranks (:) type ( timer_type ) :: coord_timer integer ( int64 ) :: current_fragment , results_received integer :: finished_nodes integer :: request_source , dummy_msg , fragment_idx type ( MPI_Status ) :: status , local_status logical :: handling_local_workers logical :: has_pending ! For local workers integer :: local_finished_workers , local_dummy ! Storage for results real ( dp ), allocatable :: scalar_results (:) integer ( int64 ) :: worker_fragment_map ( node_comm % size ()) integer :: worker_source ! MPI request handles for non-blocking operations type ( request_t ) :: req current_fragment = total_fragments finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( node_comm % size () > 1 ) results_received = 0_int64 ! Allocate storage for results allocate ( scalar_results ( total_fragments )) scalar_results = 0.0_dp worker_fragment_map = 0 call logger % verbose ( \"Global coordinator starting with \" // to_char ( total_fragments ) // & \" fragments for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers ! This MUST be checked before sending new work to avoid race conditions if ( handling_local_workers ) then ! Keep checking for results until there are none pending do call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state\" end if ! Receive scalar result and store it using the fragment index for this worker call irecv ( node_comm , scalar_results ( worker_fragment_map ( worker_source )), worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clear the mapping since we've received the result worker_fragment_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit ! Receive fragment index and scalar result from node coordinator ! TODO: serialize the data for better performance call irecv ( world_comm , fragment_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call irecv ( world_comm , scalar_results ( fragment_idx ), status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_fragment >= 1 ) then call send_fragment_to_node ( world_comm , current_fragment , polymers , request_source ) current_fragment = current_fragment - 1 else call isend ( world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < node_comm % size () - 1 ) then call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_fragment >= 1 ) then call send_fragment_to_worker ( node_comm , current_fragment , polymers , & local_status % MPI_SOURCE ) ! Track which fragment was sent to this worker worker_fragment_map ( local_status % MPI_SOURCE ) = current_fragment current_fragment = current_fragment - 1 else call isend ( node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if ! If worker still has pending results, skip the work request ! It will be processed on the next iteration after results are received end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= node_comm % size () - 1 & . and . results_received >= total_fragments ) then handling_local_workers = . false . if ( num_nodes == 1 ) then finished_nodes = finished_nodes + 1 call logger % debug ( \"Manually incremented finished_nodes for self\" ) else finished_nodes = finished_nodes + 1 call logger % verbose ( \"Global coordinator finished local workers\" ) end if end if end do call logger % verbose ( \"Global coordinator finished all fragments\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) block real ( dp ) :: mbe_total_energy ! Compute the many-body expansion energy call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () call compute_mbe_energy ( polymers , total_fragments , max_level , scalar_results , mbe_total_energy ) call coord_timer % stop () call logger % info ( \"Time to evaluate the MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end block ! Cleanup deallocate ( scalar_results ) end subroutine global_coordinator","tags":"","url":"proc/global_coordinator.html"},{"title":"node_coordinator – metalquicha","text":"public  subroutine node_coordinator(world_comm, node_comm) Node coordinator for distributing fragments to local workers\nHandles work requests and result collection from local workers Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm Calls proc~~node_coordinator~~CallsGraph proc~node_coordinator node_coordinator error error proc~node_coordinator->error iprobe iprobe proc~node_coordinator->iprobe irecv irecv proc~node_coordinator->irecv isend isend proc~node_coordinator->isend recv recv proc~node_coordinator->recv to_char to_char proc~node_coordinator->to_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~node_coordinator~~CalledByGraph proc~node_coordinator node_coordinator proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: dummy_msg integer(kind=int32), private :: finished_workers integer(kind=int32), private :: fragment_idx integer(kind=int32), private, allocatable :: fragment_indices (:) integer(kind=int32), private :: fragment_size type(MPI_Status), private :: global_status logical, private :: has_result integer(kind=int32), private :: local_dummy logical, private :: local_message_pending logical, private :: more_fragments type(request_t), private :: req real(kind=dp), private :: scalar_result type(MPI_Status), private :: status integer(kind=int32), private :: worker_fragment_map (node_comm%size()) integer(kind=int32), private :: worker_source Source Code subroutine node_coordinator ( world_comm , node_comm ) !! Node coordinator for distributing fragments to local workers !! Handles work requests and result collection from local workers class ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int32 ) :: fragment_idx , fragment_size , dummy_msg integer ( int32 ) :: finished_workers integer ( int32 ), allocatable :: fragment_indices (:) type ( MPI_Status ) :: status , global_status logical :: local_message_pending , more_fragments , has_result integer ( int32 ) :: local_dummy ! For tracking worker-fragment mapping and collecting results integer ( int32 ) :: worker_fragment_map ( node_comm % size ()) integer ( int32 ) :: worker_source real ( dp ) :: scalar_result ! MPI request handles for non-blocking operations type ( request_t ) :: req finished_workers = 0 more_fragments = . true . dummy_msg = 0 worker_fragment_map = 0 do while ( finished_workers < node_comm % size () - 1 ) ! PRIORITY 1: Check for incoming results from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_result , status ) if ( has_result ) then worker_source = status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Node coordinator received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state in node coordinator\" end if ! Receive scalar result from worker call irecv ( node_comm , scalar_result , worker_source , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Forward results to global coordinator with fragment index call isend ( world_comm , worker_fragment_map ( worker_source ), 0 , TAG_NODE_SCALAR_RESULT , req ) ! fragment_idx call wait ( req ) call isend ( world_comm , scalar_result , 0 , TAG_NODE_SCALAR_RESULT , req ) ! scalar result call wait ( req ) ! Clear the mapping worker_fragment_map ( worker_source ) = 0 end if ! PRIORITY 2: Check for work requests from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , local_message_pending , status ) if ( local_message_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( more_fragments ) then call isend ( world_comm , dummy_msg , 0 , TAG_NODE_REQUEST , req ) call wait ( req ) call irecv ( world_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , global_status ) if ( global_status % MPI_TAG == TAG_NODE_FRAGMENT ) then call irecv ( world_comm , fragment_size , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( world_comm , fragment_indices , 0 , TAG_NODE_FRAGMENT , global_status ) call isend ( node_comm , fragment_idx , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_size , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_indices , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Track which fragment was sent to this worker worker_fragment_map ( status % MPI_SOURCE ) = fragment_idx deallocate ( fragment_indices ) else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 more_fragments = . false . end if else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end if end do end subroutine node_coordinator","tags":"","url":"proc/node_coordinator.html"},{"title":"node_worker – metalquicha","text":"public  subroutine node_worker(world_comm, node_comm, sys_geom, method) Node worker for processing fragments assigned by node coordinator Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm type( system_geometry_t ), intent(in), optional :: sys_geom character(len=*), intent(in) :: method Calls proc~~node_worker~~CallsGraph proc~node_worker node_worker irecv irecv proc~node_worker->irecv isend isend proc~node_worker->isend proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~do_fragment_work do_fragment_work proc~node_worker->proc~do_fragment_work proc~fragment_destroy physical_fragment_t%fragment_destroy proc~node_worker->proc~fragment_destroy recv recv proc~node_worker->recv configuration configuration proc~do_fragment_work->configuration proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~result_destroy calculation_result_t%result_destroy proc~do_fragment_work->proc~result_destroy proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy info info proc~print_fragment_xyz->info proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom to_char to_char proc~print_fragment_xyz->to_char proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~node_worker~~CalledByGraph proc~node_worker node_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: C_flat (:) real(kind=dp), private :: dot_result integer(kind=int32), private :: dummy_msg integer(kind=int32), private :: fragment_idx integer(kind=int32), private, allocatable :: fragment_indices (:) integer(kind=int32), private :: fragment_size type( physical_fragment_t ), private :: phys_frag type(request_t), private :: req type(MPI_Status), private :: status Source Code subroutine node_worker ( world_comm , node_comm , sys_geom , method ) !! Node worker for processing fragments assigned by node coordinator class ( comm_t ), intent ( in ) :: world_comm , node_comm type ( system_geometry_t ), intent ( in ), optional :: sys_geom character ( len =* ), intent ( in ) :: method integer ( int32 ) :: fragment_idx , fragment_size , dummy_msg integer ( int32 ), allocatable :: fragment_indices (:) real ( dp ) :: dot_result real ( dp ), allocatable :: C_flat (:) type ( MPI_Status ) :: status type ( physical_fragment_t ) :: phys_frag ! MPI request handles for non-blocking operations type ( request_t ) :: req dummy_msg = 0 do call isend ( node_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( node_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) select case ( status % MPI_TAG ) case ( TAG_WORKER_FRAGMENT ) call irecv ( node_comm , fragment_size , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( node_comm , fragment_indices , 0 , TAG_WORKER_FRAGMENT , status ) ! Build physical fragment from indices if sys_geom is available if ( present ( sys_geom )) then call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag ) ! Process the chemistry fragment with physical geometry call do_fragment_work ( fragment_idx , & dot_result , C_flat , method , phys_frag ) call phys_frag % destroy () else ! Process without physical geometry (old behavior) call do_fragment_work ( fragment_idx , & dot_result , C_flat , method ) end if ! Send results back to coordinator call isend ( node_comm , dot_result , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) deallocate ( fragment_indices , C_flat ) case ( TAG_WORKER_FINISH ) exit end select end do end subroutine node_worker","tags":"","url":"proc/node_worker.html"},{"title":"serial_fragment_processor – metalquicha","text":"public  subroutine serial_fragment_processor(total_fragments, polymers, max_level, sys_geom, method) Process all fragments serially in single-rank mode\nThis is used when running with only 1 MPI rank Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom character(len=*), intent(in) :: method Calls proc~~serial_fragment_processor~~CallsGraph proc~serial_fragment_processor serial_fragment_processor get_elapsed_time get_elapsed_time proc~serial_fragment_processor->get_elapsed_time info info proc~serial_fragment_processor->info omp_get_max_threads omp_get_max_threads proc~serial_fragment_processor->omp_get_max_threads omp_set_num_threads omp_set_num_threads proc~serial_fragment_processor->omp_set_num_threads proc~build_fragment_from_indices build_fragment_from_indices proc~serial_fragment_processor->proc~build_fragment_from_indices proc~compute_mbe_energy compute_mbe_energy proc~serial_fragment_processor->proc~compute_mbe_energy proc~do_fragment_work do_fragment_work proc~serial_fragment_processor->proc~do_fragment_work proc~fragment_destroy physical_fragment_t%fragment_destroy proc~serial_fragment_processor->proc~fragment_destroy start start proc~serial_fragment_processor->start to_char to_char proc~serial_fragment_processor->to_char proc~compute_mbe_energy->get_elapsed_time proc~compute_mbe_energy->info proc~compute_mbe_energy->start proc~compute_mbe_energy->to_char configuration configuration proc~compute_mbe_energy->configuration debug debug proc~compute_mbe_energy->debug proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~do_fragment_work->configuration proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~result_destroy calculation_result_t%result_destroy proc~do_fragment_work->proc~result_destroy proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~basis_set_destroy->proc~atomic_basis_destroy proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name verbose verbose proc~print_detailed_breakdown->verbose warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->info error error proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~print_detailed_breakdown_json->warning proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~fragment_lookup_find->fnv_1a_hash proc~fragment_lookup_find->sort proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~serial_fragment_processor~~CalledByGraph proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: C_flat (:) type(timer_type), private :: coord_timer real(kind=dp), private :: dot_result integer(kind=int64), private :: frag_idx integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size real(kind=dp), private :: mbe_total_energy type( physical_fragment_t ), private :: phys_frag real(kind=dp), private, allocatable :: scalar_results (:) Source Code subroutine serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method ) !! Process all fragments serially in single-rank mode !! This is used when running with only 1 MPI rank integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: polymers (:, :), max_level type ( system_geometry_t ), intent ( in ) :: sys_geom character ( len =* ), intent ( in ) :: method integer ( int64 ) :: frag_idx integer :: fragment_size integer , allocatable :: fragment_indices (:) real ( dp ), allocatable :: scalar_results (:) real ( dp ), allocatable :: C_flat (:) real ( dp ) :: dot_result , mbe_total_energy type ( physical_fragment_t ) :: phys_frag type ( timer_type ) :: coord_timer call logger % info ( \"Processing \" // to_char ( total_fragments ) // \" fragments serially...\" ) allocate ( scalar_results ( total_fragments )) scalar_results = 0.0_dp call omp_set_num_threads ( 1 ) call coord_timer % start () do frag_idx = 1_int64 , total_fragments fragment_size = count ( polymers ( frag_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( frag_idx , 1 : fragment_size ) call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag ) call do_fragment_work ( int ( frag_idx ), & dot_result , C_flat , method , phys_frag ) scalar_results ( frag_idx ) = dot_result call phys_frag % destroy () deallocate ( fragment_indices , C_flat ) if ( mod ( frag_idx , max ( 1_int64 , total_fragments / 10 )) == 0 . or . frag_idx == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( frag_idx ) // \"/\" // to_char ( total_fragments ) // & \" fragments [\" // to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call omp_set_num_threads ( omp_get_max_threads ()) call logger % info ( \"All fragments processed\" ) call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () call compute_mbe_energy ( polymers , total_fragments , max_level , scalar_results , mbe_total_energy ) call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) deallocate ( scalar_results ) end subroutine serial_fragment_processor","tags":"","url":"proc/serial_fragment_processor.html"},{"title":"unfragmented_calculation – metalquicha","text":"public  subroutine unfragmented_calculation(sys_geom, method) Run unfragmented calculation on the entire system (nlevel=0)\nThis is a simple single-process calculation without MPI distribution Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom character(len=*), intent(in) :: method Calls proc~~unfragmented_calculation~~CallsGraph proc~unfragmented_calculation unfragmented_calculation all_monomer_indices all_monomer_indices proc~unfragmented_calculation->all_monomer_indices error error proc~unfragmented_calculation->error info info proc~unfragmented_calculation->info proc~build_fragment_from_indices build_fragment_from_indices proc~unfragmented_calculation->proc~build_fragment_from_indices proc~do_fragment_work do_fragment_work proc~unfragmented_calculation->proc~do_fragment_work temp_indices temp_indices proc~unfragmented_calculation->temp_indices to_char to_char proc~unfragmented_calculation->to_char configuration configuration proc~do_fragment_work->configuration proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~result_destroy calculation_result_t%result_destroy proc~do_fragment_work->proc~result_destroy proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~print_fragment_xyz->info proc~print_fragment_xyz->to_char proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz->proc~element_number_to_symbol proc~to_angstrom to_angstrom proc~print_fragment_xyz->proc~to_angstrom proc~result_reset calculation_result_t%result_reset proc~result_destroy->proc~result_reset new new proc~xtb_calc_energy->new new_gfn1_calculator new_gfn1_calculator proc~xtb_calc_energy->new_gfn1_calculator new_gfn2_calculator new_gfn2_calculator proc~xtb_calc_energy->new_gfn2_calculator new_wavefunction new_wavefunction proc~xtb_calc_energy->new_wavefunction xtb_singlepoint xtb_singlepoint proc~xtb_calc_energy->xtb_singlepoint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unfragmented_calculation~~CalledByGraph proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_unfragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: C_flat (:) real(kind=dp), private :: dot_result type( physical_fragment_t ), private :: full_system integer, private :: i integer, private :: total_atoms Source Code subroutine unfragmented_calculation ( sys_geom , method ) !! Run unfragmented calculation on the entire system (nlevel=0) !! This is a simple single-process calculation without MPI distribution type ( system_geometry_t ), intent ( in ), optional :: sys_geom character ( len =* ), intent ( in ) :: method real ( dp ) :: dot_result real ( dp ), allocatable :: C_flat (:) integer :: total_atoms type ( physical_fragment_t ) :: full_system integer :: i if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for unfragmented calculation\" ) error stop \"Missing geometry in unfragmented_calculation\" end if total_atoms = sys_geom % total_atoms call logger % info ( \"============================================\" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( total_atoms )) call logger % info ( \"============================================\" ) ! Build the full system as a single fragment (all monomers) block integer , allocatable :: all_monomer_indices (:) allocate ( all_monomer_indices ( sys_geom % n_monomers )) do i = 1 , sys_geom % n_monomers all_monomer_indices ( i ) = i end do call build_fragment_from_indices ( sys_geom , all_monomer_indices , full_system ) deallocate ( all_monomer_indices ) end block ! Process the full system with verbosity=1 for detailed output block integer , allocatable :: temp_indices (:) allocate ( temp_indices ( sys_geom % n_monomers )) do i = 1 , sys_geom % n_monomers temp_indices ( i ) = i end do call do_fragment_work ( 0 , & dot_result , C_flat , & method , phys_frag = full_system ) deallocate ( temp_indices ) end block call logger % info ( \"============================================\" ) call logger % info ( \"Unfragmented calculation completed\" ) block character ( len = 256 ) :: result_line write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , dot_result call logger % info ( trim ( result_line )) end block !call logger%info(\"  Matrix size: \"//to_char(size(C_flat))) call logger % info ( \"============================================\" ) if ( allocated ( C_flat )) deallocate ( C_flat ) end subroutine unfragmented_calculation","tags":"","url":"proc/unfragmented_calculation.html"},{"title":"send_fragment_to_node – metalquicha","text":"private  subroutine send_fragment_to_node(world_comm, fragment_idx, polymers, dest_rank) Send fragment data to remote node coordinator\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank Calls proc~~send_fragment_to_node~~CallsGraph proc~send_fragment_to_node send_fragment_to_node isend isend proc~send_fragment_to_node->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_fragment_to_node~~CalledByGraph proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator global_coordinator proc~global_coordinator->proc~send_fragment_to_node proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: fragment_idx_int32 integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size type(request_t), private :: req (3) Source Code subroutine send_fragment_to_node ( world_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to remote node coordinator !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 3 ) integer ( int32 ) :: fragment_idx_int32 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! TODO: serialize the data for better performance fragment_idx_int32 = int ( fragment_idx , kind = int32 ) call isend ( world_comm , fragment_idx_int32 , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_size , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , fragment_indices , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_node","tags":"","url":"proc/send_fragment_to_node.html"},{"title":"send_fragment_to_worker – metalquicha","text":"private  subroutine send_fragment_to_worker(node_comm, fragment_idx, polymers, dest_rank) Send fragment data to local worker\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank Calls proc~~send_fragment_to_worker~~CallsGraph proc~send_fragment_to_worker send_fragment_to_worker isend isend proc~send_fragment_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~send_fragment_to_worker~~CalledByGraph proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator global_coordinator proc~global_coordinator->proc~send_fragment_to_worker proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: fragment_idx_int32 integer, private, allocatable :: fragment_indices (:) integer, private :: fragment_size type(request_t), private :: req (3) Source Code subroutine send_fragment_to_worker ( node_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to local worker !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 3 ) integer ( int32 ) :: fragment_idx_int32 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! TODO: serialize the data for better performance fragment_idx_int32 = int ( fragment_idx , kind = int32 ) call isend ( node_comm , fragment_idx_int32 , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_size , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , fragment_indices , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_worker","tags":"","url":"proc/send_fragment_to_worker.html"},{"title":"element_mass – metalquicha","text":"public pure function element_mass(atomic_number) result(mass) Return atomic mass in atomic mass units (amu) for a given atomic number\nUses standard atomic weights from IUPAC Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value real(kind=dp) Called by proc~~element_mass~~CalledByGraph proc~element_mass element_mass proc~fragment_center_of_mass fragment_center_of_mass proc~fragment_center_of_mass->proc~element_mass proc~distance_between_fragments distance_between_fragments proc~distance_between_fragments->proc~fragment_center_of_mass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function element_mass ( atomic_number ) result ( mass ) !! Return atomic mass in atomic mass units (amu) for a given atomic number !! Uses standard atomic weights from IUPAC integer , intent ( in ) :: atomic_number real ( dp ) :: mass select case ( atomic_number ) case ( 1 : 118 ) mass = element_masses ( atomic_number ) case default mass = 0.0_dp ! Unknown element end select end function element_mass","tags":"","url":"proc/element_mass.html"},{"title":"element_number_to_symbol – metalquicha","text":"public pure function element_number_to_symbol(atomic_number) result(symbol) Convert atomic number to element symbol\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value character(len=2) Called by proc~~element_number_to_symbol~~CalledByGraph proc~element_number_to_symbol element_number_to_symbol proc~print_fragment_xyz print_fragment_xyz proc~print_fragment_xyz->proc~element_number_to_symbol proc~do_fragment_work do_fragment_work proc~do_fragment_work->proc~print_fragment_xyz proc~node_worker node_worker proc~node_worker->proc~do_fragment_work proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~do_fragment_work proc~unfragmented_calculation unfragmented_calculation proc~unfragmented_calculation->proc~do_fragment_work proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~node_worker proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function element_number_to_symbol ( atomic_number ) result ( symbol ) !! Convert atomic number to element symbol !! Covers the complete periodic table (elements 1-118) integer , intent ( in ) :: atomic_number character ( len = 2 ) :: symbol select case ( atomic_number ) case ( 1 : 118 ) symbol = element_symbols ( atomic_number ) case default symbol = 'Xx' ! Unknown end select end function element_number_to_symbol","tags":"","url":"proc/element_number_to_symbol.html"},{"title":"element_symbol_to_number – metalquicha","text":"public pure function element_symbol_to_number(symbol) result(atomic_number) Convert element symbol to atomic number\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Return Value integer Calls proc~~element_symbol_to_number~~CallsGraph proc~element_symbol_to_number element_symbol_to_number to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~element_symbol_to_number~~CalledByGraph proc~element_symbol_to_number element_symbol_to_number proc~initialize_system_geometry initialize_system_geometry proc~initialize_system_geometry->proc~element_symbol_to_number program~main main program~main->proc~initialize_system_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=2), private :: sym Source Code pure function element_symbol_to_number ( symbol ) result ( atomic_number ) !! Convert element symbol to atomic number !! Covers the complete periodic table (elements 1-118) character ( len =* ), intent ( in ) :: symbol integer :: atomic_number character ( len = 2 ) :: sym ! Normalize: uppercase first letter, lowercase second sym = adjustl ( symbol ) if ( len_trim ( sym ) >= 1 ) sym ( 1 : 1 ) = to_upper ( sym ( 1 : 1 )) if ( len_trim ( sym ) >= 2 ) sym ( 2 : 2 ) = to_lower ( sym ( 2 : 2 )) ! Search for symbol in table atomic_number = findloc ( element_symbols , sym , dim = 1 ) end function element_symbol_to_number","tags":"","url":"proc/element_symbol_to_number.html"},{"title":"hf_calc_energy – metalquicha","text":"private  subroutine hf_calc_energy(this, fragment, result) Calculate electronic energy using Hartree-Fock method Type Bound hf_method_t Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Called by proc~~hf_calc_energy~~CalledByGraph proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_gradient->proc~hf_calc_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hf_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement actual HF calculation ! 1. Convert fragment%basis to libcint format ! 2. Build one-electron integrals (S, T, V) ! 3. Run SCF iterations ! 4. Calculate final energy print * , \"HF: Calculating energy for fragment with\" , fragment % n_atoms , \"atoms\" print * , \"HF: nelec =\" , fragment % nelec print * , \"HF: charge =\" , fragment % charge print * , \"HF: multiplicity =\" , fragment % multiplicity ! Dummy result result % energy = - 1.0_dp ! Placeholder result % has_energy = . true . print * , \"HF: Dummy energy =\" , result % energy end subroutine hf_calc_energy","tags":"","url":"proc/hf_calc_energy.html"},{"title":"hf_calc_gradient – metalquicha","text":"private  subroutine hf_calc_gradient(this, fragment, result) Calculate energy gradient using Hartree-Fock method Type Bound hf_method_t Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result Calls proc~~hf_calc_gradient~~CallsGraph proc~hf_calc_gradient hf_method_t%hf_calc_gradient proc~hf_calc_energy hf_method_t%hf_calc_energy proc~hf_calc_gradient->proc~hf_calc_energy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hf_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement gradient calculation ! 1. Calculate energy (call calc_energy) ! 2. Calculate gradient using integral derivatives print * , \"HF: Calculating gradient for fragment with\" , fragment % n_atoms , \"atoms\" ! First get energy call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . print * , \"HF: Dummy gradient allocated\" end subroutine hf_calc_gradient","tags":"","url":"proc/hf_calc_gradient.html"},{"title":"compute_mbe – metalquicha","text":"private  function compute_mbe(fragment_idx, fragment, lookup, energies, delta_energies, n) result(delta_E) Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas)\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all subset deltaE values\nAll subsets must have been computed already (guaranteed by processing fragments in order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Index of this fragment (already known) integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup Pre-built hash table for lookups real(kind=dp), intent(in) :: energies (:) Pre-computed delta values real(kind=dp), intent(in) :: delta_energies (:) Pre-computed delta values integer, intent(in) :: n Return Value real(kind=dp) Calls proc~~compute_mbe~~CallsGraph proc~compute_mbe compute_mbe proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe~~CalledByGraph proc~compute_mbe compute_mbe proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~compute_mbe proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: has_next integer, private :: i integer, private, allocatable :: indices (:) integer, private, allocatable :: subset (:) integer(kind=int64), private :: subset_idx integer, private :: subset_size Source Code function compute_mbe ( fragment_idx , fragment , lookup , energies , delta_energies , n ) result ( delta_E ) !! Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas) !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all subset deltaE values !! All subsets must have been computed already (guaranteed by processing fragments in order) integer ( int64 ), intent ( in ) :: fragment_idx !! Index of this fragment (already known) integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup !! Pre-built hash table for lookups real ( dp ), intent ( in ) :: energies (:), delta_energies (:) !! Pre-computed delta values real ( dp ) :: delta_E integer :: subset_size , i integer , allocatable :: indices (:), subset (:) integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer energy delta_E = energies ( fragment_idx ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 allocate ( indices ( subset_size )) allocate ( subset ( subset_size )) ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset , subset_size ) if ( subset_idx < 0 ) error stop \"Subset not found in bottom-up MBE!\" ! Subtract pre-computed delta energy delta_E = delta_E - delta_energies ( subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do deallocate ( indices , subset ) end do end function compute_mbe","tags":"","url":"proc/compute_mbe.html"},{"title":"compute_mbe_energy – metalquicha","text":"public  subroutine compute_mbe_energy(polymers, fragment_count, max_level, energies, total_energy) Uses pic_logger proc~~compute_mbe_energy~~UsesGraph proc~compute_mbe_energy compute_mbe_energy pic_logger pic_logger proc~compute_mbe_energy->pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Compute the many-body expansion (MBE) energy\nTotal = sum(E(i)) + sum(deltaE(ij)) + sum(deltaE(ijk)) + …\nGeneral n-body correction:\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all lower-order terms\nUses int64 for fragment_count to handle large fragment counts that overflow int32.\nDetailed breakdown is printed only if logger level is verbose or higher. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(out) :: total_energy Calls proc~~compute_mbe_energy~~CallsGraph proc~compute_mbe_energy compute_mbe_energy configuration configuration proc~compute_mbe_energy->configuration debug debug proc~compute_mbe_energy->debug get_elapsed_time get_elapsed_time proc~compute_mbe_energy->get_elapsed_time info info proc~compute_mbe_energy->info proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json start start proc~compute_mbe_energy->start to_char to_char proc~compute_mbe_energy->to_char proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe->proc~fragment_lookup_find proc~get_next_combination get_next_combination proc~compute_mbe->proc~get_next_combination proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort header header proc~print_detailed_breakdown->header level_name level_name proc~print_detailed_breakdown->level_name proc~get_frag_level_name get_frag_level_name proc~print_detailed_breakdown->proc~get_frag_level_name verbose verbose proc~print_detailed_breakdown->verbose warning warning proc~print_detailed_breakdown->warning proc~print_detailed_breakdown_json->info error error proc~print_detailed_breakdown_json->error proc~print_detailed_breakdown_json->proc~get_frag_level_name proc~print_detailed_breakdown_json->warning proc~fragment_lookup_find->fnv_1a_hash proc~fragment_lookup_find->sort proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_mbe_energy~~CalledByGraph proc~compute_mbe_energy compute_mbe_energy proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: body_level integer, private :: current_log_level real(kind=dp), private :: delta_E real(kind=dp), private, allocatable :: delta_energies (:) logical, private :: do_detailed_print integer, private :: fragment_size integer(kind=int64), private :: i type( fragment_lookup_t ), private :: lookup type(timer_type), private :: lookup_timer real(kind=dp), private, allocatable :: sum_by_level (:) Source Code subroutine compute_mbe_energy ( polymers , fragment_count , max_level , energies , total_energy ) !! Compute the many-body expansion (MBE) energy !! Total = sum(E(i)) + sum(deltaE(ij)) + sum(deltaE(ijk)) + ... !! General n-body correction: !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all lower-order terms !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. !! Detailed breakdown is printed only if logger level is verbose or higher. use pic_logger , only : verbose_level integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level real ( dp ), intent ( in ) :: energies (:) real ( dp ), intent ( out ) :: total_energy integer ( int64 ) :: i integer :: fragment_size , body_level , current_log_level real ( dp ), allocatable :: sum_by_level (:), delta_energies (:) real ( dp ) :: delta_E logical :: do_detailed_print type ( fragment_lookup_t ) :: lookup type ( timer_type ) :: lookup_timer call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) sum_by_level = 0.0_dp delta_energies = 0.0_dp ! Build hash table for fast fragment lookups call lookup_timer % start () call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) call lookup % insert ( polymers ( i , :), fragment_size , i ) end do call lookup_timer % stop () call logger % debug ( \"Time to build lookup table: \" // to_char ( lookup_timer % get_elapsed_time ()) // \" s\" ) call logger % debug ( \"Hash table size: \" // to_char ( lookup % table_size ) // & \", entries: \" // to_char ( lookup % n_entries )) ! Bottom-up computation: process fragments by size (1-body, then 2-body, then 3-body, etc.) ! This eliminates recursion and redundant subset computations do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == 1 ) then ! 1-body: deltaE = E (no subsets to subtract) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: deltaE = E - sum(all subset deltaEs) ! All subsets have already been computed in previous iterations delta_E = compute_mbe ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E end if end do ! Clean up lookup table call lookup % destroy () total_energy = sum ( sum_by_level ) ! Print text summary to console call logger % info ( \"MBE Energy breakdown:\" ) do body_level = 1 , max_level if ( abs ( sum_by_level ( body_level )) > 1e-15_dp ) then block character ( len = 256 ) :: energy_line write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , body_level , \"-body:  \" , sum_by_level ( body_level ) call logger % info ( trim ( energy_line )) end block end if end do block character ( len = 256 ) :: total_line write ( total_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( total_line )) end block ! Print detailed breakdown if requested if ( do_detailed_print ) then call print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) end if ! Always write JSON file for machine-readable output call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy ) deallocate ( sum_by_level , delta_energies ) end subroutine compute_mbe_energy","tags":"","url":"proc/compute_mbe_energy.html"},{"title":"binomial – metalquicha","text":"public pure function binomial(n, r) result(c) Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) Calculates “n choose r” using iterative algorithm to avoid\nfactorial overflow for large numbers.\nUses int64 to handle large combinatorial values that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n Total number of items integer(kind=default_int), intent(in) :: r Number of items to choose Return Value integer(kind=int64) Binomial coefficient result Called by proc~~binomial~~CalledByGraph proc~binomial binomial proc~get_nfrags get_nfrags proc~get_nfrags->proc~binomial proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~get_nfrags proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i Loop counter Source Code pure function binomial ( n , r ) result ( c ) !! Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) !! !! Calculates \"n choose r\" using iterative algorithm to avoid !! factorial overflow for large numbers. !! Uses int64 to handle large combinatorial values that overflow int32. integer ( default_int ), intent ( in ) :: n !! Total number of items integer ( default_int ), intent ( in ) :: r !! Number of items to choose integer ( int64 ) :: c !! Binomial coefficient result integer ( default_int ) :: i !! Loop counter if ( r == 0 . or . r == n ) then c = 1_int64 else if ( r > n ) then c = 0_int64 else c = 1_int64 do i = 1 , r c = c * int ( n - i + 1 , int64 ) / int ( i , int64 ) end do end if end function binomial","tags":"","url":"proc/binomial.html"},{"title":"get_nfrags – metalquicha","text":"public pure function get_nfrags(n_monomers, max_level) result(n_expected_fragments) Calculate total number of fragments for given system size and max level Computes the sum of binomial coefficients C(n,k) for k=1 to max_level,\nrepresenting all possible fragments from monomers to max_level-mers.\nUses int64 to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n_monomers Number of monomers in system integer(kind=default_int), intent(in) :: max_level Maximum fragment size Return Value integer(kind=int64) Total fragment count Calls proc~~get_nfrags~~CallsGraph proc~get_nfrags get_nfrags proc~binomial binomial proc~get_nfrags->proc~binomial Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_nfrags~~CalledByGraph proc~get_nfrags get_nfrags proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~get_nfrags proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i Loop counter Source Code pure function get_nfrags ( n_monomers , max_level ) result ( n_expected_fragments ) !! Calculate total number of fragments for given system size and max level !! !! Computes the sum of binomial coefficients C(n,k) for k=1 to max_level, !! representing all possible fragments from monomers to max_level-mers. !! Uses int64 to handle large fragment counts that overflow int32. integer ( default_int ), intent ( in ) :: n_monomers !! Number of monomers in system integer ( default_int ), intent ( in ) :: max_level !! Maximum fragment size integer ( int64 ) :: n_expected_fragments !! Total fragment count integer ( default_int ) :: i !! Loop counter n_expected_fragments = 0_int64 do i = 1 , max_level n_expected_fragments = n_expected_fragments + binomial ( n_monomers , i ) end do end function get_nfrags","tags":"","url":"proc/get_nfrags.html"},{"title":"arrays_equal_internal – metalquicha","text":"private pure function arrays_equal_internal(a, b, n) result(equal) Check if two arrays are equal Arguments Type Intent Optional Attributes Name integer, intent(in) :: a (:) integer, intent(in) :: b (:) integer, intent(in) :: n Return Value logical Called by proc~~arrays_equal_internal~~CalledByGraph proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~fragment_lookup_find->proc~arrays_equal_internal proc~compute_mbe compute_mbe proc~compute_mbe->proc~fragment_lookup_find proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~compute_mbe proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure function arrays_equal_internal ( a , b , n ) result ( equal ) !! Check if two arrays are equal integer , intent ( in ) :: a (:), b (:), n logical :: equal integer :: i equal = . true . if ( size ( a ) /= n . or . size ( b ) /= n ) then equal = . false . return end if do i = 1 , n if ( a ( i ) /= b ( i )) then equal = . false . return end if end do end function arrays_equal_internal","tags":"","url":"proc/arrays_equal_internal.html"},{"title":"fragment_lookup_find – metalquicha","text":"private  function fragment_lookup_find(this, monomers, n) result(idx) Find fragment index for given monomer combination Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) Calls proc~~fragment_lookup_find~~CallsGraph proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find fnv_1a_hash fnv_1a_hash proc~fragment_lookup_find->fnv_1a_hash proc~arrays_equal_internal arrays_equal_internal proc~fragment_lookup_find->proc~arrays_equal_internal sort sort proc~fragment_lookup_find->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_find~~CalledByGraph proc~fragment_lookup_find fragment_lookup_t%fragment_lookup_find proc~compute_mbe compute_mbe proc~compute_mbe->proc~fragment_lookup_find proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~compute_mbe proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: bucket type( hash_entry_t ), private, pointer :: entry integer(kind=int32), private :: hash_val integer, private :: sorted_key (n) Source Code function fragment_lookup_find ( this , monomers , n ) result ( idx ) !! Find fragment index for given monomer combination class ( fragment_lookup_t ), intent ( in ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ) :: idx integer ( int32 ) :: hash_val integer :: bucket , sorted_key ( n ) type ( hash_entry_t ), pointer :: entry ! Sort monomers for canonical key sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Search chain if ( allocated ( this % table ( bucket )% key )) then if ( arrays_equal_internal ( this % table ( bucket )% key , sorted_key , n )) then idx = this % table ( bucket )% value return end if entry => this % table ( bucket )% next do while ( associated ( entry )) if ( arrays_equal_internal ( entry % key , sorted_key , n )) then idx = entry % value return end if entry => entry % next end do end if ! Not found idx = - 1 end function fragment_lookup_find","tags":"","url":"proc/fragment_lookup_find.html"},{"title":"next_prime_internal – metalquicha","text":"private pure function next_prime_internal(n) result(p) Find next prime number >= n (simple implementation) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer Called by proc~~next_prime_internal~~CalledByGraph proc~next_prime_internal next_prime_internal proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~fragment_lookup_init->proc~next_prime_internal proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~fragment_lookup_init proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i logical, private :: is_prime Source Code pure function next_prime_internal ( n ) result ( p ) !! Find next prime number >= n (simple implementation) integer , intent ( in ) :: n integer :: p , i logical :: is_prime p = max ( n , 2 ) if ( modulo ( p , 2 ) == 0 ) p = p + 1 do is_prime = . true . do i = 3 , int ( sqrt ( real ( p ))) + 1 , 2 if ( modulo ( p , i ) == 0 ) then is_prime = . false . exit end if end do if ( is_prime ) return p = p + 2 end do end function next_prime_internal","tags":"","url":"proc/next_prime_internal.html"},{"title":"create_monomer_list – metalquicha","text":"public pure subroutine create_monomer_list(monomers) Generate a list of monomer indices from 1 to N Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(inout), allocatable :: monomers (:) Called by proc~~create_monomer_list~~CalledByGraph proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~create_monomer_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: length Source Code pure subroutine create_monomer_list ( monomers ) !! Generate a list of monomer indices from 1 to N integer ( default_int ), allocatable , intent ( inout ) :: monomers (:) integer ( default_int ) :: i , length length = size ( monomers , 1 ) do i = 1 , length monomers ( i ) = i end do end subroutine create_monomer_list","tags":"","url":"proc/create_monomer_list.html"},{"title":"generate_fragment_list – metalquicha","text":"public recursive subroutine generate_fragment_list(monomers, max_level, polymers, count) Generate all possible fragments (combinations of monomers) up to max_level\nUses int64 for count to handle large numbers of fragments that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: monomers (:) integer(kind=default_int), intent(in) :: max_level integer(kind=default_int), intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: count Calls proc~~generate_fragment_list~~CallsGraph proc~generate_fragment_list generate_fragment_list proc~combine combine proc~generate_fragment_list->proc~combine proc~combine_util combine_util proc~combine->proc~combine_util proc~combine_util->proc~combine_util Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~generate_fragment_list~~CalledByGraph proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: n integer(kind=default_int), private :: r Source Code recursive subroutine generate_fragment_list ( monomers , max_level , polymers , count ) !! Generate all possible fragments (combinations of monomers) up to max_level !! Uses int64 for count to handle large numbers of fragments that overflow int32. integer ( default_int ), intent ( in ) :: monomers (:), max_level integer ( default_int ), intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: r , n n = size ( monomers , 1 ) do r = 2 , max_level call combine ( monomers , n , r , polymers , count ) end do end subroutine generate_fragment_list","tags":"","url":"proc/generate_fragment_list.html"},{"title":"get_next_combination – metalquicha","text":"public pure subroutine get_next_combination(indices, k, n, has_next) Generate next combination (updates indices in place)\nhas_next = .true. if there’s a next combination Arguments Type Intent Optional Attributes Name integer, intent(inout) :: indices (:) integer, intent(in) :: k integer, intent(in) :: n logical, intent(out) :: has_next Called by proc~~get_next_combination~~CalledByGraph proc~get_next_combination get_next_combination proc~compute_mbe compute_mbe proc~compute_mbe->proc~get_next_combination proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~compute_mbe proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code pure subroutine get_next_combination ( indices , k , n , has_next ) !! Generate next combination (updates indices in place) !! has_next = .true. if there's a next combination integer , intent ( inout ) :: indices (:) integer , intent ( in ) :: k , n logical , intent ( out ) :: has_next integer :: i has_next = . true . i = k do while ( i >= 1 ) if ( indices ( i ) < n - k + i ) then indices ( i ) = indices ( i ) + 1 do while ( i < k ) i = i + 1 indices ( i ) = indices ( i - 1 ) + 1 end do return end if i = i - 1 end do has_next = . false . end subroutine get_next_combination","tags":"","url":"proc/get_next_combination.html"},{"title":"combine – metalquicha","text":"private recursive subroutine combine(arr, n, r, out_array, count) Generate all combinations of size r from array arr of size n\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count Calls proc~~combine~~CallsGraph proc~combine combine proc~combine_util combine_util proc~combine->proc~combine_util proc~combine_util->proc~combine_util Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~combine~~CalledByGraph proc~combine combine proc~generate_fragment_list generate_fragment_list proc~generate_fragment_list->proc~combine proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: data (r) Source Code recursive subroutine combine ( arr , n , r , out_array , count ) !! Generate all combinations of size r from array arr of size n !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:) integer ( default_int ), intent ( in ) :: n , r integer ( default_int ), intent ( inout ) :: out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: data ( r ) call combine_util ( arr , n , r , 1 , data , 1 , out_array , count ) end subroutine combine","tags":"","url":"proc/combine.html"},{"title":"combine_util – metalquicha","text":"private recursive subroutine combine_util(arr, n, r, index, data, i, out_array, count) Utility for generating combinations recursively\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(in) :: index integer(kind=default_int), intent(inout) :: data (:) integer(kind=default_int), intent(in) :: i integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count Called by proc~~combine_util~~CalledByGraph proc~combine_util combine_util proc~combine_util->proc~combine_util proc~combine combine proc~combine->proc~combine_util proc~generate_fragment_list generate_fragment_list proc~generate_fragment_list->proc~combine proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~generate_fragment_list proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: j Source Code recursive subroutine combine_util ( arr , n , r , index , data , i , out_array , count ) !! Utility for generating combinations recursively !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:), n , r , index , i integer ( default_int ), intent ( inout ) :: data (:), out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: j if ( index > r ) then count = count + 1_int64 out_array ( count , 1 : r ) = data ( 1 : r ) return end if do j = i , n data ( index ) = arr ( j ) call combine_util ( arr , n , r , index + 1 , data , j + 1 , out_array , count ) end do end subroutine combine_util","tags":"","url":"proc/combine_util.html"},{"title":"fragment_lookup_destroy – metalquicha","text":"private  subroutine fragment_lookup_destroy(this) Clean up hash table and all chains Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this Called by proc~~fragment_lookup_destroy~~CalledByGraph proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( hash_entry_t ), private, pointer :: entry integer, private :: i type( hash_entry_t ), private, pointer :: next_entry Source Code subroutine fragment_lookup_destroy ( this ) !! Clean up hash table and all chains class ( fragment_lookup_t ), intent ( inout ) :: this integer :: i type ( hash_entry_t ), pointer :: entry , next_entry if (. not . this % initialized ) return do i = 1 , this % table_size ! Free chain entry => this % table ( i )% next do while ( associated ( entry )) next_entry => entry % next if ( allocated ( entry % key )) deallocate ( entry % key ) deallocate ( entry ) entry => next_entry end do ! Free bucket head if ( allocated ( this % table ( i )% key )) deallocate ( this % table ( i )% key ) end do deallocate ( this % table ) this % initialized = . false . end subroutine fragment_lookup_destroy","tags":"","url":"proc/fragment_lookup_destroy.html"},{"title":"fragment_lookup_init – metalquicha","text":"private  subroutine fragment_lookup_init(this, estimated_entries) Initialize hash table with estimated size Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries Calls proc~~fragment_lookup_init~~CallsGraph proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~next_prime_internal next_prime_internal proc~fragment_lookup_init->proc~next_prime_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_init~~CalledByGraph proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~fragment_lookup_init proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code subroutine fragment_lookup_init ( this , estimated_entries ) !! Initialize hash table with estimated size class ( fragment_lookup_t ), intent ( inout ) :: this integer ( int64 ), intent ( in ) :: estimated_entries integer :: i ! Use prime number close to estimated size for better distribution this % table_size = next_prime_internal ( int ( estimated_entries * 1.3_8 )) allocate ( this % table ( this % table_size )) ! Initialize all entries as empty do i = 1 , this % table_size nullify ( this % table ( i )% next ) end do this % n_entries = 0 this % initialized = . true . end subroutine fragment_lookup_init","tags":"","url":"proc/fragment_lookup_init.html"},{"title":"fragment_lookup_insert – metalquicha","text":"private  subroutine fragment_lookup_insert(this, monomers, n, fragment_idx) Insert a monomer combination -> fragment index mapping Type Bound fragment_lookup_t Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx Calls proc~~fragment_lookup_insert~~CallsGraph proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert fnv_1a_hash fnv_1a_hash proc~fragment_lookup_insert->fnv_1a_hash sort sort proc~fragment_lookup_insert->sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fragment_lookup_insert~~CalledByGraph proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy compute_mbe_energy proc~compute_mbe_energy->proc~fragment_lookup_insert proc~global_coordinator global_coordinator proc~global_coordinator->proc~compute_mbe_energy proc~serial_fragment_processor serial_fragment_processor proc~serial_fragment_processor->proc~compute_mbe_energy proc~run_fragmented_calculation run_fragmented_calculation proc~run_fragmented_calculation->proc~global_coordinator proc~run_fragmented_calculation->proc~serial_fragment_processor proc~run_calculation run_calculation proc~run_calculation->proc~run_fragmented_calculation program~main main program~main->proc~run_calculation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: bucket integer(kind=int32), private :: hash_val type( hash_entry_t ), private, pointer :: new_entry integer, private, allocatable :: sorted_key (:) Source Code subroutine fragment_lookup_insert ( this , monomers , n , fragment_idx ) !! Insert a monomer combination -> fragment index mapping class ( fragment_lookup_t ), intent ( inout ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ), intent ( in ) :: fragment_idx integer ( int32 ) :: hash_val integer :: bucket type ( hash_entry_t ), pointer :: new_entry integer , allocatable :: sorted_key (:) if (. not . this % initialized ) error stop \"Hash table not initialized\" ! Sort monomers for canonical key allocate ( sorted_key ( n )) sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Check if this is the first entry in bucket if (. not . allocated ( this % table ( bucket )% key )) then ! First entry in this bucket - use the head entry allocate ( this % table ( bucket )% key ( n )) this % table ( bucket )% key = sorted_key this % table ( bucket )% value = fragment_idx this % n_entries = this % n_entries + 1 else ! Bucket already has entries - chain new entry allocate ( new_entry ) allocate ( new_entry % key ( n )) new_entry % key = sorted_key new_entry % value = fragment_idx new_entry % next => this % table ( bucket )% next this % table ( bucket )% next => new_entry this % n_entries = this % n_entries + 1 end if deallocate ( sorted_key ) end subroutine fragment_lookup_insert","tags":"","url":"proc/fragment_lookup_insert.html"},{"title":"print_combos – metalquicha","text":"private  subroutine print_combos(out_array, count, max_len) Print combinations stored in out_array\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: out_array (:,:) integer(kind=int64), intent(in) :: count integer(kind=default_int), intent(in) :: max_len Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: i integer(kind=default_int), private :: j Source Code subroutine print_combos ( out_array , count , max_len ) !! Print combinations stored in out_array !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: out_array (:, :), max_len integer ( int64 ), intent ( in ) :: count integer ( int64 ) :: i integer ( default_int ) :: j do i = 1_int64 , count do j = 1 , max_len if ( out_array ( i , j ) == 0 ) exit write ( * , '(I0)' , advance = 'no' ) out_array ( i , j ) if ( j < max_len . and . out_array ( i , j + 1 ) /= 0 ) then write ( * , '(A)' , advance = 'no' ) \":\" end if end do write ( * , * ) ! newline end do end subroutine print_combos","tags":"","url":"proc/print_combos.html"},{"title":"ang_mom_char_to_int – metalquicha","text":"public pure function ang_mom_char_to_int(ang_mom_char) result(ang_mom) Convert angular momentum character to integer Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6\nSpecial case: L=-1 (combined S+P shell, requires splitting) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ang_mom_char Angular momentum symbol Return Value integer Corresponding integer value Called by proc~~ang_mom_char_to_int~~CalledByGraph proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~ang_mom_char_to_int proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function ang_mom_char_to_int ( ang_mom_char ) result ( ang_mom ) !! Convert angular momentum character to integer !! !! Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6 !! Special case: L=-1 (combined S+P shell, requires splitting) character ( len = 1 ), intent ( in ) :: ang_mom_char !! Angular momentum symbol integer :: ang_mom !! Corresponding integer value select case ( ang_mom_char ) case ( 'S' ); ang_mom = 0 case ( 'P' ); ang_mom = 1 case ( 'D' ); ang_mom = 2 case ( 'F' ); ang_mom = 3 case ( 'G' ); ang_mom = 4 case ( 'H' ); ang_mom = 5 case ( 'I' ); ang_mom = 6 case ( 'L' ); ang_mom = - 1 ! Special case: L shells are split into S+P case default ; ang_mom = - 1 end select end function ang_mom_char_to_int","tags":"","url":"proc/ang_mom_char_to_int.html"},{"title":"ang_mom_int_to_char – metalquicha","text":"public pure function ang_mom_int_to_char(ang_mom) result(ang_mom_char) Convert angular momentum integer to character Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I\nReturns ‘?’ for invalid input values. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ang_mom Angular momentum quantum number Return Value character(len=1) Corresponding symbol character Source Code pure function ang_mom_int_to_char ( ang_mom ) result ( ang_mom_char ) !! Convert angular momentum integer to character !! !! Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I !! Returns '?' for invalid input values. integer , intent ( in ) :: ang_mom !! Angular momentum quantum number character ( len = 1 ) :: ang_mom_char !! Corresponding symbol character select case ( ang_mom ) case ( 0 ); ang_mom_char = 'S' case ( 1 ); ang_mom_char = 'P' case ( 2 ); ang_mom_char = 'D' case ( 3 ); ang_mom_char = 'F' case ( 4 ); ang_mom_char = 'G' case ( 5 ); ang_mom_char = 'H' case ( 6 ); ang_mom_char = 'I' case default ; ang_mom_char = '?' end select end function ang_mom_int_to_char","tags":"","url":"proc/ang_mom_int_to_char.html"},{"title":"classify_line – metalquicha","text":"public pure function classify_line(line) result(line_type) Classify a line from a gamess formatted basis set file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer Calls proc~~classify_line~~CallsGraph proc~classify_line classify_line proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~classify_line~~CalledByGraph proc~classify_line classify_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: line_trim Source Code pure function classify_line ( line ) result ( line_type ) !! Classify a line from a gamess formatted basis set file character ( len =* ), intent ( in ) :: line integer :: line_type character ( len = :), allocatable :: line_trim line_trim = trim ( adjustl ( line )) if ( is_blank_or_control ( line_trim )) then line_type = LINE_UNKNOWN else if ( is_function_line ( line_trim )) then line_type = LINE_FUNCTION else if ( is_shell_header ( line_trim )) then line_type = LINE_SHELL else line_type = LINE_ATOM end if end function classify_line","tags":"","url":"proc/classify_line.html"},{"title":"is_blank_or_control – metalquicha","text":"private pure function is_blank_or_control(line) result(res) Check if a line is blank or a control line (starts with ‘$’) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_blank_or_control~~CalledByGraph proc~is_blank_or_control is_blank_or_control proc~classify_line classify_line proc~classify_line->proc~is_blank_or_control proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: trimmed_len Source Code pure function is_blank_or_control ( line ) result ( res ) !! Check if a line is blank or a control line (starts with '$') character ( len =* ), intent ( in ) :: line logical :: res integer :: trimmed_len trimmed_len = len_trim ( line ) if ( trimmed_len == 0 ) then res = . true . else res = ( line ( 1 : 1 ) == '$' ) end if end function is_blank_or_control","tags":"","url":"proc/is_blank_or_control.html"},{"title":"is_function_line – metalquicha","text":"private pure function is_function_line(line) result(res) Check if a line is a function coefficient line (starts with a number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_function_line~~CalledByGraph proc~is_function_line is_function_line proc~classify_line classify_line proc~classify_line->proc~is_function_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: first_char Source Code pure function is_function_line ( line ) result ( res ) !! Check if a line is a function coefficient line (starts with a number) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char if ( len_trim ( line ) == 0 ) then res = . false . return end if first_char = line ( 1 : 1 ) res = ( first_char >= '0' . and . first_char <= '9' ) end function is_function_line","tags":"","url":"proc/is_function_line.html"},{"title":"is_shell_header – metalquicha","text":"private pure function is_shell_header(line) result(res) Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Called by proc~~is_shell_header~~CalledByGraph proc~is_shell_header is_shell_header proc~classify_line classify_line proc~classify_line->proc~is_shell_header proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~classify_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~classify_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: dummy character(len=1), private :: first_char integer, private :: ios Source Code pure function is_shell_header ( line ) result ( res ) !! Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char integer :: ios , dummy res = . false . if ( len_trim ( line ) == 0 ) return first_char = line ( 1 : 1 ) if (. not . any ( first_char == [ 'S' , 'P' , 'D' , 'F' , 'G' , 'H' , 'I' , 'L' ])) return read ( line ( 2 :), * , iostat = ios ) dummy res = ( ios == 0 ) end function is_shell_header","tags":"","url":"proc/is_shell_header.html"},{"title":"build_molecular_basis – metalquicha","text":"public  subroutine build_molecular_basis(basis_string, element_names, mol_basis, stat, errmsg) Build molecular basis from geometry and basis file\nOnly parses unique elements, then copies basis data to atoms Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_names (:) Element for each atom in geometry order type( molecular_basis_type ), intent(out) :: mol_basis integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg Calls proc~~build_molecular_basis~~CallsGraph proc~build_molecular_basis build_molecular_basis proc~atomic_basis_destroy atomic_basis_type%atomic_basis_destroy proc~build_molecular_basis->proc~atomic_basis_destroy proc~basis_set_allocate_elements molecular_basis_type%basis_set_allocate_elements proc~build_molecular_basis->proc~basis_set_allocate_elements proc~copy_atomic_basis copy_atomic_basis proc~build_molecular_basis->proc~copy_atomic_basis proc~find_unique_strings find_unique_strings proc~build_molecular_basis->proc~find_unique_strings proc~parse_element_basis parse_element_basis proc~build_molecular_basis->proc~parse_element_basis proc~strings_equal strings_equal proc~build_molecular_basis->proc~strings_equal proc~cgto_destroy cgto_type%cgto_destroy proc~atomic_basis_destroy->proc~cgto_destroy proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis->proc~allocate_basis_shells proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis->proc~cgto_allocate_arrays proc~find_unique_strings->proc~strings_equal proc~parse_element_basis->proc~allocate_basis_shells proc~count_shells_for_element count_shells_for_element proc~parse_element_basis->proc~count_shells_for_element proc~fill_element_basis fill_element_basis proc~parse_element_basis->proc~fill_element_basis proc~count_shells_for_element->proc~strings_equal proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~fill_element_basis->proc~strings_equal proc~fill_element_basis->proc~cgto_allocate_arrays proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~fill_element_basis->proc~classify_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: iatom integer, private :: iunique integer, private :: match_idx integer, private :: natoms integer, private :: nunique type( atomic_basis_type ), private, allocatable :: unique_bases (:) character(len=:), private, allocatable :: unique_elements (:) Source Code subroutine build_molecular_basis ( basis_string , element_names , mol_basis , stat , errmsg ) !! Build molecular basis from geometry and basis file !! Only parses unique elements, then copies basis data to atoms character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_names (:) !! Element for each atom in geometry order type ( molecular_basis_type ), intent ( out ) :: mol_basis integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg integer :: iatom , natoms , iunique , nunique character ( len = :), allocatable :: unique_elements (:) type ( atomic_basis_type ), allocatable :: unique_bases (:) integer :: match_idx match_idx = 0 stat = 0 natoms = size ( element_names ) ! Find unique elements call find_unique_strings ( element_names , unique_elements , nunique ) print * , \"Found \" , nunique , \" unique elements out of \" , natoms , \" atoms\" ! Allocate for unique bases allocate ( unique_bases ( nunique )) ! Parse basis for each unique element do iunique = 1 , nunique print * , \"Parsing basis for: \" , trim ( unique_elements ( iunique )) call parse_element_basis ( basis_string , unique_elements ( iunique ), & unique_bases ( iunique ), stat , errmsg ) if ( stat /= 0 ) then errmsg = \"Failed to parse basis for element \" // trim ( unique_elements ( iunique )) // & \": \" // errmsg return end if end do ! Allocate molecular basis and assign to each atom call mol_basis % allocate_elements ( natoms ) do iatom = 1 , natoms ! Find which unique element this atom corresponds to do iunique = 1 , nunique if ( strings_equal ( element_names ( iatom ), unique_elements ( iunique ))) then match_idx = iunique exit end if end do ! Copy the basis data call copy_atomic_basis ( unique_bases ( match_idx ), mol_basis % elements ( iatom )) end do ! Clean up do iunique = 1 , nunique call unique_bases ( iunique )% destroy () end do end subroutine build_molecular_basis","tags":"","url":"proc/build_molecular_basis.html"},{"title":"parse_element_basis – metalquicha","text":"public pure subroutine parse_element_basis(basis_string, element_name, atom_basis, stat, errmsg) Parse basis set for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(out) :: atom_basis integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg Calls proc~~parse_element_basis~~CallsGraph proc~parse_element_basis parse_element_basis proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~parse_element_basis->proc~allocate_basis_shells proc~count_shells_for_element count_shells_for_element proc~parse_element_basis->proc~count_shells_for_element proc~fill_element_basis fill_element_basis proc~parse_element_basis->proc~fill_element_basis proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~strings_equal strings_equal proc~count_shells_for_element->proc~strings_equal proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~fill_element_basis->proc~cgto_allocate_arrays proc~fill_element_basis->proc~classify_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~fill_element_basis->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_element_basis~~CalledByGraph proc~parse_element_basis parse_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: nshells Source Code pure subroutine parse_element_basis ( basis_string , element_name , atom_basis , stat , errmsg ) !! Parse basis set for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( out ) :: atom_basis integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg integer :: nshells stat = 0 ! Pass 1: Find the element and count its shells call count_shells_for_element ( basis_string , element_name , nshells , stat , errmsg ) if ( stat /= 0 ) return if ( nshells == 0 ) then stat = 1 errmsg = \"Element \" // trim ( element_name ) // \" not found in basis file\" return end if ! ! Allocate shells atom_basis % element = trim ( element_name ) call atom_basis % allocate_shells ( nshells ) ! ! Pass 2: Parse and fill shell data call fill_element_basis ( basis_string , element_name , atom_basis , stat , errmsg ) end subroutine parse_element_basis","tags":"","url":"proc/parse_element_basis.html"},{"title":"copy_atomic_basis – metalquicha","text":"private pure subroutine copy_atomic_basis(source, dest) Deep copy of atomic basis data from source to dest Arguments Type Intent Optional Attributes Name type( atomic_basis_type ), intent(in) :: source type( atomic_basis_type ), intent(out) :: dest Calls proc~~copy_atomic_basis~~CallsGraph proc~copy_atomic_basis copy_atomic_basis proc~allocate_basis_shells atomic_basis_type%allocate_basis_shells proc~copy_atomic_basis->proc~allocate_basis_shells proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~copy_atomic_basis->proc~cgto_allocate_arrays Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_atomic_basis~~CalledByGraph proc~copy_atomic_basis copy_atomic_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~copy_atomic_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ishell Source Code pure subroutine copy_atomic_basis ( source , dest ) !! Deep copy of atomic basis data from source to dest type ( atomic_basis_type ), intent ( in ) :: source type ( atomic_basis_type ), intent ( out ) :: dest integer :: ishell dest % element = source % element call dest % allocate_shells ( source % nshells ) do ishell = 1 , source % nshells dest % shells ( ishell )% ang_mom = source % shells ( ishell )% ang_mom call dest % shells ( ishell )% allocate_arrays ( source % shells ( ishell )% nfunc ) dest % shells ( ishell )% exponents = source % shells ( ishell )% exponents dest % shells ( ishell )% coefficients = source % shells ( ishell )% coefficients end do end subroutine copy_atomic_basis","tags":"","url":"proc/copy_atomic_basis.html"},{"title":"count_shells_for_element – metalquicha","text":"private pure subroutine count_shells_for_element(basis_string, element_name, nshells, stat, errmsg) Count the number of shells for a specific element in a GAMESS formatted basis string, Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name integer, intent(out) :: nshells integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg Calls proc~~count_shells_for_element~~CallsGraph proc~count_shells_for_element count_shells_for_element proc~classify_line classify_line proc~count_shells_for_element->proc~classify_line proc~get_next_line get_next_line proc~count_shells_for_element->proc~get_next_line proc~strings_equal strings_equal proc~count_shells_for_element->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~count_shells_for_element~~CalledByGraph proc~count_shells_for_element count_shells_for_element proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: ang_mom logical, private :: found_element logical, private :: in_target_element character(len=256), private :: line integer, private :: line_end integer, private :: line_start integer, private :: line_type Source Code pure subroutine count_shells_for_element ( basis_string , element_name , nshells , stat , errmsg ) !! Count the number of shells for a specific element in a GAMESS formatted basis string, character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name integer , intent ( out ) :: nshells integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_target_element , found_element character ( len = 1 ) :: ang_mom stat = 0 nshells = 0 in_target_element = . false . found_element = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) case ( LINE_ATOM ) ! Check if this is our target element if ( strings_equal ( line , element_name )) then in_target_element = . true . found_element = . true . else ! Different element - stop counting if we were in target if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Extract angular momentum line = adjustl ( line ) ang_mom = line ( 1 : 1 ) ! L shells become 2 shells (S + P) if ( ang_mom == 'L' ) then nshells = nshells + 2 else nshells = nshells + 1 end if end if case ( LINE_UNKNOWN ) ! Skip blank lines and comments continue end select line_start = line_end end do ! Check if we found the element at all if (. not . found_element ) then stat = 1 errmsg = \"Element not found in basis string: \" // trim ( element_name ) end if end subroutine count_shells_for_element","tags":"","url":"proc/count_shells_for_element.html"},{"title":"fill_element_basis – metalquicha","text":"private pure subroutine fill_element_basis(basis_string, element_name, atom_basis, stat, errmsg) Fill in the shell data for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(inout) :: atom_basis integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg Calls proc~~fill_element_basis~~CallsGraph proc~fill_element_basis fill_element_basis proc~ang_mom_char_to_int ang_mom_char_to_int proc~fill_element_basis->proc~ang_mom_char_to_int proc~cgto_allocate_arrays cgto_type%cgto_allocate_arrays proc~fill_element_basis->proc~cgto_allocate_arrays proc~classify_line classify_line proc~fill_element_basis->proc~classify_line proc~get_next_line get_next_line proc~fill_element_basis->proc~get_next_line proc~parse_function_line parse_function_line proc~fill_element_basis->proc~parse_function_line proc~parse_shell_header parse_shell_header proc~fill_element_basis->proc~parse_shell_header proc~strings_equal strings_equal proc~fill_element_basis->proc~strings_equal proc~is_blank_or_control is_blank_or_control proc~classify_line->proc~is_blank_or_control proc~is_function_line is_function_line proc~classify_line->proc~is_function_line proc~is_shell_header is_shell_header proc~classify_line->proc~is_shell_header Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_element_basis~~CalledByGraph proc~fill_element_basis fill_element_basis proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: ang_mom real(kind=dp), private :: coeff_p real(kind=dp), private :: coeff_s real(kind=dp), private :: exponent integer, private :: func_num logical, private :: has_p integer, private :: ifunc logical, private :: in_data_block logical, private :: in_target_element integer, private :: ishell integer, private :: l_shell_p_idx integer, private :: l_shell_s_idx character(len=256), private :: line integer, private :: line_end integer, private :: line_start integer, private :: line_type integer, private :: nfunc logical, private :: reading_l_shell Source Code pure subroutine fill_element_basis ( basis_string , element_name , atom_basis , stat , errmsg ) !! Fill in the shell data for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( inout ) :: atom_basis integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_data_block , in_target_element character ( len = 1 ) :: ang_mom integer :: nfunc , func_num , ishell , ifunc real ( dp ) :: exponent , coeff_s , coeff_p logical :: has_p ! L shell handling: we split into two shells, need to track both logical :: reading_l_shell integer :: l_shell_s_idx , l_shell_p_idx stat = 0 in_data_block = . false . in_target_element = . false . ishell = 0 reading_l_shell = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) ! case (LINE_UNKNOWN) !   if (index(line, '$DATA') > 0) then !     in_data_block = .true. !   else if (index(line, '$END') > 0) then !     exit !   end if case ( LINE_ATOM ) if ( strings_equal ( line , element_name )) then in_target_element = . true . else if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Parse shell header call parse_shell_header ( line , ang_mom , nfunc , stat ) if ( stat /= 0 ) then errmsg = \"Failed to parse shell header: \" // trim ( line ) return end if if ( ang_mom == 'L' ) then ! L shell: create two shells (S and P) reading_l_shell = . true . ishell = ishell + 1 l_shell_s_idx = ishell atom_basis % shells ( ishell )% ang_mom = 0 ! S call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ishell = ishell + 1 l_shell_p_idx = ishell atom_basis % shells ( ishell )% ang_mom = 1 ! P call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 ! Reset function counter else ! Regular shell reading_l_shell = . false . ishell = ishell + 1 ! Set angular momentum (S=0, P=1, D=2, F=3, G=4, H=5, I=6) atom_basis % shells ( ishell )% ang_mom = ang_mom_char_to_int ( ang_mom ) call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 end if end if case ( LINE_FUNCTION ) if ( in_target_element ) then call parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) if ( stat /= 0 ) then errmsg = \"Failed to parse function line: \" // trim ( line ) return end if if (. not . has_p ) then stat = 1 errmsg = \"L shell requires both S and P coefficients\" return end if ifunc = ifunc + 1 if ( reading_l_shell ) then ! Store in both S and P shells atom_basis % shells ( l_shell_s_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_s_idx )% coefficients ( ifunc ) = coeff_s atom_basis % shells ( l_shell_p_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_p_idx )% coefficients ( ifunc ) = coeff_p else ! Store in current shell atom_basis % shells ( ishell )% exponents ( ifunc ) = exponent atom_basis % shells ( ishell )% coefficients ( ifunc ) = coeff_s end if end if end select line_start = line_end end do end subroutine fill_element_basis","tags":"","url":"proc/fill_element_basis.html"},{"title":"find_unique_strings – metalquicha","text":"private pure subroutine find_unique_strings(input_array, unique_array, nunique) Find unique strings in an array\nReturns array of unique strings and count Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_array (:) character(len=:), intent(out), allocatable :: unique_array (:) integer, intent(out) :: nunique Calls proc~~find_unique_strings~~CallsGraph proc~find_unique_strings find_unique_strings proc~strings_equal strings_equal proc~find_unique_strings->proc~strings_equal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_unique_strings~~CalledByGraph proc~find_unique_strings find_unique_strings proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~find_unique_strings Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i logical, private :: is_unique integer, private :: j integer, private :: n character(len=len), private, allocatable :: temp_unique (:) Source Code pure subroutine find_unique_strings ( input_array , unique_array , nunique ) !! Find unique strings in an array !! Returns array of unique strings and count character ( len =* ), intent ( in ) :: input_array (:) character ( len = :), allocatable , intent ( out ) :: unique_array (:) integer , intent ( out ) :: nunique integer :: i , j , n logical :: is_unique character ( len = len ( input_array )), allocatable :: temp_unique (:) n = size ( input_array ) allocate ( temp_unique ( n )) ! Max possible size nunique = 0 do i = 1 , n is_unique = . true . ! Check if we've already seen this string do j = 1 , nunique if ( strings_equal ( input_array ( i ), temp_unique ( j ))) then is_unique = . false . exit end if end do if ( is_unique ) then nunique = nunique + 1 temp_unique ( nunique ) = input_array ( i ) end if end do ! Allocate output array with exact size and copy allocate ( character ( len = len ( input_array )) :: unique_array ( nunique )) unique_array = temp_unique ( 1 : nunique ) end subroutine find_unique_strings","tags":"","url":"proc/find_unique_strings.html"},{"title":"get_next_line – metalquicha","text":"private pure subroutine get_next_line(string, line_start, line, line_end) Extract the next line from a string starting at line_start Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: line_start character(len=*), intent(out) :: line integer, intent(out) :: line_end Called by proc~~get_next_line~~CalledByGraph proc~get_next_line get_next_line proc~count_shells_for_element count_shells_for_element proc~count_shells_for_element->proc~get_next_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~get_next_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~count_shells_for_element proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: newline_pos Source Code pure subroutine get_next_line ( string , line_start , line , line_end ) !! Extract the next line from a string starting at line_start character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: line_start character ( len =* ), intent ( out ) :: line integer , intent ( out ) :: line_end integer :: newline_pos if ( line_start > len ( string )) then line = '' line_end = 0 return end if newline_pos = index ( string ( line_start :), new_line ( 'a' )) if ( newline_pos == 0 ) then ! Last line (no newline at end) line = string ( line_start :) line_end = len ( string ) + 1 else line = string ( line_start : line_start + newline_pos - 2 ) line_end = line_start + newline_pos end if end subroutine get_next_line","tags":"","url":"proc/get_next_line.html"},{"title":"parse_function_line – metalquicha","text":"private pure subroutine parse_function_line(line, func_num, exponent, coeff_s, coeff_p, has_p, stat) Parse function line (e.g., “1 1.0 2.0” or “1 1.0 2.0 3.0” for L shells) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(out) :: func_num real(kind=dp), intent(out) :: exponent real(kind=dp), intent(out) :: coeff_s real(kind=dp), intent(out), optional :: coeff_p logical, intent(out) :: has_p integer, intent(out) :: stat Called by proc~~parse_function_line~~CalledByGraph proc~parse_function_line parse_function_line proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~parse_function_line proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: temp_p Source Code pure subroutine parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) !! Parse function line (e.g., \"1 1.0 2.0\" or \"1 1.0 2.0 3.0\" for L shells) character ( len =* ), intent ( in ) :: line integer , intent ( out ) :: func_num real ( dp ), intent ( out ) :: exponent real ( dp ), intent ( out ) :: coeff_s real ( dp ), intent ( out ), optional :: coeff_p logical , intent ( out ) :: has_p integer , intent ( out ) :: stat real ( dp ) :: temp_p has_p = . false . ! Try to read 4 values (func_num, exponent, coeff_s, coeff_p) read ( line , * , iostat = stat ) func_num , exponent , coeff_s , temp_p if ( stat == 0 ) then ! Successfully read 4 values - this is an L shell has_p = . true . if ( present ( coeff_p )) coeff_p = temp_p else ! Try reading just 3 values (func_num, exponent, coeff_s) read ( line , * , iostat = stat ) func_num , exponent , coeff_s end if end subroutine parse_function_line","tags":"","url":"proc/parse_function_line.html"},{"title":"parse_shell_header – metalquicha","text":"private pure subroutine parse_shell_header(line, ang_mom, nfunc, stat) Parse shell header line (e.g., “S 2” or “L 3”) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(out) :: ang_mom integer, intent(out) :: nfunc integer, intent(out) :: stat Called by proc~~parse_shell_header~~CalledByGraph proc~parse_shell_header parse_shell_header proc~fill_element_basis fill_element_basis proc~fill_element_basis->proc~parse_shell_header proc~parse_element_basis parse_element_basis proc~parse_element_basis->proc~fill_element_basis proc~build_molecular_basis build_molecular_basis proc~build_molecular_basis->proc~parse_element_basis Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=256), private :: line_trim Source Code pure subroutine parse_shell_header ( line , ang_mom , nfunc , stat ) !! Parse shell header line (e.g., \"S 2\" or \"L 3\") character ( len =* ), intent ( in ) :: line character ( len = 1 ), intent ( out ) :: ang_mom integer , intent ( out ) :: nfunc integer , intent ( out ) :: stat character ( len = 256 ) :: line_trim line_trim = adjustl ( line ) ang_mom = line_trim ( 1 : 1 ) ! Read the number of functions read ( line_trim ( 2 :), * , iostat = stat ) nfunc end subroutine parse_shell_header","tags":"","url":"proc/parse_shell_header.html"},{"title":"print_logo – metalquicha","text":"public  subroutine print_logo() Print the PIC Chemistry ASCII sunflower logo Arguments None Called by proc~~print_logo~~CalledByGraph proc~print_logo print_logo program~main main program~main->proc~print_logo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine print_logo () !! Print the PIC Chemistry ASCII sunflower logo write ( * , '(A)' ) ' ' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                        __   __' write ( * , '(A)' ) '                     .-(  ''.''  )-.' write ( * , '(A)' ) '                    (   \\  |  /   )' write ( * , '(A)' ) '                   ( ''`-.;;;;;.-''` )' write ( * , '(A)' ) '                  ( :-==;;;;;;;==-: )' write ( * , '(A)' ) '                   (  .-'';;;;;''-.  )' write ( * , '(A)' ) '                    (``  /  |  \\  ``)' write ( * , '(A)' ) '                     ''-(__.''.__)-''' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                      (Art by jgs)' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '    ╔═══════════════════════════════════════════════╗' write ( * , '(A)' ) '    ║              Met\"al q\"uicha                   ║' write ( * , '(A)' ) '    ║                (Sunflower)                    ║' write ( * , '(A)' ) '    ║     A hastily put together framework for      ║' write ( * , '(A)' ) '    ║   Fortran Based High Performance Computing    ║' write ( * , '(A)' ) '    ║                                               ║' write ( * , '(A)' ) '    ║        Case study: quantum chemistry          ║' write ( * , '(A)' ) '    ╚═══════════════════════════════════════════════╝' write ( * , '(A)' ) ' ' end subroutine print_logo","tags":"","url":"proc/print_logo.html"},{"title":"mqc_input_parser – metalquicha","text":"Parses simple key=value input files to configure calculation parameters\nincluding geometry files, method selection, and fragment levels.\nMain configuration type and parser Used by module~~mqc_input_parser~~UsedByGraph module~mqc_input_parser mqc_input_parser module~mqc_driver mqc_driver module~mqc_driver->module~mqc_input_parser program~main main program~main->module~mqc_input_parser program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: input_config_t Configuration data structure for calculation parameters Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: geom_file Path to system geometry XYZ file character(len=:), public, allocatable :: log_level Logger verbosity level (debug/verbose/info/warning/error) character(len=:), public, allocatable :: method QC method (gfn1, gfn2) character(len=:), public, allocatable :: monomer_file Path to monomer template XYZ file integer, public :: nlevel = 1 Fragmentation level (default: 1) Type-Bound Procedures procedure, public :: destroy => config_destroy Cleanup allocated memory Functions public  function get_logger_level (level_string) result(level_int) Convert string log level to integer value\nThis function uses the pic_logger constants Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: level_string Return Value integer private  function remove_quotes (str) result(cleaned) Remove surrounding quotes from string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:), allocatable Subroutines public  subroutine read_input_file (filename, config, stat, errmsg) Simple parser for key=value input files\nLooks for: geom=”path/to/geometry.xyz”\n           monomer_symbols=”path/to/monomer.xyz”\n           method=”gfn1” or “gfn2” (defaults to gfn2)\n           nlevel=N (fragmentation level, defaults to 1)\n           log_level=”debug|verbose|info|performance|warning|error|knowledge” (defaults to info) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Path to input file to parse type( input_config_t ), intent(out) :: config Parsed configuration data integer, intent(out) :: stat Status code (0 = success, >0 = error) character(len=:), intent(out), allocatable :: errmsg Error message on failure private  subroutine config_destroy (this) Clean up allocated memory in input_config_t Arguments Type Intent Optional Attributes Name class( input_config_t ), intent(inout) :: this","tags":"","url":"module/mqc_input_parser.html"},{"title":"mqc_physical_fragment – metalquicha","text":"Physical molecular fragment representation and geometry handling Provides data structures and utilities for managing molecular fragments\nwith atomic coordinates, electronic properties, and geometric operations.\nSingle molecular fragment type\nComplete system geometry type\nSystem geometry initialization\nExtract fragment from system\nUnit conversion utilities\nGeometric centroid calculation\nMass-weighted center calculation\nPoint-to-point distance\nInter-fragment distance\nClosest approach distance Uses pic_types mqc_xyz_reader mqc_elements mqc_cgto mqc_geometry module~~mqc_physical_fragment~~UsesGraph module~mqc_physical_fragment mqc_physical_fragment module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader pic_types pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_physical_fragment~~UsedByGraph module~mqc_physical_fragment mqc_physical_fragment module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: bohr_radius = 0.52917721092_dp Bohr radius in Ångström Derived Types type, public :: physical_fragment_t Physical molecular fragment with atomic coordinates and properties Read more… Components Type Visibility Attributes Name Initial type( molecular_basis_type ), public, allocatable :: basis Gaussian basis functions integer, public :: charge = 0 Net molecular charge (electrons) real(kind=dp), public, allocatable :: coordinates (:,:) Cartesian coordinates (3, n_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers (Z values) integer, public :: multiplicity = 1 Spin multiplicity (2S+1) integer, public :: n_atoms Number of atoms in this fragment integer, public :: nelec = 0 Total number of electrons Type-Bound Procedures procedure, public :: compute_nelec => fragment_compute_nelec Calculate electron count procedure, public :: destroy => fragment_destroy Memory cleanup procedure, public :: set_basis => fragment_set_basis Assign basis set type, public :: system_geometry_t Complete molecular system geometry for fragment-based calculations Read more… Components Type Visibility Attributes Name Initial integer, public :: atoms_per_monomer Atoms in each monomer (assumed identical) real(kind=dp), public, allocatable :: coordinates (:,:) All coordinates (3, total_atoms) in Bohr integer, public, allocatable :: element_numbers (:) Atomic numbers for all atoms integer, public :: n_monomers Number of monomer units in system integer, public :: total_atoms Total number of atoms (n_monomers × atoms_per_monomer) Type-Bound Procedures procedure, public :: destroy => system_destroy Memory cleanup Functions public pure function distance_between_fragments (frag1, frag2, use_com) result(distance) Calculate distance between two fragments\nIf use_com is .true., uses center of mass; otherwise uses centroid\nDistance is in the same units as the fragment coordinates (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: frag1 type( physical_fragment_t ), intent(in) :: frag2 logical, intent(in) :: use_com Return Value real(kind=dp) public pure function distance_between_points (point1, point2) result(distance) Calculate Euclidean distance between two 3D points\nPoints should be in the same units (typically Bohr) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: point1 (3) real(kind=dp), intent(in) :: point2 (3) Return Value real(kind=dp) public pure function fragment_center_of_mass (fragment) result(com) Calculate the center of mass of a fragment\nWeights each atomic position by its atomic mass\nReturns coordinates in the same units as the fragment (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment Return Value real(kind=dp), (3) public pure function fragment_centroid (fragment) result(centroid) Calculate the geometric centroid (center of geometry) of a fragment\nThis is the simple average of all atomic coordinates\nReturns coordinates in the same units as the fragment (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: fragment Return Value real(kind=dp), (3) public pure function minimal_distance_between_fragments (frag1, frag2) result(min_distance) Calculate the minimal distance between any two atoms in two fragments\nThis iterates over all atom pairs and finds the closest pair\nDistance is in the same units as the fragment coordinates (typically Bohr) Arguments Type Intent Optional Attributes Name type( physical_fragment_t ), intent(in) :: frag1 type( physical_fragment_t ), intent(in) :: frag2 Return Value real(kind=dp) public pure elemental function to_angstrom (bohr_value) result(angstrom_value) Convert coordinate from Bohr to Angstrom Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: bohr_value Return Value real(kind=dp) public pure elemental function to_bohr (angstrom_value) result(bohr_value) Convert coordinate from Angstrom to Bohr Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: angstrom_value Return Value real(kind=dp) Subroutines public pure subroutine build_fragment_from_indices (sys_geom, monomer_indices, fragment) Build a fragment on-the-fly from monomer indices\ne.g., monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5 Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in) :: sys_geom integer, intent(in) :: monomer_indices (:) type( physical_fragment_t ), intent(out) :: fragment public  subroutine initialize_system_geometry (full_geom_file, monomer_file, sys_geom, stat, errmsg) Read full geometry and monomer template, initialize system_geometry_t Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full_geom_file character(len=*), intent(in) :: monomer_file type( system_geometry_t ), intent(out) :: sys_geom integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg private  subroutine fragment_compute_nelec (this) Compute number of electrons from atomic numbers and charge Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this private  subroutine fragment_destroy (this) Clean up allocated memory in physical_fragment_t Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this private  subroutine fragment_set_basis (this, basis) Set the basis set for this fragment Arguments Type Intent Optional Attributes Name class( physical_fragment_t ), intent(inout) :: this type( molecular_basis_type ), intent(in) :: basis private  subroutine system_destroy (this) Clean up allocated memory in system_geometry_t Arguments Type Intent Optional Attributes Name class( system_geometry_t ), intent(inout) :: this","tags":"","url":"module/mqc_physical_fragment.html"},{"title":"mqc_cgto – metalquicha","text":"Defines data structures for cartesian contracted Gaussian type orbitals (CGTOs) Uses pic_types module~~mqc_cgto~~UsesGraph module~mqc_cgto mqc_cgto pic_types pic_types module~mqc_cgto->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_cgto~~UsedByGraph module~mqc_cgto mqc_cgto module~mqc_basis_reader mqc_basis_reader module~mqc_basis_reader->module~mqc_cgto module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_cgto module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: atomic_basis_type Atomic basis set data structure Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: element element symbol integer, public :: nshells number of shells in type type( cgto_type ), public, allocatable :: shells (:) array of contracted shells Type-Bound Procedures procedure, public :: allocate_shells => allocate_basis_shells procedure, public :: destroy => atomic_basis_destroy procedure, public :: num_basis_functions => atomic_basis_num_basis_functions type, public :: cgto_type Contracted Gaussian type orbital (CGTO) data structure Components Type Visibility Attributes Name Initial integer, public :: ang_mom Angular momentum quantum number (0=s, 1=p, 2=d, etc.) real(kind=dp), public, allocatable :: coefficients (:) Contraction coefficients real(kind=dp), public, allocatable :: exponents (:) Exponents (alpha values) integer, public :: nfunc Number of primitive Gaussians in the contraction Type-Bound Procedures procedure, public :: allocate_arrays => cgto_allocate_arrays procedure, public :: destroy => cgto_destroy procedure, public :: num_basis_functions => cgto_num_basis_functions type, public :: molecular_basis_type Molecular basis set data structure (assembled basis) Components Type Visibility Attributes Name Initial type( atomic_basis_type ), public, allocatable :: elements (:) array of atomic basis types integer, public :: nelements total number of atoms/elements in a molecule Type-Bound Procedures procedure, public :: allocate_elements => basis_set_allocate_elements procedure, public :: destroy => basis_set_destroy procedure, public :: num_basis_functions => molecular_basis_num_basis_functions Functions private pure function atomic_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for an atom Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(in) :: self Return Value integer private pure function cgto_num_basis_functions (self) result(nbf) Get number of basis functions in a shell (Cartesian) Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(in) :: self Return Value integer private pure function molecular_basis_num_basis_functions (self) result(nbf) Get total number of basis functions for the molecule Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(in) :: self Return Value integer Subroutines private pure subroutine allocate_basis_shells (self, nshells) Allocate array of shells in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self integer, intent(in) :: nshells private pure subroutine atomic_basis_destroy (self) Clean up allocated memory in an atomic basis Arguments Type Intent Optional Attributes Name class( atomic_basis_type ), intent(inout) :: self private pure subroutine basis_set_allocate_elements (self, nelements) Allocate array of atomic basis elements in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self integer, intent(in) :: nelements private pure subroutine basis_set_destroy (self) Clean up allocated memory in a molecular basis set Arguments Type Intent Optional Attributes Name class( molecular_basis_type ), intent(inout) :: self private pure subroutine cgto_allocate_arrays (self, nfunc) Allocate arrays for exponents and coefficients in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self integer, intent(in) :: nfunc private pure subroutine cgto_destroy (self) Clean up allocated memory in a CGTO Arguments Type Intent Optional Attributes Name class( cgto_type ), intent(inout) :: self","tags":"","url":"module/mqc_cgto.html"},{"title":"mqc_result_types – metalquicha","text":"Defines data structures for storing and managing results from\nquantum chemistry calculations including energies, gradients, and properties.\nMain result container type Uses pic_types module~~mqc_result_types~~UsesGraph module~mqc_result_types mqc_result_types pic_types pic_types module~mqc_result_types->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_result_types~~UsedByGraph module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_result_types module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_result_types module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->module~mqc_method_base module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: calculation_result_t Container for quantum chemistry calculation results Read more… Components Type Visibility Attributes Name Initial real(kind=dp), public, allocatable :: dipole (:) Dipole moment vector (3) (Debye) real(kind=dp), public :: energy = 0.0_dp Total electronic energy (Hartree) real(kind=dp), public, allocatable :: gradient (:,:) Energy gradient (3, natoms) (Hartree/Bohr) logical, public :: has_dipole = .false. Dipole moment has been computed logical, public :: has_energy = .false. Energy has been computed logical, public :: has_gradient = .false. Gradient has been computed logical, public :: has_hessian = .false. Hessian has been computed real(kind=dp), public, allocatable :: hessian (:,:) Energy hessian (future implementation) Type-Bound Procedures procedure, public :: destroy => result_destroy Clean up allocated memory procedure, public :: reset => result_reset Reset all values and flags Subroutines private  subroutine result_destroy (this) Clean up allocated memory in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this private  subroutine result_reset (this) Reset all values and flags in calculation_result_t Arguments Type Intent Optional Attributes Name class( calculation_result_t ), intent(inout) :: this","tags":"","url":"module/mqc_result_types.html"},{"title":"mqc_driver – metalquicha","text":"Handles both fragmented (many-body expansion) and unfragmented calculations\nwith MPI parallelization and node-based work distribution.\nMain entry point for all calculations Uses pic_types pic_mpi_lib omp_lib mqc_frag_utils pic_logger mqc_physical_fragment mqc_input_parser mqc_mbe_fragment_distribution_scheme pic_io module~~mqc_driver~~UsesGraph module~mqc_driver mqc_driver module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_input_parser mqc_input_parser module~mqc_driver->module~mqc_input_parser module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_physical_fragment mqc_physical_fragment module~mqc_driver->module~mqc_physical_fragment omp_lib omp_lib module~mqc_driver->omp_lib pic_io pic_io module~mqc_driver->pic_io pic_logger pic_logger module~mqc_driver->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_driver->pic_mpi_lib pic_types pic_types module~mqc_driver->pic_types module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types pic_hash_32bit pic_hash_32bit module~mqc_frag_utils->pic_hash_32bit pic_sorting pic_sorting module~mqc_frag_utils->pic_sorting module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->omp_lib module~mqc_mbe_fragment_distribution_scheme->pic_io module~mqc_mbe_fragment_distribution_scheme->pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme->pic_timer module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->pic_blas_interfaces module~mqc_mbe->pic_timer module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_mbe_io->module~mqc_elements module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->pic_types module~mqc_method_xtb->module~mqc_result_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_result_types->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->pic_types module~mqc_method_base->module~mqc_result_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_driver~~UsedByGraph module~mqc_driver mqc_driver program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine run_calculation (world_comm, node_comm, config, sys_geom) Main calculation dispatcher - routes to fragmented or unfragmented calculation Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator type( input_config_t ), intent(in) :: config Parsed input configuration type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info private  subroutine run_fragmented_calculation (world_comm, node_comm, method, sys_geom, max_level, matrix_size) Handle fragmented calculation (nlevel > 0) Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type(comm_t), intent(in) :: node_comm Node-local MPI communicator character(len=*), intent(in) :: method Quantum chemistry method (gfn1/gfn2) type( system_geometry_t ), intent(in) :: sys_geom System geometry and fragment info integer, intent(in) :: max_level Maximum fragment level for MBE integer, intent(in) :: matrix_size Size of gradient matrix (natoms*3) private  subroutine run_unfragmented_calculation (world_comm, sys_geom, method) Handle unfragmented calculation (nlevel=0) Read more… Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm Global MPI communicator type( system_geometry_t ), intent(in) :: sys_geom Complete system geometry character(len=*), intent(in) :: method Quantum chemistry method (gfn1/gfn2)","tags":"","url":"module/mqc_driver.html"},{"title":"mqc_method_xtb – metalquicha","text":"Provides GFN1-xTB and GFN2-xTB methods via the tblite library,\nimplementing the abstract method interface for energy and gradient calculations.\nXTB method implementation type Uses pic_types mqc_result_types tblite_xtb_gfn2 mctc_env tblite_wavefunction tblite_context_type mqc_physical_fragment mqc_method_base tblite_xtb_gfn1 tblite_xtb_calculator mctc_io tblite_xtb_singlepoint module~~mqc_method_xtb~~UsesGraph module~mqc_method_xtb mqc_method_xtb mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_xtb->module~mqc_result_types pic_types pic_types module~mqc_method_xtb->pic_types tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_xtb~~UsedByGraph module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( qc_method_t ) :: xtb_method_t Extended Tight-Binding (xTB) method implementation Read more… Components Type Visibility Attributes Name Initial real(kind=wp), public :: accuracy = 0.01_wp Numerical accuracy parameter real(kind=wp), public :: kt = 300.0_wp*3.166808578545117e-06_wp Electronic temperature (300 K) character(len=:), public, allocatable :: variant XTB variant: “gfn1” or “gfn2” logical, public :: verbose = .false. Print calculation details Type-Bound Procedures procedure, public :: calc_energy => xtb_calc_energy Energy-only calculation procedure, public :: calc_gradient => xtb_calc_gradient Energy + gradient calculation Subroutines private  subroutine xtb_calc_energy (this, fragment, result) Calculate electronic energy using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine xtb_calc_gradient (this, fragment, result) Calculate energy gradient using Extended Tight-Binding (xTB) method Arguments Type Intent Optional Attributes Name class( xtb_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result","tags":"","url":"module/mqc_method_xtb.html"},{"title":"mqc_basis_file_reader – metalquicha","text":"Module for reading and parsing GAMESS formatted basis set files Uses pic_types module~~mqc_basis_file_reader~~UsesGraph module~mqc_basis_file_reader mqc_basis_file_reader pic_types pic_types module~mqc_basis_file_reader->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_basis_file_reader~~UsedByGraph module~mqc_basis_file_reader mqc_basis_file_reader module~mqc_basis_reader mqc_basis_reader module~mqc_basis_reader->module~mqc_basis_file_reader Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: basis_file_t Container for basis set file contents Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: data_section character(len=:), public, allocatable :: full_content Functions public  function extract_element (basis_file, element) result(element_content) Extract the basis set data for a specific element from the basis file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(in) :: basis_file character(len=*), intent(in) :: element Return Value character(len=:), allocatable public pure function strings_equal (str1, str2) result(equal) Compare two strings after trimming and adjusting (removing leading/trailing whitespace)\nCompare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str1 character(len=*), intent(in) :: str2 Return Value logical private pure function is_letter (c) result(is_alpha) Check if character is a letter (A-Z or a-z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical private pure function is_uppercase_letter (c) result(is_upper) Check if character is an uppercase letter (A-Z) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c Return Value logical private pure function uppercase (str) result(upper) Convert a string to uppercase, should use pic_ascii! Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:), allocatable Subroutines public  subroutine open_basis_file (basis_file, filename) Open and read a GAMESS formatted basis set file Arguments Type Intent Optional Attributes Name type( basis_file_t ), intent(out) :: basis_file character(len=*), intent(in) :: filename","tags":"","url":"module/mqc_basis_file_reader.html"},{"title":"mqc_cli_parser – metalquicha","text":"Handles parsing of command line options including geometry files,\nbasis set specifications, and help/usage display.\nParsed command line arguments container\nMain argument parsing routine\nDisplay program usage information\nStandardize basis set names\nLocate basis set files Derived Types type, public :: cli_args_type Container for parsed command line arguments Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: basis_name Basis set name (e.g., “6-31G”) character(len=:), public, allocatable :: xyz_file Input XYZ geometry file path Type-Bound Procedures procedure, public :: destroy => cli_args_destroy Memory cleanup Functions public  function normalize_basis_name (basis_name) result(normalized) Normalize basis set name to filename-safe format\nRules: * -> s, + -> p, remove parentheses and their contents\nExamples:\n  6-31G -> 6-31Gs\n  6-31+G -> 6-31pGs\n  6-31G(d)    -> 6-31Gd\n  6-311G(d,p) -> 6-31Gdp\n  6-311++G**  -> 6-311ppGss Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name Return Value character(len=:), allocatable Subroutines public  subroutine find_basis_file (basis_name, filename, stat, errmsg) Find basis file, trying multiple name variants\nSearches in:\n  1. basis_sets/ subdirectory\n  2. Current directory\nTries name variants:\n  1. Exact name as given\n  2. Normalized name (with * -> s, + -> p, etc.)\n  3. Common synonyms Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_name character(len=:), intent(out), allocatable :: filename integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg public  subroutine parse_command_line (args, stat, errmsg) Parse command line arguments for geometry file and basis set Read more… Arguments Type Intent Optional Attributes Name type( cli_args_type ), intent(out) :: args Parsed argument container integer, intent(out) :: stat Status (0=success, >0=error) character(len=:), intent(out), allocatable :: errmsg Error message public  subroutine print_usage () Print usage information Arguments None private  subroutine cli_args_destroy (this) Clean up CLI args Arguments Type Intent Optional Attributes Name class( cli_args_type ), intent(inout) :: this","tags":"","url":"module/mqc_cli_parser.html"},{"title":"mqc_xyz_reader – metalquicha","text":"Provides functions to parse standard XYZ format files containing\natomic coordinates and element symbols for molecular structures.\nRead XYZ file from disk\nParse XYZ data from string\nSplit text into lines (for testing) Uses pic_types mqc_geometry module~~mqc_xyz_reader~~UsesGraph module~mqc_xyz_reader mqc_xyz_reader module~mqc_geometry mqc_geometry module~mqc_xyz_reader->module~mqc_geometry pic_types pic_types module~mqc_xyz_reader->pic_types module~mqc_geometry->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_xyz_reader~~UsedByGraph module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 Maximum element symbol length Functions private pure function int_to_string (i) result(str) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=:), allocatable Subroutines public  subroutine read_xyz_file (filename, geom, stat, errmsg) Read molecular geometry from XYZ format file Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Path to XYZ file type( geometry_type ), intent(out) :: geom Parsed molecular geometry integer, intent(out) :: stat Status (0=success, >0=error) character(len=:), intent(out), allocatable :: errmsg Error message public pure subroutine read_xyz_string (xyz_string, geom, stat, errmsg) Parse molecular geometry from XYZ format string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: xyz_string type( geometry_type ), intent(out) :: geom integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg public pure subroutine split_lines (text, lines, nlines) Split input text into lines based on CR, LF, or CRLF line endings\nTrailing newlines do not create empty lines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text character(len=:), intent(out), allocatable :: lines (:) integer, intent(out) :: nlines","tags":"","url":"module/mqc_xyz_reader.html"},{"title":"mqc_geometry – metalquicha","text":"Defines the geometry data structure for molecular systems Uses pic_types module~~mqc_geometry~~UsesGraph module~mqc_geometry mqc_geometry pic_types pic_types module~mqc_geometry->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_geometry~~UsedByGraph module~mqc_geometry mqc_geometry module~mqc_physical_fragment mqc_physical_fragment module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_xyz_reader->module~mqc_geometry module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 Derived Types type, public :: geometry_type Molecular geometry data structure Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: comment real(kind=dp), public, allocatable :: coords (:,:) character(len=:), public, allocatable :: elements (:) integer, public :: natoms Type-Bound Procedures procedure, public :: destroy => geometry_destroy Subroutines private  subroutine geometry_destroy (this) Clean up allocated memory in geometry_type Arguments Type Intent Optional Attributes Name class( geometry_type ), intent(inout) :: this","tags":"","url":"module/mqc_geometry.html"},{"title":"mqc_mpi_tags – metalquicha","text":"Module defining MPI communication tags for clarity and maintainability Uses pic_types module~~mqc_mpi_tags~~UsesGraph module~mqc_mpi_tags mqc_mpi_tags pic_types pic_types module~mqc_mpi_tags->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mpi_tags~~UsedByGraph module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: TAG_NODE_FINISH = 302 Global coordinator signals node coordinator to finish integer(kind=default_int), public, parameter :: TAG_NODE_FRAGMENT = 301 Global coordinator sends fragment data to node coordinator integer(kind=default_int), public, parameter :: TAG_NODE_MATRIX_RESULT = 304 Node coordinator sends matrix results to global coordinator integer(kind=default_int), public, parameter :: TAG_NODE_REQUEST = 300 Node coordinator requests work from global coordinator integer(kind=default_int), public, parameter :: TAG_NODE_SCALAR_RESULT = 303 Node coordinator sends results (fragment_idx + scalar) to global coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_FINISH = 202 Coordinator signals worker to finish integer(kind=default_int), public, parameter :: TAG_WORKER_FRAGMENT = 201 Coordinator sends fragment data to worker integer(kind=default_int), public, parameter :: TAG_WORKER_MATRIX_RESULT = 204 Worker sends matrix results back to coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_REQUEST = 200 Worker requests work from node coordinator integer(kind=default_int), public, parameter :: TAG_WORKER_SCALAR_RESULT = 203 Worker sends scalar results back to coordinator","tags":"","url":"module/mqc_mpi_tags.html"},{"title":"mqc_mbe_io – metalquicha","text":"Uses pic_types pic_logger mqc_physical_fragment mqc_elements pic_io module~~mqc_mbe_io~~UsesGraph module~mqc_mbe_io mqc_mbe_io module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_io->module~mqc_physical_fragment pic_io pic_io module~mqc_mbe_io->pic_io pic_logger pic_logger module~mqc_mbe_io->pic_logger pic_types pic_types module~mqc_mbe_io->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_physical_fragment->module~mqc_elements module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mbe_io~~UsedByGraph module~mqc_mbe_io mqc_mbe_io module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function get_frag_level_name (frag_level) result(level_name) Map body level (n-mer) to descriptive name\nSupports up to decamers (10-mers), then falls back to “N-mers” format Arguments Type Intent Optional Attributes Name integer, intent(in) :: frag_level Return Value character(len=32) Subroutines public  subroutine print_detailed_breakdown (polymers, fragment_count, max_level, energies, delta_energies) Print detailed energy breakdown for each fragment\nShows full energy and deltaE correction for all monomers, dimers, trimers, etc.\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) public  subroutine print_detailed_breakdown_json (polymers, fragment_count, max_level, energies, delta_energies, sum_by_level, total_energy) Write detailed energy breakdown to results.json file\nOutputs structured JSON with all fragment energies and deltaE corrections\nUses int64 for fragment_count to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(in) :: delta_energies (:) real(kind=dp), intent(in) :: sum_by_level (:) real(kind=dp), intent(in) :: total_energy public  subroutine print_fragment_xyz (fragment_idx, phys_frag) Print fragment geometry in XYZ format Arguments Type Intent Optional Attributes Name integer, intent(in) :: fragment_idx type( physical_fragment_t ), intent(in) :: phys_frag","tags":"","url":"module/mqc_mbe_io.html"},{"title":"mqc_mbe_fragment_distribution_scheme – metalquicha","text":"Implements hierarchical many-body expansion for fragment-based quantum chemistry\ncalculations with MPI parallelization and energy/gradient computation. Uses pic_types mqc_mpi_tags mqc_result_types pic_mpi_lib omp_lib pic_blas_interfaces pic_timer pic_logger mqc_physical_fragment mqc_mbe mqc_method_xtb pic_io mqc_mbe_io module~~mqc_mbe_fragment_distribution_scheme~~UsesGraph module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types omp_lib omp_lib module~mqc_mbe_fragment_distribution_scheme->omp_lib pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces pic_io pic_io module~mqc_mbe_fragment_distribution_scheme->pic_io pic_logger pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib pic_timer pic_timer module~mqc_mbe_fragment_distribution_scheme->pic_timer pic_types pic_types module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_blas_interfaces module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->pic_types module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_result_types module~mqc_method_xtb->pic_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types pic_hash_32bit pic_hash_32bit module~mqc_frag_utils->pic_hash_32bit pic_sorting pic_sorting module~mqc_frag_utils->pic_sorting module~mqc_geometry->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mbe_fragment_distribution_scheme~~UsedByGraph module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine do_fragment_work (fragment_idx, water_energy, C_flat, method, phys_frag) Process a single fragment for quantum chemistry calculation Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: fragment_idx Fragment index for identification real(kind=dp), intent(out) :: water_energy Computed energy for this fragment real(kind=dp), intent(out), allocatable :: C_flat (:) Flattened gradient array character(len=*), intent(in) :: method QC method (gfn1, gfn2) type( physical_fragment_t ), intent(in), optional :: phys_frag Fragment geometry public  subroutine global_coordinator (world_comm, node_comm, total_fragments, polymers, max_level, node_leader_ranks, num_nodes) Global coordinator for distributing fragments to node coordinators\nwill act as a node coordinator for a single node calculation\nUses int64 for total_fragments to handle large fragment counts that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level integer, intent(in) :: node_leader_ranks (:) integer, intent(in) :: num_nodes public  subroutine node_coordinator (world_comm, node_comm) Node coordinator for distributing fragments to local workers\nHandles work requests and result collection from local workers Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm public  subroutine node_worker (world_comm, node_comm, sys_geom, method) Node worker for processing fragments assigned by node coordinator Arguments Type Intent Optional Attributes Name class(comm_t), intent(in) :: world_comm class(comm_t), intent(in) :: node_comm type( system_geometry_t ), intent(in), optional :: sys_geom character(len=*), intent(in) :: method public  subroutine serial_fragment_processor (total_fragments, polymers, max_level, sys_geom, method) Process all fragments serially in single-rank mode\nThis is used when running with only 1 MPI rank Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: total_fragments integer, intent(in) :: polymers (:,:) integer, intent(in) :: max_level type( system_geometry_t ), intent(in) :: sys_geom character(len=*), intent(in) :: method public  subroutine unfragmented_calculation (sys_geom, method) Run unfragmented calculation on the entire system (nlevel=0)\nThis is a simple single-process calculation without MPI distribution Arguments Type Intent Optional Attributes Name type( system_geometry_t ), intent(in), optional :: sys_geom character(len=*), intent(in) :: method private  subroutine send_fragment_to_node (world_comm, fragment_idx, polymers, dest_rank) Send fragment data to remote node coordinator\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: world_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank private  subroutine send_fragment_to_worker (node_comm, fragment_idx, polymers, dest_rank) Send fragment data to local worker\nUses int64 for fragment_idx to handle large fragment indices that overflow int32. Arguments Type Intent Optional Attributes Name type(comm_t), intent(in) :: node_comm integer(kind=int64), intent(in) :: fragment_idx integer, intent(in) :: polymers (:,:) integer, intent(in) :: dest_rank","tags":"","url":"module/mqc_mbe_fragment_distribution_scheme.html"},{"title":"mqc_libcint_interface – metalquicha","text":"Provides Fortran interface to the Libcint library for integral calculations","tags":"","url":"module/mqc_libcint_interface.html"},{"title":"mqc_elements – metalquicha","text":"Provides atomic numbers, element symbols, and atomic masses for the complete\nperiodic table (elements 1-118) with conversion functions between representations.\nConvert element symbol to atomic number\nConvert atomic number to element symbol\nGet atomic mass by atomic number Uses pic_types pic_ascii module~~mqc_elements~~UsesGraph module~mqc_elements mqc_elements pic_ascii pic_ascii module~mqc_elements->pic_ascii pic_types pic_types module~mqc_elements->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_elements~~UsedByGraph module~mqc_elements mqc_elements module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_io->module~mqc_elements module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_physical_fragment->module~mqc_elements module~mqc_driver mqc_driver module~mqc_driver->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_method_base mqc_method_base module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_physical_fragment module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->module~mqc_method_base program~main main program~main->module~mqc_physical_fragment program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private, parameter :: element_masses (118) = [1.008_dp, 4.0026_dp, 6.94_dp, 9.0122_dp, 10.81_dp, 12.011_dp, 14.007_dp, 15.999_dp, 18.998_dp, 20.180_dp, 22.990_dp, 24.305_dp, 26.982_dp, 28.085_dp, 30.974_dp, 32.06_dp, 35.45_dp, 39.948_dp, 39.098_dp, 40.078_dp, 44.956_dp, 47.867_dp, 50.942_dp, 51.996_dp, 54.938_dp, 55.845_dp, 58.933_dp, 58.693_dp, 63.546_dp, 65.38_dp, 69.723_dp, 72.630_dp, 74.922_dp, 78.971_dp, 79.904_dp, 83.798_dp, 85.468_dp, 87.62_dp, 88.906_dp, 91.224_dp, 92.906_dp, 95.95_dp, 98.0_dp, 101.07_dp, 102.91_dp, 106.42_dp, 107.87_dp, 112.41_dp, 114.82_dp, 118.71_dp, 121.76_dp, 127.60_dp, 126.90_dp, 131.29_dp, 132.91_dp, 137.33_dp, 138.91_dp, 140.12_dp, 140.91_dp, 144.24_dp, 145.0_dp, 150.36_dp, 151.96_dp, 157.25_dp, 158.93_dp, 162.50_dp, 164.93_dp, 167.26_dp, 168.93_dp, 173.05_dp, 174.97_dp, 178.49_dp, 180.95_dp, 183.84_dp, 186.21_dp, 190.23_dp, 192.22_dp, 195.08_dp, 196.97_dp, 200.59_dp, 204.38_dp, 207.2_dp, 208.98_dp, 209.0_dp, 210.0_dp, 222.0_dp, 223.0_dp, 226.0_dp, 227.0_dp, 232.04_dp, 231.04_dp, 238.03_dp, 237.0_dp, 244.0_dp, 243.0_dp, 247.0_dp, 247.0_dp, 251.0_dp, 252.0_dp, 257.0_dp, 258.0_dp, 259.0_dp, 262.0_dp, 267.0_dp, 268.0_dp, 271.0_dp, 272.0_dp, 270.0_dp, 276.0_dp, 281.0_dp, 280.0_dp, 285.0_dp, 284.0_dp, 289.0_dp, 288.0_dp, 293.0_dp, 294.0_dp, 294.0_dp] Standard atomic masses in atomic mass units (amu)\nBased on IUPAC standard atomic weights, ordered by atomic number character(len=2), private, parameter :: element_symbols (118) = [character(len=2)::'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og'] Element symbols for the complete periodic table (H through Og)\nOrdered by atomic number from 1 to 118 Functions public pure function element_mass (atomic_number) result(mass) Return atomic mass in atomic mass units (amu) for a given atomic number\nUses standard atomic weights from IUPAC Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value real(kind=dp) public pure function element_number_to_symbol (atomic_number) result(symbol) Convert atomic number to element symbol\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name integer, intent(in) :: atomic_number Return Value character(len=2) public pure function element_symbol_to_number (symbol) result(atomic_number) Convert element symbol to atomic number\nCovers the complete periodic table (elements 1-118) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: symbol Return Value integer","tags":"","url":"module/mqc_elements.html"},{"title":"mqc_method_base – metalquicha","text":"Defines the common interface that all quantum chemistry methods must implement,\nproviding a unified API for energy and gradient calculations.\nAbstract base type for all QC methods Uses pic_types mqc_physical_fragment mqc_result_types module~~mqc_method_base~~UsesGraph module~mqc_method_base mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_base->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_base->module~mqc_result_types pic_types pic_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_method_base~~UsedByGraph module~mqc_method_base mqc_method_base module~mqc_method_hf mqc_method_hf module~mqc_method_hf->module~mqc_method_base module~mqc_method_xtb mqc_method_xtb module~mqc_method_xtb->module~mqc_method_base module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface private  subroutine calc_energy_interface(this, fragment, result) Interface for energy-only calculations Computes the electronic energy for a molecular fragment\nusing the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Calculation results abstract interface private  subroutine calc_gradient_interface(this, fragment, result) Interface for energy and gradient calculations Computes both electronic energy and nuclear gradients for a\nmolecular fragment using the specified quantum chemistry method. Arguments Type Intent Optional Attributes Name class( qc_method_t ), intent(in) :: this Method instance type( physical_fragment_t ), intent(in) :: fragment Molecular fragment type( calculation_result_t ), intent(out) :: result Derived Types type, public, abstract :: qc_method_t Abstract base type for all quantum chemistry methods Read more… Type-Bound Procedures procedure( calc_energy_interface ), public, deferred :: calc_energy Energy calculation interface procedure( calc_gradient_interface ), public, deferred :: calc_gradient Gradient calculation interface","tags":"","url":"module/mqc_method_base.html"},{"title":"mqc_method_hf – metalquicha","text":"Implements the Hartree-Fock quantum chemistry method\nProvides energy and gradient calculations using a basic SCF procedure. Uses pic_types mqc_physical_fragment mqc_method_base mqc_result_types module~~mqc_method_hf~~UsesGraph module~mqc_method_hf mqc_method_hf module~mqc_method_base mqc_method_base module~mqc_method_hf->module~mqc_method_base module~mqc_physical_fragment mqc_physical_fragment module~mqc_method_hf->module~mqc_physical_fragment module~mqc_result_types mqc_result_types module~mqc_method_hf->module~mqc_result_types pic_types pic_types module~mqc_method_hf->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->module~mqc_result_types module~mqc_method_base->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_result_types->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, extends( qc_method_t ) :: hf_method_t Hartree-Fock method implementation Components Type Visibility Attributes Name Initial type( hf_options_t ), public :: options Type-Bound Procedures procedure, public :: calc_energy => hf_calc_energy procedure, public :: calc_gradient => hf_calc_gradient type, public :: hf_options_t Hartree-Fock calculation options Components Type Visibility Attributes Name Initial real(kind=dp), public :: conv_tol = 1.0e-8_dp Energy convergence threshold integer, public :: max_iter = 100 Maximum SCF iterations logical, public :: spherical = .false. Use spherical (true) or Cartesian (false) basis logical, public :: verbose = .true. Print SCF iterations Subroutines private  subroutine hf_calc_energy (this, fragment, result) Calculate electronic energy using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result private  subroutine hf_calc_gradient (this, fragment, result) Calculate energy gradient using Hartree-Fock method Arguments Type Intent Optional Attributes Name class( hf_method_t ), intent(in) :: this type( physical_fragment_t ), intent(in) :: fragment type( calculation_result_t ), intent(out) :: result","tags":"","url":"module/mqc_method_hf.html"},{"title":"mqc_mbe – metalquicha","text":"Implements hierarchical many-body expansion for fragment-based quantum chemistry\ncalculations with MPI parallelization and energy/gradient computation. Uses pic_types mqc_mpi_tags pic_mpi_lib pic_blas_interfaces pic_timer pic_logger mqc_physical_fragment mqc_frag_utils pic_io mqc_mbe_io module~~mqc_mbe~~UsesGraph module~mqc_mbe mqc_mbe module~mqc_frag_utils mqc_frag_utils module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_io mqc_mbe_io module~mqc_mbe->module~mqc_mbe_io module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe->module~mqc_mpi_tags module~mqc_physical_fragment mqc_physical_fragment module~mqc_mbe->module~mqc_physical_fragment pic_blas_interfaces pic_blas_interfaces module~mqc_mbe->pic_blas_interfaces pic_io pic_io module~mqc_mbe->pic_io pic_logger pic_logger module~mqc_mbe->pic_logger pic_mpi_lib pic_mpi_lib module~mqc_mbe->pic_mpi_lib pic_timer pic_timer module~mqc_mbe->pic_timer pic_types pic_types module~mqc_mbe->pic_types module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types pic_hash_32bit pic_hash_32bit module~mqc_frag_utils->pic_hash_32bit pic_sorting pic_sorting module~mqc_frag_utils->pic_sorting module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->pic_types module~mqc_elements mqc_elements module~mqc_mbe_io->module~mqc_elements module~mqc_mpi_tags->pic_types module~mqc_physical_fragment->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_geometry->pic_types module~mqc_xyz_reader->pic_types module~mqc_xyz_reader->module~mqc_geometry Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_mbe~~UsedByGraph module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_driver mqc_driver module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function compute_mbe (fragment_idx, fragment, lookup, energies, delta_energies, n) result(delta_E) Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas)\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all subset deltaE values\nAll subsets must have been computed already (guaranteed by processing fragments in order) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: fragment_idx Index of this fragment (already known) integer, intent(in) :: fragment (:) type( fragment_lookup_t ), intent(in) :: lookup Pre-built hash table for lookups real(kind=dp), intent(in) :: energies (:) Pre-computed delta values real(kind=dp), intent(in) :: delta_energies (:) Pre-computed delta values integer, intent(in) :: n Return Value real(kind=dp) Subroutines public  subroutine compute_mbe_energy (polymers, fragment_count, max_level, energies, total_energy) Compute the many-body expansion (MBE) energy\nTotal = sum(E(i)) + sum(deltaE(ij)) + sum(deltaE(ijk)) + …\nGeneral n-body correction:\ndeltaE(i1,i2,…,in) = E(i1,i2,…,in) - sum of all lower-order terms\nUses int64 for fragment_count to handle large fragment counts that overflow int32.\nDetailed breakdown is printed only if logger level is verbose or higher. Arguments Type Intent Optional Attributes Name integer, intent(in) :: polymers (:,:) integer(kind=int64), intent(in) :: fragment_count integer, intent(in) :: max_level real(kind=dp), intent(in) :: energies (:) real(kind=dp), intent(out) :: total_energy","tags":"","url":"module/mqc_mbe.html"},{"title":"mqc_frag_utils – metalquicha","text":"Provides combinatorial functions and algorithms for generating molecular\nfragments, managing fragment lists, and performing many-body expansion calculations.\nBinomial coefficient calculation\nGenerate sequential monomer indices\nGenerate all fragments up to max level\nCalculate total number of fragments\nGenerate next combination in sequence\nHash-based lookup table for fast fragment index retrieval Uses pic_types pic_logger pic_sorting pic_hash_32bit module~~mqc_frag_utils~~UsesGraph module~mqc_frag_utils mqc_frag_utils pic_hash_32bit pic_hash_32bit module~mqc_frag_utils->pic_hash_32bit pic_logger pic_logger module~mqc_frag_utils->pic_logger pic_sorting pic_sorting module~mqc_frag_utils->pic_sorting pic_types pic_types module~mqc_frag_utils->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mqc_frag_utils~~UsedByGraph module~mqc_frag_utils mqc_frag_utils module~mqc_driver mqc_driver module~mqc_driver->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme module~mqc_mbe mqc_mbe module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe program~main main program~main->module~mqc_driver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: fragment_lookup_t Hash-based lookup table for O(1) fragment index retrieval Components Type Visibility Attributes Name Initial logical, public :: initialized = .false. integer(kind=int64), public :: n_entries = 0 type( hash_entry_t ), public, allocatable :: table (:) integer, public :: table_size = 0 Type-Bound Procedures procedure, public :: destroy => fragment_lookup_destroy procedure, public :: find => fragment_lookup_find procedure, public :: init => fragment_lookup_init procedure, public :: insert => fragment_lookup_insert type, private :: hash_entry_t Single entry in hash table (private helper type) Components Type Visibility Attributes Name Initial integer, public, allocatable :: key (:) Sorted monomer indices type( hash_entry_t ), public, pointer :: next => null() Chain for collisions integer(kind=int64), public :: value Fragment index Functions public pure function binomial (n, r) result(c) Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) Read more… Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n Total number of items integer(kind=default_int), intent(in) :: r Number of items to choose Return Value integer(kind=int64) Binomial coefficient result public pure function get_nfrags (n_monomers, max_level) result(n_expected_fragments) Calculate total number of fragments for given system size and max level Read more… Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n_monomers Number of monomers in system integer(kind=default_int), intent(in) :: max_level Maximum fragment size Return Value integer(kind=int64) Total fragment count private pure function arrays_equal_internal (a, b, n) result(equal) Check if two arrays are equal Arguments Type Intent Optional Attributes Name integer, intent(in) :: a (:) integer, intent(in) :: b (:) integer, intent(in) :: n Return Value logical private  function fragment_lookup_find (this, monomers, n) result(idx) Find fragment index for given monomer combination Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(in) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n Return Value integer(kind=int64) private pure function next_prime_internal (n) result(p) Find next prime number >= n (simple implementation) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer Subroutines public pure subroutine create_monomer_list (monomers) Generate a list of monomer indices from 1 to N Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(inout), allocatable :: monomers (:) public recursive subroutine generate_fragment_list (monomers, max_level, polymers, count) Generate all possible fragments (combinations of monomers) up to max_level\nUses int64 for count to handle large numbers of fragments that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: monomers (:) integer(kind=default_int), intent(in) :: max_level integer(kind=default_int), intent(inout) :: polymers (:,:) integer(kind=int64), intent(inout) :: count public pure subroutine get_next_combination (indices, k, n, has_next) Generate next combination (updates indices in place)\nhas_next = .true. if there’s a next combination Arguments Type Intent Optional Attributes Name integer, intent(inout) :: indices (:) integer, intent(in) :: k integer, intent(in) :: n logical, intent(out) :: has_next private recursive subroutine combine (arr, n, r, out_array, count) Generate all combinations of size r from array arr of size n\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count private recursive subroutine combine_util (arr, n, r, index, data, i, out_array, count) Utility for generating combinations recursively\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: arr (:) integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: r integer(kind=default_int), intent(in) :: index integer(kind=default_int), intent(inout) :: data (:) integer(kind=default_int), intent(in) :: i integer(kind=default_int), intent(inout) :: out_array (:,:) integer(kind=int64), intent(inout) :: count private  subroutine fragment_lookup_destroy (this) Clean up hash table and all chains Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this private  subroutine fragment_lookup_init (this, estimated_entries) Initialize hash table with estimated size Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer(kind=int64), intent(in) :: estimated_entries private  subroutine fragment_lookup_insert (this, monomers, n, fragment_idx) Insert a monomer combination -> fragment index mapping Arguments Type Intent Optional Attributes Name class( fragment_lookup_t ), intent(inout) :: this integer, intent(in) :: monomers (:) integer, intent(in) :: n integer(kind=int64), intent(in) :: fragment_idx private  subroutine print_combos (out_array, count, max_len) Print combinations stored in out_array\nUses int64 for count to handle large numbers of combinations that overflow int32. Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: out_array (:,:) integer(kind=int64), intent(in) :: count integer(kind=default_int), intent(in) :: max_len","tags":"","url":"module/mqc_frag_utils.html"},{"title":"mqc_basis_reader – metalquicha","text":"Gaussian basis set parser and molecular basis construction Provides utilities for parsing Gaussian-type orbital basis sets\nfrom text files and building molecular basis sets for quantum calculations.\nDetermine basis file line type\nParse basis for single element\nBuild complete molecular basis\nConvert angular momentum character to integer\nConvert angular momentum integer to character Uses pic_types mqc_basis_file_reader mqc_cgto module~~mqc_basis_reader~~UsesGraph module~mqc_basis_reader mqc_basis_reader module~mqc_basis_file_reader mqc_basis_file_reader module~mqc_basis_reader->module~mqc_basis_file_reader module~mqc_cgto mqc_cgto module~mqc_basis_reader->module~mqc_cgto pic_types pic_types module~mqc_basis_reader->pic_types module~mqc_basis_file_reader->pic_types module~mqc_cgto->pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: LINE_ATOM = 1 Element specification line integer, public, parameter :: LINE_FUNCTION = 3 Basis function coefficient line integer, public, parameter :: LINE_SHELL = 2 Shell definition line integer, public, parameter :: LINE_UNKNOWN = 0 Unrecognized line type Functions public pure function ang_mom_char_to_int (ang_mom_char) result(ang_mom) Convert angular momentum character to integer Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: ang_mom_char Angular momentum symbol Return Value integer Corresponding integer value public pure function ang_mom_int_to_char (ang_mom) result(ang_mom_char) Convert angular momentum integer to character Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ang_mom Angular momentum quantum number Return Value character(len=1) Corresponding symbol character public pure function classify_line (line) result(line_type) Classify a line from a gamess formatted basis set file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value integer private pure function is_blank_or_control (line) result(res) Check if a line is blank or a control line (starts with ‘$’) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical private pure function is_function_line (line) result(res) Check if a line is a function coefficient line (starts with a number) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical private pure function is_shell_header (line) result(res) Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line Return Value logical Subroutines public  subroutine build_molecular_basis (basis_string, element_names, mol_basis, stat, errmsg) Build molecular basis from geometry and basis file\nOnly parses unique elements, then copies basis data to atoms Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_names (:) Element for each atom in geometry order type( molecular_basis_type ), intent(out) :: mol_basis integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg public pure subroutine parse_element_basis (basis_string, element_name, atom_basis, stat, errmsg) Parse basis set for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(out) :: atom_basis integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg private pure subroutine copy_atomic_basis (source, dest) Deep copy of atomic basis data from source to dest Arguments Type Intent Optional Attributes Name type( atomic_basis_type ), intent(in) :: source type( atomic_basis_type ), intent(out) :: dest private pure subroutine count_shells_for_element (basis_string, element_name, nshells, stat, errmsg) Count the number of shells for a specific element in a GAMESS formatted basis string, Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name integer, intent(out) :: nshells integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg private pure subroutine fill_element_basis (basis_string, element_name, atom_basis, stat, errmsg) Fill in the shell data for a specific element from a GAMESS formatted basis string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: basis_string character(len=*), intent(in) :: element_name type( atomic_basis_type ), intent(inout) :: atom_basis integer, intent(out) :: stat character(len=:), intent(out), allocatable :: errmsg private pure subroutine find_unique_strings (input_array, unique_array, nunique) Find unique strings in an array\nReturns array of unique strings and count Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_array (:) character(len=:), intent(out), allocatable :: unique_array (:) integer, intent(out) :: nunique private pure subroutine get_next_line (string, line_start, line, line_end) Extract the next line from a string starting at line_start Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: line_start character(len=*), intent(out) :: line integer, intent(out) :: line_end private pure subroutine parse_function_line (line, func_num, exponent, coeff_s, coeff_p, has_p, stat) Parse function line (e.g., “1 1.0 2.0” or “1 1.0 2.0 3.0” for L shells) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(out) :: func_num real(kind=dp), intent(out) :: exponent real(kind=dp), intent(out) :: coeff_s real(kind=dp), intent(out), optional :: coeff_p logical, intent(out) :: has_p integer, intent(out) :: stat private pure subroutine parse_shell_header (line, ang_mom, nfunc, stat) Parse shell header line (e.g., “S 2” or “L 3”) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(out) :: ang_mom integer, intent(out) :: nfunc integer, intent(out) :: stat","tags":"","url":"module/mqc_basis_reader.html"},{"title":"mqc_logo – metalquicha","text":"Provides the project branding sunflower logo and version information\ndisplayed at program startup.\nDisplay ASCII sunflower logo and project info Used by module~~mqc_logo~~UsedByGraph module~mqc_logo mqc_logo program~main main program~main->module~mqc_logo Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine print_logo () Print the PIC Chemistry ASCII sunflower logo Arguments None","tags":"","url":"module/mqc_logo.html"},{"title":"main – metalquicha","text":"Uses pic_mpi_lib pic_logger mqc_physical_fragment pic_timer mqc_logo mqc_input_parser pic_io mqc_driver program~~main~~UsesGraph program~main main module~mqc_driver mqc_driver program~main->module~mqc_driver module~mqc_input_parser mqc_input_parser program~main->module~mqc_input_parser module~mqc_logo mqc_logo program~main->module~mqc_logo module~mqc_physical_fragment mqc_physical_fragment program~main->module~mqc_physical_fragment pic_io pic_io program~main->pic_io pic_logger pic_logger program~main->pic_logger pic_mpi_lib pic_mpi_lib program~main->pic_mpi_lib pic_timer pic_timer program~main->pic_timer module~mqc_driver->module~mqc_input_parser module~mqc_driver->module~mqc_physical_fragment module~mqc_driver->pic_io module~mqc_driver->pic_logger module~mqc_driver->pic_mpi_lib module~mqc_frag_utils mqc_frag_utils module~mqc_driver->module~mqc_frag_utils module~mqc_mbe_fragment_distribution_scheme mqc_mbe_fragment_distribution_scheme module~mqc_driver->module~mqc_mbe_fragment_distribution_scheme omp_lib omp_lib module~mqc_driver->omp_lib pic_types pic_types module~mqc_driver->pic_types module~mqc_cgto mqc_cgto module~mqc_physical_fragment->module~mqc_cgto module~mqc_elements mqc_elements module~mqc_physical_fragment->module~mqc_elements module~mqc_geometry mqc_geometry module~mqc_physical_fragment->module~mqc_geometry module~mqc_xyz_reader mqc_xyz_reader module~mqc_physical_fragment->module~mqc_xyz_reader module~mqc_physical_fragment->pic_types module~mqc_cgto->pic_types module~mqc_elements->pic_types pic_ascii pic_ascii module~mqc_elements->pic_ascii module~mqc_frag_utils->pic_logger module~mqc_frag_utils->pic_types pic_hash_32bit pic_hash_32bit module~mqc_frag_utils->pic_hash_32bit pic_sorting pic_sorting module~mqc_frag_utils->pic_sorting module~mqc_geometry->pic_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_physical_fragment module~mqc_mbe_fragment_distribution_scheme->pic_io module~mqc_mbe_fragment_distribution_scheme->pic_logger module~mqc_mbe_fragment_distribution_scheme->pic_mpi_lib module~mqc_mbe_fragment_distribution_scheme->pic_timer module~mqc_mbe_fragment_distribution_scheme->omp_lib module~mqc_mbe_fragment_distribution_scheme->pic_types module~mqc_mbe mqc_mbe module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe module~mqc_mbe_io mqc_mbe_io module~mqc_mbe_fragment_distribution_scheme->module~mqc_mbe_io module~mqc_method_xtb mqc_method_xtb module~mqc_mbe_fragment_distribution_scheme->module~mqc_method_xtb module~mqc_mpi_tags mqc_mpi_tags module~mqc_mbe_fragment_distribution_scheme->module~mqc_mpi_tags module~mqc_result_types mqc_result_types module~mqc_mbe_fragment_distribution_scheme->module~mqc_result_types pic_blas_interfaces pic_blas_interfaces module~mqc_mbe_fragment_distribution_scheme->pic_blas_interfaces module~mqc_xyz_reader->module~mqc_geometry module~mqc_xyz_reader->pic_types module~mqc_mbe->module~mqc_physical_fragment module~mqc_mbe->pic_io module~mqc_mbe->pic_logger module~mqc_mbe->pic_mpi_lib module~mqc_mbe->pic_timer module~mqc_mbe->module~mqc_frag_utils module~mqc_mbe->pic_types module~mqc_mbe->module~mqc_mbe_io module~mqc_mbe->module~mqc_mpi_tags module~mqc_mbe->pic_blas_interfaces module~mqc_mbe_io->module~mqc_physical_fragment module~mqc_mbe_io->pic_io module~mqc_mbe_io->pic_logger module~mqc_mbe_io->module~mqc_elements module~mqc_mbe_io->pic_types module~mqc_method_xtb->module~mqc_physical_fragment module~mqc_method_xtb->pic_types module~mqc_method_xtb->module~mqc_result_types mctc_env mctc_env module~mqc_method_xtb->mctc_env mctc_io mctc_io module~mqc_method_xtb->mctc_io module~mqc_method_base mqc_method_base module~mqc_method_xtb->module~mqc_method_base tblite_context_type tblite_context_type module~mqc_method_xtb->tblite_context_type tblite_wavefunction tblite_wavefunction module~mqc_method_xtb->tblite_wavefunction tblite_xtb_calculator tblite_xtb_calculator module~mqc_method_xtb->tblite_xtb_calculator tblite_xtb_gfn1 tblite_xtb_gfn1 module~mqc_method_xtb->tblite_xtb_gfn1 tblite_xtb_gfn2 tblite_xtb_gfn2 module~mqc_method_xtb->tblite_xtb_gfn2 tblite_xtb_singlepoint tblite_xtb_singlepoint module~mqc_method_xtb->tblite_xtb_singlepoint module~mqc_mpi_tags->pic_types module~mqc_result_types->pic_types module~mqc_method_base->module~mqc_physical_fragment module~mqc_method_base->pic_types module~mqc_method_base->module~mqc_result_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Orchestrates MPI initialization, input parsing, geometry loading,\nand dispatches to appropriate calculation routines (fragmented or unfragmented). Calls program~~main~~CallsGraph program~main main abort_comm abort_comm program~main->abort_comm comm_world comm_world program~main->comm_world configure configure program~main->configure error error program~main->error finalize finalize program~main->finalize get_elapsed_time get_elapsed_time program~main->get_elapsed_time info info program~main->info pic_mpi_finalize pic_mpi_finalize program~main->pic_mpi_finalize pic_mpi_init pic_mpi_init program~main->pic_mpi_init proc~config_destroy input_config_t%config_destroy program~main->proc~config_destroy proc~get_logger_level get_logger_level program~main->proc~get_logger_level proc~initialize_system_geometry initialize_system_geometry program~main->proc~initialize_system_geometry proc~print_logo print_logo program~main->proc~print_logo proc~read_input_file read_input_file program~main->proc~read_input_file proc~run_calculation run_calculation program~main->proc~run_calculation split split program~main->split start start program~main->start to_char to_char program~main->to_char proc~element_symbol_to_number element_symbol_to_number proc~initialize_system_geometry->proc~element_symbol_to_number proc~geometry_destroy geometry_type%geometry_destroy proc~initialize_system_geometry->proc~geometry_destroy proc~read_xyz_file read_xyz_file proc~initialize_system_geometry->proc~read_xyz_file proc~to_bohr to_bohr proc~initialize_system_geometry->proc~to_bohr proc~remove_quotes remove_quotes proc~read_input_file->proc~remove_quotes proc~run_calculation->info proc~run_calculation->to_char omp_set_num_threads omp_set_num_threads proc~run_calculation->omp_set_num_threads proc~run_fragmented_calculation run_fragmented_calculation proc~run_calculation->proc~run_fragmented_calculation proc~run_unfragmented_calculation run_unfragmented_calculation proc~run_calculation->proc~run_unfragmented_calculation to_lower to_lower proc~element_symbol_to_number->to_lower to_upper to_upper proc~element_symbol_to_number->to_upper proc~read_xyz_string read_xyz_string proc~read_xyz_file->proc~read_xyz_string proc~run_fragmented_calculation->info proc~run_fragmented_calculation->to_char proc~run_fragmented_calculation->omp_set_num_threads allgather allgather proc~run_fragmented_calculation->allgather bcast bcast proc~run_fragmented_calculation->bcast leader leader proc~run_fragmented_calculation->leader omp_get_max_threads omp_get_max_threads proc~run_fragmented_calculation->omp_get_max_threads proc~create_monomer_list create_monomer_list proc~run_fragmented_calculation->proc~create_monomer_list proc~generate_fragment_list generate_fragment_list proc~run_fragmented_calculation->proc~generate_fragment_list proc~get_nfrags get_nfrags proc~run_fragmented_calculation->proc~get_nfrags proc~global_coordinator global_coordinator proc~run_fragmented_calculation->proc~global_coordinator proc~node_coordinator node_coordinator proc~run_fragmented_calculation->proc~node_coordinator proc~node_worker node_worker proc~run_fragmented_calculation->proc~node_worker proc~serial_fragment_processor serial_fragment_processor proc~run_fragmented_calculation->proc~serial_fragment_processor verbose verbose proc~run_fragmented_calculation->verbose proc~run_unfragmented_calculation->abort_comm proc~run_unfragmented_calculation->error proc~run_unfragmented_calculation->info proc~run_unfragmented_calculation->to_char proc~unfragmented_calculation unfragmented_calculation proc~run_unfragmented_calculation->proc~unfragmented_calculation proc~combine combine proc~generate_fragment_list->proc~combine proc~binomial binomial proc~get_nfrags->proc~binomial proc~global_coordinator->error proc~global_coordinator->get_elapsed_time proc~global_coordinator->info proc~global_coordinator->start proc~global_coordinator->to_char proc~global_coordinator->verbose debug debug proc~global_coordinator->debug iprobe iprobe proc~global_coordinator->iprobe irecv irecv proc~global_coordinator->irecv isend isend proc~global_coordinator->isend proc~compute_mbe_energy compute_mbe_energy proc~global_coordinator->proc~compute_mbe_energy proc~send_fragment_to_node send_fragment_to_node proc~global_coordinator->proc~send_fragment_to_node proc~send_fragment_to_worker send_fragment_to_worker proc~global_coordinator->proc~send_fragment_to_worker proc~node_coordinator->error proc~node_coordinator->to_char proc~node_coordinator->iprobe proc~node_coordinator->irecv proc~node_coordinator->isend recv recv proc~node_coordinator->recv proc~node_worker->irecv proc~node_worker->isend proc~build_fragment_from_indices build_fragment_from_indices proc~node_worker->proc~build_fragment_from_indices proc~do_fragment_work do_fragment_work proc~node_worker->proc~do_fragment_work proc~fragment_destroy physical_fragment_t%fragment_destroy proc~node_worker->proc~fragment_destroy proc~node_worker->recv proc~int_to_string int_to_string proc~read_xyz_string->proc~int_to_string proc~split_lines split_lines proc~read_xyz_string->proc~split_lines proc~serial_fragment_processor->get_elapsed_time proc~serial_fragment_processor->info proc~serial_fragment_processor->start proc~serial_fragment_processor->to_char proc~serial_fragment_processor->omp_set_num_threads proc~serial_fragment_processor->omp_get_max_threads proc~serial_fragment_processor->proc~build_fragment_from_indices proc~serial_fragment_processor->proc~compute_mbe_energy proc~serial_fragment_processor->proc~do_fragment_work proc~serial_fragment_processor->proc~fragment_destroy proc~unfragmented_calculation->error proc~unfragmented_calculation->info proc~unfragmented_calculation->to_char all_monomer_indices all_monomer_indices proc~unfragmented_calculation->all_monomer_indices proc~unfragmented_calculation->proc~build_fragment_from_indices proc~unfragmented_calculation->proc~do_fragment_work temp_indices temp_indices proc~unfragmented_calculation->temp_indices proc~combine_util combine_util proc~combine->proc~combine_util proc~compute_mbe_energy->get_elapsed_time proc~compute_mbe_energy->info proc~compute_mbe_energy->start proc~compute_mbe_energy->to_char proc~compute_mbe_energy->debug configuration configuration proc~compute_mbe_energy->configuration proc~compute_mbe compute_mbe proc~compute_mbe_energy->proc~compute_mbe proc~fragment_lookup_destroy fragment_lookup_t%fragment_lookup_destroy proc~compute_mbe_energy->proc~fragment_lookup_destroy proc~fragment_lookup_init fragment_lookup_t%fragment_lookup_init proc~compute_mbe_energy->proc~fragment_lookup_init proc~fragment_lookup_insert fragment_lookup_t%fragment_lookup_insert proc~compute_mbe_energy->proc~fragment_lookup_insert proc~print_detailed_breakdown print_detailed_breakdown proc~compute_mbe_energy->proc~print_detailed_breakdown proc~print_detailed_breakdown_json print_detailed_breakdown_json proc~compute_mbe_energy->proc~print_detailed_breakdown_json proc~do_fragment_work->configuration proc~print_fragment_xyz print_fragment_xyz proc~do_fragment_work->proc~print_fragment_xyz proc~result_destroy calculation_result_t%result_destroy proc~do_fragment_work->proc~result_destroy proc~xtb_calc_energy xtb_method_t%xtb_calc_energy proc~do_fragment_work->proc~xtb_calc_energy proc~basis_set_destroy molecular_basis_type%basis_set_destroy proc~fragment_destroy->proc~basis_set_destroy proc~send_fragment_to_node->isend proc~send_fragment_to_worker->isend Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( input_config_t ) :: config Parsed input configuration character(len=:), allocatable :: errmsg Error messages character(len=256) :: input_file Input file name type(timer_type) :: my_timer Execution timing type(comm_t) :: node_comm Node-local MPI communicator integer :: stat Status code for error handling type( system_geometry_t ) :: sys_geom Loaded molecular system type(comm_t) :: world_comm Global MPI communicator Source Code program main !! Orchestrates MPI initialization, input parsing, geometry loading, !! and dispatches to appropriate calculation routines (fragmented or unfragmented). use pic_logger , only : logger => global_logger , info_level use pic_io , only : to_char use pic_mpi_lib , only : pic_mpi_init , comm_world , comm_t , abort_comm , pic_mpi_finalize use mqc_driver , only : run_calculation use mqc_physical_fragment , only : initialize_system_geometry , system_geometry_t use mqc_input_parser , only : read_input_file , input_config_t , get_logger_level use mqc_logo , only : print_logo use pic_timer , only : timer_type implicit none type ( timer_type ) :: my_timer !! Execution timing type ( comm_t ) :: world_comm !! Global MPI communicator type ( comm_t ) :: node_comm !! Node-local MPI communicator type ( input_config_t ) :: config !! Parsed input configuration type ( system_geometry_t ) :: sys_geom !! Loaded molecular system integer :: stat !! Status code for error handling character ( len = :), allocatable :: errmsg !! Error messages character ( len = 256 ) :: input_file !! Input file name ! Initialize MPI ! pic-mpi will call mpi_init_thread when needed call pic_mpi_init () ! Create communicators world_comm = comm_world () node_comm = world_comm % split () if ( world_comm % rank () == 0 ) then call print_logo () call my_timer % start () end if input_file = \"test.inp\" call read_input_file ( input_file , config , stat , errmsg ) if ( stat /= 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error reading input file \" // errmsg ) end if call abort_comm ( world_comm , 1 ) end if ! Configure logger verbosity based on input file call logger % configure ( get_logger_level ( config % log_level )) if ( world_comm % rank () == 0 ) then call logger % info ( \"Logger verbosity set to: \" // trim ( config % log_level )) end if call initialize_system_geometry ( config % geom_file , config % monomer_file , sys_geom , stat , errmsg ) if ( stat /= 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error loeading geometry \" // errmsg ) end if call abort_comm ( world_comm , 1 ) end if call run_calculation ( world_comm , node_comm , config , sys_geom ) if ( world_comm % rank () == 0 ) then call my_timer % stop () call logger % info ( \"Total processing time: \" // to_char ( my_timer % get_elapsed_time ()) // \" s\" ) end if call config % destroy () call sys_geom % destroy () call world_comm % finalize () call node_comm % finalize () call pic_mpi_finalize () end program main","tags":"","url":"program/main.html"},{"title":"mqc_input_parser.f90 – metalquicha","text":"Input file parser for the hastily put together input file format Files dependent on this one sourcefile~~mqc_input_parser.f90~~AfferentGraph sourcefile~mqc_input_parser.f90 mqc_input_parser.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_input_parser.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_input_parser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Input file parser for the hastily put together input file format module mqc_input_parser !! Parses simple key=value input files to configure calculation parameters !! including geometry files, method selection, and fragment levels. implicit none private public :: input_config_t , read_input_file , get_logger_level !! Main configuration type and parser type :: input_config_t !! Configuration data structure for calculation parameters !! !! Stores parsed input file contents including file paths, !! method selection, and fragmentation level. character ( len = :), allocatable :: geom_file !! Path to system geometry XYZ file character ( len = :), allocatable :: monomer_file !! Path to monomer template XYZ file character ( len = :), allocatable :: method !! QC method (gfn1, gfn2) character ( len = :), allocatable :: log_level !! Logger verbosity level (debug/verbose/info/warning/error) integer :: nlevel = 1 !! Fragmentation level (default: 1) contains procedure :: destroy => config_destroy !! Cleanup allocated memory end type input_config_t contains subroutine read_input_file ( filename , config , stat , errmsg ) !! Simple parser for key=value input files !! Looks for: geom=\"path/to/geometry.xyz\" !!            monomer_symbols=\"path/to/monomer.xyz\" !!            method=\"gfn1\" or \"gfn2\" (defaults to gfn2) !!            nlevel=N (fragmentation level, defaults to 1) !!            log_level=\"debug|verbose|info|performance|warning|error|knowledge\" (defaults to info) character ( len =* ), intent ( in ) :: filename !! Path to input file to parse type ( input_config_t ), intent ( out ) :: config !! Parsed configuration data integer , intent ( out ) :: stat !! Status code (0 = success, >0 = error) character ( len = :), allocatable , intent ( out ) :: errmsg !! Error message on failure integer :: unit !! File unit number integer :: io_stat !! I/O operation status character ( len = 512 ) :: line !! Current line being parsed character ( len = 512 ) :: key !! Parsed key name character ( len = 512 ) :: value !! Parsed value string integer :: eq_pos !! Position of '=' character in line logical :: file_exists !! Whether input file exists stat = 0 inquire ( file = filename , exist = file_exists ) if (. not . file_exists ) then stat = 1 errmsg = \"Input file not found: \" // trim ( filename ) return end if open ( newunit = unit , file = filename , status = 'old' , action = 'read' , iostat = io_stat ) if ( io_stat /= 0 ) then stat = io_stat errmsg = \"Error opening input file: \" // trim ( filename ) return end if ! Read line by line do read ( unit , '(A)' , iostat = io_stat ) line if ( io_stat /= 0 ) exit ! Skip empty lines and comments line = adjustl ( line ) if ( len_trim ( line ) == 0 ) cycle if ( line ( 1 : 1 ) == '#' . or . line ( 1 : 1 ) == '!' ) cycle ! Find '=' sign eq_pos = index ( line , '=' ) if ( eq_pos == 0 ) cycle ! Extract key and value key = adjustl ( line ( 1 : eq_pos - 1 )) value = adjustl ( line ( eq_pos + 1 :)) ! Remove quotes from value if present value = remove_quotes ( value ) ! Parse recognized keys select case ( trim ( key )) case ( 'geom' ) config % geom_file = trim ( value ) case ( 'monomer_symbols' ) config % monomer_file = trim ( value ) case ( 'method' ) ! Validate that method is gfn1 or gfn2 select case ( trim ( value )) case ( 'gfn1' , 'gfn2' ) config % method = trim ( value ) case default stat = 1 errmsg = \"Invalid method: \" // trim ( value ) // \" (supported: gfn1, gfn2)\" return end select case ( 'nlevel' ) read ( value , * , iostat = io_stat ) config % nlevel if ( io_stat /= 0 ) then stat = 1 errmsg = \"Invalid value for nlevel: \" // trim ( value ) return end if if ( config % nlevel < 0 ) then stat = 1 errmsg = \"nlevel must be >= 0 (0 for unfragmented calculation)\" return end if case ( 'log_level' ) ! Validate log level select case ( trim ( value )) case ( 'debug' , 'Debug' , 'DEBUG' , & 'verbose' , 'Verbose' , 'VERBOSE' , & 'info' , 'Info' , 'INFO' , & 'performance' , 'Performance' , 'PERFORMANCE' , & 'warning' , 'Warning' , 'WARNING' , & 'error' , 'Error' , 'ERROR' , & 'knowledge' , 'Knowledge' , 'KNOWLEDGE' ) config % log_level = trim ( value ) case default stat = 1 errmsg = \"Invalid log_level: \" // trim ( value ) // & \" (supported: debug, verbose, info, performance, warning, error, knowledge)\" return end select case default ! Ignore unrecognized keys continue end select end do close ( unit ) ! Validate required fields if (. not . allocated ( config % geom_file )) then stat = 1 errmsg = \"Missing required field: geom\" return end if if (. not . allocated ( config % monomer_file )) then stat = 1 errmsg = \"Missing required field: monomer_symbols\" return end if ! Set default method if not specified if (. not . allocated ( config % method )) then config % method = \"gfn2\" ! Default to GFN2-xTB end if ! Set default log_level if not specified if (. not . allocated ( config % log_level )) then config % log_level = \"info\" ! Default to info level end if end subroutine read_input_file function remove_quotes ( str ) result ( cleaned ) !! Remove surrounding quotes from string character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: cleaned character ( len = len ( str )) :: temp integer :: start_pos , end_pos temp = adjustl ( str ) start_pos = 1 end_pos = len_trim ( temp ) ! Remove leading quote if ( end_pos > 0 ) then if ( temp ( 1 : 1 ) == '\"' . or . temp ( 1 : 1 ) == \"'\" ) then start_pos = 2 end if end if ! Remove trailing quote if ( end_pos > 0 ) then if ( temp ( end_pos : end_pos ) == '\"' . or . temp ( end_pos : end_pos ) == \"'\" ) then end_pos = end_pos - 1 end if end if if ( end_pos >= start_pos ) then cleaned = temp ( start_pos : end_pos ) else cleaned = \"\" end if end function remove_quotes function get_logger_level ( level_string ) result ( level_int ) !! Convert string log level to integer value !! This function uses the pic_logger constants use pic_logger , only : debug_level , verbose_level , info_level , performance_level , & warning_level , error_level , knowledge_level character ( len =* ), intent ( in ) :: level_string integer :: level_int select case ( trim ( adjustl ( level_string ))) case ( 'debug' , 'Debug' , 'DEBUG' ) level_int = debug_level case ( 'verbose' , 'Verbose' , 'VERBOSE' ) level_int = verbose_level case ( 'info' , 'Info' , 'INFO' ) level_int = info_level case ( 'performance' , 'Performance' , 'PERFORMANCE' ) level_int = performance_level case ( 'warning' , 'Warning' , 'WARNING' ) level_int = warning_level case ( 'error' , 'Error' , 'ERROR' ) level_int = error_level case ( 'knowledge' , 'Knowledge' , 'KNOWLEDGE' ) level_int = knowledge_level case default ! Default to info level if unknown level_int = info_level end select end function get_logger_level subroutine config_destroy ( this ) !! Clean up allocated memory in input_config_t class ( input_config_t ), intent ( inout ) :: this if ( allocated ( this % geom_file )) deallocate ( this % geom_file ) if ( allocated ( this % monomer_file )) deallocate ( this % monomer_file ) if ( allocated ( this % method )) deallocate ( this % method ) if ( allocated ( this % log_level )) deallocate ( this % log_level ) end subroutine config_destroy end module mqc_input_parser","tags":"","url":"sourcefile/mqc_input_parser.f90.html"},{"title":"mqc_physical_fragment.f90 – metalquicha","text":"This file contains all routines and types to represent a “physical” fragment or molecule\ni.e., with atomic coordinates, element types, electronic properties, etc. This file depends on sourcefile~~mqc_physical_fragment.f90~~EfferentGraph sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_physical_fragment.f90~~AfferentGraph sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This file contains all routines and types to represent a \"physical\" fragment or molecule !! i.e., with atomic coordinates, element types, electronic properties, etc. module mqc_physical_fragment !! Physical molecular fragment representation and geometry handling !! !! Provides data structures and utilities for managing molecular fragments !! with atomic coordinates, electronic properties, and geometric operations. use pic_types , only : dp , default_int use mqc_geometry , only : geometry_type use mqc_xyz_reader , only : read_xyz_file use mqc_elements , only : element_symbol_to_number , element_number_to_symbol , element_mass use mqc_cgto , only : molecular_basis_type implicit none private public :: physical_fragment_t !! Single molecular fragment type public :: system_geometry_t !! Complete system geometry type public :: initialize_system_geometry !! System geometry initialization public :: build_fragment_from_indices !! Extract fragment from system public :: to_angstrom , to_bohr !! Unit conversion utilities public :: fragment_centroid !! Geometric centroid calculation public :: fragment_center_of_mass !! Mass-weighted center calculation public :: distance_between_points !! Point-to-point distance public :: distance_between_fragments !! Inter-fragment distance public :: minimal_distance_between_fragments !! Closest approach distance type :: physical_fragment_t !! Physical molecular fragment with atomic coordinates and properties !! !! Represents a molecular fragment containing atomic positions, element types, !! electronic structure information, and basis set data for quantum calculations. integer :: n_atoms !! Number of atoms in this fragment integer , allocatable :: element_numbers (:) !! Atomic numbers (Z values) real ( dp ), allocatable :: coordinates (:, :) !! Cartesian coordinates (3, n_atoms) in Bohr ! Electronic structure properties integer :: charge = 0 !! Net molecular charge (electrons) integer :: multiplicity = 1 !! Spin multiplicity (2S+1) integer :: nelec = 0 !! Total number of electrons ! Quantum chemistry basis set type ( molecular_basis_type ), allocatable :: basis !! Gaussian basis functions contains procedure :: destroy => fragment_destroy !! Memory cleanup procedure :: compute_nelec => fragment_compute_nelec !! Calculate electron count procedure :: set_basis => fragment_set_basis !! Assign basis set end type physical_fragment_t type :: system_geometry_t !! Complete molecular system geometry for fragment-based calculations !! !! Contains the full atomic structure of a molecular cluster organized !! by monomers for efficient fragment generation and MBE calculations. integer :: n_monomers !! Number of monomer units in system integer :: atoms_per_monomer !! Atoms in each monomer (assumed identical) integer :: total_atoms !! Total number of atoms (n_monomers × atoms_per_monomer) integer , allocatable :: element_numbers (:) !! Atomic numbers for all atoms real ( dp ), allocatable :: coordinates (:, :) !! All coordinates (3, total_atoms) in Bohr contains procedure :: destroy => system_destroy !! Memory cleanup end type system_geometry_t ! Physical constants real ( dp ), parameter :: bohr_radius = 0.52917721092_dp !! Bohr radius in Ångström contains pure elemental function to_angstrom ( bohr_value ) result ( angstrom_value ) !! Convert coordinate from Bohr to Angstrom real ( dp ), intent ( in ) :: bohr_value real ( dp ) :: angstrom_value angstrom_value = bohr_value * bohr_radius end function to_angstrom pure elemental function to_bohr ( angstrom_value ) result ( bohr_value ) !! Convert coordinate from Angstrom to Bohr real ( dp ), intent ( in ) :: angstrom_value real ( dp ) :: bohr_value bohr_value = angstrom_value / bohr_radius end function to_bohr subroutine initialize_system_geometry ( full_geom_file , monomer_file , sys_geom , stat , errmsg ) !! Read full geometry and monomer template, initialize system_geometry_t character ( len =* ), intent ( in ) :: full_geom_file , monomer_file type ( system_geometry_t ), intent ( out ) :: sys_geom integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg type ( geometry_type ) :: full_geom , monomer_geom integer :: i call read_xyz_file ( full_geom_file , full_geom , stat , errmsg ) if ( stat /= 0 ) return ! Read monomer template ! this will be changed once we have a proper input file parsing call read_xyz_file ( monomer_file , monomer_geom , stat , errmsg ) if ( stat /= 0 ) then call full_geom % destroy () return end if ! Validate that full geometry is a multiple of monomer size sys_geom % atoms_per_monomer = monomer_geom % natoms sys_geom % total_atoms = full_geom % natoms if ( mod ( sys_geom % total_atoms , sys_geom % atoms_per_monomer ) /= 0 ) then stat = 1 errmsg = \"Full geometry atoms not a multiple of monomer atoms\" call full_geom % destroy () call monomer_geom % destroy () return end if sys_geom % n_monomers = sys_geom % total_atoms / sys_geom % atoms_per_monomer ! TODO JORGE: this can be a sys_geom%allocate() allocate ( sys_geom % element_numbers ( sys_geom % total_atoms )) allocate ( sys_geom % coordinates ( 3 , sys_geom % total_atoms )) do i = 1 , sys_geom % total_atoms sys_geom % element_numbers ( i ) = element_symbol_to_number ( full_geom % elements ( i )) end do ! Store coordinates in Bohr (convert from Angstroms) ! TODO JORGE: need a way to handle units sys_geom % coordinates = to_bohr ( full_geom % coords ) call full_geom % destroy () call monomer_geom % destroy () stat = 0 end subroutine initialize_system_geometry pure subroutine build_fragment_from_indices ( sys_geom , monomer_indices , fragment ) !! Build a fragment on-the-fly from monomer indices !! e.g., monomer_indices = [1, 3, 5] extracts waters 1, 3, and 5 type ( system_geometry_t ), intent ( in ) :: sys_geom integer , intent ( in ) :: monomer_indices (:) type ( physical_fragment_t ), intent ( out ) :: fragment integer :: n_monomers_in_frag , atoms_per_monomer integer :: i , mono_idx , atom_start , atom_end , frag_atom_idx n_monomers_in_frag = size ( monomer_indices ) atoms_per_monomer = sys_geom % atoms_per_monomer fragment % n_atoms = n_monomers_in_frag * atoms_per_monomer allocate ( fragment % element_numbers ( fragment % n_atoms )) allocate ( fragment % coordinates ( 3 , fragment % n_atoms )) frag_atom_idx = 0 do i = 1 , n_monomers_in_frag mono_idx = monomer_indices ( i ) atom_start = ( mono_idx - 1 ) * atoms_per_monomer + 1 atom_end = mono_idx * atoms_per_monomer fragment % element_numbers ( frag_atom_idx + 1 : frag_atom_idx + atoms_per_monomer ) = & sys_geom % element_numbers ( atom_start : atom_end ) fragment % coordinates (:, frag_atom_idx + 1 : frag_atom_idx + atoms_per_monomer ) = & sys_geom % coordinates (:, atom_start : atom_end ) frag_atom_idx = frag_atom_idx + atoms_per_monomer end do end subroutine build_fragment_from_indices subroutine fragment_destroy ( this ) !! Clean up allocated memory in physical_fragment_t class ( physical_fragment_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if this % n_atoms = 0 this % charge = 0 this % multiplicity = 1 this % nelec = 0 end subroutine fragment_destroy subroutine fragment_compute_nelec ( this ) !! Compute number of electrons from atomic numbers and charge class ( physical_fragment_t ), intent ( inout ) :: this integer :: nuclear_charge nuclear_charge = sum ( this % element_numbers ) this % nelec = nuclear_charge - this % charge end subroutine fragment_compute_nelec subroutine fragment_set_basis ( this , basis ) !! Set the basis set for this fragment class ( physical_fragment_t ), intent ( inout ) :: this type ( molecular_basis_type ), intent ( in ) :: basis if ( allocated ( this % basis )) then call this % basis % destroy () deallocate ( this % basis ) end if allocate ( this % basis ) this % basis = basis end subroutine fragment_set_basis subroutine system_destroy ( this ) !! Clean up allocated memory in system_geometry_t class ( system_geometry_t ), intent ( inout ) :: this if ( allocated ( this % element_numbers )) deallocate ( this % element_numbers ) if ( allocated ( this % coordinates )) deallocate ( this % coordinates ) this % n_monomers = 0 this % atoms_per_monomer = 0 this % total_atoms = 0 end subroutine system_destroy pure function fragment_centroid ( fragment ) result ( centroid ) !! Calculate the geometric centroid (center of geometry) of a fragment !! This is the simple average of all atomic coordinates !! Returns coordinates in the same units as the fragment (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ) :: centroid ( 3 ) integer :: i centroid = 0.0_dp do i = 1 , fragment % n_atoms centroid = centroid + fragment % coordinates (:, i ) end do centroid = centroid / real ( fragment % n_atoms , dp ) end function fragment_centroid pure function fragment_center_of_mass ( fragment ) result ( com ) !! Calculate the center of mass of a fragment !! Weights each atomic position by its atomic mass !! Returns coordinates in the same units as the fragment (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: fragment real ( dp ) :: com ( 3 ) real ( dp ) :: total_mass , atom_mass integer :: i com = 0.0_dp total_mass = 0.0_dp do i = 1 , fragment % n_atoms atom_mass = element_mass ( fragment % element_numbers ( i )) com = com + atom_mass * fragment % coordinates (:, i ) total_mass = total_mass + atom_mass end do com = com / total_mass end function fragment_center_of_mass pure function distance_between_points ( point1 , point2 ) result ( distance ) !! Calculate Euclidean distance between two 3D points !! Points should be in the same units (typically Bohr) real ( dp ), intent ( in ) :: point1 ( 3 ), point2 ( 3 ) real ( dp ) :: distance real ( dp ) :: diff ( 3 ) diff = point2 - point1 distance = sqrt ( dot_product ( diff , diff )) end function distance_between_points pure function distance_between_fragments ( frag1 , frag2 , use_com ) result ( distance ) !! Calculate distance between two fragments !! If use_com is .true., uses center of mass; otherwise uses centroid !! Distance is in the same units as the fragment coordinates (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: frag1 , frag2 logical , intent ( in ) :: use_com real ( dp ) :: distance real ( dp ) :: point1 ( 3 ), point2 ( 3 ) if ( use_com ) then point1 = fragment_center_of_mass ( frag1 ) point2 = fragment_center_of_mass ( frag2 ) else point1 = fragment_centroid ( frag1 ) point2 = fragment_centroid ( frag2 ) end if distance = distance_between_points ( point1 , point2 ) end function distance_between_fragments pure function minimal_distance_between_fragments ( frag1 , frag2 ) result ( min_distance ) !! Calculate the minimal distance between any two atoms in two fragments !! This iterates over all atom pairs and finds the closest pair !! Distance is in the same units as the fragment coordinates (typically Bohr) type ( physical_fragment_t ), intent ( in ) :: frag1 , frag2 real ( dp ) :: min_distance real ( dp ) :: current_distance integer :: i , j ! Initialize with a very large value min_distance = huge ( 1.0_dp ) do i = 1 , frag1 % n_atoms do j = 1 , frag2 % n_atoms current_distance = distance_between_points ( frag1 % coordinates (:, i ), & frag2 % coordinates (:, j )) if ( current_distance < min_distance ) then min_distance = current_distance end if end do end do end function minimal_distance_between_fragments end module mqc_physical_fragment","tags":"","url":"sourcefile/mqc_physical_fragment.f90.html"},{"title":"mqc_cgto.f90 – metalquicha","text":"Data structures for cartesian contracted Gaussian type orbitals (CGTOs) Files dependent on this one sourcefile~~mqc_cgto.f90~~AfferentGraph sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Data structures for cartesian contracted Gaussian type orbitals (CGTOs) module mqc_cgto !! Defines data structures for cartesian contracted Gaussian type orbitals (CGTOs) use pic_types , only : dp implicit none private public :: cgto_type , atomic_basis_type , molecular_basis_type type :: cgto_type !! Contracted Gaussian type orbital (CGTO) data structure integer :: ang_mom !! Angular momentum quantum number (0=s, 1=p, 2=d, etc.) integer :: nfunc !! Number of primitive Gaussians in the contraction real ( dp ), allocatable :: exponents (:) !! Exponents (alpha values) real ( dp ), allocatable :: coefficients (:) !! Contraction coefficients contains procedure :: allocate_arrays => cgto_allocate_arrays procedure :: destroy => cgto_destroy procedure :: num_basis_functions => cgto_num_basis_functions end type cgto_type type :: atomic_basis_type !! Atomic basis set data structure character ( len = :), allocatable :: element !! element symbol type ( cgto_type ), allocatable :: shells (:) !! array of contracted shells integer :: nshells !! number of shells in type contains procedure :: allocate_shells => allocate_basis_shells procedure :: destroy => atomic_basis_destroy procedure :: num_basis_functions => atomic_basis_num_basis_functions end type atomic_basis_type type :: molecular_basis_type !! Molecular basis set data structure (assembled basis) type ( atomic_basis_type ), allocatable :: elements (:) !! array of atomic basis types integer :: nelements !! total number of atoms/elements in a molecule contains procedure :: allocate_elements => basis_set_allocate_elements procedure :: destroy => basis_set_destroy procedure :: num_basis_functions => molecular_basis_num_basis_functions end type molecular_basis_type contains pure subroutine cgto_allocate_arrays ( self , nfunc ) !! Allocate arrays for exponents and coefficients in a CGTO class ( cgto_type ), intent ( inout ) :: self integer , intent ( in ) :: nfunc self % nfunc = nfunc allocate ( self % exponents ( nfunc )) allocate ( self % coefficients ( nfunc )) end subroutine cgto_allocate_arrays pure subroutine cgto_destroy ( self ) !! Clean up allocated memory in a CGTO class ( cgto_type ), intent ( inout ) :: self if ( allocated ( self % exponents )) deallocate ( self % exponents ) if ( allocated ( self % coefficients )) deallocate ( self % coefficients ) self % nfunc = 0 self % ang_mom = 0 end subroutine cgto_destroy pure subroutine allocate_basis_shells ( self , nshells ) !! Allocate array of shells in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nshells self % nshells = nshells allocate ( self % shells ( nshells )) end subroutine allocate_basis_shells pure subroutine atomic_basis_destroy ( self ) !! Clean up allocated memory in an atomic basis class ( atomic_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % shells )) then do i = 1 , self % nshells call self % shells ( i )% destroy () end do deallocate ( self % shells ) end if if ( allocated ( self % element )) deallocate ( self % element ) self % nshells = 0 end subroutine atomic_basis_destroy pure subroutine basis_set_allocate_elements ( self , nelements ) !! Allocate array of atomic basis elements in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer , intent ( in ) :: nelements self % nelements = nelements allocate ( self % elements ( nelements )) end subroutine basis_set_allocate_elements pure subroutine basis_set_destroy ( self ) !! Clean up allocated memory in a molecular basis set class ( molecular_basis_type ), intent ( inout ) :: self integer :: i if ( allocated ( self % elements )) then do i = 1 , self % nelements call self % elements ( i )% destroy () end do deallocate ( self % elements ) end if self % nelements = 0 end subroutine basis_set_destroy pure function cgto_num_basis_functions ( self ) result ( nbf ) !! Get number of basis functions in a shell (Cartesian) class ( cgto_type ), intent ( in ) :: self integer :: nbf ! Cartesian: (ang_mom+1)*(ang_mom+2)/2 nbf = ( self % ang_mom + 1 ) * ( self % ang_mom + 2 ) / 2 end function cgto_num_basis_functions pure function atomic_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for an atom class ( atomic_basis_type ), intent ( in ) :: self integer :: nbf integer :: ishell nbf = 0 do ishell = 1 , self % nshells nbf = nbf + self % shells ( ishell )% num_basis_functions () end do end function atomic_basis_num_basis_functions pure function molecular_basis_num_basis_functions ( self ) result ( nbf ) !! Get total number of basis functions for the molecule class ( molecular_basis_type ), intent ( in ) :: self integer :: nbf integer :: iatom nbf = 0 do iatom = 1 , self % nelements nbf = nbf + self % elements ( iatom )% num_basis_functions () end do end function molecular_basis_num_basis_functions end module mqc_cgto","tags":"","url":"sourcefile/mqc_cgto.f90.html"},{"title":"mqc_result_types.f90 – metalquicha","text":"Quantum chemistry calculation result containers Files dependent on this one sourcefile~~mqc_result_types.f90~~AfferentGraph sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Quantum chemistry calculation result containers module mqc_result_types !! Defines data structures for storing and managing results from !! quantum chemistry calculations including energies, gradients, and properties. use pic_types , only : dp implicit none private public :: calculation_result_t !! Main result container type type :: calculation_result_t !! Container for quantum chemistry calculation results !! !! Stores computed quantities from QC calculations with flags !! indicating which properties have been computed. real ( dp ) :: energy = 0.0_dp !! Total electronic energy (Hartree) real ( dp ), allocatable :: gradient (:, :) !! Energy gradient (3, natoms) (Hartree/Bohr) real ( dp ), allocatable :: hessian (:, :) !! Energy hessian (future implementation) real ( dp ), allocatable :: dipole (:) !! Dipole moment vector (3) (Debye) ! Computation status flags logical :: has_energy = . false . !! Energy has been computed logical :: has_gradient = . false . !! Gradient has been computed logical :: has_hessian = . false . !! Hessian has been computed logical :: has_dipole = . false . !! Dipole moment has been computed contains procedure :: destroy => result_destroy !! Clean up allocated memory procedure :: reset => result_reset !! Reset all values and flags end type calculation_result_t contains subroutine result_destroy ( this ) !! Clean up allocated memory in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this if ( allocated ( this % gradient )) deallocate ( this % gradient ) if ( allocated ( this % hessian )) deallocate ( this % hessian ) if ( allocated ( this % dipole )) deallocate ( this % dipole ) call this % reset () end subroutine result_destroy subroutine result_reset ( this ) !! Reset all values and flags in calculation_result_t class ( calculation_result_t ), intent ( inout ) :: this this % energy = 0.0_dp this % has_energy = . false . this % has_gradient = . false . this % has_hessian = . false . this % has_dipole = . false . end subroutine result_reset end module mqc_result_types","tags":"","url":"sourcefile/mqc_result_types.f90.html"},{"title":"mqc_driver.f90 – metalquicha","text":"Main calculation driver module for metalquicha This file depends on sourcefile~~mqc_driver.f90~~EfferentGraph sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_input_parser.f90 mqc_input_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_input_parser.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_driver.f90~~AfferentGraph sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Main calculation driver module for metalquicha module mqc_driver !! Handles both fragmented (many-body expansion) and unfragmented calculations !! with MPI parallelization and node-based work distribution. use pic_types , only : int64 , dp use pic_mpi_lib , only : comm_t , abort_comm , bcast , allgather use pic_logger , only : logger => global_logger use pic_io , only : to_char use omp_lib , only : omp_get_max_threads , omp_set_num_threads use mqc_mbe_fragment_distribution_scheme , only : global_coordinator , node_coordinator , node_worker , unfragmented_calculation , & serial_fragment_processor use mqc_frag_utils , only : get_nfrags , create_monomer_list , generate_fragment_list use mqc_physical_fragment , only : system_geometry_t use mqc_input_parser , only : input_config_t implicit none private public :: run_calculation !! Main entry point for all calculations contains subroutine run_calculation ( world_comm , node_comm , config , sys_geom ) !! Main calculation dispatcher - routes to fragmented or unfragmented calculation !! !! Determines calculation type based on nlevel and dispatches to appropriate !! calculation routine with proper MPI setup and validation. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator type ( input_config_t ), intent ( in ) :: config !! Parsed input configuration type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info ! Local variables integer :: max_level !! Maximum fragment level (nlevel from config) integer :: matrix_size !! Size of gradient matrix (natoms*3), tmp ! Set max_level from config ! TODO JORGE: change to max fragmentation level max_level = config % nlevel ! Set matrix_size based on atoms per monomer (natoms * 3 for gradient) ! TODO JORGE: this is temporary, until we define a result_struct that will initialize itself matrix_size = sys_geom % atoms_per_monomer * 3 if ( world_comm % rank () == 0 ) then call logger % info ( \"============================================\" ) call logger % info ( \"Loaded geometry:\" ) call logger % info ( \"  Total monomers: \" // to_char ( sys_geom % n_monomers )) call logger % info ( \"  Atoms per monomer: \" // to_char ( sys_geom % atoms_per_monomer )) call logger % info ( \"  Total atoms: \" // to_char ( sys_geom % total_atoms )) call logger % info ( \"  Fragment level: \" // to_char ( max_level )) call logger % info ( \"  Matrix size (natoms*3): \" // to_char ( matrix_size )) call logger % info ( \"============================================\" ) end if if ( max_level == 0 ) then call omp_set_num_threads ( 1 ) call run_unfragmented_calculation ( world_comm , sys_geom , config % method ) else call run_fragmented_calculation ( world_comm , node_comm , config % method , sys_geom , max_level , & matrix_size ) end if end subroutine run_calculation subroutine run_unfragmented_calculation ( world_comm , sys_geom , method ) !! Handle unfragmented calculation (nlevel=0) !! !! Validates single MPI rank requirement and runs direct calculation !! on entire system using OpenMP for parallelization. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( system_geometry_t ), intent ( in ) :: sys_geom !! Complete system geometry character ( len =* ), intent ( in ) :: method !! Quantum chemistry method (gfn1/gfn2) ! Validate that only a single rank is used for unfragmented calculation ! (parallelism comes from OpenMP threads, not MPI ranks) if ( world_comm % size () > 1 ) then ! TODO JORGE: maybe don't fail? prune the extra ranks ? if ( world_comm % rank () == 0 ) then call logger % error ( \" \" ) call logger % error ( \"Unfragmented calculation (nlevel=0) requires exactly 1 MPI rank\" ) call logger % error ( \"  Parallelism is achieved through OpenMP threads, not MPI\" ) call logger % error ( \"  Current number of MPI ranks: \" // to_char ( world_comm % size ()) // \" (must be 1)\" ) call logger % error ( \" \" ) call logger % error ( \"Please run with a single MPI rank (e.g., mpirun -np 1 ...)\" ) call logger % error ( \"Use OMP_NUM_THREADS to control thread-level parallelism\" ) call logger % error ( \" \" ) end if call abort_comm ( world_comm , 1 ) end if if ( world_comm % rank () == 0 ) then call logger % info ( \" \" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \" \" ) call unfragmented_calculation ( sys_geom , method ) end if end subroutine run_unfragmented_calculation subroutine run_fragmented_calculation ( world_comm , node_comm , method , sys_geom , max_level , matrix_size ) !! Handle fragmented calculation (nlevel > 0) !! !! Generates fragments, distributes work across MPI processes organized in nodes, !! and coordinates many-body expansion calculation using hierarchical parallelism. type ( comm_t ), intent ( in ) :: world_comm !! Global MPI communicator type ( comm_t ), intent ( in ) :: node_comm !! Node-local MPI communicator character ( len =* ), intent ( in ) :: method !! Quantum chemistry method (gfn1/gfn2) type ( system_geometry_t ), intent ( in ) :: sys_geom !! System geometry and fragment info integer , intent ( in ) :: max_level !! Maximum fragment level for MBE integer , intent ( in ) :: matrix_size !! Size of gradient matrix (natoms*3) integer ( int64 ) :: total_fragments !! Total number of fragments generated (int64 to handle large systems) integer , allocatable :: polymers (:, :) !! Fragment composition array (fragment, monomer_indices) integer :: num_nodes !! Number of compute nodes integer :: i , j !! Loop counters integer , allocatable :: node_leader_ranks (:) !! Ranks of processes that lead each node integer , allocatable :: monomers (:) !! Temporary monomer list for fragment generation integer ( int64 ) :: n_expected_frags !! Expected number of fragments based on combinatorics (int64 to handle large systems) integer ( int64 ) :: n_rows !! Number of rows needed for polymers array (int64 to handle large systems) integer :: global_node_rank !! Global rank if this process leads a node, -1 otherwise integer , allocatable :: all_node_leader_ranks (:) !! Node leader status for all ranks ! Generate fragments if ( world_comm % rank () == 0 ) then ! Calculate expected number of fragments n_expected_frags = get_nfrags ( sys_geom % n_monomers , max_level ) n_rows = n_expected_frags ! Allocate monomer list and polymers array allocate ( monomers ( sys_geom % n_monomers )) allocate ( polymers ( n_rows , max_level )) polymers = 0 ! Create monomer list [1, 2, 3, ..., n_monomers] call create_monomer_list ( monomers ) ! Generate all fragments (includes monomers in polymers array) total_fragments = 0_int64 ! First add monomers do i = 1 , sys_geom % n_monomers total_fragments = total_fragments + 1_int64 polymers ( total_fragments , 1 ) = i end do ! Then add n-mers for n >= 2 call generate_fragment_list ( monomers , max_level , polymers , total_fragments ) deallocate ( monomers ) call logger % info ( \"Generated fragments:\" ) call logger % info ( \"  Total fragments: \" // to_char ( total_fragments )) call logger % info ( \"  Max level: \" // to_char ( max_level )) end if ! Broadcast total_fragments to all ranks call bcast ( world_comm , total_fragments , 1 , 0 ) ! Determine node leaders global_node_rank = - 1 if ( node_comm % rank () == 0 ) global_node_rank = world_comm % rank () allocate ( all_node_leader_ranks ( world_comm % size ())) call allgather ( world_comm , global_node_rank , all_node_leader_ranks ) num_nodes = count ( all_node_leader_ranks /= - 1 ) if ( world_comm % rank () == 0 ) then call logger % info ( \"Running with \" // to_char ( num_nodes ) // \" node(s)\" ) end if allocate ( node_leader_ranks ( num_nodes )) i = 0 do j = 1 , world_comm % size () if ( all_node_leader_ranks ( j ) /= - 1 ) then i = i + 1 node_leader_ranks ( i ) = all_node_leader_ranks ( j ) end if end do deallocate ( all_node_leader_ranks ) ! Execute appropriate role if ( world_comm % size () == 1 ) then ! Single rank: process fragments serially call logger % info ( \"Running in serial mode (single MPI rank)\" ) call serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method ) else if ( world_comm % leader () . and . node_comm % leader ()) then ! Global coordinator (rank 0, node leader on node 0) call omp_set_num_threads ( omp_get_max_threads ()) call logger % verbose ( \"Rank 0: Acting as global coordinator\" ) call global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes ) else if ( node_comm % leader ()) then ! Node coordinator (node leader on other nodes) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as node coordinator\" ) call node_coordinator ( world_comm , node_comm ) else ! Worker call omp_set_num_threads ( 1 ) call logger % verbose ( \"Rank \" // to_char ( world_comm % rank ()) // \": Acting as worker\" ) call node_worker ( world_comm , node_comm , sys_geom , method ) end if ! Cleanup if ( world_comm % rank () == 0 ) then if ( allocated ( polymers )) deallocate ( polymers ) if ( allocated ( node_leader_ranks )) deallocate ( node_leader_ranks ) end if end subroutine run_fragmented_calculation end module mqc_driver","tags":"","url":"sourcefile/mqc_driver.f90.html"},{"title":"mqc_method_xtb.f90 – metalquicha","text":"Extended Tight-Binding (xTB) quantum chemistry method implementation This file depends on sourcefile~~mqc_method_xtb.f90~~EfferentGraph sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_xtb.f90~~AfferentGraph sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Extended Tight-Binding (xTB) quantum chemistry method implementation module mqc_method_xtb !! Provides GFN1-xTB and GFN2-xTB methods via the tblite library, !! implementing the abstract method interface for energy and gradient calculations. use pic_types , only : dp use mqc_method_base , only : qc_method_t use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t ! tblite imports (reuse from mqc_mbe) use mctc_env , only : wp , error_type use mctc_io , only : structure_type , new use tblite_context_type , only : context_type use tblite_wavefunction , only : wavefunction_type , new_wavefunction use tblite_xtb_calculator , only : xtb_calculator use tblite_xtb_gfn1 , only : new_gfn1_calculator use tblite_xtb_gfn2 , only : new_gfn2_calculator use tblite_xtb_singlepoint , only : xtb_singlepoint implicit none private public :: xtb_method_t !! XTB method implementation type type , extends ( qc_method_t ) :: xtb_method_t !! Extended Tight-Binding (xTB) method implementation !! !! Concrete implementation of the abstract quantum chemistry method !! interface for GFN1-xTB and GFN2-xTB calculations via tblite. character ( len = :), allocatable :: variant !! XTB variant: \"gfn1\" or \"gfn2\" logical :: verbose = . false . !! Print calculation details real ( wp ) :: accuracy = 0.01_wp !! Numerical accuracy parameter real ( wp ) :: kt = 30 0.0_wp * 3.166808578545117e-06_wp !! Electronic temperature (300 K) contains procedure :: calc_energy => xtb_calc_energy !! Energy-only calculation procedure :: calc_gradient => xtb_calc_gradient !! Energy + gradient calculation end type xtb_method_t contains subroutine xtb_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! tblite calculation variables type ( error_type ), allocatable :: error type ( structure_type ) :: mol real ( wp ), allocatable :: xyz (:, :) integer , allocatable :: num (:) type ( xtb_calculator ) :: calc type ( wavefunction_type ) :: wfn real ( wp ) :: energy type ( context_type ) :: ctx integer :: verbosity if ( this % verbose ) then print * , \"XTB: Calculating energy using \" , this % variant print * , \"XTB: Fragment has\" , fragment % n_atoms , \"atoms\" print * , \"XTB: nelec =\" , fragment % nelec print * , \"XTB: charge =\" , fragment % charge end if ! Convert fragment to tblite format allocate ( num ( fragment % n_atoms )) allocate ( xyz ( 3 , fragment % n_atoms )) num = fragment % element_numbers xyz = fragment % coordinates ! Already in Bohr ! Create molecular structure ! charge is real(wp), multiplicity converted to uhf (unpaired electrons) call new ( mol , num , xyz , charge = real ( fragment % charge , wp ), & uhf = fragment % multiplicity - 1 ) ! Select and create appropriate GFN calculator select case ( this % variant ) case ( \"gfn1\" ) call new_gfn1_calculator ( calc , mol , error ) case ( \"gfn2\" ) call new_gfn2_calculator ( calc , mol , error ) case default error stop \"Unknown XTB variant: \" // this % variant end select if ( allocated ( error )) then error stop \"Failed to create XTB calculator\" end if ! Create wavefunction and run single point calculation call new_wavefunction ( wfn , mol % nat , calc % bas % nsh , calc % bas % nao , 1 , this % kt ) energy = 0.0_wp verbosity = merge ( 1 , 0 , this % verbose ) call xtb_singlepoint ( ctx , mol , calc , wfn , this % accuracy , energy , verbosity = verbosity ) ! Store result result % energy = real ( energy , dp ) result % has_energy = . true . if ( this % verbose ) then print * , \"XTB: Energy =\" , result % energy end if deallocate ( num , xyz ) end subroutine xtb_calc_energy subroutine xtb_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Extended Tight-Binding (xTB) method class ( xtb_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! TODO: Implement gradient calculation using tblite ! For now, just get energy and return zero gradient if ( this % verbose ) then print * , \"XTB: Calculating gradient using \" , this % variant end if ! First get energy call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient (TODO: get real gradient from tblite) allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . if ( this % verbose ) then print * , \"XTB: Gradient calculation complete (dummy for now)\" end if end subroutine xtb_calc_gradient end module mqc_method_xtb","tags":"","url":"sourcefile/mqc_method_xtb.f90.html"},{"title":"mqc_basis_file_reader.f90 – metalquicha","text":"this file contains the modules and routines to open and read a GAMESS formatted basis set file Files dependent on this one sourcefile~~mqc_basis_file_reader.f90~~AfferentGraph sourcefile~mqc_basis_file_reader.f90 mqc_basis_file_reader.f90 sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_basis_file_reader.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this file contains the modules and routines to open and read a GAMESS formatted basis set file module mqc_basis_file_reader !! Module for reading and parsing GAMESS formatted basis set files use pic_types , only : int32 , dp implicit none private public :: basis_file_t , open_basis_file , extract_element , strings_equal type :: basis_file_t !! Container for basis set file contents character ( len = :), allocatable :: full_content character ( len = :), allocatable :: data_section end type basis_file_t contains subroutine open_basis_file ( basis_file , filename ) !! Open and read a GAMESS formatted basis set file type ( basis_file_t ), intent ( out ) :: basis_file character ( len =* ), intent ( in ) :: filename integer :: unit , iostat , file_size logical :: file_exists integer :: data_start , data_end ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then error stop \"Basis set file not found: \" // filename end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: basis_file % full_content ) ! Open and read entire file open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = iostat ) if ( iostat /= 0 ) error stop \"Error opening file: \" // filename read ( unit , iostat = iostat ) basis_file % full_content if ( iostat /= 0 ) error stop \"Error reading file: \" // filename close ( unit ) ! Extract the $DATA section data_start = index ( basis_file % full_content , \"$DATA\" ) if ( data_start == 0 ) then error stop \"Could not find $DATA section in basis set file\" end if data_end = index ( basis_file % full_content ( data_start :), \"$END\" ) if ( data_end == 0 ) then error stop \"Could not find $END marker in basis set file\" end if ! Store just the data section (between $DATA and $END) basis_file % data_section = basis_file % full_content ( data_start + 5 : data_start + data_end - 2 ) end subroutine open_basis_file function extract_element ( basis_file , element ) result ( element_content ) !! Extract the basis set data for a specific element from the basis file type ( basis_file_t ), intent ( in ) :: basis_file character ( len =* ), intent ( in ) :: element character ( len = :), allocatable :: element_content integer :: start_pos , end_pos , i character ( len = :), allocatable :: search_element logical :: at_line_start ! Convert element to uppercase for searching search_element = uppercase ( trim ( element )) ! Find the element name (it appears on its own line) start_pos = index ( basis_file % data_section , new_line ( 'a' ) // trim ( search_element ) // new_line ( 'a' )) if ( start_pos == 0 ) then ! Try without leading newline (might be first element after $DATA) if ( index ( basis_file % data_section , trim ( search_element ) // new_line ( 'a' )) == 1 ) then start_pos = 1 else error stop \"Element not found in basis set file: \" // element end if else start_pos = start_pos + 1 ! Skip the leading newline end if ! Find the next element by looking for a line that: ! - Starts with an uppercase letter ! - Has a second character that is also a letter (not a space or number) ! This distinguishes \"CARBON\" from \"S   3\" end_pos = len ( basis_file % data_section ) at_line_start = . false . i = start_pos + len ( search_element ) + 1 do while ( i < len ( basis_file % data_section )) if ( basis_file % data_section ( i : i ) == new_line ( 'a' )) then at_line_start = . true . i = i + 1 cycle end if if ( at_line_start ) then ! We're at the start of a new line if ( is_uppercase_letter ( basis_file % data_section ( i : i ))) then ! Check if next character is also a letter if ( i + 1 <= len ( basis_file % data_section )) then if ( is_letter ( basis_file % data_section ( i + 1 : i + 1 ))) then ! Found next element! end_pos = i - 1 exit end if end if end if at_line_start = . false . end if i = i + 1 end do ! Extract the section element_content = basis_file % data_section ( start_pos : end_pos ) end function extract_element pure function is_letter ( c ) result ( is_alpha ) !! Check if character is a letter (A-Z or a-z) character ( len = 1 ), intent ( in ) :: c logical :: is_alpha integer :: ic ic = iachar ( c ) is_alpha = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) . or . & ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) end function is_letter pure function uppercase ( str ) result ( upper ) !! Convert a string to uppercase, should use pic_ascii! character ( len =* ), intent ( in ) :: str character ( len = :), allocatable :: upper integer :: i , ic allocate ( character ( len = len ( str )) :: upper ) upper = str do i = 1 , len ( str ) ic = iachar ( str ( i : i )) if ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) then upper ( i : i ) = achar ( ic - 32 ) end if end do end function uppercase pure function is_uppercase_letter ( c ) result ( is_upper ) !! Check if character is an uppercase letter (A-Z) character ( len = 1 ), intent ( in ) :: c logical :: is_upper integer :: ic ic = iachar ( c ) is_upper = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) end function is_uppercase_letter !> Compare two strings after trimming and adjusting (removing leading/trailing whitespace) pure function strings_equal ( str1 , str2 ) result ( equal ) !! Compare two strings for equality after trimming and adjusting (removing leading/trailing whitespace) character ( len =* ), intent ( in ) :: str1 , str2 logical :: equal equal = trim ( adjustl ( str1 )) == trim ( adjustl ( str2 )) end function strings_equal end module mqc_basis_file_reader","tags":"","url":"sourcefile/mqc_basis_file_reader.f90.html"},{"title":"mqc_cli_parser.f90 – metalquicha","text":"Command line argument parsing for metalquicha Source Code !! Command line argument parsing for metalquicha module mqc_cli_parser !! Handles parsing of command line options including geometry files, !! basis set specifications, and help/usage display. implicit none private public :: cli_args_type !! Parsed command line arguments container public :: parse_command_line !! Main argument parsing routine public :: print_usage !! Display program usage information public :: normalize_basis_name !! Standardize basis set names public :: find_basis_file !! Locate basis set files type :: cli_args_type !! Container for parsed command line arguments !! !! Stores file paths and options extracted from command line, !! with automatic memory management for string allocations. character ( len = :), allocatable :: xyz_file !! Input XYZ geometry file path character ( len = :), allocatable :: basis_name !! Basis set name (e.g., \"6-31G\") contains procedure :: destroy => cli_args_destroy !! Memory cleanup end type cli_args_type contains subroutine parse_command_line ( args , stat , errmsg ) !! Parse command line arguments for geometry file and basis set !! !! Extracts XYZ file path and basis set name from command line, !! validates arguments, and handles help requests. type ( cli_args_type ), intent ( out ) :: args !! Parsed argument container integer , intent ( out ) :: stat !! Status (0=success, >0=error) character ( len = :), allocatable , intent ( out ) :: errmsg !! Error message integer :: nargs !! Number of command line arguments character ( len = 256 ) :: arg_buffer !! Temporary argument buffer integer :: arg_len !! Length of current argument stat = 0 ! Get number of command line arguments nargs = command_argument_count () ! Check for help flag if ( nargs >= 1 ) then call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then errmsg = \"Error reading command line argument 1\" return end if arg_buffer = trim ( arg_buffer ) if ( arg_buffer == \"-h\" . or . arg_buffer == \"--help\" ) then call print_usage () stat = - 1 ! Special code to indicate help was requested return end if end if ! Validate number of arguments if ( nargs < 2 ) then stat = 1 errmsg = \"Error: Insufficient arguments. Expected 2 arguments (geometry.xyz basis_name)\" call print_usage () return end if if ( nargs > 2 ) then stat = 1 errmsg = \"Error: Too many arguments. Expected 2 arguments (geometry.xyz basis_name)\" call print_usage () return end if ! Parse argument 1: XYZ file call get_command_argument ( 1 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then errmsg = \"Error reading geometry file argument\" return end if args % xyz_file = trim ( arg_buffer ) ! Parse argument 2: Basis set name call get_command_argument ( 2 , arg_buffer , arg_len , stat ) if ( stat /= 0 ) then errmsg = \"Error reading basis set name argument\" return end if args % basis_name = trim ( arg_buffer ) ! Reset stat to success stat = 0 end subroutine parse_command_line !> Print usage information subroutine print_usage () character ( len = 256 ) :: prog_name integer :: stat call get_command_argument ( 0 , prog_name , status = stat ) if ( stat /= 0 ) prog_name = \"pic_basis_reader\" print * print * , \"Usage: \" , trim ( prog_name ), \" <geometry.xyz> <basis_name>\" print * print * , \"Arguments:\" print * , \"  geometry.xyz   XYZ format molecular geometry file\" print * , \"  basis_name     Name of basis set (e.g., 6-31G, 6-311G**)\" print * print * , \"Options:\" print * , \"  -h, --help     Show this help message\" print * print * , \"Example:\" print * , \"  \" , trim ( prog_name ), \" water.xyz 6-31G\" print * end subroutine print_usage !> Clean up CLI args subroutine cli_args_destroy ( this ) class ( cli_args_type ), intent ( inout ) :: this if ( allocated ( this % xyz_file )) deallocate ( this % xyz_file ) if ( allocated ( this % basis_name )) deallocate ( this % basis_name ) end subroutine cli_args_destroy !> Normalize basis set name to filename-safe format !! Rules: * -> s, + -> p, remove parentheses and their contents !! Examples: !!   6-31G*      -> 6-31Gs !!   6-31+G*     -> 6-31pGs !!   6-31G(d)    -> 6-31Gd !!   6-311G(d,p) -> 6-31Gdp !!   6-311++G**  -> 6-311ppGss function normalize_basis_name ( basis_name ) result ( normalized ) character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable :: normalized integer :: i , out_pos character ( len = 256 ) :: buffer logical :: in_parens buffer = \"\" out_pos = 0 in_parens = . false . do i = 1 , len_trim ( basis_name ) select case ( basis_name ( i : i )) case ( '*' ) ! Star becomes 's' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 's' case ( '+' ) ! Plus becomes 'p' out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = 'p' case ( '(' ) ! Start of parentheses - we'll extract contents in_parens = . true . case ( ')' ) ! End of parentheses in_parens = . false . case ( ',' , ' ' ) ! Skip commas and spaces inside parentheses if ( in_parens ) cycle ! Keep them outside parentheses out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = basis_name ( i : i ) case default ! Copy character as-is out_pos = out_pos + 1 buffer ( out_pos : out_pos ) = basis_name ( i : i ) end select end do normalized = trim ( buffer ( 1 : out_pos )) end function normalize_basis_name !> Find basis file, trying multiple name variants !! Searches in: !!   1. basis_sets/ subdirectory !!   2. Current directory !! Tries name variants: !!   1. Exact name as given !!   2. Normalized name (with * -> s, + -> p, etc.) !!   3. Common synonyms subroutine find_basis_file ( basis_name , filename , stat , errmsg ) character ( len =* ), intent ( in ) :: basis_name character ( len = :), allocatable , intent ( out ) :: filename integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg character ( len = :), allocatable :: normalized logical :: file_exists integer :: i , j character ( len = 256 ), dimension ( 10 ) :: variants integer :: nvariants character ( len = 256 ) :: test_path character ( len = 256 ), dimension ( 2 ) :: search_dirs stat = 0 nvariants = 0 ! Define search directories (in order of priority) search_dirs ( 1 ) = \"basis_sets/\" search_dirs ( 2 ) = \"\" ! Current directory ! Variant 1: Exact name nvariants = nvariants + 1 variants ( nvariants ) = trim ( basis_name ) // \".txt\" ! Variant 2: Normalized name normalized = normalize_basis_name ( basis_name ) if ( trim ( normalized ) /= trim ( basis_name )) then nvariants = nvariants + 1 variants ( nvariants ) = trim ( normalized ) // \".txt\" end if ! Variant 3: Common synonyms ! 6-31G* = 6-31G(d) if ( trim ( basis_name ) == \"6-31G*\" . or . trim ( basis_name ) == \"6-31G(d)\" ) then nvariants = nvariants + 1 variants ( nvariants ) = \"6-31Gs.txt\" nvariants = nvariants + 1 variants ( nvariants ) = \"6-31Gd.txt\" end if ! 6-31G** = 6-31G(d,p) if ( trim ( basis_name ) == \"6-31G**\" . or . trim ( basis_name ) == \"6-31G(d,p)\" ) then nvariants = nvariants + 1 variants ( nvariants ) = \"6-31Gss.txt\" nvariants = nvariants + 1 variants ( nvariants ) = \"6-31Gdp.txt\" end if ! 6-311G* = 6-311G(d) if ( trim ( basis_name ) == \"6-311G*\" . or . trim ( basis_name ) == \"6-311G(d)\" ) then nvariants = nvariants + 1 variants ( nvariants ) = \"6-311Gs.txt\" nvariants = nvariants + 1 variants ( nvariants ) = \"6-311Gd.txt\" end if ! Try each directory with each variant do j = 1 , 2 do i = 1 , nvariants test_path = trim ( search_dirs ( j )) // trim ( variants ( i )) inquire ( file = trim ( test_path ), exist = file_exists ) if ( file_exists ) then filename = trim ( test_path ) return end if end do end do ! None found - return error with all paths tried stat = 1 errmsg = \"Basis set file not found. Tried: \" do j = 1 , 2 do i = 1 , nvariants test_path = trim ( search_dirs ( j )) // trim ( variants ( i )) if ( i == 1 . and . j == 1 ) then errmsg = errmsg // trim ( test_path ) else errmsg = errmsg // \", \" // trim ( test_path ) end if end do end do end subroutine find_basis_file end module mqc_cli_parser","tags":"","url":"sourcefile/mqc_cli_parser.f90.html"},{"title":"mqc_xyz_reader.f90 – metalquicha","text":"XYZ molecular geometry file reader This file depends on sourcefile~~mqc_xyz_reader.f90~~EfferentGraph sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_xyz_reader.f90~~AfferentGraph sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! XYZ molecular geometry file reader module mqc_xyz_reader !! Provides functions to parse standard XYZ format files containing !! atomic coordinates and element symbols for molecular structures. use pic_types , only : dp use mqc_geometry , only : geometry_type implicit none private public :: read_xyz_file !! Read XYZ file from disk public :: read_xyz_string !! Parse XYZ data from string public :: split_lines !! Split text into lines (for testing) ! Constants integer , parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 !! Maximum element symbol length contains subroutine read_xyz_file ( filename , geom , stat , errmsg ) !! Read molecular geometry from XYZ format file !! !! Parses standard XYZ files with format: !! Line 1: Number of atoms !! Line 2: Comment/title line !! Lines 3+: Element X Y Z (coordinates in Angstrom) character ( len =* ), intent ( in ) :: filename !! Path to XYZ file type ( geometry_type ), intent ( out ) :: geom !! Parsed molecular geometry integer , intent ( out ) :: stat !! Status (0=success, >0=error) character ( len = :), allocatable , intent ( out ) :: errmsg !! Error message integer :: unit !! File unit number integer :: io_stat !! I/O operation status integer :: file_size !! File size in bytes logical :: file_exists !! Whether file exists on disk character ( len = :), allocatable :: file_contents !! Full file content buffer stat = 0 ! Check if file exists inquire ( file = filename , exist = file_exists , size = file_size ) if (. not . file_exists ) then stat = 1 errmsg = \"XYZ file not found: \" // trim ( filename ) return end if ! Allocate buffer for entire file allocate ( character ( len = file_size ) :: file_contents ) ! Open and read entire file as stream open ( newunit = unit , file = filename , status = 'old' , action = 'read' , & access = 'stream' , form = 'unformatted' , iostat = io_stat ) if ( io_stat /= 0 ) then stat = io_stat errmsg = \"Error opening file: \" // trim ( filename ) return end if read ( unit , iostat = io_stat ) file_contents close ( unit ) if ( io_stat /= 0 ) then stat = io_stat errmsg = \"Error reading file: \" // trim ( filename ) return end if ! Parse the contents call read_xyz_string ( file_contents , geom , stat , errmsg ) end subroutine read_xyz_file pure subroutine read_xyz_string ( xyz_string , geom , stat , errmsg ) !! Parse molecular geometry from XYZ format string character ( len =* ), intent ( in ) :: xyz_string type ( geometry_type ), intent ( out ) :: geom integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg character ( len = :), allocatable :: lines (:) integer :: nlines , iatom , io_stat character ( len = 256 ) :: element real ( dp ) :: x , y , z stat = 0 ! Split into lines call split_lines ( xyz_string , lines , nlines ) if ( nlines < 2 ) then stat = 1 errmsg = \"XYZ file must have at least 2 lines (natoms + comment)\" return end if ! Read number of atoms from first line read ( lines ( 1 ), * , iostat = io_stat ) geom % natoms if ( io_stat /= 0 ) then stat = 1 errmsg = \"Failed to read number of atoms from first line\" return end if if ( geom % natoms < 0 ) then stat = 1 errmsg = \"Number of atoms must be non-negative\" return end if ! Store comment line geom % comment = trim ( adjustl ( lines ( 2 ))) ! Check we have enough lines if ( nlines < 2 + geom % natoms ) then stat = 1 errmsg = \"XYZ file has insufficient lines: expected \" // & trim ( int_to_string ( 2 + geom % natoms )) // \", got \" // & trim ( int_to_string ( nlines )) return end if ! Allocate arrays allocate ( character ( len = MAX_ELEMENT_SYMBOL_LEN ) :: geom % elements ( geom % natoms )) allocate ( geom % coords ( 3 , geom % natoms )) ! Read atom data do iatom = 1 , geom % natoms read ( lines ( 2 + iatom ), * , iostat = io_stat ) element , x , y , z if ( io_stat /= 0 ) then stat = 1 errmsg = \"Failed to parse atom data on line \" // & trim ( int_to_string ( 2 + iatom )) // \": '\" // & trim ( lines ( 2 + iatom )) // \"'\" return end if geom % elements ( iatom ) = trim ( adjustl ( element )) geom % coords ( 1 , iatom ) = x geom % coords ( 2 , iatom ) = y geom % coords ( 3 , iatom ) = z end do end subroutine read_xyz_string pure function int_to_string ( i ) result ( str ) !! Convert integer to string integer , intent ( in ) :: i character ( len = :), allocatable :: str character ( len = 20 ) :: buffer write ( buffer , '(I0)' ) i str = trim ( adjustl ( buffer )) end function int_to_string pure subroutine split_lines ( text , lines , nlines ) !! Split input text into lines based on CR, LF, or CRLF line endings !! Trailing newlines do not create empty lines character ( len =* ), intent ( in ) :: text character ( len = :), allocatable , intent ( out ) :: lines (:) integer , intent ( out ) :: nlines integer :: i , line_start , line_end , max_line_len character ( len = :), allocatable :: temp_lines (:) if ( len ( text ) == 0 ) then nlines = 0 allocate ( character ( len = 1 ) :: lines ( 0 )) return end if ! Pass 1: Count lines and find maximum line length nlines = 0 max_line_len = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 ! Skip both CR and LF else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 max_line_len = max ( max_line_len , line_end - line_start + 1 ) i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 max_line_len = max ( max_line_len , len ( text ) - line_start + 1 ) end if ! Handle empty text or ensure at least length 1 if ( max_line_len == 0 ) max_line_len = 1 ! Allocate output array allocate ( character ( len = max_line_len ) :: temp_lines ( nlines )) ! Pass 2: Extract lines nlines = 0 line_start = 1 i = 1 do while ( i <= len ( text )) ! Check for line ending if ( text ( i : i ) == achar ( 13 )) then ! CR ! Check for CRLF if ( i < len ( text ) . and . text ( i + 1 : i + 1 ) == achar ( 10 )) then line_end = i - 1 i = i + 2 else line_end = i - 1 i = i + 1 end if nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if line_start = i else if ( text ( i : i ) == achar ( 10 )) then ! LF line_end = i - 1 nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying if ( line_end >= line_start ) then ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = line_end - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if i = i + 1 line_start = i else i = i + 1 end if end do ! Handle last line if text doesn't end with newline if ( line_start <= len ( text )) then nlines = nlines + 1 temp_lines ( nlines ) = \"\" ! Initialize line before copying ! Intel compiler workaround: use character-by-character copy block integer :: j , line_len line_len = len ( text ) - line_start + 1 do j = 1 , line_len temp_lines ( nlines ) ( j : j ) = text ( line_start + j - 1 : line_start + j - 1 ) end do end block end if ! Copy to output (use explicit loop for Intel compiler compatibility) allocate ( character ( len = max_line_len ) :: lines ( nlines )) block integer :: iline do iline = 1 , nlines lines ( iline ) = temp_lines ( iline ) end do end block end subroutine split_lines end module mqc_xyz_reader","tags":"","url":"sourcefile/mqc_xyz_reader.f90.html"},{"title":"mqc_geometry.f90 – metalquicha","text":"Geometry data structure for molecular systems Files dependent on this one sourcefile~~mqc_geometry.f90~~AfferentGraph sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Geometry data structure for molecular systems module mqc_geometry !! Defines the geometry data structure for molecular systems use pic_types , only : dp implicit none private public :: geometry_type ! Parameters integer , parameter :: MAX_ELEMENT_SYMBOL_LEN = 4 type :: geometry_type !! Molecular geometry data structure integer :: natoms character ( len = :), allocatable :: elements (:) real ( dp ), allocatable :: coords (:, :) ! coords(3, natoms) character ( len = :), allocatable :: comment contains procedure :: destroy => geometry_destroy end type geometry_type contains subroutine geometry_destroy ( this ) !! Clean up allocated memory in geometry_type class ( geometry_type ), intent ( inout ) :: this if ( allocated ( this % elements )) deallocate ( this % elements ) if ( allocated ( this % coords )) deallocate ( this % coords ) if ( allocated ( this % comment )) deallocate ( this % comment ) this % natoms = 0 end subroutine geometry_destroy end module mqc_geometry","tags":"","url":"sourcefile/mqc_geometry.f90.html"},{"title":"mqc_mpi_tags.f90 – metalquicha","text":"contains MPI tags used in the MQC parallel implementation Files dependent on this one sourcefile~~mqc_mpi_tags.f90~~AfferentGraph sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! contains MPI tags used in the MQC parallel implementation module mqc_mpi_tags !! Module defining MPI communication tags for clarity and maintainability use pic_types , only : default_int implicit none private ! Local worker communication tags (shared memory within a node) integer ( default_int ), parameter , public :: TAG_WORKER_REQUEST = 200 !! Worker requests work from node coordinator integer ( default_int ), parameter , public :: TAG_WORKER_FRAGMENT = 201 !! Coordinator sends fragment data to worker integer ( default_int ), parameter , public :: TAG_WORKER_FINISH = 202 !! Coordinator signals worker to finish integer ( default_int ), parameter , public :: TAG_WORKER_SCALAR_RESULT = 203 !! Worker sends scalar results back to coordinator integer ( default_int ), parameter , public :: TAG_WORKER_MATRIX_RESULT = 204 !! Worker sends matrix results back to coordinator ! Remote node communication tags (between nodes via world communicator) integer ( default_int ), parameter , public :: TAG_NODE_REQUEST = 300 !! Node coordinator requests work from global coordinator integer ( default_int ), parameter , public :: TAG_NODE_FRAGMENT = 301 !! Global coordinator sends fragment data to node coordinator integer ( default_int ), parameter , public :: TAG_NODE_FINISH = 302 !! Global coordinator signals node coordinator to finish integer ( default_int ), parameter , public :: TAG_NODE_SCALAR_RESULT = 303 !! Node coordinator sends results (fragment_idx + scalar) to global coordinator integer ( default_int ), parameter , public :: TAG_NODE_MATRIX_RESULT = 304 !! Node coordinator sends matrix results to global coordinator end module mqc_mpi_tags","tags":"","url":"sourcefile/mqc_mpi_tags.f90.html"},{"title":"mqc_mbe_io.f90 – metalquicha","text":"This file depends on sourcefile~~mqc_mbe_io.f90~~EfferentGraph sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe_io.f90~~AfferentGraph sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module mqc_mbe_io use pic_types , only : int32 , int64 , dp use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_physical_fragment , only : physical_fragment_t , to_angstrom use mqc_elements , only : element_number_to_symbol implicit none private public :: print_fragment_xyz , print_detailed_breakdown , print_detailed_breakdown_json contains function get_frag_level_name ( frag_level ) result ( level_name ) !! Map body level (n-mer) to descriptive name !! Supports up to decamers (10-mers), then falls back to \"N-mers\" format integer , intent ( in ) :: frag_level character ( len = 32 ) :: level_name select case ( frag_level ) case ( 1 ) level_name = \"monomers\" case ( 2 ) level_name = \"dimers\" case ( 3 ) level_name = \"trimers\" case ( 4 ) level_name = \"tetramers\" case ( 5 ) level_name = \"pentamers\" case ( 6 ) level_name = \"hexamers\" case ( 7 ) level_name = \"heptamers\" case ( 8 ) level_name = \"octamers\" case ( 9 ) level_name = \"nonamers\" case ( 10 ) level_name = \"decamers\" case default ! For levels > 10, use generic format write ( level_name , '(i0,a)' ) frag_level , \"-mers\" end select end function get_frag_level_name subroutine print_fragment_xyz ( fragment_idx , phys_frag ) !! Print fragment geometry in XYZ format integer , intent ( in ) :: fragment_idx type ( physical_fragment_t ), intent ( in ) :: phys_frag integer :: i character ( len = 2 ) :: symbol character ( len = 256 ) :: coord_line call logger % info ( \"=========================================\" ) call logger % info ( \" Fragment \" // to_char ( fragment_idx )) call logger % info ( \" Number of atoms: \" // to_char ( phys_frag % n_atoms )) call logger % info ( \" Coordinates in Angstroms:\" ) call logger % info ( \"-----------------------------------------\" ) do i = 1 , phys_frag % n_atoms symbol = element_number_to_symbol ( phys_frag % element_numbers ( i )) ! Convert from Bohr back to Angstroms for printing write ( coord_line , '(a2,3f15.8)' ) symbol , to_angstrom ( phys_frag % coordinates ( 1 : 3 , i )) call logger % info ( trim ( coord_line )) end do call logger % info ( \"=========================================\" ) end subroutine print_fragment_xyz subroutine print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) !! Print detailed energy breakdown for each fragment !! Shows full energy and deltaE correction for all monomers, dimers, trimers, etc. !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) integer ( int64 ) :: i integer :: fragment_size , j , frag_level character ( len = 512 ) :: fragment_str , energy_line integer ( int64 ) :: count_by_level call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) call logger % verbose ( \"Detailed Energy Breakdown by Fragment\" ) call logger % verbose ( \"============================================\" ) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). Using generic N-mers notation.\" ) end if do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then call logger % verbose ( \" \" ) block character ( len = 256 ) :: header character ( len = 32 ) :: level_name level_name = get_frag_level_name ( frag_level ) write ( header , '(a,a,i0,a)' ) trim ( level_name ), \" (\" , count_by_level , \" fragments):\" ! Capitalize first letter if ( len_trim ( level_name ) > 0 ) then if ( level_name ( 1 : 1 ) >= 'a' . and . level_name ( 1 : 1 ) <= 'z' ) then header ( 1 : 1 ) = achar ( iachar ( header ( 1 : 1 )) - 32 ) end if end if call logger % verbose ( trim ( header )) end block call logger % verbose ( \"--------------------------------------------\" ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then fragment_str = \"[\" do j = 1 , fragment_size if ( j > 1 ) then write ( fragment_str , '(a,a,i0)' ) trim ( fragment_str ), \",\" , polymers ( i , j ) else write ( fragment_str , '(a,i0)' ) trim ( fragment_str ), polymers ( i , j ) end if end do write ( fragment_str , '(a,a)' ) trim ( fragment_str ), \"]\" if ( frag_level == 1 ) then write ( energy_line , '(a,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ) else write ( energy_line , '(a,a,f20.10,a,f20.10)' ) & \"  Fragment \" , trim ( adjustl ( fragment_str )), energies ( i ), & \"   deltaE: \" , delta_energies ( i ) end if call logger % verbose ( trim ( energy_line )) end if end do end if end do call logger % verbose ( \" \" ) call logger % verbose ( \"============================================\" ) end subroutine print_detailed_breakdown subroutine print_detailed_breakdown_json ( polymers , fragment_count , max_level , & energies , delta_energies , sum_by_level , total_energy ) !! Write detailed energy breakdown to results.json file !! Outputs structured JSON with all fragment energies and deltaE corrections !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. integer , intent ( in ) :: polymers (:, :), max_level integer ( int64 ), intent ( in ) :: fragment_count real ( dp ), intent ( in ) :: energies (:), delta_energies (:) real ( dp ), intent ( in ) :: sum_by_level (:), total_energy integer ( int64 ) :: i integer :: fragment_size , j , frag_level , unit , io_stat character ( len = 512 ) :: json_line integer ( int64 ) :: count_by_level logical :: first_level , first_fragment character ( len = 32 ) :: level_name open ( newunit = unit , file = 'results.json' , status = 'replace' , action = 'write' , iostat = io_stat ) if ( io_stat /= 0 ) then call logger % error ( \"Failed to open results.json for writing\" ) return end if call logger % info ( \"Writing JSON output to results.json\" ) ! Warn if we have very high fragmentation levels if ( max_level > 10 ) then call logger % warning ( \"Fragment levels exceed decamers (10-mers). JSON will use generic N-mers notation.\" ) end if write ( unit , '(a)' ) \"{\" write ( unit , '(a)' ) '  \"mbe_breakdown\": {' write ( json_line , '(a,f20.10,a)' ) '    \"total_energy\": ' , total_energy , ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '    \"levels\": [' first_level = . true . do frag_level = 1 , max_level count_by_level = 0_int64 do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) count_by_level = count_by_level + 1_int64 end do if ( count_by_level > 0_int64 ) then if (. not . first_level ) then write ( unit , '(a)' ) '      },' end if first_level = . false . write ( unit , '(a)' ) '      {' level_name = get_frag_level_name ( frag_level ) write ( json_line , '(a,i0,a)' ) '        \"frag_level\": ' , frag_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,a,a)' ) '        \"name\": \"' , trim ( level_name ), '\",' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,i0,a)' ) '        \"count\": ' , count_by_level , ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10,a)' ) '        \"total_energy\": ' , sum_by_level ( frag_level ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( unit , '(a)' ) '        \"fragments\": [' first_fragment = . true . do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == frag_level ) then if (. not . first_fragment ) then write ( unit , '(a)' ) '          },' end if first_fragment = . false . write ( unit , '(a)' ) '          {' json_line = '            \"indices\": [' do j = 1 , fragment_size if ( j > 1 ) then write ( json_line , '(a,a,i0)' ) trim ( json_line ), ', ' , polymers ( i , j ) else write ( json_line , '(a,i0)' ) trim ( json_line ), polymers ( i , j ) end if end do write ( json_line , '(a,a)' ) trim ( json_line ), '],' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '            \"energy\": ' , energies ( i ) if ( frag_level > 1 ) then write ( json_line , '(a,a)' ) trim ( json_line ), ',' write ( unit , '(a)' ) trim ( json_line ) write ( json_line , '(a,f20.10)' ) '            \"delta_energy\": ' , delta_energies ( i ) end if write ( unit , '(a)' ) trim ( json_line ) end if end do if (. not . first_fragment ) then write ( unit , '(a)' ) '          }' end if write ( unit , '(a)' ) '        ]' end if end do if (. not . first_level ) then write ( unit , '(a)' ) '      }' end if write ( unit , '(a)' ) '    ]' write ( unit , '(a)' ) '  }' write ( unit , '(a)' ) '}' close ( unit ) call logger % info ( \"JSON output written successfully to results.json\" ) end subroutine print_detailed_breakdown_json end module mqc_mbe_io","tags":"","url":"sourcefile/mqc_mbe_io.f90.html"},{"title":"mqc_mbe_fragment_distribution_scheme.F90 – metalquicha","text":"Many-Body Expansion (MBE) calculation module This file depends on sourcefile~~mqc_mbe_fragment_distribution_scheme.f90~~EfferentGraph sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe_fragment_distribution_scheme.f90~~AfferentGraph sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Many-Body Expansion (MBE) calculation module module mqc_mbe_fragment_distribution_scheme !! Implements hierarchical many-body expansion for fragment-based quantum chemistry !! calculations with MPI parallelization and energy/gradient computation. use pic_types , only : int32 , int64 , dp use pic_timer , only : timer_type use pic_blas_interfaces , only : pic_gemm , pic_dot use pic_mpi_lib , only : comm_t , send , recv , isend , irecv , wait , iprobe , MPI_Status , request_t , MPI_ANY_SOURCE , MPI_ANY_TAG use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_mbe_io , only : print_fragment_xyz use omp_lib , only : omp_set_num_threads , omp_get_max_threads use mqc_mbe , only : compute_mbe_energy use mqc_mpi_tags , only : TAG_WORKER_REQUEST , TAG_WORKER_FRAGMENT , TAG_WORKER_FINISH , & TAG_WORKER_SCALAR_RESULT , & TAG_NODE_REQUEST , TAG_NODE_FRAGMENT , TAG_NODE_FINISH , & TAG_NODE_SCALAR_RESULT use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , build_fragment_from_indices , to_angstrom ! Method API imports #ifndef MQC_WITHOUT_TBLITE use mqc_method_xtb , only : xtb_method_t #endif use mqc_result_types , only : calculation_result_t implicit none private ! Public interface public :: do_fragment_work , global_coordinator , node_coordinator public :: serial_fragment_processor public :: node_worker , unfragmented_calculation contains subroutine do_fragment_work ( fragment_idx , & water_energy , C_flat , method , phys_frag ) !! Process a single fragment for quantum chemistry calculation !! !! Performs energy and gradient calculation on a molecular fragment using !! specified quantum chemistry method (GFN-xTB variants). !! Verbosity is controlled by the global logger level. use pic_logger , only : verbose_level integer , intent ( in ) :: fragment_idx !! Fragment index for identification real ( dp ), intent ( out ) :: water_energy !! Computed energy for this fragment real ( dp ), allocatable , intent ( out ) :: C_flat (:) !! Flattened gradient array character ( len =* ), intent ( in ) :: method !! QC method (gfn1, gfn2) type ( physical_fragment_t ), intent ( in ), optional :: phys_frag !! Fragment geometry integer :: current_log_level !! Current logger verbosity level logical :: is_verbose !! Whether verbose output is enabled #ifndef MQC_WITHOUT_TBLITE type ( xtb_method_t ) :: xtb_calc !! XTB calculator instance #endif type ( calculation_result_t ) :: result !! Computation results ! Query logger to determine verbosity call logger % configuration ( level = current_log_level ) is_verbose = ( current_log_level >= verbose_level ) ! Print fragment geometry if provided and verbose mode is enabled if ( present ( phys_frag )) then if ( is_verbose ) then call print_fragment_xyz ( fragment_idx , phys_frag ) end if #ifndef MQC_WITHOUT_TBLITE ! Setup XTB method xtb_calc % variant = method xtb_calc % verbose = is_verbose ! Run the calculation using the method API call xtb_calc % calc_energy ( phys_frag , result ) water_energy = result % energy ! Clean up result call result % destroy () #else call logger % error ( \"XTB method requested but tblite support not compiled in\" ) call logger % error ( \"Please rebuild with -DMQC_ENABLE_TBLITE=ON\" ) error stop \"tblite support not available\" #endif else water_energy = 0.0_dp end if ! Return empty vector for C_flat allocate ( C_flat ( 1 )) C_flat ( 1 ) = 0.0_dp end subroutine do_fragment_work subroutine global_coordinator ( world_comm , node_comm , total_fragments , polymers , max_level , & node_leader_ranks , num_nodes ) !! Global coordinator for distributing fragments to node coordinators !! will act as a node coordinator for a single node calculation !! Uses int64 for total_fragments to handle large fragment counts that overflow int32. type ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: max_level , num_nodes integer , intent ( in ) :: polymers (:, :), node_leader_ranks (:) type ( timer_type ) :: coord_timer integer ( int64 ) :: current_fragment , results_received integer :: finished_nodes integer :: request_source , dummy_msg , fragment_idx type ( MPI_Status ) :: status , local_status logical :: handling_local_workers logical :: has_pending ! For local workers integer :: local_finished_workers , local_dummy ! Storage for results real ( dp ), allocatable :: scalar_results (:) integer ( int64 ) :: worker_fragment_map ( node_comm % size ()) integer :: worker_source ! MPI request handles for non-blocking operations type ( request_t ) :: req current_fragment = total_fragments finished_nodes = 0 local_finished_workers = 0 handling_local_workers = ( node_comm % size () > 1 ) results_received = 0_int64 ! Allocate storage for results allocate ( scalar_results ( total_fragments )) scalar_results = 0.0_dp worker_fragment_map = 0 call logger % verbose ( \"Global coordinator starting with \" // to_char ( total_fragments ) // & \" fragments for \" // to_char ( num_nodes ) // \" nodes\" ) call coord_timer % start () do while ( finished_nodes < num_nodes ) ! PRIORITY 1: Check for incoming results from local workers ! This MUST be checked before sending new work to avoid race conditions if ( handling_local_workers ) then ! Keep checking for results until there are none pending do call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_pending , local_status ) if (. not . has_pending ) exit worker_source = local_status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state\" end if ! Receive scalar result and store it using the fragment index for this worker call irecv ( node_comm , scalar_results ( worker_fragment_map ( worker_source )), worker_source , & TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Clear the mapping since we've received the result worker_fragment_map ( worker_source ) = 0 results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do end if ! PRIORITY 1b: Check for incoming results from remote node coordinators do call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_SCALAR_RESULT , has_pending , status ) if (. not . has_pending ) exit ! Receive fragment index and scalar result from node coordinator ! TODO: serialize the data for better performance call irecv ( world_comm , fragment_idx , status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) call irecv ( world_comm , scalar_results ( fragment_idx ), status % MPI_SOURCE , TAG_NODE_SCALAR_RESULT , req ) call wait ( req ) results_received = results_received + 1 if ( mod ( results_received , max ( 1_int64 , total_fragments / 10 )) == 0 . or . & results_received == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( results_received ) // \"/\" // & to_char ( total_fragments ) // \" fragments [\" // & to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do ! PRIORITY 2: Remote node coordinator requests call iprobe ( world_comm , MPI_ANY_SOURCE , TAG_NODE_REQUEST , has_pending , status ) if ( has_pending ) then call irecv ( world_comm , dummy_msg , status % MPI_SOURCE , TAG_NODE_REQUEST , req ) call wait ( req ) request_source = status % MPI_SOURCE if ( current_fragment >= 1 ) then call send_fragment_to_node ( world_comm , current_fragment , polymers , request_source ) current_fragment = current_fragment - 1 else call isend ( world_comm , - 1 , request_source , TAG_NODE_FINISH , req ) call wait ( req ) finished_nodes = finished_nodes + 1 end if end if ! PRIORITY 3: Local workers (shared memory) - send new work if ( handling_local_workers . and . local_finished_workers < node_comm % size () - 1 ) then call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , has_pending , local_status ) if ( has_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( local_status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , local_status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( current_fragment >= 1 ) then call send_fragment_to_worker ( node_comm , current_fragment , polymers , & local_status % MPI_SOURCE ) ! Track which fragment was sent to this worker worker_fragment_map ( local_status % MPI_SOURCE ) = current_fragment current_fragment = current_fragment - 1 else call isend ( node_comm , - 1 , local_status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) local_finished_workers = local_finished_workers + 1 end if end if ! If worker still has pending results, skip the work request ! It will be processed on the next iteration after results are received end if end if ! Finalize local worker completion if ( handling_local_workers . and . local_finished_workers >= node_comm % size () - 1 & . and . results_received >= total_fragments ) then handling_local_workers = . false . if ( num_nodes == 1 ) then finished_nodes = finished_nodes + 1 call logger % debug ( \"Manually incremented finished_nodes for self\" ) else finished_nodes = finished_nodes + 1 call logger % verbose ( \"Global coordinator finished local workers\" ) end if end if end do call logger % verbose ( \"Global coordinator finished all fragments\" ) call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) block real ( dp ) :: mbe_total_energy ! Compute the many-body expansion energy call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () call compute_mbe_energy ( polymers , total_fragments , max_level , scalar_results , mbe_total_energy ) call coord_timer % stop () call logger % info ( \"Time to evaluate the MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) end block ! Cleanup deallocate ( scalar_results ) end subroutine global_coordinator subroutine send_fragment_to_node ( world_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to remote node coordinator !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: world_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 3 ) integer ( int32 ) :: fragment_idx_int32 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! TODO: serialize the data for better performance fragment_idx_int32 = int ( fragment_idx , kind = int32 ) call isend ( world_comm , fragment_idx_int32 , dest_rank , TAG_NODE_FRAGMENT , req ( 1 )) call isend ( world_comm , fragment_size , dest_rank , TAG_NODE_FRAGMENT , req ( 2 )) call isend ( world_comm , fragment_indices , dest_rank , TAG_NODE_FRAGMENT , req ( 3 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_node subroutine send_fragment_to_worker ( node_comm , fragment_idx , polymers , dest_rank ) !! Send fragment data to local worker !! Uses int64 for fragment_idx to handle large fragment indices that overflow int32. type ( comm_t ), intent ( in ) :: node_comm integer ( int64 ), intent ( in ) :: fragment_idx integer , intent ( in ) :: dest_rank integer , intent ( in ) :: polymers (:, :) integer :: fragment_size integer , allocatable :: fragment_indices (:) type ( request_t ) :: req ( 3 ) integer ( int32 ) :: fragment_idx_int32 fragment_size = count ( polymers ( fragment_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( fragment_idx , 1 : fragment_size ) ! TODO: serialize the data for better performance fragment_idx_int32 = int ( fragment_idx , kind = int32 ) call isend ( node_comm , fragment_idx_int32 , dest_rank , TAG_WORKER_FRAGMENT , req ( 1 )) call isend ( node_comm , fragment_size , dest_rank , TAG_WORKER_FRAGMENT , req ( 2 )) call isend ( node_comm , fragment_indices , dest_rank , TAG_WORKER_FRAGMENT , req ( 3 )) ! Wait for all sends to complete call wait ( req ( 1 )) call wait ( req ( 2 )) call wait ( req ( 3 )) deallocate ( fragment_indices ) end subroutine send_fragment_to_worker subroutine node_coordinator ( world_comm , node_comm ) !! Node coordinator for distributing fragments to local workers !! Handles work requests and result collection from local workers class ( comm_t ), intent ( in ) :: world_comm , node_comm integer ( int32 ) :: fragment_idx , fragment_size , dummy_msg integer ( int32 ) :: finished_workers integer ( int32 ), allocatable :: fragment_indices (:) type ( MPI_Status ) :: status , global_status logical :: local_message_pending , more_fragments , has_result integer ( int32 ) :: local_dummy ! For tracking worker-fragment mapping and collecting results integer ( int32 ) :: worker_fragment_map ( node_comm % size ()) integer ( int32 ) :: worker_source real ( dp ) :: scalar_result ! MPI request handles for non-blocking operations type ( request_t ) :: req finished_workers = 0 more_fragments = . true . dummy_msg = 0 worker_fragment_map = 0 do while ( finished_workers < node_comm % size () - 1 ) ! PRIORITY 1: Check for incoming results from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_SCALAR_RESULT , has_result , status ) if ( has_result ) then worker_source = status % MPI_SOURCE ! Safety check: worker should have a fragment assigned if ( worker_fragment_map ( worker_source ) == 0 ) then call logger % error ( \"Node coordinator received result from worker \" // to_char ( worker_source ) // & \" but no fragment was assigned!\" ) error stop \"Invalid worker_fragment_map state in node coordinator\" end if ! Receive scalar result from worker call irecv ( node_comm , scalar_result , worker_source , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) ! Forward results to global coordinator with fragment index call isend ( world_comm , worker_fragment_map ( worker_source ), 0 , TAG_NODE_SCALAR_RESULT , req ) ! fragment_idx call wait ( req ) call isend ( world_comm , scalar_result , 0 , TAG_NODE_SCALAR_RESULT , req ) ! scalar result call wait ( req ) ! Clear the mapping worker_fragment_map ( worker_source ) = 0 end if ! PRIORITY 2: Check for work requests from local workers call iprobe ( node_comm , MPI_ANY_SOURCE , TAG_WORKER_REQUEST , local_message_pending , status ) if ( local_message_pending ) then ! Only process work request if this worker doesn't have pending results if ( worker_fragment_map ( status % MPI_SOURCE ) == 0 ) then call irecv ( node_comm , local_dummy , status % MPI_SOURCE , TAG_WORKER_REQUEST , req ) call wait ( req ) if ( more_fragments ) then call isend ( world_comm , dummy_msg , 0 , TAG_NODE_REQUEST , req ) call wait ( req ) call irecv ( world_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , global_status ) if ( global_status % MPI_TAG == TAG_NODE_FRAGMENT ) then call irecv ( world_comm , fragment_size , 0 , TAG_NODE_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( world_comm , fragment_indices , 0 , TAG_NODE_FRAGMENT , global_status ) call isend ( node_comm , fragment_idx , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_size , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) call isend ( node_comm , fragment_indices , status % MPI_SOURCE , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Track which fragment was sent to this worker worker_fragment_map ( status % MPI_SOURCE ) = fragment_idx deallocate ( fragment_indices ) else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 more_fragments = . false . end if else call isend ( node_comm , - 1 , status % MPI_SOURCE , TAG_WORKER_FINISH , req ) call wait ( req ) finished_workers = finished_workers + 1 end if end if end if end do end subroutine node_coordinator subroutine node_worker ( world_comm , node_comm , sys_geom , method ) !! Node worker for processing fragments assigned by node coordinator class ( comm_t ), intent ( in ) :: world_comm , node_comm type ( system_geometry_t ), intent ( in ), optional :: sys_geom character ( len =* ), intent ( in ) :: method integer ( int32 ) :: fragment_idx , fragment_size , dummy_msg integer ( int32 ), allocatable :: fragment_indices (:) real ( dp ) :: dot_result real ( dp ), allocatable :: C_flat (:) type ( MPI_Status ) :: status type ( physical_fragment_t ) :: phys_frag ! MPI request handles for non-blocking operations type ( request_t ) :: req dummy_msg = 0 do call isend ( node_comm , dummy_msg , 0 , TAG_WORKER_REQUEST , req ) call wait ( req ) call irecv ( node_comm , fragment_idx , 0 , MPI_ANY_TAG , req ) call wait ( req , status ) select case ( status % MPI_TAG ) case ( TAG_WORKER_FRAGMENT ) call irecv ( node_comm , fragment_size , 0 , TAG_WORKER_FRAGMENT , req ) call wait ( req ) ! Note: must use blocking recv for allocatable arrays since size is unknown allocate ( fragment_indices ( fragment_size )) call recv ( node_comm , fragment_indices , 0 , TAG_WORKER_FRAGMENT , status ) ! Build physical fragment from indices if sys_geom is available if ( present ( sys_geom )) then call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag ) ! Process the chemistry fragment with physical geometry call do_fragment_work ( fragment_idx , & dot_result , C_flat , method , phys_frag ) call phys_frag % destroy () else ! Process without physical geometry (old behavior) call do_fragment_work ( fragment_idx , & dot_result , C_flat , method ) end if ! Send results back to coordinator call isend ( node_comm , dot_result , 0 , TAG_WORKER_SCALAR_RESULT , req ) call wait ( req ) deallocate ( fragment_indices , C_flat ) case ( TAG_WORKER_FINISH ) exit end select end do end subroutine node_worker subroutine unfragmented_calculation ( sys_geom , method ) !! Run unfragmented calculation on the entire system (nlevel=0) !! This is a simple single-process calculation without MPI distribution type ( system_geometry_t ), intent ( in ), optional :: sys_geom character ( len =* ), intent ( in ) :: method real ( dp ) :: dot_result real ( dp ), allocatable :: C_flat (:) integer :: total_atoms type ( physical_fragment_t ) :: full_system integer :: i if (. not . present ( sys_geom )) then call logger % error ( \"sys_geom required for unfragmented calculation\" ) error stop \"Missing geometry in unfragmented_calculation\" end if total_atoms = sys_geom % total_atoms call logger % info ( \"============================================\" ) call logger % info ( \"Running unfragmented calculation\" ) call logger % info ( \"  Total atoms: \" // to_char ( total_atoms )) call logger % info ( \"============================================\" ) ! Build the full system as a single fragment (all monomers) block integer , allocatable :: all_monomer_indices (:) allocate ( all_monomer_indices ( sys_geom % n_monomers )) do i = 1 , sys_geom % n_monomers all_monomer_indices ( i ) = i end do call build_fragment_from_indices ( sys_geom , all_monomer_indices , full_system ) deallocate ( all_monomer_indices ) end block ! Process the full system with verbosity=1 for detailed output block integer , allocatable :: temp_indices (:) allocate ( temp_indices ( sys_geom % n_monomers )) do i = 1 , sys_geom % n_monomers temp_indices ( i ) = i end do call do_fragment_work ( 0 , & dot_result , C_flat , & method , phys_frag = full_system ) deallocate ( temp_indices ) end block call logger % info ( \"============================================\" ) call logger % info ( \"Unfragmented calculation completed\" ) block character ( len = 256 ) :: result_line write ( result_line , '(a,f25.15)' ) \"  Final energy: \" , dot_result call logger % info ( trim ( result_line )) end block !call logger%info(\"  Matrix size: \"//to_char(size(C_flat))) call logger % info ( \"============================================\" ) if ( allocated ( C_flat )) deallocate ( C_flat ) end subroutine unfragmented_calculation subroutine serial_fragment_processor ( total_fragments , polymers , max_level , sys_geom , method ) !! Process all fragments serially in single-rank mode !! This is used when running with only 1 MPI rank integer ( int64 ), intent ( in ) :: total_fragments integer , intent ( in ) :: polymers (:, :), max_level type ( system_geometry_t ), intent ( in ) :: sys_geom character ( len =* ), intent ( in ) :: method integer ( int64 ) :: frag_idx integer :: fragment_size integer , allocatable :: fragment_indices (:) real ( dp ), allocatable :: scalar_results (:) real ( dp ), allocatable :: C_flat (:) real ( dp ) :: dot_result , mbe_total_energy type ( physical_fragment_t ) :: phys_frag type ( timer_type ) :: coord_timer call logger % info ( \"Processing \" // to_char ( total_fragments ) // \" fragments serially...\" ) allocate ( scalar_results ( total_fragments )) scalar_results = 0.0_dp call omp_set_num_threads ( 1 ) call coord_timer % start () do frag_idx = 1_int64 , total_fragments fragment_size = count ( polymers ( frag_idx , :) > 0 ) allocate ( fragment_indices ( fragment_size )) fragment_indices = polymers ( frag_idx , 1 : fragment_size ) call build_fragment_from_indices ( sys_geom , fragment_indices , phys_frag ) call do_fragment_work ( int ( frag_idx ), & dot_result , C_flat , method , phys_frag ) scalar_results ( frag_idx ) = dot_result call phys_frag % destroy () deallocate ( fragment_indices , C_flat ) if ( mod ( frag_idx , max ( 1_int64 , total_fragments / 10 )) == 0 . or . frag_idx == total_fragments ) then call logger % info ( \"  Processed \" // to_char ( frag_idx ) // \"/\" // to_char ( total_fragments ) // & \" fragments [\" // to_char ( coord_timer % get_elapsed_time ()) // \" s]\" ) end if end do call coord_timer % stop () call logger % info ( \"Time to evaluate all fragments \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) call omp_set_num_threads ( omp_get_max_threads ()) call logger % info ( \"All fragments processed\" ) call logger % info ( \" \" ) call logger % info ( \"Computing Many-Body Expansion (MBE)...\" ) call coord_timer % start () call compute_mbe_energy ( polymers , total_fragments , max_level , scalar_results , mbe_total_energy ) call coord_timer % stop () call logger % info ( \"Time to compute MBE \" // to_char ( coord_timer % get_elapsed_time ()) // \" s\" ) deallocate ( scalar_results ) end subroutine serial_fragment_processor end module mqc_mbe_fragment_distribution_scheme","tags":"","url":"sourcefile/mqc_mbe_fragment_distribution_scheme.f90.html"},{"title":"mqc_libcint_interface.f90 – metalquicha","text":"Libcint Fortran interface module Source Code !! Libcint Fortran interface module module mqc_libcint_interface !! Provides Fortran interface to the Libcint library for integral calculations !use libcint_fortran implicit none private end module mqc_libcint_interface","tags":"","url":"sourcefile/mqc_libcint_interface.f90.html"},{"title":"mqc_elements.f90 – metalquicha","text":"Periodic table data and element utilities Files dependent on this one sourcefile~~mqc_elements.f90~~AfferentGraph sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Periodic table data and element utilities module mqc_elements !! Provides atomic numbers, element symbols, and atomic masses for the complete !! periodic table (elements 1-118) with conversion functions between representations. use pic_ascii , only : to_upper , to_lower use pic_types , only : dp implicit none private public :: element_symbol_to_number !! Convert element symbol to atomic number public :: element_number_to_symbol !! Convert atomic number to element symbol public :: element_mass !! Get atomic mass by atomic number ! TODO: refactr to use findloc ! Periodic table data as module-level parameters character ( len = 2 ), parameter :: element_symbols ( 118 ) = [ character ( len = 2 ) :: & !! Element symbols for the complete periodic table (H through Og) !! Ordered by atomic number from 1 to 118 ! for some reason this is how the formatted formats this (????) 'H' , 'He' , & 'Li' , 'Be' , 'B' , 'C' , 'N' , 'O' , 'F' , 'Ne' , & 'Na' , 'Mg' , 'Al' , 'Si' , 'P' , 'S' , 'Cl' , 'Ar' , & 'K' , 'Ca' , 'Sc' , 'Ti' , 'V' , 'Cr' , 'Mn' , 'Fe' , 'Co' , 'Ni' , 'Cu' , 'Zn' , 'Ga' , 'Ge' , 'As' , 'Se' , 'Br' , 'Kr' , & 'Rb' , 'Sr' , 'Y' , 'Zr' , 'Nb' , 'Mo' , 'Tc' , 'Ru' , 'Rh' , 'Pd' , 'Ag' , 'Cd' , 'In' , 'Sn' , 'Sb' , 'Te' , 'I' , 'Xe' , & 'Cs' , 'Ba' , 'La' , 'Ce' , 'Pr' , 'Nd' , 'Pm' , 'Sm' , 'Eu' , 'Gd' , 'Tb' , 'Dy' , 'Ho' , 'Er' , 'Tm' , 'Yb' , 'Lu' , & 'Hf' , 'Ta' , 'W' , 'Re' , 'Os' , 'Ir' , 'Pt' , 'Au' , 'Hg' , 'Tl' , 'Pb' , 'Bi' , 'Po' , 'At' , 'Rn' , & 'Fr' , 'Ra' , 'Ac' , 'Th' , 'Pa' , 'U' , 'Np' , 'Pu' , 'Am' , 'Cm' , 'Bk' , 'Cf' , 'Es' , 'Fm' , 'Md' , 'No' , 'Lr' , & 'Rf' , 'Db' , 'Sg' , 'Bh' , 'Hs' , 'Mt' , 'Ds' , 'Rg' , 'Cn' , 'Nh' , 'Fl' , 'Mc' , 'Lv' , 'Ts' , 'Og' ] real ( dp ), parameter :: element_masses ( 118 ) = [ & !! Standard atomic masses in atomic mass units (amu) !! Based on IUPAC standard atomic weights, ordered by atomic number ! for some reason this is how the formatted formats this (????) 1.008_dp , 4.0026_dp , & ! H-He 6.94_dp , 9.0122_dp , 1 0.81_dp , 1 2.011_dp , 1 4.007_dp , 1 5.999_dp , 1 8.998_dp , 2 0.180_dp , & ! Li-Ne 2 2.990_dp , 2 4.305_dp , 2 6.982_dp , 2 8.085_dp , 3 0.974_dp , 3 2.06_dp , 3 5.45_dp , 3 9.948_dp , & ! Na-Ar 3 9.098_dp , 4 0.078_dp , 4 4.956_dp , 4 7.867_dp , 5 0.942_dp , 5 1.996_dp , 5 4.938_dp , 5 5.845_dp , & ! K-Fe 5 8.933_dp , 5 8.693_dp , 6 3.546_dp , 6 5.38_dp , 6 9.723_dp , 7 2.630_dp , 7 4.922_dp , 7 8.971_dp , & ! Co-Se 7 9.904_dp , 8 3.798_dp , & ! Br-Kr 8 5.468_dp , 8 7.62_dp , 8 8.906_dp , 9 1.224_dp , 9 2.906_dp , 9 5.95_dp , 9 8.0_dp , 10 1.07_dp , & ! Rb-Ru 10 2.91_dp , 10 6.42_dp , 10 7.87_dp , 11 2.41_dp , 11 4.82_dp , 11 8.71_dp , 12 1.76_dp , 12 7.60_dp , & ! Rh-Te 12 6.90_dp , 13 1.29_dp , & ! I-Xe 13 2.91_dp , 13 7.33_dp , 13 8.91_dp , 14 0.12_dp , 14 0.91_dp , 14 4.24_dp , 14 5.0_dp , 15 0.36_dp , & ! Cs-Sm 15 1.96_dp , 15 7.25_dp , 15 8.93_dp , 16 2.50_dp , 16 4.93_dp , 16 7.26_dp , 16 8.93_dp , 17 3.05_dp , & ! Eu-Yb 17 4.97_dp , 17 8.49_dp , 18 0.95_dp , 18 3.84_dp , 18 6.21_dp , 19 0.23_dp , 19 2.22_dp , 19 5.08_dp , & ! Lu-Pt 19 6.97_dp , 20 0.59_dp , 20 4.38_dp , 20 7.2_dp , 20 8.98_dp , 20 9.0_dp , 21 0.0_dp , 22 2.0_dp , & ! Au-Rn 22 3.0_dp , 22 6.0_dp , 22 7.0_dp , 23 2.04_dp , 23 1.04_dp , 23 8.03_dp , 23 7.0_dp , 24 4.0_dp , & ! Fr-Pu 24 3.0_dp , 24 7.0_dp , 24 7.0_dp , 25 1.0_dp , 25 2.0_dp , 25 7.0_dp , 25 8.0_dp , 25 9.0_dp , & ! Am-No 26 2.0_dp , 26 7.0_dp , 26 8.0_dp , 27 1.0_dp , 27 2.0_dp , 27 0.0_dp , 27 6.0_dp , 28 1.0_dp , & ! Lr-Ds 28 0.0_dp , 28 5.0_dp , 28 4.0_dp , 28 9.0_dp , 28 8.0_dp , 29 3.0_dp , 29 4.0_dp , 29 4.0_dp ] ! Rg-Og contains pure function element_symbol_to_number ( symbol ) result ( atomic_number ) !! Convert element symbol to atomic number !! Covers the complete periodic table (elements 1-118) character ( len =* ), intent ( in ) :: symbol integer :: atomic_number character ( len = 2 ) :: sym ! Normalize: uppercase first letter, lowercase second sym = adjustl ( symbol ) if ( len_trim ( sym ) >= 1 ) sym ( 1 : 1 ) = to_upper ( sym ( 1 : 1 )) if ( len_trim ( sym ) >= 2 ) sym ( 2 : 2 ) = to_lower ( sym ( 2 : 2 )) ! Search for symbol in table atomic_number = findloc ( element_symbols , sym , dim = 1 ) end function element_symbol_to_number pure function element_number_to_symbol ( atomic_number ) result ( symbol ) !! Convert atomic number to element symbol !! Covers the complete periodic table (elements 1-118) integer , intent ( in ) :: atomic_number character ( len = 2 ) :: symbol select case ( atomic_number ) case ( 1 : 118 ) symbol = element_symbols ( atomic_number ) case default symbol = 'Xx' ! Unknown end select end function element_number_to_symbol pure function element_mass ( atomic_number ) result ( mass ) !! Return atomic mass in atomic mass units (amu) for a given atomic number !! Uses standard atomic weights from IUPAC integer , intent ( in ) :: atomic_number real ( dp ) :: mass select case ( atomic_number ) case ( 1 : 118 ) mass = element_masses ( atomic_number ) case default mass = 0.0_dp ! Unknown element end select end function element_mass end module mqc_elements","tags":"","url":"sourcefile/mqc_elements.f90.html"},{"title":"main.f90 – metalquicha","text":"This file simply contains the main program, look at it as the base of the calculation\nand how everything sits together. This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_input_parser.f90 mqc_input_parser.f90 sourcefile~main.f90->sourcefile~mqc_input_parser.f90 sourcefile~mqc_logo.f90 mqc_logo.f90 sourcefile~main.f90->sourcefile~mqc_logo.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~main.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_input_parser.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This file simply contains the main program, look at it as the base of the calculation !! and how everything sits together. program main !! Orchestrates MPI initialization, input parsing, geometry loading, !! and dispatches to appropriate calculation routines (fragmented or unfragmented). use pic_logger , only : logger => global_logger , info_level use pic_io , only : to_char use pic_mpi_lib , only : pic_mpi_init , comm_world , comm_t , abort_comm , pic_mpi_finalize use mqc_driver , only : run_calculation use mqc_physical_fragment , only : initialize_system_geometry , system_geometry_t use mqc_input_parser , only : read_input_file , input_config_t , get_logger_level use mqc_logo , only : print_logo use pic_timer , only : timer_type implicit none type ( timer_type ) :: my_timer !! Execution timing type ( comm_t ) :: world_comm !! Global MPI communicator type ( comm_t ) :: node_comm !! Node-local MPI communicator type ( input_config_t ) :: config !! Parsed input configuration type ( system_geometry_t ) :: sys_geom !! Loaded molecular system integer :: stat !! Status code for error handling character ( len = :), allocatable :: errmsg !! Error messages character ( len = 256 ) :: input_file !! Input file name ! Initialize MPI ! pic-mpi will call mpi_init_thread when needed call pic_mpi_init () ! Create communicators world_comm = comm_world () node_comm = world_comm % split () if ( world_comm % rank () == 0 ) then call print_logo () call my_timer % start () end if input_file = \"test.inp\" call read_input_file ( input_file , config , stat , errmsg ) if ( stat /= 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error reading input file \" // errmsg ) end if call abort_comm ( world_comm , 1 ) end if ! Configure logger verbosity based on input file call logger % configure ( get_logger_level ( config % log_level )) if ( world_comm % rank () == 0 ) then call logger % info ( \"Logger verbosity set to: \" // trim ( config % log_level )) end if call initialize_system_geometry ( config % geom_file , config % monomer_file , sys_geom , stat , errmsg ) if ( stat /= 0 ) then if ( world_comm % rank () == 0 ) then call logger % error ( \"Error loeading geometry \" // errmsg ) end if call abort_comm ( world_comm , 1 ) end if call run_calculation ( world_comm , node_comm , config , sys_geom ) if ( world_comm % rank () == 0 ) then call my_timer % stop () call logger % info ( \"Total processing time: \" // to_char ( my_timer % get_elapsed_time ()) // \" s\" ) end if call config % destroy () call sys_geom % destroy () call world_comm % finalize () call node_comm % finalize () call pic_mpi_finalize () end program main","tags":"","url":"sourcefile/main.f90.html"},{"title":"mqc_method_base.f90 – metalquicha","text":"Abstract base module for quantum chemistry method implementations This file depends on sourcefile~~mqc_method_base.f90~~EfferentGraph sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_method_base.f90~~AfferentGraph sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_method_xtb.f90 mqc_method_xtb.f90 sourcefile~mqc_method_xtb.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_method_xtb.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Abstract base module for quantum chemistry method implementations module mqc_method_base !! Defines the common interface that all quantum chemistry methods must implement, !! providing a unified API for energy and gradient calculations. use pic_types , only : dp use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: qc_method_t !! Abstract base type for all QC methods type , abstract :: qc_method_t !! Abstract base type for all quantum chemistry methods !! !! Defines the required interface for energy and gradient calculations !! that must be implemented by all concrete method types (XTB, HF, etc.). contains procedure ( calc_energy_interface ), deferred :: calc_energy !! Energy calculation interface procedure ( calc_gradient_interface ), deferred :: calc_gradient !! Gradient calculation interface end type qc_method_t abstract interface subroutine calc_energy_interface ( this , fragment , result ) !! Interface for energy-only calculations !! !! Computes the electronic energy for a molecular fragment !! using the specified quantum chemistry method. import :: qc_method_t , calculation_result_t , physical_fragment_t implicit none class ( qc_method_t ), intent ( in ) :: this !! Method instance type ( physical_fragment_t ), intent ( in ) :: fragment !! Molecular fragment type ( calculation_result_t ), intent ( out ) :: result !! Calculation results end subroutine calc_energy_interface subroutine calc_gradient_interface ( this , fragment , result ) !! Interface for energy and gradient calculations !! !! Computes both electronic energy and nuclear gradients for a !! molecular fragment using the specified quantum chemistry method. import :: qc_method_t , calculation_result_t , physical_fragment_t implicit none class ( qc_method_t ), intent ( in ) :: this !! Method instance type ( physical_fragment_t ), intent ( in ) :: fragment !! Molecular fragment type ( calculation_result_t ), intent ( out ) :: result end subroutine calc_gradient_interface end interface end module mqc_method_base","tags":"","url":"sourcefile/mqc_method_base.f90.html"},{"title":"mqc_method_hf.f90 – metalquicha","text":"Hartree-Fock method implementation for metalquicha This file depends on sourcefile~~mqc_method_hf.f90~~EfferentGraph sourcefile~mqc_method_hf.f90 mqc_method_hf.f90 sourcefile~mqc_method_base.f90 mqc_method_base.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_method_base.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_result_types.f90 mqc_result_types.f90 sourcefile~mqc_method_hf.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_method_base.f90->sourcefile~mqc_result_types.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Hartree-Fock method implementation for metalquicha module mqc_method_hf !! Implements the Hartree-Fock quantum chemistry method !! Provides energy and gradient calculations using a basic SCF procedure. use pic_types , only : dp use mqc_method_base , only : qc_method_t use mqc_result_types , only : calculation_result_t use mqc_physical_fragment , only : physical_fragment_t implicit none private public :: hf_method_t , hf_options_t type :: hf_options_t !! Hartree-Fock calculation options integer :: max_iter = 100 !! Maximum SCF iterations real ( dp ) :: conv_tol = 1.0e-8_dp !! Energy convergence threshold logical :: spherical = . false . !! Use spherical (true) or Cartesian (false) basis logical :: verbose = . true . !! Print SCF iterations end type hf_options_t type , extends ( qc_method_t ) :: hf_method_t !! Hartree-Fock method implementation type ( hf_options_t ) :: options contains procedure :: calc_energy => hf_calc_energy procedure :: calc_gradient => hf_calc_gradient end type hf_method_t contains subroutine hf_calc_energy ( this , fragment , result ) !! Calculate electronic energy using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement actual HF calculation ! 1. Convert fragment%basis to libcint format ! 2. Build one-electron integrals (S, T, V) ! 3. Run SCF iterations ! 4. Calculate final energy print * , \"HF: Calculating energy for fragment with\" , fragment % n_atoms , \"atoms\" print * , \"HF: nelec =\" , fragment % nelec print * , \"HF: charge =\" , fragment % charge print * , \"HF: multiplicity =\" , fragment % multiplicity ! Dummy result result % energy = - 1.0_dp ! Placeholder result % has_energy = . true . print * , \"HF: Dummy energy =\" , result % energy end subroutine hf_calc_energy subroutine hf_calc_gradient ( this , fragment , result ) !! Calculate energy gradient using Hartree-Fock method class ( hf_method_t ), intent ( in ) :: this type ( physical_fragment_t ), intent ( in ) :: fragment type ( calculation_result_t ), intent ( out ) :: result ! DUMMY IMPLEMENTATION ! TODO: Implement gradient calculation ! 1. Calculate energy (call calc_energy) ! 2. Calculate gradient using integral derivatives print * , \"HF: Calculating gradient for fragment with\" , fragment % n_atoms , \"atoms\" ! First get energy call this % calc_energy ( fragment , result ) ! Allocate and fill dummy gradient allocate ( result % gradient ( 3 , fragment % n_atoms )) result % gradient = 0.0_dp ! Placeholder result % has_gradient = . true . print * , \"HF: Dummy gradient allocated\" end subroutine hf_calc_gradient end module mqc_method_hf","tags":"","url":"sourcefile/mqc_method_hf.f90.html"},{"title":"mqc_mbe.f90 – metalquicha","text":"Many-Body Expansion (MBE) calculation module This file depends on sourcefile~~mqc_mbe.f90~~EfferentGraph sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_io.f90 mqc_mbe_io.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mbe_io.f90 sourcefile~mqc_mpi_tags.f90 mqc_mpi_tags.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_mpi_tags.f90 sourcefile~mqc_physical_fragment.f90 mqc_physical_fragment.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_physical_fragment.f90 sourcefile~mqc_elements.f90 mqc_elements.f90 sourcefile~mqc_mbe_io.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_cgto.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_elements.f90 sourcefile~mqc_geometry.f90 mqc_geometry.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_geometry.f90 sourcefile~mqc_xyz_reader.f90 mqc_xyz_reader.f90 sourcefile~mqc_physical_fragment.f90->sourcefile~mqc_xyz_reader.f90 sourcefile~mqc_xyz_reader.f90->sourcefile~mqc_geometry.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mqc_mbe.f90~~AfferentGraph sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Many-Body Expansion (MBE) calculation module module mqc_mbe !! Implements hierarchical many-body expansion for fragment-based quantum chemistry !! calculations with MPI parallelization and energy/gradient computation. use pic_types , only : int32 , int64 , dp use pic_timer , only : timer_type use pic_blas_interfaces , only : pic_gemm , pic_dot use pic_mpi_lib , only : comm_t , send , recv , iprobe , MPI_Status , MPI_ANY_SOURCE , MPI_ANY_TAG use pic_logger , only : logger => global_logger use pic_io , only : to_char use mqc_mbe_io , only : print_detailed_breakdown , print_detailed_breakdown_json use mqc_mpi_tags , only : TAG_WORKER_REQUEST , TAG_WORKER_FRAGMENT , TAG_WORKER_FINISH , & TAG_WORKER_SCALAR_RESULT , & TAG_NODE_REQUEST , TAG_NODE_FRAGMENT , TAG_NODE_FINISH , & TAG_NODE_SCALAR_RESULT use mqc_physical_fragment , only : system_geometry_t , physical_fragment_t , build_fragment_from_indices , to_angstrom use mqc_frag_utils , only : get_next_combination , fragment_lookup_t implicit none private ! Public interface public :: compute_mbe_energy contains subroutine compute_mbe_energy ( polymers , fragment_count , max_level , energies , total_energy ) !! Compute the many-body expansion (MBE) energy !! Total = sum(E(i)) + sum(deltaE(ij)) + sum(deltaE(ijk)) + ... !! General n-body correction: !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all lower-order terms !! Uses int64 for fragment_count to handle large fragment counts that overflow int32. !! Detailed breakdown is printed only if logger level is verbose or higher. use pic_logger , only : verbose_level integer ( int64 ), intent ( in ) :: fragment_count integer , intent ( in ) :: polymers (:, :), max_level real ( dp ), intent ( in ) :: energies (:) real ( dp ), intent ( out ) :: total_energy integer ( int64 ) :: i integer :: fragment_size , body_level , current_log_level real ( dp ), allocatable :: sum_by_level (:), delta_energies (:) real ( dp ) :: delta_E logical :: do_detailed_print type ( fragment_lookup_t ) :: lookup type ( timer_type ) :: lookup_timer call logger % configuration ( level = current_log_level ) do_detailed_print = ( current_log_level >= verbose_level ) allocate ( sum_by_level ( max_level )) allocate ( delta_energies ( fragment_count )) sum_by_level = 0.0_dp delta_energies = 0.0_dp ! Build hash table for fast fragment lookups call lookup_timer % start () call lookup % init ( fragment_count ) do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) call lookup % insert ( polymers ( i , :), fragment_size , i ) end do call lookup_timer % stop () call logger % debug ( \"Time to build lookup table: \" // to_char ( lookup_timer % get_elapsed_time ()) // \" s\" ) call logger % debug ( \"Hash table size: \" // to_char ( lookup % table_size ) // & \", entries: \" // to_char ( lookup % n_entries )) ! Bottom-up computation: process fragments by size (1-body, then 2-body, then 3-body, etc.) ! This eliminates recursion and redundant subset computations do i = 1_int64 , fragment_count fragment_size = count ( polymers ( i , :) > 0 ) if ( fragment_size == 1 ) then ! 1-body: deltaE = E (no subsets to subtract) delta_energies ( i ) = energies ( i ) sum_by_level ( 1 ) = sum_by_level ( 1 ) + delta_energies ( i ) else if ( fragment_size >= 2 . and . fragment_size <= max_level ) then ! n-body: deltaE = E - sum(all subset deltaEs) ! All subsets have already been computed in previous iterations delta_E = compute_mbe ( i , polymers ( i , 1 : fragment_size ), lookup , & energies , delta_energies , fragment_size ) delta_energies ( i ) = delta_E sum_by_level ( fragment_size ) = sum_by_level ( fragment_size ) + delta_E end if end do ! Clean up lookup table call lookup % destroy () total_energy = sum ( sum_by_level ) ! Print text summary to console call logger % info ( \"MBE Energy breakdown:\" ) do body_level = 1 , max_level if ( abs ( sum_by_level ( body_level )) > 1e-15_dp ) then block character ( len = 256 ) :: energy_line write ( energy_line , '(a,i0,a,f20.10)' ) \"  \" , body_level , \"-body:  \" , sum_by_level ( body_level ) call logger % info ( trim ( energy_line )) end block end if end do block character ( len = 256 ) :: total_line write ( total_line , '(a,f20.10)' ) \"  Total:   \" , total_energy call logger % info ( trim ( total_line )) end block ! Print detailed breakdown if requested if ( do_detailed_print ) then call print_detailed_breakdown ( polymers , fragment_count , max_level , energies , delta_energies ) end if ! Always write JSON file for machine-readable output call print_detailed_breakdown_json ( polymers , fragment_count , max_level , energies , delta_energies , & sum_by_level , total_energy ) deallocate ( sum_by_level , delta_energies ) end subroutine compute_mbe_energy function compute_mbe ( fragment_idx , fragment , lookup , energies , delta_energies , n ) result ( delta_E ) !! Bottom-up computation of n-body correction (non-recursive, uses pre-computed subset deltas) !! deltaE(i1,i2,...,in) = E(i1,i2,...,in) - sum of all subset deltaE values !! All subsets must have been computed already (guaranteed by processing fragments in order) integer ( int64 ), intent ( in ) :: fragment_idx !! Index of this fragment (already known) integer , intent ( in ) :: fragment (:), n type ( fragment_lookup_t ), intent ( in ) :: lookup !! Pre-built hash table for lookups real ( dp ), intent ( in ) :: energies (:), delta_energies (:) !! Pre-computed delta values real ( dp ) :: delta_E integer :: subset_size , i integer , allocatable :: indices (:), subset (:) integer ( int64 ) :: subset_idx logical :: has_next ! Start with the full n-mer energy delta_E = energies ( fragment_idx ) ! Subtract all proper subsets (size 1 to n-1) do subset_size = 1 , n - 1 allocate ( indices ( subset_size )) allocate ( subset ( subset_size )) ! Initialize first combination do i = 1 , subset_size indices ( i ) = i end do ! Loop through all combinations do ! Build current subset do i = 1 , subset_size subset ( i ) = fragment ( indices ( i )) end do ! Look up subset index subset_idx = lookup % find ( subset , subset_size ) if ( subset_idx < 0 ) error stop \"Subset not found in bottom-up MBE!\" ! Subtract pre-computed delta energy delta_E = delta_E - delta_energies ( subset_idx ) ! Get next combination call get_next_combination ( indices , subset_size , n , has_next ) if (. not . has_next ) exit end do deallocate ( indices , subset ) end do end function compute_mbe end module mqc_mbe","tags":"","url":"sourcefile/mqc_mbe.f90.html"},{"title":"mqc_frag_utils.f90 – metalquicha","text":"Fragment generation and manipulation utilities Files dependent on this one sourcefile~~mqc_frag_utils.f90~~AfferentGraph sourcefile~mqc_frag_utils.f90 mqc_frag_utils.f90 sourcefile~mqc_driver.f90 mqc_driver.f90 sourcefile~mqc_driver.f90->sourcefile~mqc_frag_utils.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90 mqc_mbe_fragment_distribution_scheme.F90 sourcefile~mqc_driver.f90->sourcefile~mqc_mbe_fragment_distribution_scheme.f90 sourcefile~mqc_mbe.f90 mqc_mbe.f90 sourcefile~mqc_mbe.f90->sourcefile~mqc_frag_utils.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_driver.f90 sourcefile~mqc_mbe_fragment_distribution_scheme.f90->sourcefile~mqc_mbe.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Fragment generation and manipulation utilities module mqc_frag_utils !! Provides combinatorial functions and algorithms for generating molecular !! fragments, managing fragment lists, and performing many-body expansion calculations. use pic_types , only : default_int , int32 , int64 , dp use pic_logger , only : logger => global_logger use pic_sorting , only : sort use pic_hash_32bit , only : fnv_1a_hash implicit none private public :: binomial !! Binomial coefficient calculation public :: create_monomer_list !! Generate sequential monomer indices public :: generate_fragment_list !! Generate all fragments up to max level public :: get_nfrags !! Calculate total number of fragments public :: get_next_combination !! Generate next combination in sequence public :: fragment_lookup_t !! Hash-based lookup table for fast fragment index retrieval type :: hash_entry_t !! Single entry in hash table (private helper type) integer , allocatable :: key (:) !! Sorted monomer indices integer ( int64 ) :: value !! Fragment index type ( hash_entry_t ), pointer :: next => null () !! Chain for collisions end type hash_entry_t type :: fragment_lookup_t !! Hash-based lookup table for O(1) fragment index retrieval integer :: table_size = 0 type ( hash_entry_t ), allocatable :: table (:) integer ( int64 ) :: n_entries = 0 logical :: initialized = . false . contains procedure :: init => fragment_lookup_init procedure :: insert => fragment_lookup_insert procedure :: find => fragment_lookup_find procedure :: destroy => fragment_lookup_destroy end type fragment_lookup_t contains pure function get_nfrags ( n_monomers , max_level ) result ( n_expected_fragments ) !! Calculate total number of fragments for given system size and max level !! !! Computes the sum of binomial coefficients C(n,k) for k=1 to max_level, !! representing all possible fragments from monomers to max_level-mers. !! Uses int64 to handle large fragment counts that overflow int32. integer ( default_int ), intent ( in ) :: n_monomers !! Number of monomers in system integer ( default_int ), intent ( in ) :: max_level !! Maximum fragment size integer ( int64 ) :: n_expected_fragments !! Total fragment count integer ( default_int ) :: i !! Loop counter n_expected_fragments = 0_int64 do i = 1 , max_level n_expected_fragments = n_expected_fragments + binomial ( n_monomers , i ) end do end function get_nfrags pure function binomial ( n , r ) result ( c ) !! Compute binomial coefficient C(n,r) = n! / (r! * (n-r)!) !! !! Calculates \"n choose r\" using iterative algorithm to avoid !! factorial overflow for large numbers. !! Uses int64 to handle large combinatorial values that overflow int32. integer ( default_int ), intent ( in ) :: n !! Total number of items integer ( default_int ), intent ( in ) :: r !! Number of items to choose integer ( int64 ) :: c !! Binomial coefficient result integer ( default_int ) :: i !! Loop counter if ( r == 0 . or . r == n ) then c = 1_int64 else if ( r > n ) then c = 0_int64 else c = 1_int64 do i = 1 , r c = c * int ( n - i + 1 , int64 ) / int ( i , int64 ) end do end if end function binomial pure subroutine create_monomer_list ( monomers ) !! Generate a list of monomer indices from 1 to N integer ( default_int ), allocatable , intent ( inout ) :: monomers (:) integer ( default_int ) :: i , length length = size ( monomers , 1 ) do i = 1 , length monomers ( i ) = i end do end subroutine create_monomer_list recursive subroutine generate_fragment_list ( monomers , max_level , polymers , count ) !! Generate all possible fragments (combinations of monomers) up to max_level !! Uses int64 for count to handle large numbers of fragments that overflow int32. integer ( default_int ), intent ( in ) :: monomers (:), max_level integer ( default_int ), intent ( inout ) :: polymers (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: r , n n = size ( monomers , 1 ) do r = 2 , max_level call combine ( monomers , n , r , polymers , count ) end do end subroutine generate_fragment_list recursive subroutine combine ( arr , n , r , out_array , count ) !! Generate all combinations of size r from array arr of size n !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:) integer ( default_int ), intent ( in ) :: n , r integer ( default_int ), intent ( inout ) :: out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: data ( r ) call combine_util ( arr , n , r , 1 , data , 1 , out_array , count ) end subroutine combine recursive subroutine combine_util ( arr , n , r , index , data , i , out_array , count ) !! Utility for generating combinations recursively !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: arr (:), n , r , index , i integer ( default_int ), intent ( inout ) :: data (:), out_array (:, :) integer ( int64 ), intent ( inout ) :: count integer ( default_int ) :: j if ( index > r ) then count = count + 1_int64 out_array ( count , 1 : r ) = data ( 1 : r ) return end if do j = i , n data ( index ) = arr ( j ) call combine_util ( arr , n , r , index + 1 , data , j + 1 , out_array , count ) end do end subroutine combine_util subroutine print_combos ( out_array , count , max_len ) !! Print combinations stored in out_array !! Uses int64 for count to handle large numbers of combinations that overflow int32. integer ( default_int ), intent ( in ) :: out_array (:, :), max_len integer ( int64 ), intent ( in ) :: count integer ( int64 ) :: i integer ( default_int ) :: j do i = 1_int64 , count do j = 1 , max_len if ( out_array ( i , j ) == 0 ) exit write ( * , '(I0)' , advance = 'no' ) out_array ( i , j ) if ( j < max_len . and . out_array ( i , j + 1 ) /= 0 ) then write ( * , '(A)' , advance = 'no' ) \":\" end if end do write ( * , * ) ! newline end do end subroutine print_combos pure subroutine get_next_combination ( indices , k , n , has_next ) !! Generate next combination (updates indices in place) !! has_next = .true. if there's a next combination integer , intent ( inout ) :: indices (:) integer , intent ( in ) :: k , n logical , intent ( out ) :: has_next integer :: i has_next = . true . i = k do while ( i >= 1 ) if ( indices ( i ) < n - k + i ) then indices ( i ) = indices ( i ) + 1 do while ( i < k ) i = i + 1 indices ( i ) = indices ( i - 1 ) + 1 end do return end if i = i - 1 end do has_next = . false . end subroutine get_next_combination subroutine fragment_lookup_init ( this , estimated_entries ) !! Initialize hash table with estimated size class ( fragment_lookup_t ), intent ( inout ) :: this integer ( int64 ), intent ( in ) :: estimated_entries integer :: i ! Use prime number close to estimated size for better distribution this % table_size = next_prime_internal ( int ( estimated_entries * 1.3_8 )) allocate ( this % table ( this % table_size )) ! Initialize all entries as empty do i = 1 , this % table_size nullify ( this % table ( i )% next ) end do this % n_entries = 0 this % initialized = . true . end subroutine fragment_lookup_init subroutine fragment_lookup_insert ( this , monomers , n , fragment_idx ) !! Insert a monomer combination -> fragment index mapping class ( fragment_lookup_t ), intent ( inout ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ), intent ( in ) :: fragment_idx integer ( int32 ) :: hash_val integer :: bucket type ( hash_entry_t ), pointer :: new_entry integer , allocatable :: sorted_key (:) if (. not . this % initialized ) error stop \"Hash table not initialized\" ! Sort monomers for canonical key allocate ( sorted_key ( n )) sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Check if this is the first entry in bucket if (. not . allocated ( this % table ( bucket )% key )) then ! First entry in this bucket - use the head entry allocate ( this % table ( bucket )% key ( n )) this % table ( bucket )% key = sorted_key this % table ( bucket )% value = fragment_idx this % n_entries = this % n_entries + 1 else ! Bucket already has entries - chain new entry allocate ( new_entry ) allocate ( new_entry % key ( n )) new_entry % key = sorted_key new_entry % value = fragment_idx new_entry % next => this % table ( bucket )% next this % table ( bucket )% next => new_entry this % n_entries = this % n_entries + 1 end if deallocate ( sorted_key ) end subroutine fragment_lookup_insert function fragment_lookup_find ( this , monomers , n ) result ( idx ) !! Find fragment index for given monomer combination class ( fragment_lookup_t ), intent ( in ) :: this integer , intent ( in ) :: monomers (:), n integer ( int64 ) :: idx integer ( int32 ) :: hash_val integer :: bucket , sorted_key ( n ) type ( hash_entry_t ), pointer :: entry ! Sort monomers for canonical key sorted_key = monomers ( 1 : n ) call sort ( sorted_key ) ! Compute hash hash_val = fnv_1a_hash ( sorted_key ) bucket = 1 + modulo ( hash_val , int ( this % table_size , int32 )) ! Search chain if ( allocated ( this % table ( bucket )% key )) then if ( arrays_equal_internal ( this % table ( bucket )% key , sorted_key , n )) then idx = this % table ( bucket )% value return end if entry => this % table ( bucket )% next do while ( associated ( entry )) if ( arrays_equal_internal ( entry % key , sorted_key , n )) then idx = entry % value return end if entry => entry % next end do end if ! Not found idx = - 1 end function fragment_lookup_find subroutine fragment_lookup_destroy ( this ) !! Clean up hash table and all chains class ( fragment_lookup_t ), intent ( inout ) :: this integer :: i type ( hash_entry_t ), pointer :: entry , next_entry if (. not . this % initialized ) return do i = 1 , this % table_size ! Free chain entry => this % table ( i )% next do while ( associated ( entry )) next_entry => entry % next if ( allocated ( entry % key )) deallocate ( entry % key ) deallocate ( entry ) entry => next_entry end do ! Free bucket head if ( allocated ( this % table ( i )% key )) deallocate ( this % table ( i )% key ) end do deallocate ( this % table ) this % initialized = . false . end subroutine fragment_lookup_destroy ! Helper functions for hash table pure function arrays_equal_internal ( a , b , n ) result ( equal ) !! Check if two arrays are equal integer , intent ( in ) :: a (:), b (:), n logical :: equal integer :: i equal = . true . if ( size ( a ) /= n . or . size ( b ) /= n ) then equal = . false . return end if do i = 1 , n if ( a ( i ) /= b ( i )) then equal = . false . return end if end do end function arrays_equal_internal pure function next_prime_internal ( n ) result ( p ) !! Find next prime number >= n (simple implementation) integer , intent ( in ) :: n integer :: p , i logical :: is_prime p = max ( n , 2 ) if ( modulo ( p , 2 ) == 0 ) p = p + 1 do is_prime = . true . do i = 3 , int ( sqrt ( real ( p ))) + 1 , 2 if ( modulo ( p , i ) == 0 ) then is_prime = . false . exit end if end do if ( is_prime ) return p = p + 2 end do end function next_prime_internal end module mqc_frag_utils","tags":"","url":"sourcefile/mqc_frag_utils.f90.html"},{"title":"mqc_basis_reader.f90 – metalquicha","text":"This file contains basis set reader routines for basis sets This file depends on sourcefile~~mqc_basis_reader.f90~~EfferentGraph sourcefile~mqc_basis_reader.f90 mqc_basis_reader.f90 sourcefile~mqc_basis_file_reader.f90 mqc_basis_file_reader.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_basis_file_reader.f90 sourcefile~mqc_cgto.f90 mqc_cgto.f90 sourcefile~mqc_basis_reader.f90->sourcefile~mqc_cgto.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This file contains basis set reader routines for basis sets module mqc_basis_reader !! Gaussian basis set parser and molecular basis construction !! !! Provides utilities for parsing Gaussian-type orbital basis sets !! from text files and building molecular basis sets for quantum calculations. use mqc_cgto , only : cgto_type , atomic_basis_type , molecular_basis_type use mqc_basis_file_reader , only : strings_equal use pic_types , only : dp implicit none private public :: classify_line !! Determine basis file line type public :: parse_element_basis !! Parse basis for single element public :: build_molecular_basis !! Build complete molecular basis public :: ang_mom_char_to_int !! Convert angular momentum character to integer public :: ang_mom_int_to_char !! Convert angular momentum integer to character ! Basis file line classification constants integer , parameter , public :: LINE_UNKNOWN = 0 !! Unrecognized line type integer , parameter , public :: LINE_ATOM = 1 !! Element specification line integer , parameter , public :: LINE_SHELL = 2 !! Shell definition line integer , parameter , public :: LINE_FUNCTION = 3 !! Basis function coefficient line contains pure function ang_mom_char_to_int ( ang_mom_char ) result ( ang_mom ) !! Convert angular momentum character to integer !! !! Standard mapping: S=0, P=1, D=2, F=3, G=4, H=5, I=6 !! Special case: L=-1 (combined S+P shell, requires splitting) character ( len = 1 ), intent ( in ) :: ang_mom_char !! Angular momentum symbol integer :: ang_mom !! Corresponding integer value select case ( ang_mom_char ) case ( 'S' ); ang_mom = 0 case ( 'P' ); ang_mom = 1 case ( 'D' ); ang_mom = 2 case ( 'F' ); ang_mom = 3 case ( 'G' ); ang_mom = 4 case ( 'H' ); ang_mom = 5 case ( 'I' ); ang_mom = 6 case ( 'L' ); ang_mom = - 1 ! Special case: L shells are split into S+P case default ; ang_mom = - 1 end select end function ang_mom_char_to_int pure function ang_mom_int_to_char ( ang_mom ) result ( ang_mom_char ) !! Convert angular momentum integer to character !! !! Inverse mapping: 0=S, 1=P, 2=D, 3=F, 4=G, 5=H, 6=I !! Returns '?' for invalid input values. integer , intent ( in ) :: ang_mom !! Angular momentum quantum number character ( len = 1 ) :: ang_mom_char !! Corresponding symbol character select case ( ang_mom ) case ( 0 ); ang_mom_char = 'S' case ( 1 ); ang_mom_char = 'P' case ( 2 ); ang_mom_char = 'D' case ( 3 ); ang_mom_char = 'F' case ( 4 ); ang_mom_char = 'G' case ( 5 ); ang_mom_char = 'H' case ( 6 ); ang_mom_char = 'I' case default ; ang_mom_char = '?' end select end function ang_mom_int_to_char pure function classify_line ( line ) result ( line_type ) !! Classify a line from a gamess formatted basis set file character ( len =* ), intent ( in ) :: line integer :: line_type character ( len = :), allocatable :: line_trim line_trim = trim ( adjustl ( line )) if ( is_blank_or_control ( line_trim )) then line_type = LINE_UNKNOWN else if ( is_function_line ( line_trim )) then line_type = LINE_FUNCTION else if ( is_shell_header ( line_trim )) then line_type = LINE_SHELL else line_type = LINE_ATOM end if end function classify_line pure function is_blank_or_control ( line ) result ( res ) !! Check if a line is blank or a control line (starts with '$') character ( len =* ), intent ( in ) :: line logical :: res integer :: trimmed_len trimmed_len = len_trim ( line ) if ( trimmed_len == 0 ) then res = . true . else res = ( line ( 1 : 1 ) == '$' ) end if end function is_blank_or_control pure function is_function_line ( line ) result ( res ) !! Check if a line is a function coefficient line (starts with a number) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char if ( len_trim ( line ) == 0 ) then res = . false . return end if first_char = line ( 1 : 1 ) res = ( first_char >= '0' . and . first_char <= '9' ) end function is_function_line pure function is_shell_header ( line ) result ( res ) !! Check if a line is a shell header line (starts with S, P, D, F, G, H, I, or L) character ( len =* ), intent ( in ) :: line logical :: res character ( len = 1 ) :: first_char integer :: ios , dummy res = . false . if ( len_trim ( line ) == 0 ) return first_char = line ( 1 : 1 ) if (. not . any ( first_char == [ 'S' , 'P' , 'D' , 'F' , 'G' , 'H' , 'I' , 'L' ])) return read ( line ( 2 :), * , iostat = ios ) dummy res = ( ios == 0 ) end function is_shell_header pure subroutine parse_element_basis ( basis_string , element_name , atom_basis , stat , errmsg ) !! Parse basis set for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( out ) :: atom_basis integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg integer :: nshells stat = 0 ! Pass 1: Find the element and count its shells call count_shells_for_element ( basis_string , element_name , nshells , stat , errmsg ) if ( stat /= 0 ) return if ( nshells == 0 ) then stat = 1 errmsg = \"Element \" // trim ( element_name ) // \" not found in basis file\" return end if ! ! Allocate shells atom_basis % element = trim ( element_name ) call atom_basis % allocate_shells ( nshells ) ! ! Pass 2: Parse and fill shell data call fill_element_basis ( basis_string , element_name , atom_basis , stat , errmsg ) end subroutine parse_element_basis pure subroutine count_shells_for_element ( basis_string , element_name , nshells , stat , errmsg ) !! Count the number of shells for a specific element in a GAMESS formatted basis string, character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name integer , intent ( out ) :: nshells integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_target_element , found_element character ( len = 1 ) :: ang_mom stat = 0 nshells = 0 in_target_element = . false . found_element = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) case ( LINE_ATOM ) ! Check if this is our target element if ( strings_equal ( line , element_name )) then in_target_element = . true . found_element = . true . else ! Different element - stop counting if we were in target if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Extract angular momentum line = adjustl ( line ) ang_mom = line ( 1 : 1 ) ! L shells become 2 shells (S + P) if ( ang_mom == 'L' ) then nshells = nshells + 2 else nshells = nshells + 1 end if end if case ( LINE_UNKNOWN ) ! Skip blank lines and comments continue end select line_start = line_end end do ! Check if we found the element at all if (. not . found_element ) then stat = 1 errmsg = \"Element not found in basis string: \" // trim ( element_name ) end if end subroutine count_shells_for_element pure subroutine get_next_line ( string , line_start , line , line_end ) !! Extract the next line from a string starting at line_start character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: line_start character ( len =* ), intent ( out ) :: line integer , intent ( out ) :: line_end integer :: newline_pos if ( line_start > len ( string )) then line = '' line_end = 0 return end if newline_pos = index ( string ( line_start :), new_line ( 'a' )) if ( newline_pos == 0 ) then ! Last line (no newline at end) line = string ( line_start :) line_end = len ( string ) + 1 else line = string ( line_start : line_start + newline_pos - 2 ) line_end = line_start + newline_pos end if end subroutine get_next_line pure subroutine parse_shell_header ( line , ang_mom , nfunc , stat ) !! Parse shell header line (e.g., \"S 2\" or \"L 3\") character ( len =* ), intent ( in ) :: line character ( len = 1 ), intent ( out ) :: ang_mom integer , intent ( out ) :: nfunc integer , intent ( out ) :: stat character ( len = 256 ) :: line_trim line_trim = adjustl ( line ) ang_mom = line_trim ( 1 : 1 ) ! Read the number of functions read ( line_trim ( 2 :), * , iostat = stat ) nfunc end subroutine parse_shell_header pure subroutine parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) !! Parse function line (e.g., \"1 1.0 2.0\" or \"1 1.0 2.0 3.0\" for L shells) character ( len =* ), intent ( in ) :: line integer , intent ( out ) :: func_num real ( dp ), intent ( out ) :: exponent real ( dp ), intent ( out ) :: coeff_s real ( dp ), intent ( out ), optional :: coeff_p logical , intent ( out ) :: has_p integer , intent ( out ) :: stat real ( dp ) :: temp_p has_p = . false . ! Try to read 4 values (func_num, exponent, coeff_s, coeff_p) read ( line , * , iostat = stat ) func_num , exponent , coeff_s , temp_p if ( stat == 0 ) then ! Successfully read 4 values - this is an L shell has_p = . true . if ( present ( coeff_p )) coeff_p = temp_p else ! Try reading just 3 values (func_num, exponent, coeff_s) read ( line , * , iostat = stat ) func_num , exponent , coeff_s end if end subroutine parse_function_line pure subroutine fill_element_basis ( basis_string , element_name , atom_basis , stat , errmsg ) !! Fill in the shell data for a specific element from a GAMESS formatted basis string character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_name type ( atomic_basis_type ), intent ( inout ) :: atom_basis integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg integer :: line_start , line_end , line_type character ( len = 256 ) :: line logical :: in_data_block , in_target_element character ( len = 1 ) :: ang_mom integer :: nfunc , func_num , ishell , ifunc real ( dp ) :: exponent , coeff_s , coeff_p logical :: has_p ! L shell handling: we split into two shells, need to track both logical :: reading_l_shell integer :: l_shell_s_idx , l_shell_p_idx stat = 0 in_data_block = . false . in_target_element = . false . ishell = 0 reading_l_shell = . false . line_start = 1 do while ( line_start <= len ( basis_string )) call get_next_line ( basis_string , line_start , line , line_end ) if ( line_end == 0 ) exit line = adjustl ( line ) line_type = classify_line ( line ) select case ( line_type ) ! case (LINE_UNKNOWN) !   if (index(line, '$DATA') > 0) then !     in_data_block = .true. !   else if (index(line, '$END') > 0) then !     exit !   end if case ( LINE_ATOM ) if ( strings_equal ( line , element_name )) then in_target_element = . true . else if ( in_target_element ) exit in_target_element = . false . end if case ( LINE_SHELL ) if ( in_target_element ) then ! Parse shell header call parse_shell_header ( line , ang_mom , nfunc , stat ) if ( stat /= 0 ) then errmsg = \"Failed to parse shell header: \" // trim ( line ) return end if if ( ang_mom == 'L' ) then ! L shell: create two shells (S and P) reading_l_shell = . true . ishell = ishell + 1 l_shell_s_idx = ishell atom_basis % shells ( ishell )% ang_mom = 0 ! S call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ishell = ishell + 1 l_shell_p_idx = ishell atom_basis % shells ( ishell )% ang_mom = 1 ! P call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 ! Reset function counter else ! Regular shell reading_l_shell = . false . ishell = ishell + 1 ! Set angular momentum (S=0, P=1, D=2, F=3, G=4, H=5, I=6) atom_basis % shells ( ishell )% ang_mom = ang_mom_char_to_int ( ang_mom ) call atom_basis % shells ( ishell )% allocate_arrays ( nfunc ) ifunc = 0 end if end if case ( LINE_FUNCTION ) if ( in_target_element ) then call parse_function_line ( line , func_num , exponent , coeff_s , coeff_p , has_p , stat ) if ( stat /= 0 ) then errmsg = \"Failed to parse function line: \" // trim ( line ) return end if if (. not . has_p ) then stat = 1 errmsg = \"L shell requires both S and P coefficients\" return end if ifunc = ifunc + 1 if ( reading_l_shell ) then ! Store in both S and P shells atom_basis % shells ( l_shell_s_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_s_idx )% coefficients ( ifunc ) = coeff_s atom_basis % shells ( l_shell_p_idx )% exponents ( ifunc ) = exponent atom_basis % shells ( l_shell_p_idx )% coefficients ( ifunc ) = coeff_p else ! Store in current shell atom_basis % shells ( ishell )% exponents ( ifunc ) = exponent atom_basis % shells ( ishell )% coefficients ( ifunc ) = coeff_s end if end if end select line_start = line_end end do end subroutine fill_element_basis pure subroutine find_unique_strings ( input_array , unique_array , nunique ) !! Find unique strings in an array !! Returns array of unique strings and count character ( len =* ), intent ( in ) :: input_array (:) character ( len = :), allocatable , intent ( out ) :: unique_array (:) integer , intent ( out ) :: nunique integer :: i , j , n logical :: is_unique character ( len = len ( input_array )), allocatable :: temp_unique (:) n = size ( input_array ) allocate ( temp_unique ( n )) ! Max possible size nunique = 0 do i = 1 , n is_unique = . true . ! Check if we've already seen this string do j = 1 , nunique if ( strings_equal ( input_array ( i ), temp_unique ( j ))) then is_unique = . false . exit end if end do if ( is_unique ) then nunique = nunique + 1 temp_unique ( nunique ) = input_array ( i ) end if end do ! Allocate output array with exact size and copy allocate ( character ( len = len ( input_array )) :: unique_array ( nunique )) unique_array = temp_unique ( 1 : nunique ) end subroutine find_unique_strings pure subroutine copy_atomic_basis ( source , dest ) !! Deep copy of atomic basis data from source to dest type ( atomic_basis_type ), intent ( in ) :: source type ( atomic_basis_type ), intent ( out ) :: dest integer :: ishell dest % element = source % element call dest % allocate_shells ( source % nshells ) do ishell = 1 , source % nshells dest % shells ( ishell )% ang_mom = source % shells ( ishell )% ang_mom call dest % shells ( ishell )% allocate_arrays ( source % shells ( ishell )% nfunc ) dest % shells ( ishell )% exponents = source % shells ( ishell )% exponents dest % shells ( ishell )% coefficients = source % shells ( ishell )% coefficients end do end subroutine copy_atomic_basis subroutine build_molecular_basis ( basis_string , element_names , mol_basis , stat , errmsg ) !! Build molecular basis from geometry and basis file !! Only parses unique elements, then copies basis data to atoms character ( len =* ), intent ( in ) :: basis_string character ( len =* ), intent ( in ) :: element_names (:) !! Element for each atom in geometry order type ( molecular_basis_type ), intent ( out ) :: mol_basis integer , intent ( out ) :: stat character ( len = :), allocatable , intent ( out ) :: errmsg integer :: iatom , natoms , iunique , nunique character ( len = :), allocatable :: unique_elements (:) type ( atomic_basis_type ), allocatable :: unique_bases (:) integer :: match_idx match_idx = 0 stat = 0 natoms = size ( element_names ) ! Find unique elements call find_unique_strings ( element_names , unique_elements , nunique ) print * , \"Found \" , nunique , \" unique elements out of \" , natoms , \" atoms\" ! Allocate for unique bases allocate ( unique_bases ( nunique )) ! Parse basis for each unique element do iunique = 1 , nunique print * , \"Parsing basis for: \" , trim ( unique_elements ( iunique )) call parse_element_basis ( basis_string , unique_elements ( iunique ), & unique_bases ( iunique ), stat , errmsg ) if ( stat /= 0 ) then errmsg = \"Failed to parse basis for element \" // trim ( unique_elements ( iunique )) // & \": \" // errmsg return end if end do ! Allocate molecular basis and assign to each atom call mol_basis % allocate_elements ( natoms ) do iatom = 1 , natoms ! Find which unique element this atom corresponds to do iunique = 1 , nunique if ( strings_equal ( element_names ( iatom ), unique_elements ( iunique ))) then match_idx = iunique exit end if end do ! Copy the basis data call copy_atomic_basis ( unique_bases ( match_idx ), mol_basis % elements ( iatom )) end do ! Clean up do iunique = 1 , nunique call unique_bases ( iunique )% destroy () end do end subroutine build_molecular_basis end module mqc_basis_reader","tags":"","url":"sourcefile/mqc_basis_reader.f90.html"},{"title":"mqc_logo.f90 – metalquicha","text":"ASCII art logo display for metalquicha Files dependent on this one sourcefile~~mqc_logo.f90~~AfferentGraph sourcefile~mqc_logo.f90 mqc_logo.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mqc_logo.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! ASCII art logo display for metalquicha module mqc_logo !! Provides the project branding sunflower logo and version information !! displayed at program startup. implicit none private public :: print_logo !! Display ASCII sunflower logo and project info contains subroutine print_logo () !! Print the PIC Chemistry ASCII sunflower logo write ( * , '(A)' ) ' ' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                        __   __' write ( * , '(A)' ) '                     .-(  ''.''  )-.' write ( * , '(A)' ) '                    (   \\  |  /   )' write ( * , '(A)' ) '                   ( ''`-.;;;;;.-''` )' write ( * , '(A)' ) '                  ( :-==;;;;;;;==-: )' write ( * , '(A)' ) '                   (  .-'';;;;;''-.  )' write ( * , '(A)' ) '                    (``  /  |  \\  ``)' write ( * , '(A)' ) '                     ''-(__.''.__)-''' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '                      (Art by jgs)' write ( * , '(A)' ) ' ' write ( * , '(A)' ) '    ╔═══════════════════════════════════════════════╗' write ( * , '(A)' ) '    ║              Met\"al q\"uicha                   ║' write ( * , '(A)' ) '    ║                (Sunflower)                    ║' write ( * , '(A)' ) '    ║     A hastily put together framework for      ║' write ( * , '(A)' ) '    ║   Fortran Based High Performance Computing    ║' write ( * , '(A)' ) '    ║                                               ║' write ( * , '(A)' ) '    ║        Case study: quantum chemistry          ║' write ( * , '(A)' ) '    ╚═══════════════════════════════════════════════╝' write ( * , '(A)' ) ' ' end subroutine print_logo end module mqc_logo","tags":"","url":"sourcefile/mqc_logo.f90.html"}]}